impl serde::Serialize for AFlash {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.AFlash", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AFlash {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AFlash;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AFlash")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AFlash, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(AFlash {
                })
            }
        }
        deserializer.deserialize_struct("protocol.AFlash", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for a_flash::ConfirmResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.album_wf.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AFlash.ConfirmResult", len)?;
        let v = a_flash::Scene::try_from(self.scene)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.scene)))?;
        struct_ser.serialize_field("scene", &v)?;
        struct_ser.serialize_field("confirm", &self.confirm)?;
        struct_ser.serialize_field("content", &self.content)?;
        if let Some(v) = self.album_wf.as_ref() {
            struct_ser.serialize_field("albumWf", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for a_flash::ConfirmResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scene",
            "confirm",
            "content",
            "album_wf",
            "albumWf",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scene,
            Confirm,
            Content,
            AlbumWf,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scene" => Ok(GeneratedField::Scene),
                            "confirm" => Ok(GeneratedField::Confirm),
                            "content" => Ok(GeneratedField::Content),
                            "albumWf" | "album_wf" => Ok(GeneratedField::AlbumWf),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = a_flash::ConfirmResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AFlash.ConfirmResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<a_flash::ConfirmResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene__ = None;
                let mut confirm__ = None;
                let mut content__ = None;
                let mut album_wf__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scene => {
                            if scene__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scene"));
                            }
                            scene__ = Some(map_.next_value::<a_flash::Scene>()? as i32);
                        }
                        GeneratedField::Confirm => {
                            if confirm__.is_some() {
                                return Err(serde::de::Error::duplicate_field("confirm"));
                            }
                            confirm__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AlbumWf => {
                            if album_wf__.is_some() {
                                return Err(serde::de::Error::duplicate_field("albumWf"));
                            }
                            album_wf__ = map_.next_value()?;
                        }
                    }
                }
                Ok(a_flash::ConfirmResult {
                    scene: scene__.ok_or_else(|| serde::de::Error::missing_field("scene"))?,
                    confirm: confirm__.ok_or_else(|| serde::de::Error::missing_field("confirm"))?,
                    content: content__.ok_or_else(|| serde::de::Error::missing_field("content"))?,
                    album_wf: album_wf__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AFlash.ConfirmResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for a_flash::confirm_result::AlbumWf {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AFlash.ConfirmResult.AlbumWF", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        let v = ImageFormat::try_from(self.image_format)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.image_format)))?;
        struct_ser.serialize_field("imageFormat", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for a_flash::confirm_result::AlbumWf {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "image_format",
            "imageFormat",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            ImageFormat,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "imageFormat" | "image_format" => Ok(GeneratedField::ImageFormat),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = a_flash::confirm_result::AlbumWf;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AFlash.ConfirmResult.AlbumWF")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<a_flash::confirm_result::AlbumWf, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut image_format__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ImageFormat => {
                            if image_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageFormat"));
                            }
                            image_format__ = Some(map_.next_value::<ImageFormat>()? as i32);
                        }
                    }
                }
                Ok(a_flash::confirm_result::AlbumWf {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    image_format: image_format__.ok_or_else(|| serde::de::Error::missing_field("imageFormat"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AFlash.ConfirmResult.AlbumWF", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for a_flash::Scene {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::QuestionAndAnswer => "QUESTION_AND_ANSWER",
            Self::TextToImage => "TEXT_TO_IMAGE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for a_flash::Scene {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QUESTION_AND_ANSWER",
            "TEXT_TO_IMAGE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = a_flash::Scene;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "QUESTION_AND_ANSWER" => Ok(a_flash::Scene::QuestionAndAnswer),
                    "TEXT_TO_IMAGE" => Ok(a_flash::Scene::TextToImage),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for a_flash::SupportedLanguage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AFlash.SupportedLanguage", len)?;
        struct_ser.serialize_field("languages", &self.languages)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for a_flash::SupportedLanguage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "languages",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Languages,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "languages" => Ok(GeneratedField::Languages),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = a_flash::SupportedLanguage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AFlash.SupportedLanguage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<a_flash::SupportedLanguage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut languages__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Languages => {
                            if languages__.is_some() {
                                return Err(serde::de::Error::duplicate_field("languages"));
                            }
                            languages__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(a_flash::SupportedLanguage {
                    languages: languages__.ok_or_else(|| serde::de::Error::missing_field("languages"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AFlash.SupportedLanguage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AbstractItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AbstractItem", len)?;
        struct_ser.serialize_field("k", &self.k)?;
        struct_ser.serialize_field("v", &self.v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AbstractItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "k",
            "v",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            K,
            V,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "k" => Ok(GeneratedField::K),
                            "v" => Ok(GeneratedField::V),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AbstractItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AbstractItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AbstractItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut k__ = None;
                let mut v__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::K => {
                            if k__.is_some() {
                                return Err(serde::de::Error::duplicate_field("k"));
                            }
                            k__ = Some(map_.next_value()?);
                        }
                        GeneratedField::V => {
                            if v__.is_some() {
                                return Err(serde::de::Error::duplicate_field("v"));
                            }
                            v__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AbstractItem {
                    k: k__.ok_or_else(|| serde::de::Error::missing_field("k"))?,
                    v: v__.ok_or_else(|| serde::de::Error::missing_field("v"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AbstractItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for abstract_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AbstractItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for abstract_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = abstract_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AbstractItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<abstract_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(abstract_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AbstractItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Account {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Account", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                account::Payload::BindStatus(v) => {
                    struct_ser.serialize_field("bindStatus", v)?;
                }
                account::Payload::BindKey(v) => {
                    struct_ser.serialize_field("bindKey", v)?;
                }
                account::Payload::ErrorCode(v) => {
                    let v = account::ErrorCode::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("errorCode", &v)?;
                }
                account::Payload::BindInfo(v) => {
                    struct_ser.serialize_field("bindInfo", v)?;
                }
                account::Payload::BindResult(v) => {
                    struct_ser.serialize_field("bindResult", v)?;
                }
                account::Payload::LoginStatus(v) => {
                    struct_ser.serialize_field("loginStatus", v)?;
                }
                account::Payload::VerifyKey(v) => {
                    struct_ser.serialize_field("verifyKey", v)?;
                }
                account::Payload::VerifyResult(v) => {
                    struct_ser.serialize_field("verifyResult", v)?;
                }
                account::Payload::BondApply(v) => {
                    struct_ser.serialize_field("bondApply", v)?;
                }
                account::Payload::BondReply(v) => {
                    struct_ser.serialize_field("bondReply", v)?;
                }
                account::Payload::BindStartV2(v) => {
                    struct_ser.serialize_field("bindStartV2", v)?;
                }
                account::Payload::BindInfoV2(v) => {
                    struct_ser.serialize_field("bindInfoV2", v)?;
                }
                account::Payload::PskServerVerify(v) => {
                    struct_ser.serialize_field("pskServerVerify", v)?;
                }
                account::Payload::PskDeviceVerify(v) => {
                    struct_ser.serialize_field("pskDeviceVerify", v)?;
                }
                account::Payload::PskAppConfirm(v) => {
                    struct_ser.serialize_field("pskAppConfirm", v)?;
                }
                account::Payload::PskDeviceConfirm(v) => {
                    struct_ser.serialize_field("pskDeviceConfirm", v)?;
                }
                account::Payload::LocalAppVerify(v) => {
                    struct_ser.serialize_field("localAppVerify", v)?;
                }
                account::Payload::LocalDeviceVerify(v) => {
                    struct_ser.serialize_field("localDeviceVerify", v)?;
                }
                account::Payload::LocalAppConfirm(v) => {
                    struct_ser.serialize_field("localAppConfirm", v)?;
                }
                account::Payload::LocalDeviceConfirm(v) => {
                    struct_ser.serialize_field("localDeviceConfirm", v)?;
                }
                account::Payload::BindResultV2(v) => {
                    struct_ser.serialize_field("bindResultV2", v)?;
                }
                account::Payload::AuthAppVerify(v) => {
                    struct_ser.serialize_field("authAppVerify", v)?;
                }
                account::Payload::AuthDeviceVerify(v) => {
                    struct_ser.serialize_field("authDeviceVerify", v)?;
                }
                account::Payload::AuthAppConfirm(v) => {
                    struct_ser.serialize_field("authAppConfirm", v)?;
                }
                account::Payload::AuthDeviceConfirm(v) => {
                    struct_ser.serialize_field("authDeviceConfirm", v)?;
                }
                account::Payload::PassTokenApply(v) => {
                    struct_ser.serialize_field("passTokenApply", v)?;
                }
                account::Payload::PassTokenReply(v) => {
                    struct_ser.serialize_field("passTokenReply", v)?;
                }
                account::Payload::StatusChange(v) => {
                    struct_ser.serialize_field("statusChange", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Account {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bind_status",
            "bindStatus",
            "bind_key",
            "bindKey",
            "error_code",
            "errorCode",
            "bind_info",
            "bindInfo",
            "bind_result",
            "bindResult",
            "login_status",
            "loginStatus",
            "verify_key",
            "verifyKey",
            "verify_result",
            "verifyResult",
            "bond_apply",
            "bondApply",
            "bond_reply",
            "bondReply",
            "bind_start_v2",
            "bindStartV2",
            "bind_info_v2",
            "bindInfoV2",
            "psk_server_verify",
            "pskServerVerify",
            "psk_device_verify",
            "pskDeviceVerify",
            "psk_app_confirm",
            "pskAppConfirm",
            "psk_device_confirm",
            "pskDeviceConfirm",
            "local_app_verify",
            "localAppVerify",
            "local_device_verify",
            "localDeviceVerify",
            "local_app_confirm",
            "localAppConfirm",
            "local_device_confirm",
            "localDeviceConfirm",
            "bind_result_v2",
            "bindResultV2",
            "auth_app_verify",
            "authAppVerify",
            "auth_device_verify",
            "authDeviceVerify",
            "auth_app_confirm",
            "authAppConfirm",
            "auth_device_confirm",
            "authDeviceConfirm",
            "pass_token_apply",
            "passTokenApply",
            "pass_token_reply",
            "passTokenReply",
            "status_change",
            "statusChange",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BindStatus,
            BindKey,
            ErrorCode,
            BindInfo,
            BindResult,
            LoginStatus,
            VerifyKey,
            VerifyResult,
            BondApply,
            BondReply,
            BindStartV2,
            BindInfoV2,
            PskServerVerify,
            PskDeviceVerify,
            PskAppConfirm,
            PskDeviceConfirm,
            LocalAppVerify,
            LocalDeviceVerify,
            LocalAppConfirm,
            LocalDeviceConfirm,
            BindResultV2,
            AuthAppVerify,
            AuthDeviceVerify,
            AuthAppConfirm,
            AuthDeviceConfirm,
            PassTokenApply,
            PassTokenReply,
            StatusChange,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bindStatus" | "bind_status" => Ok(GeneratedField::BindStatus),
                            "bindKey" | "bind_key" => Ok(GeneratedField::BindKey),
                            "errorCode" | "error_code" => Ok(GeneratedField::ErrorCode),
                            "bindInfo" | "bind_info" => Ok(GeneratedField::BindInfo),
                            "bindResult" | "bind_result" => Ok(GeneratedField::BindResult),
                            "loginStatus" | "login_status" => Ok(GeneratedField::LoginStatus),
                            "verifyKey" | "verify_key" => Ok(GeneratedField::VerifyKey),
                            "verifyResult" | "verify_result" => Ok(GeneratedField::VerifyResult),
                            "bondApply" | "bond_apply" => Ok(GeneratedField::BondApply),
                            "bondReply" | "bond_reply" => Ok(GeneratedField::BondReply),
                            "bindStartV2" | "bind_start_v2" => Ok(GeneratedField::BindStartV2),
                            "bindInfoV2" | "bind_info_v2" => Ok(GeneratedField::BindInfoV2),
                            "pskServerVerify" | "psk_server_verify" => Ok(GeneratedField::PskServerVerify),
                            "pskDeviceVerify" | "psk_device_verify" => Ok(GeneratedField::PskDeviceVerify),
                            "pskAppConfirm" | "psk_app_confirm" => Ok(GeneratedField::PskAppConfirm),
                            "pskDeviceConfirm" | "psk_device_confirm" => Ok(GeneratedField::PskDeviceConfirm),
                            "localAppVerify" | "local_app_verify" => Ok(GeneratedField::LocalAppVerify),
                            "localDeviceVerify" | "local_device_verify" => Ok(GeneratedField::LocalDeviceVerify),
                            "localAppConfirm" | "local_app_confirm" => Ok(GeneratedField::LocalAppConfirm),
                            "localDeviceConfirm" | "local_device_confirm" => Ok(GeneratedField::LocalDeviceConfirm),
                            "bindResultV2" | "bind_result_v2" => Ok(GeneratedField::BindResultV2),
                            "authAppVerify" | "auth_app_verify" => Ok(GeneratedField::AuthAppVerify),
                            "authDeviceVerify" | "auth_device_verify" => Ok(GeneratedField::AuthDeviceVerify),
                            "authAppConfirm" | "auth_app_confirm" => Ok(GeneratedField::AuthAppConfirm),
                            "authDeviceConfirm" | "auth_device_confirm" => Ok(GeneratedField::AuthDeviceConfirm),
                            "passTokenApply" | "pass_token_apply" => Ok(GeneratedField::PassTokenApply),
                            "passTokenReply" | "pass_token_reply" => Ok(GeneratedField::PassTokenReply),
                            "statusChange" | "status_change" => Ok(GeneratedField::StatusChange),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Account;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Account")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Account, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BindStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindStatus);
                        }
                        GeneratedField::BindKey => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindKey"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindKey);
                        }
                        GeneratedField::ErrorCode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorCode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<account::ErrorCode>>()?.map(|x| account::Payload::ErrorCode(x as i32));
                        }
                        GeneratedField::BindInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindInfo)
;
                        }
                        GeneratedField::BindResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindResult)
;
                        }
                        GeneratedField::LoginStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loginStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::LoginStatus);
                        }
                        GeneratedField::VerifyKey => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verifyKey"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::VerifyKey);
                        }
                        GeneratedField::VerifyResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verifyResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::VerifyResult);
                        }
                        GeneratedField::BondApply => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bondApply"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BondApply)
;
                        }
                        GeneratedField::BondReply => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bondReply"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BondReply)
;
                        }
                        GeneratedField::BindStartV2 => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindStartV2"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindStartV2)
;
                        }
                        GeneratedField::BindInfoV2 => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindInfoV2"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindInfoV2)
;
                        }
                        GeneratedField::PskServerVerify => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pskServerVerify"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::PskServerVerify)
;
                        }
                        GeneratedField::PskDeviceVerify => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pskDeviceVerify"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::PskDeviceVerify)
;
                        }
                        GeneratedField::PskAppConfirm => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pskAppConfirm"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::PskAppConfirm)
;
                        }
                        GeneratedField::PskDeviceConfirm => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pskDeviceConfirm"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::PskDeviceConfirm)
;
                        }
                        GeneratedField::LocalAppVerify => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localAppVerify"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::LocalAppVerify)
;
                        }
                        GeneratedField::LocalDeviceVerify => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localDeviceVerify"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::LocalDeviceVerify)
;
                        }
                        GeneratedField::LocalAppConfirm => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localAppConfirm"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::LocalAppConfirm)
;
                        }
                        GeneratedField::LocalDeviceConfirm => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("localDeviceConfirm"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::LocalDeviceConfirm)
;
                        }
                        GeneratedField::BindResultV2 => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindResultV2"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::BindResultV2)
;
                        }
                        GeneratedField::AuthAppVerify => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authAppVerify"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::AuthAppVerify)
;
                        }
                        GeneratedField::AuthDeviceVerify => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authDeviceVerify"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::AuthDeviceVerify)
;
                        }
                        GeneratedField::AuthAppConfirm => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authAppConfirm"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::AuthAppConfirm)
;
                        }
                        GeneratedField::AuthDeviceConfirm => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authDeviceConfirm"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::AuthDeviceConfirm)
;
                        }
                        GeneratedField::PassTokenApply => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("passTokenApply"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::PassTokenApply)
;
                        }
                        GeneratedField::PassTokenReply => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("passTokenReply"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::PassTokenReply)
;
                        }
                        GeneratedField::StatusChange => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("statusChange"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(account::Payload::StatusChange)
;
                        }
                    }
                }
                Ok(Account {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Account", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for account::AccountId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::BindStatus => "BIND_STATUS",
            Self::BindStart => "BIND_START",
            Self::BindResult => "BIND_RESULT",
            Self::LoginStatus => "LOGIN_STATUS",
            Self::LoginStart => "LOGIN_START",
            Self::AccountVerify => "ACCOUNT_VERIFY",
            Self::BondApply => "BOND_APPLY",
            Self::BindStartV2 => "BIND_START_V2",
            Self::BindVerify => "BIND_VERIFY",
            Self::BindConfirm => "BIND_CONFIRM",
            Self::BindResultV2 => "BIND_RESULT_V2",
            Self::AuthVerify => "AUTH_VERIFY",
            Self::AuthConfirm => "AUTH_CONFIRM",
            Self::ApplyDevicePasstoken => "APPLY_DEVICE_PASSTOKEN",
            Self::ReplyDevicePasstoken => "REPLY_DEVICE_PASSTOKEN",
            Self::NotifyLoginStatusChanged => "NOTIFY_LOGIN_STATUS_CHANGED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for account::AccountId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BIND_STATUS",
            "BIND_START",
            "BIND_RESULT",
            "LOGIN_STATUS",
            "LOGIN_START",
            "ACCOUNT_VERIFY",
            "BOND_APPLY",
            "BIND_START_V2",
            "BIND_VERIFY",
            "BIND_CONFIRM",
            "BIND_RESULT_V2",
            "AUTH_VERIFY",
            "AUTH_CONFIRM",
            "APPLY_DEVICE_PASSTOKEN",
            "REPLY_DEVICE_PASSTOKEN",
            "NOTIFY_LOGIN_STATUS_CHANGED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = account::AccountId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BIND_STATUS" => Ok(account::AccountId::BindStatus),
                    "BIND_START" => Ok(account::AccountId::BindStart),
                    "BIND_RESULT" => Ok(account::AccountId::BindResult),
                    "LOGIN_STATUS" => Ok(account::AccountId::LoginStatus),
                    "LOGIN_START" => Ok(account::AccountId::LoginStart),
                    "ACCOUNT_VERIFY" => Ok(account::AccountId::AccountVerify),
                    "BOND_APPLY" => Ok(account::AccountId::BondApply),
                    "BIND_START_V2" => Ok(account::AccountId::BindStartV2),
                    "BIND_VERIFY" => Ok(account::AccountId::BindVerify),
                    "BIND_CONFIRM" => Ok(account::AccountId::BindConfirm),
                    "BIND_RESULT_V2" => Ok(account::AccountId::BindResultV2),
                    "AUTH_VERIFY" => Ok(account::AccountId::AuthVerify),
                    "AUTH_CONFIRM" => Ok(account::AccountId::AuthConfirm),
                    "APPLY_DEVICE_PASSTOKEN" => Ok(account::AccountId::ApplyDevicePasstoken),
                    "REPLY_DEVICE_PASSTOKEN" => Ok(account::AccountId::ReplyDevicePasstoken),
                    "NOTIFY_LOGIN_STATUS_CHANGED" => Ok(account::AccountId::NotifyLoginStatusChanged),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for account::ErrorCode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoError => "NO_ERROR",
            Self::HaveBound => "HAVE_BOUND",
            Self::InfoMissing => "INFO_MISSING",
            Self::InvalidParam => "INVALID_PARAM",
            Self::NoBound => "NO_BOUND",
            Self::ServerError => "SERVER_ERROR",
            Self::Cancel => "CANCEL",
            Self::VerifyError => "VERIFY_ERROR",
            Self::StateNotMatch => "STATE_NOT_MATCH",
            Self::UserChanged => "USER_CHANGED",
            Self::ConnectionReachLimit => "CONNECTION_REACH_LIMIT",
            Self::Unknown => "UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for account::ErrorCode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_ERROR",
            "HAVE_BOUND",
            "INFO_MISSING",
            "INVALID_PARAM",
            "NO_BOUND",
            "SERVER_ERROR",
            "CANCEL",
            "VERIFY_ERROR",
            "STATE_NOT_MATCH",
            "USER_CHANGED",
            "CONNECTION_REACH_LIMIT",
            "UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = account::ErrorCode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_ERROR" => Ok(account::ErrorCode::NoError),
                    "HAVE_BOUND" => Ok(account::ErrorCode::HaveBound),
                    "INFO_MISSING" => Ok(account::ErrorCode::InfoMissing),
                    "INVALID_PARAM" => Ok(account::ErrorCode::InvalidParam),
                    "NO_BOUND" => Ok(account::ErrorCode::NoBound),
                    "SERVER_ERROR" => Ok(account::ErrorCode::ServerError),
                    "CANCEL" => Ok(account::ErrorCode::Cancel),
                    "VERIFY_ERROR" => Ok(account::ErrorCode::VerifyError),
                    "STATE_NOT_MATCH" => Ok(account::ErrorCode::StateNotMatch),
                    "USER_CHANGED" => Ok(account::ErrorCode::UserChanged),
                    "CONNECTION_REACH_LIMIT" => Ok(account::ErrorCode::ConnectionReachLimit),
                    "UNKNOWN" => Ok(account::ErrorCode::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ActivityReminder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ActivityReminder", len)?;
        struct_ser.serialize_field("sevenDayStage", &self.seven_day_stage)?;
        struct_ser.serialize_field("dayUpperLimit", &self.day_upper_limit)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ActivityReminder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "seven_day_stage",
            "sevenDayStage",
            "day_upper_limit",
            "dayUpperLimit",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SevenDayStage,
            DayUpperLimit,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sevenDayStage" | "seven_day_stage" => Ok(GeneratedField::SevenDayStage),
                            "dayUpperLimit" | "day_upper_limit" => Ok(GeneratedField::DayUpperLimit),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActivityReminder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ActivityReminder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActivityReminder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut seven_day_stage__ = None;
                let mut day_upper_limit__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SevenDayStage => {
                            if seven_day_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sevenDayStage"));
                            }
                            seven_day_stage__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DayUpperLimit => {
                            if day_upper_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dayUpperLimit"));
                            }
                            day_upper_limit__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ActivityReminder {
                    seven_day_stage: seven_day_stage__.ok_or_else(|| serde::de::Error::missing_field("sevenDayStage"))?,
                    day_upper_limit: day_upper_limit__.ok_or_else(|| serde::de::Error::missing_field("dayUpperLimit"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ActivityReminder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Aivs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Aivs", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                aivs::Payload::InstructionList(v) => {
                    struct_ser.serialize_field("instructionList", v)?;
                }
                aivs::Payload::AivsConfig(v) => {
                    struct_ser.serialize_field("aivsConfig", v)?;
                }
                aivs::Payload::ImageConfig(v) => {
                    struct_ser.serialize_field("imageConfig", v)?;
                }
                aivs::Payload::MultiModel(v) => {
                    struct_ser.serialize_field("multiModel", v)?;
                }
                aivs::Payload::AivsStatus(v) => {
                    struct_ser.serialize_field("aivsStatus", v)?;
                }
                aivs::Payload::AivsError(v) => {
                    struct_ser.serialize_field("aivsError", v)?;
                }
                aivs::Payload::AflashSupportedLanguage(v) => {
                    struct_ser.serialize_field("aflashSupportedLanguage", v)?;
                }
                aivs::Payload::AflashConfirmResult(v) => {
                    struct_ser.serialize_field("aflashConfirmResult", v)?;
                }
                aivs::Payload::LlmImageRequest(v) => {
                    struct_ser.serialize_field("llmImageRequest", v)?;
                }
                aivs::Payload::LlmImageResponse(v) => {
                    struct_ser.serialize_field("llmImageResponse", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Aivs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "instruction_list",
            "instructionList",
            "aivs_config",
            "aivsConfig",
            "image_config",
            "imageConfig",
            "multi_model",
            "multiModel",
            "aivs_status",
            "aivsStatus",
            "aivs_error",
            "aivsError",
            "aflash_supported_language",
            "aflashSupportedLanguage",
            "aflash_confirm_result",
            "aflashConfirmResult",
            "llm_image_request",
            "llmImageRequest",
            "llm_image_response",
            "llmImageResponse",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            InstructionList,
            AivsConfig,
            ImageConfig,
            MultiModel,
            AivsStatus,
            AivsError,
            AflashSupportedLanguage,
            AflashConfirmResult,
            LlmImageRequest,
            LlmImageResponse,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "instructionList" | "instruction_list" => Ok(GeneratedField::InstructionList),
                            "aivsConfig" | "aivs_config" => Ok(GeneratedField::AivsConfig),
                            "imageConfig" | "image_config" => Ok(GeneratedField::ImageConfig),
                            "multiModel" | "multi_model" => Ok(GeneratedField::MultiModel),
                            "aivsStatus" | "aivs_status" => Ok(GeneratedField::AivsStatus),
                            "aivsError" | "aivs_error" => Ok(GeneratedField::AivsError),
                            "aflashSupportedLanguage" | "aflash_supported_language" => Ok(GeneratedField::AflashSupportedLanguage),
                            "aflashConfirmResult" | "aflash_confirm_result" => Ok(GeneratedField::AflashConfirmResult),
                            "llmImageRequest" | "llm_image_request" => Ok(GeneratedField::LlmImageRequest),
                            "llmImageResponse" | "llm_image_response" => Ok(GeneratedField::LlmImageResponse),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Aivs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Aivs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Aivs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::InstructionList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("instructionList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::InstructionList)
;
                        }
                        GeneratedField::AivsConfig => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aivsConfig"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::AivsConfig)
;
                        }
                        GeneratedField::ImageConfig => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageConfig"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::ImageConfig)
;
                        }
                        GeneratedField::MultiModel => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multiModel"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::MultiModel)
;
                        }
                        GeneratedField::AivsStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aivsStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::AivsStatus)
;
                        }
                        GeneratedField::AivsError => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aivsError"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::AivsError)
;
                        }
                        GeneratedField::AflashSupportedLanguage => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aflashSupportedLanguage"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::AflashSupportedLanguage)
;
                        }
                        GeneratedField::AflashConfirmResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aflashConfirmResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::AflashConfirmResult)
;
                        }
                        GeneratedField::LlmImageRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("llmImageRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::LlmImageRequest)
;
                        }
                        GeneratedField::LlmImageResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("llmImageResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(aivs::Payload::LlmImageResponse)
;
                        }
                    }
                }
                Ok(Aivs {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Aivs", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for aivs::AivsId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SyncInstructionList => "SYNC_INSTRUCTION_LIST",
            Self::GetConfig => "GET_CONFIG",
            Self::SetConfig => "SET_CONFIG",
            Self::GetMediaConfig => "GET_MEDIA_CONFIG",
            Self::RequestMultiModal => "REQUEST_MULTI_MODAL",
            Self::SyncAivsStatus => "SYNC_AIVS_STATUS",
            Self::SyncAivsError => "SYNC_AIVS_ERROR",
            Self::GetAflashSupportedLanguage => "GET_AFLASH_SUPPORTED_LANGUAGE",
            Self::ReplyAflashConfirmResult => "REPLY_AFLASH_CONFIRM_RESULT",
            Self::LlmIssueImage => "LLM_ISSUE_IMAGE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs::AivsId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SYNC_INSTRUCTION_LIST",
            "GET_CONFIG",
            "SET_CONFIG",
            "GET_MEDIA_CONFIG",
            "REQUEST_MULTI_MODAL",
            "SYNC_AIVS_STATUS",
            "SYNC_AIVS_ERROR",
            "GET_AFLASH_SUPPORTED_LANGUAGE",
            "REPLY_AFLASH_CONFIRM_RESULT",
            "LLM_ISSUE_IMAGE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs::AivsId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SYNC_INSTRUCTION_LIST" => Ok(aivs::AivsId::SyncInstructionList),
                    "GET_CONFIG" => Ok(aivs::AivsId::GetConfig),
                    "SET_CONFIG" => Ok(aivs::AivsId::SetConfig),
                    "GET_MEDIA_CONFIG" => Ok(aivs::AivsId::GetMediaConfig),
                    "REQUEST_MULTI_MODAL" => Ok(aivs::AivsId::RequestMultiModal),
                    "SYNC_AIVS_STATUS" => Ok(aivs::AivsId::SyncAivsStatus),
                    "SYNC_AIVS_ERROR" => Ok(aivs::AivsId::SyncAivsError),
                    "GET_AFLASH_SUPPORTED_LANGUAGE" => Ok(aivs::AivsId::GetAflashSupportedLanguage),
                    "REPLY_AFLASH_CONFIRM_RESULT" => Ok(aivs::AivsId::ReplyAflashConfirmResult),
                    "LLM_ISSUE_IMAGE" => Ok(aivs::AivsId::LlmIssueImage),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AivsConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AivsConfig", len)?;
        struct_ser.serialize_field("enableTts", &self.enable_tts)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AivsConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enable_tts",
            "enableTts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnableTts,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enableTts" | "enable_tts" => Ok(GeneratedField::EnableTts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AivsConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AivsConfig")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AivsConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enable_tts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnableTts => {
                            if enable_tts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enableTts"));
                            }
                            enable_tts__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AivsConfig {
                    enable_tts: enable_tts__.ok_or_else(|| serde::de::Error::missing_field("enableTts"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AivsConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AivsError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AivsError", len)?;
        struct_ser.serialize_field("errorCode", &self.error_code)?;
        struct_ser.serialize_field("errorMsg", &self.error_msg)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AivsError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "error_code",
            "errorCode",
            "error_msg",
            "errorMsg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrorCode,
            ErrorMsg,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "errorCode" | "error_code" => Ok(GeneratedField::ErrorCode),
                            "errorMsg" | "error_msg" => Ok(GeneratedField::ErrorMsg),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AivsError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AivsError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AivsError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut error_code__ = None;
                let mut error_msg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrorCode => {
                            if error_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorCode"));
                            }
                            error_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ErrorMsg => {
                            if error_msg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorMsg"));
                            }
                            error_msg__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AivsError {
                    error_code: error_code__.ok_or_else(|| serde::de::Error::missing_field("errorCode"))?,
                    error_msg: error_msg__.ok_or_else(|| serde::de::Error::missing_field("errorMsg"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AivsError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AivsInstruction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.recognize_result.is_some() {
            len += 1;
        }
        if self.template_toast.is_some() {
            len += 1;
        }
        if self.template_general.is_some() {
            len += 1;
        }
        if self.template_general2.is_some() {
            len += 1;
        }
        if self.template_weather.is_some() {
            len += 1;
        }
        if self.template_playinfo.is_some() {
            len += 1;
        }
        if self.template_lists.is_some() {
            len += 1;
        }
        if self.template_switchpanel.is_some() {
            len += 1;
        }
        if self.alerts_setalert.is_some() {
            len += 1;
        }
        if self.speechsynthesizer_speak.is_some() {
            len += 1;
        }
        if self.laucher_lauchapp.is_some() {
            len += 1;
        }
        if self.template_switchpanellist.is_some() {
            len += 1;
        }
        if self.brightnesscontroller_ajustbrightness.is_some() {
            len += 1;
        }
        if self.system_setproperty.is_some() {
            len += 1;
        }
        if self.application_operate.is_some() {
            len += 1;
        }
        if self.alerts_deliveralertintention.is_some() {
            len += 1;
        }
        if self.media_errortype.is_some() {
            len += 1;
        }
        if self.speaker_setmute.is_some() {
            len += 1;
        }
        if self.speaker_setvolume.is_some() {
            len += 1;
        }
        if self.speaker_ajustvolume.is_some() {
            len += 1;
        }
        if self.template_devicelist.is_some() {
            len += 1;
        }
        if self.execute_deviceskill.is_some() {
            len += 1;
        }
        if self.show_contacts.is_some() {
            len += 1;
        }
        if self.contact_data.is_some() {
            len += 1;
        }
        if self.wearable_controller_switch.is_some() {
            len += 1;
        }
        if self.wearable_controller_execute.is_some() {
            len += 1;
        }
        if self.llm_loading_card.is_some() {
            len += 1;
        }
        if self.llm_declaration_content.is_some() {
            len += 1;
        }
        if self.llm_illegal_content.is_some() {
            len += 1;
        }
        if self.llm_toast_stream.is_some() {
            len += 1;
        }
        if self.wearable_controller_action.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AivsInstruction", len)?;
        let v = ResultType::try_from(self.result_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.result_type)))?;
        struct_ser.serialize_field("resultType", &v)?;
        struct_ser.serialize_field("sessionId", &self.session_id)?;
        if let Some(v) = self.recognize_result.as_ref() {
            struct_ser.serialize_field("recognizeResult", v)?;
        }
        if let Some(v) = self.template_toast.as_ref() {
            struct_ser.serialize_field("templateToast", v)?;
        }
        if let Some(v) = self.template_general.as_ref() {
            struct_ser.serialize_field("templateGeneral", v)?;
        }
        if let Some(v) = self.template_general2.as_ref() {
            struct_ser.serialize_field("templateGeneral2", v)?;
        }
        if let Some(v) = self.template_weather.as_ref() {
            struct_ser.serialize_field("templateWeather", v)?;
        }
        if let Some(v) = self.template_playinfo.as_ref() {
            struct_ser.serialize_field("templatePlayinfo", v)?;
        }
        if let Some(v) = self.template_lists.as_ref() {
            struct_ser.serialize_field("templateLists", v)?;
        }
        if let Some(v) = self.template_switchpanel.as_ref() {
            struct_ser.serialize_field("templateSwitchpanel", v)?;
        }
        if let Some(v) = self.alerts_setalert.as_ref() {
            struct_ser.serialize_field("alertsSetalert", v)?;
        }
        if let Some(v) = self.speechsynthesizer_speak.as_ref() {
            struct_ser.serialize_field("speechsynthesizerSpeak", v)?;
        }
        if let Some(v) = self.laucher_lauchapp.as_ref() {
            struct_ser.serialize_field("laucherLauchapp", v)?;
        }
        if let Some(v) = self.template_switchpanellist.as_ref() {
            struct_ser.serialize_field("templateSwitchpanellist", v)?;
        }
        if let Some(v) = self.brightnesscontroller_ajustbrightness.as_ref() {
            struct_ser.serialize_field("brightnesscontrollerAjustbrightness", v)?;
        }
        if let Some(v) = self.system_setproperty.as_ref() {
            struct_ser.serialize_field("systemSetproperty", v)?;
        }
        if let Some(v) = self.application_operate.as_ref() {
            struct_ser.serialize_field("applicationOperate", v)?;
        }
        if let Some(v) = self.alerts_deliveralertintention.as_ref() {
            struct_ser.serialize_field("alertsDeliveralertintention", v)?;
        }
        if let Some(v) = self.media_errortype.as_ref() {
            let v = MediaErrorType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("mediaErrortype", &v)?;
        }
        if let Some(v) = self.speaker_setmute.as_ref() {
            struct_ser.serialize_field("speakerSetmute", v)?;
        }
        if let Some(v) = self.speaker_setvolume.as_ref() {
            struct_ser.serialize_field("speakerSetvolume", v)?;
        }
        if let Some(v) = self.speaker_ajustvolume.as_ref() {
            struct_ser.serialize_field("speakerAjustvolume", v)?;
        }
        if let Some(v) = self.template_devicelist.as_ref() {
            struct_ser.serialize_field("templateDevicelist", v)?;
        }
        if let Some(v) = self.execute_deviceskill.as_ref() {
            struct_ser.serialize_field("executeDeviceskill", v)?;
        }
        if let Some(v) = self.show_contacts.as_ref() {
            struct_ser.serialize_field("showContacts", v)?;
        }
        if let Some(v) = self.contact_data.as_ref() {
            struct_ser.serialize_field("contactData", v)?;
        }
        if let Some(v) = self.wearable_controller_switch.as_ref() {
            struct_ser.serialize_field("wearableControllerSwitch", v)?;
        }
        if let Some(v) = self.wearable_controller_execute.as_ref() {
            struct_ser.serialize_field("wearableControllerExecute", v)?;
        }
        if let Some(v) = self.llm_loading_card.as_ref() {
            struct_ser.serialize_field("llmLoadingCard", v)?;
        }
        if let Some(v) = self.llm_declaration_content.as_ref() {
            struct_ser.serialize_field("llmDeclarationContent", v)?;
        }
        if let Some(v) = self.llm_illegal_content.as_ref() {
            struct_ser.serialize_field("llmIllegalContent", v)?;
        }
        if let Some(v) = self.llm_toast_stream.as_ref() {
            struct_ser.serialize_field("llmToastStream", v)?;
        }
        if let Some(v) = self.wearable_controller_action.as_ref() {
            struct_ser.serialize_field("wearableControllerAction", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AivsInstruction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "result_type",
            "resultType",
            "session_id",
            "sessionId",
            "recognize_result",
            "recognizeResult",
            "template_toast",
            "templateToast",
            "template_general",
            "templateGeneral",
            "template_general2",
            "templateGeneral2",
            "template_weather",
            "templateWeather",
            "template_playinfo",
            "templatePlayinfo",
            "template_lists",
            "templateLists",
            "template_switchpanel",
            "templateSwitchpanel",
            "alerts_setalert",
            "alertsSetalert",
            "speechsynthesizer_speak",
            "speechsynthesizerSpeak",
            "laucher_lauchapp",
            "laucherLauchapp",
            "template_switchpanellist",
            "templateSwitchpanellist",
            "brightnesscontroller_ajustbrightness",
            "brightnesscontrollerAjustbrightness",
            "system_setproperty",
            "systemSetproperty",
            "application_operate",
            "applicationOperate",
            "alerts_deliveralertintention",
            "alertsDeliveralertintention",
            "media_errortype",
            "mediaErrortype",
            "speaker_setmute",
            "speakerSetmute",
            "speaker_setvolume",
            "speakerSetvolume",
            "speaker_ajustvolume",
            "speakerAjustvolume",
            "template_devicelist",
            "templateDevicelist",
            "execute_deviceskill",
            "executeDeviceskill",
            "show_contacts",
            "showContacts",
            "contact_data",
            "contactData",
            "wearable_controller_switch",
            "wearableControllerSwitch",
            "wearable_controller_execute",
            "wearableControllerExecute",
            "llm_loading_card",
            "llmLoadingCard",
            "llm_declaration_content",
            "llmDeclarationContent",
            "llm_illegal_content",
            "llmIllegalContent",
            "llm_toast_stream",
            "llmToastStream",
            "wearable_controller_action",
            "wearableControllerAction",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResultType,
            SessionId,
            RecognizeResult,
            TemplateToast,
            TemplateGeneral,
            TemplateGeneral2,
            TemplateWeather,
            TemplatePlayinfo,
            TemplateLists,
            TemplateSwitchpanel,
            AlertsSetalert,
            SpeechsynthesizerSpeak,
            LaucherLauchapp,
            TemplateSwitchpanellist,
            BrightnesscontrollerAjustbrightness,
            SystemSetproperty,
            ApplicationOperate,
            AlertsDeliveralertintention,
            MediaErrortype,
            SpeakerSetmute,
            SpeakerSetvolume,
            SpeakerAjustvolume,
            TemplateDevicelist,
            ExecuteDeviceskill,
            ShowContacts,
            ContactData,
            WearableControllerSwitch,
            WearableControllerExecute,
            LlmLoadingCard,
            LlmDeclarationContent,
            LlmIllegalContent,
            LlmToastStream,
            WearableControllerAction,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "resultType" | "result_type" => Ok(GeneratedField::ResultType),
                            "sessionId" | "session_id" => Ok(GeneratedField::SessionId),
                            "recognizeResult" | "recognize_result" => Ok(GeneratedField::RecognizeResult),
                            "templateToast" | "template_toast" => Ok(GeneratedField::TemplateToast),
                            "templateGeneral" | "template_general" => Ok(GeneratedField::TemplateGeneral),
                            "templateGeneral2" | "template_general2" => Ok(GeneratedField::TemplateGeneral2),
                            "templateWeather" | "template_weather" => Ok(GeneratedField::TemplateWeather),
                            "templatePlayinfo" | "template_playinfo" => Ok(GeneratedField::TemplatePlayinfo),
                            "templateLists" | "template_lists" => Ok(GeneratedField::TemplateLists),
                            "templateSwitchpanel" | "template_switchpanel" => Ok(GeneratedField::TemplateSwitchpanel),
                            "alertsSetalert" | "alerts_setalert" => Ok(GeneratedField::AlertsSetalert),
                            "speechsynthesizerSpeak" | "speechsynthesizer_speak" => Ok(GeneratedField::SpeechsynthesizerSpeak),
                            "laucherLauchapp" | "laucher_lauchapp" => Ok(GeneratedField::LaucherLauchapp),
                            "templateSwitchpanellist" | "template_switchpanellist" => Ok(GeneratedField::TemplateSwitchpanellist),
                            "brightnesscontrollerAjustbrightness" | "brightnesscontroller_ajustbrightness" => Ok(GeneratedField::BrightnesscontrollerAjustbrightness),
                            "systemSetproperty" | "system_setproperty" => Ok(GeneratedField::SystemSetproperty),
                            "applicationOperate" | "application_operate" => Ok(GeneratedField::ApplicationOperate),
                            "alertsDeliveralertintention" | "alerts_deliveralertintention" => Ok(GeneratedField::AlertsDeliveralertintention),
                            "mediaErrortype" | "media_errortype" => Ok(GeneratedField::MediaErrortype),
                            "speakerSetmute" | "speaker_setmute" => Ok(GeneratedField::SpeakerSetmute),
                            "speakerSetvolume" | "speaker_setvolume" => Ok(GeneratedField::SpeakerSetvolume),
                            "speakerAjustvolume" | "speaker_ajustvolume" => Ok(GeneratedField::SpeakerAjustvolume),
                            "templateDevicelist" | "template_devicelist" => Ok(GeneratedField::TemplateDevicelist),
                            "executeDeviceskill" | "execute_deviceskill" => Ok(GeneratedField::ExecuteDeviceskill),
                            "showContacts" | "show_contacts" => Ok(GeneratedField::ShowContacts),
                            "contactData" | "contact_data" => Ok(GeneratedField::ContactData),
                            "wearableControllerSwitch" | "wearable_controller_switch" => Ok(GeneratedField::WearableControllerSwitch),
                            "wearableControllerExecute" | "wearable_controller_execute" => Ok(GeneratedField::WearableControllerExecute),
                            "llmLoadingCard" | "llm_loading_card" => Ok(GeneratedField::LlmLoadingCard),
                            "llmDeclarationContent" | "llm_declaration_content" => Ok(GeneratedField::LlmDeclarationContent),
                            "llmIllegalContent" | "llm_illegal_content" => Ok(GeneratedField::LlmIllegalContent),
                            "llmToastStream" | "llm_toast_stream" => Ok(GeneratedField::LlmToastStream),
                            "wearableControllerAction" | "wearable_controller_action" => Ok(GeneratedField::WearableControllerAction),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AivsInstruction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AivsInstruction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AivsInstruction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result_type__ = None;
                let mut session_id__ = None;
                let mut recognize_result__ = None;
                let mut template_toast__ = None;
                let mut template_general__ = None;
                let mut template_general2__ = None;
                let mut template_weather__ = None;
                let mut template_playinfo__ = None;
                let mut template_lists__ = None;
                let mut template_switchpanel__ = None;
                let mut alerts_setalert__ = None;
                let mut speechsynthesizer_speak__ = None;
                let mut laucher_lauchapp__ = None;
                let mut template_switchpanellist__ = None;
                let mut brightnesscontroller_ajustbrightness__ = None;
                let mut system_setproperty__ = None;
                let mut application_operate__ = None;
                let mut alerts_deliveralertintention__ = None;
                let mut media_errortype__ = None;
                let mut speaker_setmute__ = None;
                let mut speaker_setvolume__ = None;
                let mut speaker_ajustvolume__ = None;
                let mut template_devicelist__ = None;
                let mut execute_deviceskill__ = None;
                let mut show_contacts__ = None;
                let mut contact_data__ = None;
                let mut wearable_controller_switch__ = None;
                let mut wearable_controller_execute__ = None;
                let mut llm_loading_card__ = None;
                let mut llm_declaration_content__ = None;
                let mut llm_illegal_content__ = None;
                let mut llm_toast_stream__ = None;
                let mut wearable_controller_action__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResultType => {
                            if result_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultType"));
                            }
                            result_type__ = Some(map_.next_value::<ResultType>()? as i32);
                        }
                        GeneratedField::SessionId => {
                            if session_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionId"));
                            }
                            session_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::RecognizeResult => {
                            if recognize_result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recognizeResult"));
                            }
                            recognize_result__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateToast => {
                            if template_toast__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateToast"));
                            }
                            template_toast__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateGeneral => {
                            if template_general__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateGeneral"));
                            }
                            template_general__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateGeneral2 => {
                            if template_general2__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateGeneral2"));
                            }
                            template_general2__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateWeather => {
                            if template_weather__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateWeather"));
                            }
                            template_weather__ = map_.next_value()?;
                        }
                        GeneratedField::TemplatePlayinfo => {
                            if template_playinfo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templatePlayinfo"));
                            }
                            template_playinfo__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateLists => {
                            if template_lists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateLists"));
                            }
                            template_lists__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateSwitchpanel => {
                            if template_switchpanel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateSwitchpanel"));
                            }
                            template_switchpanel__ = map_.next_value()?;
                        }
                        GeneratedField::AlertsSetalert => {
                            if alerts_setalert__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertsSetalert"));
                            }
                            alerts_setalert__ = map_.next_value()?;
                        }
                        GeneratedField::SpeechsynthesizerSpeak => {
                            if speechsynthesizer_speak__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speechsynthesizerSpeak"));
                            }
                            speechsynthesizer_speak__ = map_.next_value()?;
                        }
                        GeneratedField::LaucherLauchapp => {
                            if laucher_lauchapp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("laucherLauchapp"));
                            }
                            laucher_lauchapp__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateSwitchpanellist => {
                            if template_switchpanellist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateSwitchpanellist"));
                            }
                            template_switchpanellist__ = map_.next_value()?;
                        }
                        GeneratedField::BrightnesscontrollerAjustbrightness => {
                            if brightnesscontroller_ajustbrightness__.is_some() {
                                return Err(serde::de::Error::duplicate_field("brightnesscontrollerAjustbrightness"));
                            }
                            brightnesscontroller_ajustbrightness__ = map_.next_value()?;
                        }
                        GeneratedField::SystemSetproperty => {
                            if system_setproperty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemSetproperty"));
                            }
                            system_setproperty__ = map_.next_value()?;
                        }
                        GeneratedField::ApplicationOperate => {
                            if application_operate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("applicationOperate"));
                            }
                            application_operate__ = map_.next_value()?;
                        }
                        GeneratedField::AlertsDeliveralertintention => {
                            if alerts_deliveralertintention__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertsDeliveralertintention"));
                            }
                            alerts_deliveralertintention__ = map_.next_value()?;
                        }
                        GeneratedField::MediaErrortype => {
                            if media_errortype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaErrortype"));
                            }
                            media_errortype__ = map_.next_value::<::std::option::Option<MediaErrorType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SpeakerSetmute => {
                            if speaker_setmute__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speakerSetmute"));
                            }
                            speaker_setmute__ = map_.next_value()?;
                        }
                        GeneratedField::SpeakerSetvolume => {
                            if speaker_setvolume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speakerSetvolume"));
                            }
                            speaker_setvolume__ = map_.next_value()?;
                        }
                        GeneratedField::SpeakerAjustvolume => {
                            if speaker_ajustvolume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speakerAjustvolume"));
                            }
                            speaker_ajustvolume__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateDevicelist => {
                            if template_devicelist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateDevicelist"));
                            }
                            template_devicelist__ = map_.next_value()?;
                        }
                        GeneratedField::ExecuteDeviceskill => {
                            if execute_deviceskill__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executeDeviceskill"));
                            }
                            execute_deviceskill__ = map_.next_value()?;
                        }
                        GeneratedField::ShowContacts => {
                            if show_contacts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("showContacts"));
                            }
                            show_contacts__ = map_.next_value()?;
                        }
                        GeneratedField::ContactData => {
                            if contact_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contactData"));
                            }
                            contact_data__ = map_.next_value()?;
                        }
                        GeneratedField::WearableControllerSwitch => {
                            if wearable_controller_switch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearableControllerSwitch"));
                            }
                            wearable_controller_switch__ = map_.next_value()?;
                        }
                        GeneratedField::WearableControllerExecute => {
                            if wearable_controller_execute__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearableControllerExecute"));
                            }
                            wearable_controller_execute__ = map_.next_value()?;
                        }
                        GeneratedField::LlmLoadingCard => {
                            if llm_loading_card__.is_some() {
                                return Err(serde::de::Error::duplicate_field("llmLoadingCard"));
                            }
                            llm_loading_card__ = map_.next_value()?;
                        }
                        GeneratedField::LlmDeclarationContent => {
                            if llm_declaration_content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("llmDeclarationContent"));
                            }
                            llm_declaration_content__ = map_.next_value()?;
                        }
                        GeneratedField::LlmIllegalContent => {
                            if llm_illegal_content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("llmIllegalContent"));
                            }
                            llm_illegal_content__ = map_.next_value()?;
                        }
                        GeneratedField::LlmToastStream => {
                            if llm_toast_stream__.is_some() {
                                return Err(serde::de::Error::duplicate_field("llmToastStream"));
                            }
                            llm_toast_stream__ = map_.next_value()?;
                        }
                        GeneratedField::WearableControllerAction => {
                            if wearable_controller_action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearableControllerAction"));
                            }
                            wearable_controller_action__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AivsInstruction {
                    result_type: result_type__.ok_or_else(|| serde::de::Error::missing_field("resultType"))?,
                    session_id: session_id__.ok_or_else(|| serde::de::Error::missing_field("sessionId"))?,
                    recognize_result: recognize_result__,
                    template_toast: template_toast__,
                    template_general: template_general__,
                    template_general2: template_general2__,
                    template_weather: template_weather__,
                    template_playinfo: template_playinfo__,
                    template_lists: template_lists__,
                    template_switchpanel: template_switchpanel__,
                    alerts_setalert: alerts_setalert__,
                    speechsynthesizer_speak: speechsynthesizer_speak__,
                    laucher_lauchapp: laucher_lauchapp__,
                    template_switchpanellist: template_switchpanellist__,
                    brightnesscontroller_ajustbrightness: brightnesscontroller_ajustbrightness__,
                    system_setproperty: system_setproperty__,
                    application_operate: application_operate__,
                    alerts_deliveralertintention: alerts_deliveralertintention__,
                    media_errortype: media_errortype__,
                    speaker_setmute: speaker_setmute__,
                    speaker_setvolume: speaker_setvolume__,
                    speaker_ajustvolume: speaker_ajustvolume__,
                    template_devicelist: template_devicelist__,
                    execute_deviceskill: execute_deviceskill__,
                    show_contacts: show_contacts__,
                    contact_data: contact_data__,
                    wearable_controller_switch: wearable_controller_switch__,
                    wearable_controller_execute: wearable_controller_execute__,
                    llm_loading_card: llm_loading_card__,
                    llm_declaration_content: llm_declaration_content__,
                    llm_illegal_content: llm_illegal_content__,
                    llm_toast_stream: llm_toast_stream__,
                    wearable_controller_action: wearable_controller_action__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AivsInstruction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_instruction::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AivsInstruction.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for aivs_instruction::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_instruction::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AivsInstruction.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<aivs_instruction::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(aivs_instruction::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AivsInstruction.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AivsRequestInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AivsRequestInfo", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("requestId", pbjson::private::base64::encode(&self.request_id).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("transactionId", pbjson::private::base64::encode(&self.transaction_id).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AivsRequestInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "request_id",
            "requestId",
            "transaction_id",
            "transactionId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RequestId,
            TransactionId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "requestId" | "request_id" => Ok(GeneratedField::RequestId),
                            "transactionId" | "transaction_id" => Ok(GeneratedField::TransactionId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AivsRequestInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AivsRequestInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AivsRequestInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request_id__ = None;
                let mut transaction_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RequestId => {
                            if request_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requestId"));
                            }
                            request_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::TransactionId => {
                            if transaction_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactionId"));
                            }
                            transaction_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AivsRequestInfo {
                    request_id: request_id__.ok_or_else(|| serde::de::Error::missing_field("requestId"))?,
                    transaction_id: transaction_id__.ok_or_else(|| serde::de::Error::missing_field("transactionId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AivsRequestInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AivsStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 6;
        let mut struct_ser = serializer.serialize_struct("protocol.AivsStatus", len)?;
        let v = aivs_status::VoiceStatus::try_from(self.voice_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.voice_status)))?;
        struct_ser.serialize_field("voiceStatus", &v)?;
        let v = aivs_status::TtsStatus::try_from(self.tts_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.tts_status)))?;
        struct_ser.serialize_field("ttsStatus", &v)?;
        let v = aivs_status::MediaPlayStatus::try_from(self.media_play_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.media_play_status)))?;
        struct_ser.serialize_field("mediaPlayStatus", &v)?;
        let v = aivs_status::ImageStatus::try_from(self.image_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.image_status)))?;
        struct_ser.serialize_field("imageStatus", &v)?;
        let v = aivs_status::OperatingStatus::try_from(self.operating_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.operating_status)))?;
        struct_ser.serialize_field("operatingStatus", &v)?;
        let v = aivs_status::DeviceStatus::try_from(self.device_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.device_status)))?;
        struct_ser.serialize_field("deviceStatus", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AivsStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "voice_status",
            "voiceStatus",
            "tts_status",
            "ttsStatus",
            "media_play_status",
            "mediaPlayStatus",
            "image_status",
            "imageStatus",
            "operating_status",
            "operatingStatus",
            "device_status",
            "deviceStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VoiceStatus,
            TtsStatus,
            MediaPlayStatus,
            ImageStatus,
            OperatingStatus,
            DeviceStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "voiceStatus" | "voice_status" => Ok(GeneratedField::VoiceStatus),
                            "ttsStatus" | "tts_status" => Ok(GeneratedField::TtsStatus),
                            "mediaPlayStatus" | "media_play_status" => Ok(GeneratedField::MediaPlayStatus),
                            "imageStatus" | "image_status" => Ok(GeneratedField::ImageStatus),
                            "operatingStatus" | "operating_status" => Ok(GeneratedField::OperatingStatus),
                            "deviceStatus" | "device_status" => Ok(GeneratedField::DeviceStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AivsStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AivsStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AivsStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut voice_status__ = None;
                let mut tts_status__ = None;
                let mut media_play_status__ = None;
                let mut image_status__ = None;
                let mut operating_status__ = None;
                let mut device_status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VoiceStatus => {
                            if voice_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("voiceStatus"));
                            }
                            voice_status__ = Some(map_.next_value::<aivs_status::VoiceStatus>()? as i32);
                        }
                        GeneratedField::TtsStatus => {
                            if tts_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ttsStatus"));
                            }
                            tts_status__ = Some(map_.next_value::<aivs_status::TtsStatus>()? as i32);
                        }
                        GeneratedField::MediaPlayStatus => {
                            if media_play_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaPlayStatus"));
                            }
                            media_play_status__ = Some(map_.next_value::<aivs_status::MediaPlayStatus>()? as i32);
                        }
                        GeneratedField::ImageStatus => {
                            if image_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageStatus"));
                            }
                            image_status__ = Some(map_.next_value::<aivs_status::ImageStatus>()? as i32);
                        }
                        GeneratedField::OperatingStatus => {
                            if operating_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operatingStatus"));
                            }
                            operating_status__ = Some(map_.next_value::<aivs_status::OperatingStatus>()? as i32);
                        }
                        GeneratedField::DeviceStatus => {
                            if device_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceStatus"));
                            }
                            device_status__ = Some(map_.next_value::<aivs_status::DeviceStatus>()? as i32);
                        }
                    }
                }
                Ok(AivsStatus {
                    voice_status: voice_status__.ok_or_else(|| serde::de::Error::missing_field("voiceStatus"))?,
                    tts_status: tts_status__.ok_or_else(|| serde::de::Error::missing_field("ttsStatus"))?,
                    media_play_status: media_play_status__.ok_or_else(|| serde::de::Error::missing_field("mediaPlayStatus"))?,
                    image_status: image_status__.ok_or_else(|| serde::de::Error::missing_field("imageStatus"))?,
                    operating_status: operating_status__.ok_or_else(|| serde::de::Error::missing_field("operatingStatus"))?,
                    device_status: device_status__.ok_or_else(|| serde::de::Error::missing_field("deviceStatus"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AivsStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_status::DeviceStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ConnectedOnline => "CONNECTED_ONLINE",
            Self::ConnectedOffline => "CONNECTED_OFFLINE",
            Self::DisconnectedOffline => "DISCONNECTED_OFFLINE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs_status::DeviceStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CONNECTED_ONLINE",
            "CONNECTED_OFFLINE",
            "DISCONNECTED_OFFLINE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_status::DeviceStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CONNECTED_ONLINE" => Ok(aivs_status::DeviceStatus::ConnectedOnline),
                    "CONNECTED_OFFLINE" => Ok(aivs_status::DeviceStatus::ConnectedOffline),
                    "DISCONNECTED_OFFLINE" => Ok(aivs_status::DeviceStatus::DisconnectedOffline),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_status::ImageStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ImageIdle => "IMAGE_IDLE",
            Self::ImagePrepare => "IMAGE_PREPARE",
            Self::ImageUploading => "IMAGE_UPLOADING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs_status::ImageStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IMAGE_IDLE",
            "IMAGE_PREPARE",
            "IMAGE_UPLOADING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_status::ImageStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "IMAGE_IDLE" => Ok(aivs_status::ImageStatus::ImageIdle),
                    "IMAGE_PREPARE" => Ok(aivs_status::ImageStatus::ImagePrepare),
                    "IMAGE_UPLOADING" => Ok(aivs_status::ImageStatus::ImageUploading),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_status::MediaPlayStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::MediaIdle => "MEDIA_IDLE",
            Self::MediaPlaying => "MEDIA_PLAYING",
            Self::MediaPaused => "MEDIA_PAUSED",
            Self::MediaStopped => "MEDIA_STOPPED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs_status::MediaPlayStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MEDIA_IDLE",
            "MEDIA_PLAYING",
            "MEDIA_PAUSED",
            "MEDIA_STOPPED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_status::MediaPlayStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "MEDIA_IDLE" => Ok(aivs_status::MediaPlayStatus::MediaIdle),
                    "MEDIA_PLAYING" => Ok(aivs_status::MediaPlayStatus::MediaPlaying),
                    "MEDIA_PAUSED" => Ok(aivs_status::MediaPlayStatus::MediaPaused),
                    "MEDIA_STOPPED" => Ok(aivs_status::MediaPlayStatus::MediaStopped),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_status::OperatingStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::OperatingIdle => "OPERATING_IDLE",
            Self::Executing => "EXECUTING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs_status::OperatingStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OPERATING_IDLE",
            "EXECUTING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_status::OperatingStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OPERATING_IDLE" => Ok(aivs_status::OperatingStatus::OperatingIdle),
                    "EXECUTING" => Ok(aivs_status::OperatingStatus::Executing),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_status::TtsStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::TtsIdle => "TTS_IDLE",
            Self::TtsPlaying => "TTS_PLAYING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs_status::TtsStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TTS_IDLE",
            "TTS_PLAYING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_status::TtsStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TTS_IDLE" => Ok(aivs_status::TtsStatus::TtsIdle),
                    "TTS_PLAYING" => Ok(aivs_status::TtsStatus::TtsPlaying),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for aivs_status::VoiceStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::VoiceIdle => "VOICE_IDLE",
            Self::WakeUp => "WAKE_UP",
            Self::Recording => "RECORDING",
            Self::Standby => "STANDBY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for aivs_status::VoiceStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VOICE_IDLE",
            "WAKE_UP",
            "RECORDING",
            "STANDBY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = aivs_status::VoiceStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "VOICE_IDLE" => Ok(aivs_status::VoiceStatus::VoiceIdle),
                    "WAKE_UP" => Ok(aivs_status::VoiceStatus::WakeUp),
                    "RECORDING" => Ok(aivs_status::VoiceStatus::Recording),
                    "STANDBY" => Ok(aivs_status::VoiceStatus::Standby),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlertCircleType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "AlertCircleType_UNKNOWN",
            Self::Once => "ONCE",
            Self::Everyday => "EVERYDAY",
            Self::Workday => "WORKDAY",
            Self::MondayToFriday => "MONDAY_TO_FRIDAY",
            Self::Holiday => "HOLIDAY",
            Self::Weekend => "WEEKEND",
            Self::Weekly => "WEEKLY",
            Self::Monthly => "MONTHLY",
            Self::Yearly => "YEARLY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlertCircleType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AlertCircleType_UNKNOWN",
            "ONCE",
            "EVERYDAY",
            "WORKDAY",
            "MONDAY_TO_FRIDAY",
            "HOLIDAY",
            "WEEKEND",
            "WEEKLY",
            "MONTHLY",
            "YEARLY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertCircleType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AlertCircleType_UNKNOWN" => Ok(AlertCircleType::Unknown),
                    "ONCE" => Ok(AlertCircleType::Once),
                    "EVERYDAY" => Ok(AlertCircleType::Everyday),
                    "WORKDAY" => Ok(AlertCircleType::Workday),
                    "MONDAY_TO_FRIDAY" => Ok(AlertCircleType::MondayToFriday),
                    "HOLIDAY" => Ok(AlertCircleType::Holiday),
                    "WEEKEND" => Ok(AlertCircleType::Weekend),
                    "WEEKLY" => Ok(AlertCircleType::Weekly),
                    "MONTHLY" => Ok(AlertCircleType::Monthly),
                    "YEARLY" => Ok(AlertCircleType::Yearly),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlertDateTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertDateTime", len)?;
        struct_ser.serialize_field("value", &self.value)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("timestamp", ToString::to_string(&self.timestamp).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlertDateTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
            "timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertDateTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertDateTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlertDateTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AlertDateTime {
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertDateTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlertFilterType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AlertfilterUnknown => "ALERTFILTER_UNKNOWN",
            Self::AlertfilterRecentlySet => "ALERTFILTER_RECENTLY_SET",
            Self::AlertfilterRecentlyCall => "ALERTFILTER_RECENTLY_CALL",
            Self::AlertfilterOnStatus => "ALERTFILTER_ON_STATUS",
            Self::AlertfilterOffStatus => "ALERTFILTER_OFF_STATUS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlertFilterType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALERTFILTER_UNKNOWN",
            "ALERTFILTER_RECENTLY_SET",
            "ALERTFILTER_RECENTLY_CALL",
            "ALERTFILTER_ON_STATUS",
            "ALERTFILTER_OFF_STATUS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertFilterType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALERTFILTER_UNKNOWN" => Ok(AlertFilterType::AlertfilterUnknown),
                    "ALERTFILTER_RECENTLY_SET" => Ok(AlertFilterType::AlertfilterRecentlySet),
                    "ALERTFILTER_RECENTLY_CALL" => Ok(AlertFilterType::AlertfilterRecentlyCall),
                    "ALERTFILTER_ON_STATUS" => Ok(AlertFilterType::AlertfilterOnStatus),
                    "ALERTFILTER_OFF_STATUS" => Ok(AlertFilterType::AlertfilterOffStatus),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlertOperation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "AlertOperation_UNKNOWN",
            Self::Open => "OPEN",
            Self::Close => "CLOSE",
            Self::Pause => "PAUSE",
            Self::Proceed => "PROCEED",
            Self::Query => "QUERY",
            Self::Delete => "DELETE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlertOperation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AlertOperation_UNKNOWN",
            "OPEN",
            "CLOSE",
            "PAUSE",
            "PROCEED",
            "QUERY",
            "DELETE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertOperation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AlertOperation_UNKNOWN" => Ok(AlertOperation::Unknown),
                    "OPEN" => Ok(AlertOperation::Open),
                    "CLOSE" => Ok(AlertOperation::Close),
                    "PAUSE" => Ok(AlertOperation::Pause),
                    "PROCEED" => Ok(AlertOperation::Proceed),
                    "QUERY" => Ok(AlertOperation::Query),
                    "DELETE" => Ok(AlertOperation::Delete),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlertStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.battery.is_some() {
            len += 1;
        }
        if self.temperature.is_some() {
            len += 1;
        }
        if self.storage.is_some() {
            len += 1;
        }
        if self.ota.is_some() {
            len += 1;
        }
        if self.electrochromic.is_some() {
            len += 1;
        }
        if self.camera.is_some() {
            len += 1;
        }
        if self.wear.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus", len)?;
        if let Some(v) = self.battery.as_ref() {
            struct_ser.serialize_field("battery", v)?;
        }
        if let Some(v) = self.temperature.as_ref() {
            struct_ser.serialize_field("temperature", v)?;
        }
        if let Some(v) = self.storage.as_ref() {
            struct_ser.serialize_field("storage", v)?;
        }
        if let Some(v) = self.ota.as_ref() {
            struct_ser.serialize_field("ota", v)?;
        }
        if let Some(v) = self.electrochromic.as_ref() {
            struct_ser.serialize_field("electrochromic", v)?;
        }
        if let Some(v) = self.camera.as_ref() {
            struct_ser.serialize_field("camera", v)?;
        }
        if let Some(v) = self.wear.as_ref() {
            struct_ser.serialize_field("wear", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlertStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "battery",
            "temperature",
            "storage",
            "ota",
            "electrochromic",
            "camera",
            "wear",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Battery,
            Temperature,
            Storage,
            Ota,
            Electrochromic,
            Camera,
            Wear,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "battery" => Ok(GeneratedField::Battery),
                            "temperature" => Ok(GeneratedField::Temperature),
                            "storage" => Ok(GeneratedField::Storage),
                            "ota" => Ok(GeneratedField::Ota),
                            "electrochromic" => Ok(GeneratedField::Electrochromic),
                            "camera" => Ok(GeneratedField::Camera),
                            "wear" => Ok(GeneratedField::Wear),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlertStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut battery__ = None;
                let mut temperature__ = None;
                let mut storage__ = None;
                let mut ota__ = None;
                let mut electrochromic__ = None;
                let mut camera__ = None;
                let mut wear__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Battery => {
                            if battery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("battery"));
                            }
                            battery__ = map_.next_value()?;
                        }
                        GeneratedField::Temperature => {
                            if temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("temperature"));
                            }
                            temperature__ = map_.next_value()?;
                        }
                        GeneratedField::Storage => {
                            if storage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storage"));
                            }
                            storage__ = map_.next_value()?;
                        }
                        GeneratedField::Ota => {
                            if ota__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ota"));
                            }
                            ota__ = map_.next_value()?;
                        }
                        GeneratedField::Electrochromic => {
                            if electrochromic__.is_some() {
                                return Err(serde::de::Error::duplicate_field("electrochromic"));
                            }
                            electrochromic__ = map_.next_value()?;
                        }
                        GeneratedField::Camera => {
                            if camera__.is_some() {
                                return Err(serde::de::Error::duplicate_field("camera"));
                            }
                            camera__ = map_.next_value()?;
                        }
                        GeneratedField::Wear => {
                            if wear__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wear"));
                            }
                            wear__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlertStatus {
                    battery: battery__,
                    temperature: temperature__,
                    storage: storage__,
                    ota: ota__,
                    electrochromic: electrochromic__,
                    camera: camera__,
                    wear: wear__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Battery {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Battery", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("capacity", &self.capacity)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Battery {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "capacity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Capacity,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "capacity" => Ok(GeneratedField::Capacity),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Battery;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Battery")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Battery, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut capacity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capacity"));
                            }
                            capacity__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Battery {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    capacity: capacity__.ok_or_else(|| serde::de::Error::missing_field("capacity"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Battery", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Camera {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Camera", len)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Camera {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Camera;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Camera")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Camera, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Camera {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Camera", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Electrochromic {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Electrochromic", len)?;
        struct_ser.serialize_field("color", &self.color)?;
        struct_ser.serialize_field("level", &self.level)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Electrochromic {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "color",
            "level",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Color,
            Level,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "color" => Ok(GeneratedField::Color),
                            "level" => Ok(GeneratedField::Level),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Electrochromic;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Electrochromic")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Electrochromic, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut color__ = None;
                let mut level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Color => {
                            if color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("color"));
                            }
                            color__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("level"));
                            }
                            level__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Electrochromic {
                    color: color__.ok_or_else(|| serde::de::Error::missing_field("color"))?,
                    level: level__.ok_or_else(|| serde::de::Error::missing_field("level"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Electrochromic", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Ota {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.status.is_some() {
            len += 1;
        }
        if self.error_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Ota", len)?;
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.error_code.as_ref() {
            struct_ser.serialize_field("errorCode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Ota {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
            "error_code",
            "errorCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            ErrorCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "errorCode" | "error_code" => Ok(GeneratedField::ErrorCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Ota;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Ota")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Ota, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut error_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ErrorCode => {
                            if error_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorCode"));
                            }
                            error_code__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Ota {
                    status: status__,
                    error_code: error_code__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Ota", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Storage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Storage", len)?;
        struct_ser.serialize_field("freeSpace", &self.free_space)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Storage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "free_space",
            "freeSpace",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FreeSpace,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "freeSpace" | "free_space" => Ok(GeneratedField::FreeSpace),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Storage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Storage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Storage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut free_space__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FreeSpace => {
                            if free_space__.is_some() {
                                return Err(serde::de::Error::duplicate_field("freeSpace"));
                            }
                            free_space__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Storage {
                    free_space: free_space__.ok_or_else(|| serde::de::Error::missing_field("freeSpace"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Storage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Temperature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Temperature", len)?;
        struct_ser.serialize_field("high", &self.high)?;
        struct_ser.serialize_field("temp", &self.temp)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Temperature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "high",
            "temp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            High,
            Temp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "high" => Ok(GeneratedField::High),
                            "temp" => Ok(GeneratedField::Temp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Temperature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Temperature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Temperature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut high__ = None;
                let mut temp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::High => {
                            if high__.is_some() {
                                return Err(serde::de::Error::duplicate_field("high"));
                            }
                            high__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Temp => {
                            if temp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("temp"));
                            }
                            temp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Temperature {
                    high: high__.ok_or_else(|| serde::de::Error::missing_field("high"))?,
                    temp: temp__.ok_or_else(|| serde::de::Error::missing_field("temp"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Temperature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alert_status::Wear {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AlertStatus.Wear", len)?;
        struct_ser.serialize_field("mode", &self.mode)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alert_status::Wear {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mode" => Ok(GeneratedField::Mode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alert_status::Wear;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertStatus.Wear")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alert_status::Wear, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(alert_status::Wear {
                    mode: mode__.ok_or_else(|| serde::de::Error::missing_field("mode"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertStatus.Wear", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlertTimeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.datetime.is_some() {
            len += 1;
        }
        if self.start_datetime.is_some() {
            len += 1;
        }
        if self.end_datetime.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlertTimeInfo", len)?;
        let v = AlertTimeType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("token", &self.token)?;
        if let Some(v) = self.datetime.as_ref() {
            struct_ser.serialize_field("datetime", v)?;
        }
        if let Some(v) = self.start_datetime.as_ref() {
            struct_ser.serialize_field("startDatetime", v)?;
        }
        if let Some(v) = self.end_datetime.as_ref() {
            struct_ser.serialize_field("endDatetime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlertTimeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "token",
            "datetime",
            "start_datetime",
            "startDatetime",
            "end_datetime",
            "endDatetime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Token,
            Datetime,
            StartDatetime,
            EndDatetime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "token" => Ok(GeneratedField::Token),
                            "datetime" => Ok(GeneratedField::Datetime),
                            "startDatetime" | "start_datetime" => Ok(GeneratedField::StartDatetime),
                            "endDatetime" | "end_datetime" => Ok(GeneratedField::EndDatetime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertTimeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertTimeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlertTimeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut token__ = None;
                let mut datetime__ = None;
                let mut start_datetime__ = None;
                let mut end_datetime__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<AlertTimeType>()? as i32);
                        }
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("token"));
                            }
                            token__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Datetime => {
                            if datetime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datetime"));
                            }
                            datetime__ = map_.next_value()?;
                        }
                        GeneratedField::StartDatetime => {
                            if start_datetime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startDatetime"));
                            }
                            start_datetime__ = map_.next_value()?;
                        }
                        GeneratedField::EndDatetime => {
                            if end_datetime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endDatetime"));
                            }
                            end_datetime__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlertTimeInfo {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    token: token__.ok_or_else(|| serde::de::Error::missing_field("token"))?,
                    datetime: datetime__,
                    start_datetime: start_datetime__,
                    end_datetime: end_datetime__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertTimeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlertTimeType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AlerttimeUnknown => "ALERTTIME_UNKNOWN",
            Self::AlerttimeDatetime => "ALERTTIME_DATETIME",
            Self::AlerttimeDuration => "ALERTTIME_DURATION",
            Self::AlerttimeOffset => "ALERTTIME_OFFSET",
            Self::AlerttimeIndeterDatetime => "ALERTTIME_INDETER_DATETIME",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlertTimeType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALERTTIME_UNKNOWN",
            "ALERTTIME_DATETIME",
            "ALERTTIME_DURATION",
            "ALERTTIME_OFFSET",
            "ALERTTIME_INDETER_DATETIME",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertTimeType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALERTTIME_UNKNOWN" => Ok(AlertTimeType::AlerttimeUnknown),
                    "ALERTTIME_DATETIME" => Ok(AlertTimeType::AlerttimeDatetime),
                    "ALERTTIME_DURATION" => Ok(AlertTimeType::AlerttimeDuration),
                    "ALERTTIME_OFFSET" => Ok(AlertTimeType::AlerttimeOffset),
                    "ALERTTIME_INDETER_DATETIME" => Ok(AlertTimeType::AlerttimeIndeterDatetime),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlertType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "AlertType_UNKNOWN",
            Self::Alarm => "ALARM",
            Self::Reminder => "REMINDER",
            Self::Timer => "TIMER",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlertType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AlertType_UNKNOWN",
            "ALARM",
            "REMINDER",
            "TIMER",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AlertType_UNKNOWN" => Ok(AlertType::Unknown),
                    "ALARM" => Ok(AlertType::Alarm),
                    "REMINDER" => Ok(AlertType::Reminder),
                    "TIMER" => Ok(AlertType::Timer),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Alerts {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.Alerts", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("level", &self.level)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("detail", &self.detail)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Alerts {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "level",
            "title",
            "detail",
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Level,
            Title,
            Detail,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "level" => Ok(GeneratedField::Level),
                            "title" => Ok(GeneratedField::Title),
                            "detail" => Ok(GeneratedField::Detail),
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Alerts;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Alerts")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Alerts, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut level__ = None;
                let mut title__ = None;
                let mut detail__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("level"));
                            }
                            level__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Alerts {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    level: level__.ok_or_else(|| serde::de::Error::missing_field("level"))?,
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    detail: detail__.ok_or_else(|| serde::de::Error::missing_field("detail"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Alerts", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alerts::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Alerts.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alerts::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alerts::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Alerts.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alerts::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(alerts::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Alerts.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlertsDeliverAlertIntention {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 5;
        if self.circle.is_some() {
            len += 1;
        }
        if self.filter_type.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlertsDeliverAlertIntention", len)?;
        let v = AlertType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        let v = AlertOperation::try_from(self.operation)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.operation)))?;
        struct_ser.serialize_field("operation", &v)?;
        struct_ser.serialize_field("operateAll", &self.operate_all)?;
        if let Some(v) = self.circle.as_ref() {
            let v = AlertCircleType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("circle", &v)?;
        }
        struct_ser.serialize_field("circleExtra", &self.circle_extra)?;
        struct_ser.serialize_field("event", &self.event)?;
        if let Some(v) = self.filter_type.as_ref() {
            let v = AlertFilterType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("filterType", &v)?;
        }
        if let Some(v) = self.time.as_ref() {
            struct_ser.serialize_field("time", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlertsDeliverAlertIntention {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "operation",
            "operate_all",
            "operateAll",
            "circle",
            "circle_extra",
            "circleExtra",
            "event",
            "filter_type",
            "filterType",
            "time",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Operation,
            OperateAll,
            Circle,
            CircleExtra,
            Event,
            FilterType,
            Time,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "operation" => Ok(GeneratedField::Operation),
                            "operateAll" | "operate_all" => Ok(GeneratedField::OperateAll),
                            "circle" => Ok(GeneratedField::Circle),
                            "circleExtra" | "circle_extra" => Ok(GeneratedField::CircleExtra),
                            "event" => Ok(GeneratedField::Event),
                            "filterType" | "filter_type" => Ok(GeneratedField::FilterType),
                            "time" => Ok(GeneratedField::Time),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertsDeliverAlertIntention;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertsDeliverAlertIntention")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlertsDeliverAlertIntention, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut operation__ = None;
                let mut operate_all__ = None;
                let mut circle__ = None;
                let mut circle_extra__ = None;
                let mut event__ = None;
                let mut filter_type__ = None;
                let mut time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<AlertType>()? as i32);
                        }
                        GeneratedField::Operation => {
                            if operation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operation"));
                            }
                            operation__ = Some(map_.next_value::<AlertOperation>()? as i32);
                        }
                        GeneratedField::OperateAll => {
                            if operate_all__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operateAll"));
                            }
                            operate_all__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Circle => {
                            if circle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("circle"));
                            }
                            circle__ = map_.next_value::<::std::option::Option<AlertCircleType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CircleExtra => {
                            if circle_extra__.is_some() {
                                return Err(serde::de::Error::duplicate_field("circleExtra"));
                            }
                            circle_extra__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Event => {
                            if event__.is_some() {
                                return Err(serde::de::Error::duplicate_field("event"));
                            }
                            event__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FilterType => {
                            if filter_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("filterType"));
                            }
                            filter_type__ = map_.next_value::<::std::option::Option<AlertFilterType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            time__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlertsDeliverAlertIntention {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    operation: operation__.ok_or_else(|| serde::de::Error::missing_field("operation"))?,
                    operate_all: operate_all__.ok_or_else(|| serde::de::Error::missing_field("operateAll"))?,
                    circle: circle__,
                    circle_extra: circle_extra__.ok_or_else(|| serde::de::Error::missing_field("circleExtra"))?,
                    event: event__.ok_or_else(|| serde::de::Error::missing_field("event"))?,
                    filter_type: filter_type__,
                    time: time__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertsDeliverAlertIntention", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlertsSetAlert {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 6;
        if self.circle.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlertsSetAlert", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        let v = AlertType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("datetime", &self.datetime)?;
        if let Some(v) = self.circle.as_ref() {
            let v = AlertCircleType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("circle", &v)?;
        }
        struct_ser.serialize_field("circleExtra", &self.circle_extra)?;
        struct_ser.serialize_field("offset", &self.offset)?;
        struct_ser.serialize_field("event", &self.event)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlertsSetAlert {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "type",
            "datetime",
            "circle",
            "circle_extra",
            "circleExtra",
            "offset",
            "event",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Type,
            Datetime,
            Circle,
            CircleExtra,
            Offset,
            Event,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "type" => Ok(GeneratedField::Type),
                            "datetime" => Ok(GeneratedField::Datetime),
                            "circle" => Ok(GeneratedField::Circle),
                            "circleExtra" | "circle_extra" => Ok(GeneratedField::CircleExtra),
                            "offset" => Ok(GeneratedField::Offset),
                            "event" => Ok(GeneratedField::Event),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlertsSetAlert;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlertsSetAlert")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlertsSetAlert, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut r#type__ = None;
                let mut datetime__ = None;
                let mut circle__ = None;
                let mut circle_extra__ = None;
                let mut offset__ = None;
                let mut event__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<AlertType>()? as i32);
                        }
                        GeneratedField::Datetime => {
                            if datetime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datetime"));
                            }
                            datetime__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Circle => {
                            if circle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("circle"));
                            }
                            circle__ = map_.next_value::<::std::option::Option<AlertCircleType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CircleExtra => {
                            if circle_extra__.is_some() {
                                return Err(serde::de::Error::duplicate_field("circleExtra"));
                            }
                            circle_extra__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Offset => {
                            if offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offset"));
                            }
                            offset__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Event => {
                            if event__.is_some() {
                                return Err(serde::de::Error::duplicate_field("event"));
                            }
                            event__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlertsSetAlert {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    datetime: datetime__.ok_or_else(|| serde::de::Error::missing_field("datetime"))?,
                    circle: circle__,
                    circle_extra: circle_extra__.ok_or_else(|| serde::de::Error::missing_field("circleExtra"))?,
                    offset: offset__.ok_or_else(|| serde::de::Error::missing_field("offset"))?,
                    event: event__.ok_or_else(|| serde::de::Error::missing_field("event"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlertsSetAlert", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Alexa {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Alexa", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                alexa::Payload::InstructionList(v) => {
                    struct_ser.serialize_field("instructionList", v)?;
                }
                alexa::Payload::Config(v) => {
                    struct_ser.serialize_field("config", v)?;
                }
                alexa::Payload::QuietMode(v) => {
                    struct_ser.serialize_field("quietMode", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Alexa {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "instruction_list",
            "instructionList",
            "config",
            "quiet_mode",
            "quietMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            InstructionList,
            Config,
            QuietMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "instructionList" | "instruction_list" => Ok(GeneratedField::InstructionList),
                            "config" => Ok(GeneratedField::Config),
                            "quietMode" | "quiet_mode" => Ok(GeneratedField::QuietMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Alexa;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Alexa")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Alexa, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::InstructionList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("instructionList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(alexa::Payload::InstructionList)
;
                        }
                        GeneratedField::Config => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("config"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(alexa::Payload::Config)
;
                        }
                        GeneratedField::QuietMode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quietMode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(alexa::Payload::QuietMode)
;
                        }
                    }
                }
                Ok(Alexa {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Alexa", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alexa::AlexaId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SyncInstructionList => "SYNC_INSTRUCTION_LIST",
            Self::SetConfig => "SET_CONFIG",
            Self::GetConfig => "GET_CONFIG",
            Self::ReportQuietMode => "REPORT_QUIET_MODE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for alexa::AlexaId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SYNC_INSTRUCTION_LIST",
            "SET_CONFIG",
            "GET_CONFIG",
            "REPORT_QUIET_MODE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alexa::AlexaId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SYNC_INSTRUCTION_LIST" => Ok(alexa::AlexaId::SyncInstructionList),
                    "SET_CONFIG" => Ok(alexa::AlexaId::SetConfig),
                    "GET_CONFIG" => Ok(alexa::AlexaId::GetConfig),
                    "REPORT_QUIET_MODE" => Ok(alexa::AlexaId::ReportQuietMode),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaAlertType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "ALEXA_AlertType_UNKNOWN",
            Self::AlexaAlarm => "ALEXA_ALARM",
            Self::AlexaReminder => "ALEXA_REMINDER",
            Self::AlexaTimer => "ALEXA_TIMER",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlexaAlertType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALEXA_AlertType_UNKNOWN",
            "ALEXA_ALARM",
            "ALEXA_REMINDER",
            "ALEXA_TIMER",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaAlertType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALEXA_AlertType_UNKNOWN" => Ok(AlexaAlertType::Unknown),
                    "ALEXA_ALARM" => Ok(AlexaAlertType::AlexaAlarm),
                    "ALEXA_REMINDER" => Ok(AlexaAlertType::AlexaReminder),
                    "ALEXA_TIMER" => Ok(AlexaAlertType::AlexaTimer),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaAlertsDeleteAlert {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaAlertsDeleteAlert", len)?;
        struct_ser.serialize_field("token", &self.token)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaAlertsDeleteAlert {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "token",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Token,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "token" => Ok(GeneratedField::Token),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaAlertsDeleteAlert;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaAlertsDeleteAlert")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaAlertsDeleteAlert, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("token"));
                            }
                            token__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaAlertsDeleteAlert {
                    token: token__.ok_or_else(|| serde::de::Error::missing_field("token"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaAlertsDeleteAlert", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alexa_alerts_delete_alert::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaAlertsDeleteAlert.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alexa_alerts_delete_alert::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alexa_alerts_delete_alert::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaAlertsDeleteAlert.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alexa_alerts_delete_alert::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(alexa_alerts_delete_alert::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaAlertsDeleteAlert.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaAlertsSetAlert {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaAlertsSetAlert", len)?;
        struct_ser.serialize_field("token", &self.token)?;
        let v = AlexaAlertType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("scheduledTime", &self.scheduled_time)?;
        struct_ser.serialize_field("label", &self.label)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaAlertsSetAlert {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "token",
            "type",
            "scheduledTime",
            "label",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Token,
            Type,
            ScheduledTime,
            Label,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "token" => Ok(GeneratedField::Token),
                            "type" => Ok(GeneratedField::Type),
                            "scheduledTime" => Ok(GeneratedField::ScheduledTime),
                            "label" => Ok(GeneratedField::Label),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaAlertsSetAlert;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaAlertsSetAlert")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaAlertsSetAlert, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut token__ = None;
                let mut r#type__ = None;
                let mut scheduled_time__ = None;
                let mut label__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("token"));
                            }
                            token__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<AlexaAlertType>()? as i32);
                        }
                        GeneratedField::ScheduledTime => {
                            if scheduled_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scheduledTime"));
                            }
                            scheduled_time__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Label => {
                            if label__.is_some() {
                                return Err(serde::de::Error::duplicate_field("label"));
                            }
                            label__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaAlertsSetAlert {
                    token: token__.ok_or_else(|| serde::de::Error::missing_field("token"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    scheduled_time: scheduled_time__.ok_or_else(|| serde::de::Error::missing_field("scheduledTime"))?,
                    label: label__.ok_or_else(|| serde::de::Error::missing_field("label"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaAlertsSetAlert", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaAuthStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AlexaAuth => "ALEXA_AUTH",
            Self::AlexaNoAuth => "ALEXA_NO_AUTH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlexaAuthStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALEXA_AUTH",
            "ALEXA_NO_AUTH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaAuthStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALEXA_AUTH" => Ok(AlexaAuthStatus::AlexaAuth),
                    "ALEXA_NO_AUTH" => Ok(AlexaAuthStatus::AlexaNoAuth),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaConfig", len)?;
        struct_ser.serialize_field("clientId", &self.client_id)?;
        struct_ser.serialize_field("refreshToken", &self.refresh_token)?;
        struct_ser.serialize_field("language", &self.language)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "client_id",
            "clientId",
            "refresh_token",
            "refreshToken",
            "language",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ClientId,
            RefreshToken,
            Language,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "clientId" | "client_id" => Ok(GeneratedField::ClientId),
                            "refreshToken" | "refresh_token" => Ok(GeneratedField::RefreshToken),
                            "language" => Ok(GeneratedField::Language),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaConfig")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut client_id__ = None;
                let mut refresh_token__ = None;
                let mut language__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ClientId => {
                            if client_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clientId"));
                            }
                            client_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RefreshToken => {
                            if refresh_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("refreshToken"));
                            }
                            refresh_token__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Language => {
                            if language__.is_some() {
                                return Err(serde::de::Error::duplicate_field("language"));
                            }
                            language__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaConfig {
                    client_id: client_id__.ok_or_else(|| serde::de::Error::missing_field("clientId"))?,
                    refresh_token: refresh_token__.ok_or_else(|| serde::de::Error::missing_field("refreshToken"))?,
                    language: language__.ok_or_else(|| serde::de::Error::missing_field("language"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaInstruction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.template_general.is_some() {
            len += 1;
        }
        if self.template_weather.is_some() {
            len += 1;
        }
        if self.template_lists.is_some() {
            len += 1;
        }
        if self.alerts_setalert.is_some() {
            len += 1;
        }
        if self.speechsynthesizer_speak.is_some() {
            len += 1;
        }
        if self.auth_status.is_some() {
            len += 1;
        }
        if self.alerts_deletealerts.is_some() {
            len += 1;
        }
        if self.notifications_setindicator.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaInstruction", len)?;
        let v = AlexaResultType::try_from(self.result_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.result_type)))?;
        struct_ser.serialize_field("resultType", &v)?;
        if let Some(v) = self.template_general.as_ref() {
            struct_ser.serialize_field("templateGeneral", v)?;
        }
        if let Some(v) = self.template_weather.as_ref() {
            struct_ser.serialize_field("templateWeather", v)?;
        }
        if let Some(v) = self.template_lists.as_ref() {
            struct_ser.serialize_field("templateLists", v)?;
        }
        if let Some(v) = self.alerts_setalert.as_ref() {
            struct_ser.serialize_field("alertsSetalert", v)?;
        }
        if let Some(v) = self.speechsynthesizer_speak.as_ref() {
            struct_ser.serialize_field("speechsynthesizerSpeak", v)?;
        }
        if let Some(v) = self.auth_status.as_ref() {
            let v = AlexaAuthStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("authStatus", &v)?;
        }
        if let Some(v) = self.alerts_deletealerts.as_ref() {
            struct_ser.serialize_field("alertsDeletealerts", v)?;
        }
        if let Some(v) = self.notifications_setindicator.as_ref() {
            struct_ser.serialize_field("notificationsSetindicator", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaInstruction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "result_type",
            "resultType",
            "template_general",
            "templateGeneral",
            "template_weather",
            "templateWeather",
            "template_lists",
            "templateLists",
            "alerts_setalert",
            "alertsSetalert",
            "speechsynthesizer_speak",
            "speechsynthesizerSpeak",
            "auth_status",
            "authStatus",
            "alerts_deletealerts",
            "alertsDeletealerts",
            "notifications_setindicator",
            "notificationsSetindicator",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResultType,
            TemplateGeneral,
            TemplateWeather,
            TemplateLists,
            AlertsSetalert,
            SpeechsynthesizerSpeak,
            AuthStatus,
            AlertsDeletealerts,
            NotificationsSetindicator,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "resultType" | "result_type" => Ok(GeneratedField::ResultType),
                            "templateGeneral" | "template_general" => Ok(GeneratedField::TemplateGeneral),
                            "templateWeather" | "template_weather" => Ok(GeneratedField::TemplateWeather),
                            "templateLists" | "template_lists" => Ok(GeneratedField::TemplateLists),
                            "alertsSetalert" | "alerts_setalert" => Ok(GeneratedField::AlertsSetalert),
                            "speechsynthesizerSpeak" | "speechsynthesizer_speak" => Ok(GeneratedField::SpeechsynthesizerSpeak),
                            "authStatus" | "auth_status" => Ok(GeneratedField::AuthStatus),
                            "alertsDeletealerts" | "alerts_deletealerts" => Ok(GeneratedField::AlertsDeletealerts),
                            "notificationsSetindicator" | "notifications_setindicator" => Ok(GeneratedField::NotificationsSetindicator),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaInstruction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaInstruction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaInstruction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result_type__ = None;
                let mut template_general__ = None;
                let mut template_weather__ = None;
                let mut template_lists__ = None;
                let mut alerts_setalert__ = None;
                let mut speechsynthesizer_speak__ = None;
                let mut auth_status__ = None;
                let mut alerts_deletealerts__ = None;
                let mut notifications_setindicator__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResultType => {
                            if result_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resultType"));
                            }
                            result_type__ = Some(map_.next_value::<AlexaResultType>()? as i32);
                        }
                        GeneratedField::TemplateGeneral => {
                            if template_general__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateGeneral"));
                            }
                            template_general__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateWeather => {
                            if template_weather__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateWeather"));
                            }
                            template_weather__ = map_.next_value()?;
                        }
                        GeneratedField::TemplateLists => {
                            if template_lists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("templateLists"));
                            }
                            template_lists__ = map_.next_value()?;
                        }
                        GeneratedField::AlertsSetalert => {
                            if alerts_setalert__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertsSetalert"));
                            }
                            alerts_setalert__ = map_.next_value()?;
                        }
                        GeneratedField::SpeechsynthesizerSpeak => {
                            if speechsynthesizer_speak__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speechsynthesizerSpeak"));
                            }
                            speechsynthesizer_speak__ = map_.next_value()?;
                        }
                        GeneratedField::AuthStatus => {
                            if auth_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authStatus"));
                            }
                            auth_status__ = map_.next_value::<::std::option::Option<AlexaAuthStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::AlertsDeletealerts => {
                            if alerts_deletealerts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertsDeletealerts"));
                            }
                            alerts_deletealerts__ = map_.next_value()?;
                        }
                        GeneratedField::NotificationsSetindicator => {
                            if notifications_setindicator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("notificationsSetindicator"));
                            }
                            notifications_setindicator__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AlexaInstruction {
                    result_type: result_type__.ok_or_else(|| serde::de::Error::missing_field("resultType"))?,
                    template_general: template_general__,
                    template_weather: template_weather__,
                    template_lists: template_lists__,
                    alerts_setalert: alerts_setalert__,
                    speechsynthesizer_speak: speechsynthesizer_speak__,
                    auth_status: auth_status__,
                    alerts_deletealerts: alerts_deletealerts__,
                    notifications_setindicator: notifications_setindicator__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaInstruction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alexa_instruction::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaInstruction.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alexa_instruction::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alexa_instruction::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaInstruction.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alexa_instruction::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(alexa_instruction::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaInstruction.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaListsItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaListsItem", len)?;
        struct_ser.serialize_field("left", &self.left)?;
        struct_ser.serialize_field("right", &self.right)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaListsItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "left",
            "right",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Left,
            Right,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "left" => Ok(GeneratedField::Left),
                            "right" => Ok(GeneratedField::Right),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaListsItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaListsItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaListsItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut left__ = None;
                let mut right__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Left => {
                            if left__.is_some() {
                                return Err(serde::de::Error::duplicate_field("left"));
                            }
                            left__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Right => {
                            if right__.is_some() {
                                return Err(serde::de::Error::duplicate_field("right"));
                            }
                            right__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaListsItem {
                    left: left__.ok_or_else(|| serde::de::Error::missing_field("left"))?,
                    right: right__.ok_or_else(|| serde::de::Error::missing_field("right"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaListsItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alexa_lists_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaListsItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alexa_lists_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alexa_lists_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaListsItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alexa_lists_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(alexa_lists_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaListsItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaNotificationsSetIndicator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaNotificationsSetIndicator", len)?;
        struct_ser.serialize_field("playAudioIndicator", &self.play_audio_indicator)?;
        struct_ser.serialize_field("persistVisualIndicator", &self.persist_visual_indicator)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaNotificationsSetIndicator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "playAudioIndicator",
            "persistVisualIndicator",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayAudioIndicator,
            PersistVisualIndicator,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "playAudioIndicator" => Ok(GeneratedField::PlayAudioIndicator),
                            "persistVisualIndicator" => Ok(GeneratedField::PersistVisualIndicator),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaNotificationsSetIndicator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaNotificationsSetIndicator")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaNotificationsSetIndicator, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut play_audio_indicator__ = None;
                let mut persist_visual_indicator__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayAudioIndicator => {
                            if play_audio_indicator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("playAudioIndicator"));
                            }
                            play_audio_indicator__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PersistVisualIndicator => {
                            if persist_visual_indicator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("persistVisualIndicator"));
                            }
                            persist_visual_indicator__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaNotificationsSetIndicator {
                    play_audio_indicator: play_audio_indicator__.ok_or_else(|| serde::de::Error::missing_field("playAudioIndicator"))?,
                    persist_visual_indicator: persist_visual_indicator__.ok_or_else(|| serde::de::Error::missing_field("persistVisualIndicator"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaNotificationsSetIndicator", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaQuietMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaQuietMode", len)?;
        struct_ser.serialize_field("on", &self.on)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaQuietMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "on",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            On,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "on" => Ok(GeneratedField::On),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaQuietMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaQuietMode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaQuietMode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut on__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::On => {
                            if on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("on"));
                            }
                            on__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaQuietMode {
                    on: on__.ok_or_else(|| serde::de::Error::missing_field("on"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaQuietMode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaResultType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AlexaStartListening => "ALEXA_START_LISTENING",
            Self::AlexaEndListening => "ALEXA_END_LISTENING",
            Self::AlexaAuthStatus => "ALEXA_AUTH_STATUS",
            Self::AlexaErrorNetwork => "ALEXA_ERROR_NETWORK",
            Self::AlexaErrorAuth => "ALEXA_ERROR_AUTH",
            Self::AlexaErrorContentTooLong => "ALEXA_ERROR_CONTENT_TOO_LONG",
            Self::AlexaErrorUnrecognizableSpeech => "ALEXA_ERROR_UNRECOGNIZABLE_SPEECH",
            Self::AlexaErrorUnsupportedArea => "ALEXA_ERROR_UNSUPPORTED_AREA",
            Self::AlexaErrorIosDeviceNotSupport => "ALEXA_ERROR_IOS_DEVICE_NOT_SUPPORT",
            Self::AlexaErrorAndroidDeviceNotSupport => "ALEXA_ERROR_ANDROID_DEVICE_NOT_SUPPORT",
            Self::AlexaErrorPlayNotSupport => "ALEXA_ERROR_PLAY_NOT_SUPPORT",
            Self::AlexaTemplateGeneral => "ALEXA_TEMPLATE_GENERAL",
            Self::AlexaTemplateWeather => "ALEXA_TEMPLATE_WEATHER",
            Self::AlexaTemplateLists => "ALEXA_TEMPLATE_LISTS",
            Self::AlexaAlertsSetalert => "ALEXA_ALERTS_SETALERT",
            Self::AlexaAlertsDeletealerts => "ALEXA_ALERTS_DELETEALERTS",
            Self::AlexaSpeechsynthesizerSpeak => "ALEXA_SPEECHSYNTHESIZER_SPEAK",
            Self::AlexaSpeechrecognizerExpectspeech => "ALEXA_SPEECHRECOGNIZER_EXPECTSPEECH",
            Self::AlexaNotificationsSetindicator => "ALEXA_NOTIFICATIONS_SETINDICATOR",
            Self::AlexaNotificationsClearindicator => "ALEXA_NOTIFICATIONS_CLEARINDICATOR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for AlexaResultType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALEXA_START_LISTENING",
            "ALEXA_END_LISTENING",
            "ALEXA_AUTH_STATUS",
            "ALEXA_ERROR_NETWORK",
            "ALEXA_ERROR_AUTH",
            "ALEXA_ERROR_CONTENT_TOO_LONG",
            "ALEXA_ERROR_UNRECOGNIZABLE_SPEECH",
            "ALEXA_ERROR_UNSUPPORTED_AREA",
            "ALEXA_ERROR_IOS_DEVICE_NOT_SUPPORT",
            "ALEXA_ERROR_ANDROID_DEVICE_NOT_SUPPORT",
            "ALEXA_ERROR_PLAY_NOT_SUPPORT",
            "ALEXA_TEMPLATE_GENERAL",
            "ALEXA_TEMPLATE_WEATHER",
            "ALEXA_TEMPLATE_LISTS",
            "ALEXA_ALERTS_SETALERT",
            "ALEXA_ALERTS_DELETEALERTS",
            "ALEXA_SPEECHSYNTHESIZER_SPEAK",
            "ALEXA_SPEECHRECOGNIZER_EXPECTSPEECH",
            "ALEXA_NOTIFICATIONS_SETINDICATOR",
            "ALEXA_NOTIFICATIONS_CLEARINDICATOR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaResultType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALEXA_START_LISTENING" => Ok(AlexaResultType::AlexaStartListening),
                    "ALEXA_END_LISTENING" => Ok(AlexaResultType::AlexaEndListening),
                    "ALEXA_AUTH_STATUS" => Ok(AlexaResultType::AlexaAuthStatus),
                    "ALEXA_ERROR_NETWORK" => Ok(AlexaResultType::AlexaErrorNetwork),
                    "ALEXA_ERROR_AUTH" => Ok(AlexaResultType::AlexaErrorAuth),
                    "ALEXA_ERROR_CONTENT_TOO_LONG" => Ok(AlexaResultType::AlexaErrorContentTooLong),
                    "ALEXA_ERROR_UNRECOGNIZABLE_SPEECH" => Ok(AlexaResultType::AlexaErrorUnrecognizableSpeech),
                    "ALEXA_ERROR_UNSUPPORTED_AREA" => Ok(AlexaResultType::AlexaErrorUnsupportedArea),
                    "ALEXA_ERROR_IOS_DEVICE_NOT_SUPPORT" => Ok(AlexaResultType::AlexaErrorIosDeviceNotSupport),
                    "ALEXA_ERROR_ANDROID_DEVICE_NOT_SUPPORT" => Ok(AlexaResultType::AlexaErrorAndroidDeviceNotSupport),
                    "ALEXA_ERROR_PLAY_NOT_SUPPORT" => Ok(AlexaResultType::AlexaErrorPlayNotSupport),
                    "ALEXA_TEMPLATE_GENERAL" => Ok(AlexaResultType::AlexaTemplateGeneral),
                    "ALEXA_TEMPLATE_WEATHER" => Ok(AlexaResultType::AlexaTemplateWeather),
                    "ALEXA_TEMPLATE_LISTS" => Ok(AlexaResultType::AlexaTemplateLists),
                    "ALEXA_ALERTS_SETALERT" => Ok(AlexaResultType::AlexaAlertsSetalert),
                    "ALEXA_ALERTS_DELETEALERTS" => Ok(AlexaResultType::AlexaAlertsDeletealerts),
                    "ALEXA_SPEECHSYNTHESIZER_SPEAK" => Ok(AlexaResultType::AlexaSpeechsynthesizerSpeak),
                    "ALEXA_SPEECHRECOGNIZER_EXPECTSPEECH" => Ok(AlexaResultType::AlexaSpeechrecognizerExpectspeech),
                    "ALEXA_NOTIFICATIONS_SETINDICATOR" => Ok(AlexaResultType::AlexaNotificationsSetindicator),
                    "ALEXA_NOTIFICATIONS_CLEARINDICATOR" => Ok(AlexaResultType::AlexaNotificationsClearindicator),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaSpeechSynthesizerSpeak {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaSpeechSynthesizerSpeak", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaSpeechSynthesizerSpeak {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaSpeechSynthesizerSpeak;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaSpeechSynthesizerSpeak")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaSpeechSynthesizerSpeak, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaSpeechSynthesizerSpeak {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaSpeechSynthesizerSpeak", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaTemplateGeneral {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaTemplateGeneral", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaTemplateGeneral {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaTemplateGeneral;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaTemplateGeneral")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaTemplateGeneral, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaTemplateGeneral {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaTemplateGeneral", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaTemplateLists {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaTemplateLists", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("items", &self.items)?;
        struct_ser.serialize_field("exceedMaxItems", &self.exceed_max_items)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaTemplateLists {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "items",
            "exceed_max_items",
            "exceedMaxItems",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Items,
            ExceedMaxItems,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "items" => Ok(GeneratedField::Items),
                            "exceedMaxItems" | "exceed_max_items" => Ok(GeneratedField::ExceedMaxItems),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaTemplateLists;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaTemplateLists")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaTemplateLists, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut items__ = None;
                let mut exceed_max_items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                        GeneratedField::ExceedMaxItems => {
                            if exceed_max_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exceedMaxItems"));
                            }
                            exceed_max_items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaTemplateLists {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                    exceed_max_items: exceed_max_items__.ok_or_else(|| serde::de::Error::missing_field("exceedMaxItems"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaTemplateLists", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaTemplateWeather {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 8;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaTemplateWeather", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("currentWeather", &self.current_weather)?;
        struct_ser.serialize_field("description", &self.description)?;
        struct_ser.serialize_field("highTemperature", &self.high_temperature)?;
        struct_ser.serialize_field("lowTemperature", &self.low_temperature)?;
        struct_ser.serialize_field("image", &self.image)?;
        struct_ser.serialize_field("weatherForecast", &self.weather_forecast)?;
        struct_ser.serialize_field("weatherCode", &self.weather_code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaTemplateWeather {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "current_weather",
            "currentWeather",
            "description",
            "high_temperature",
            "highTemperature",
            "low_temperature",
            "lowTemperature",
            "image",
            "weatherForecast",
            "weather_code",
            "weatherCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            CurrentWeather,
            Description,
            HighTemperature,
            LowTemperature,
            Image,
            WeatherForecast,
            WeatherCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "currentWeather" | "current_weather" => Ok(GeneratedField::CurrentWeather),
                            "description" => Ok(GeneratedField::Description),
                            "highTemperature" | "high_temperature" => Ok(GeneratedField::HighTemperature),
                            "lowTemperature" | "low_temperature" => Ok(GeneratedField::LowTemperature),
                            "image" => Ok(GeneratedField::Image),
                            "weatherForecast" => Ok(GeneratedField::WeatherForecast),
                            "weatherCode" | "weather_code" => Ok(GeneratedField::WeatherCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaTemplateWeather;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaTemplateWeather")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaTemplateWeather, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut current_weather__ = None;
                let mut description__ = None;
                let mut high_temperature__ = None;
                let mut low_temperature__ = None;
                let mut image__ = None;
                let mut weather_forecast__ = None;
                let mut weather_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::CurrentWeather => {
                            if current_weather__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentWeather"));
                            }
                            current_weather__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HighTemperature => {
                            if high_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("highTemperature"));
                            }
                            high_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LowTemperature => {
                            if low_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowTemperature"));
                            }
                            low_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WeatherForecast => {
                            if weather_forecast__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weatherForecast"));
                            }
                            weather_forecast__ = map_.next_value()?;
                        }
                        GeneratedField::WeatherCode => {
                            if weather_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weatherCode"));
                            }
                            weather_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AlexaTemplateWeather {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    current_weather: current_weather__.ok_or_else(|| serde::de::Error::missing_field("currentWeather"))?,
                    description: description__.ok_or_else(|| serde::de::Error::missing_field("description"))?,
                    high_temperature: high_temperature__.ok_or_else(|| serde::de::Error::missing_field("highTemperature"))?,
                    low_temperature: low_temperature__.ok_or_else(|| serde::de::Error::missing_field("lowTemperature"))?,
                    image: image__.ok_or_else(|| serde::de::Error::missing_field("image"))?,
                    weather_forecast: weather_forecast__.ok_or_else(|| serde::de::Error::missing_field("weatherForecast"))?,
                    weather_code: weather_code__.ok_or_else(|| serde::de::Error::missing_field("weatherCode"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaTemplateWeather", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaTitle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaTitle", len)?;
        struct_ser.serialize_field("mainTitle", &self.main_title)?;
        struct_ser.serialize_field("subTitle", &self.sub_title)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaTitle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "main_title",
            "mainTitle",
            "sub_title",
            "subTitle",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MainTitle,
            SubTitle,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mainTitle" | "main_title" => Ok(GeneratedField::MainTitle),
                            "subTitle" | "sub_title" => Ok(GeneratedField::SubTitle),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaTitle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaTitle")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaTitle, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut main_title__ = None;
                let mut sub_title__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MainTitle => {
                            if main_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainTitle"));
                            }
                            main_title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubTitle => {
                            if sub_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subTitle"));
                            }
                            sub_title__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AlexaTitle {
                    main_title: main_title__.ok_or_else(|| serde::de::Error::missing_field("mainTitle"))?,
                    sub_title: sub_title__.ok_or_else(|| serde::de::Error::missing_field("subTitle"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaTitle", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AlexaWeatherItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 6;
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaWeatherItem", len)?;
        struct_ser.serialize_field("date", &self.date)?;
        struct_ser.serialize_field("weekday", &self.weekday)?;
        struct_ser.serialize_field("highTemperature", &self.high_temperature)?;
        struct_ser.serialize_field("lowTemperature", &self.low_temperature)?;
        struct_ser.serialize_field("image", &self.image)?;
        struct_ser.serialize_field("weatherCode", &self.weather_code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AlexaWeatherItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "date",
            "weekday",
            "high_temperature",
            "highTemperature",
            "low_temperature",
            "lowTemperature",
            "image",
            "weather_code",
            "weatherCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Date,
            Weekday,
            HighTemperature,
            LowTemperature,
            Image,
            WeatherCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "date" => Ok(GeneratedField::Date),
                            "weekday" => Ok(GeneratedField::Weekday),
                            "highTemperature" | "high_temperature" => Ok(GeneratedField::HighTemperature),
                            "lowTemperature" | "low_temperature" => Ok(GeneratedField::LowTemperature),
                            "image" => Ok(GeneratedField::Image),
                            "weatherCode" | "weather_code" => Ok(GeneratedField::WeatherCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AlexaWeatherItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaWeatherItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AlexaWeatherItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut date__ = None;
                let mut weekday__ = None;
                let mut high_temperature__ = None;
                let mut low_temperature__ = None;
                let mut image__ = None;
                let mut weather_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Date => {
                            if date__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            date__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Weekday => {
                            if weekday__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekday"));
                            }
                            weekday__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HighTemperature => {
                            if high_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("highTemperature"));
                            }
                            high_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LowTemperature => {
                            if low_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowTemperature"));
                            }
                            low_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Image => {
                            if image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("image"));
                            }
                            image__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WeatherCode => {
                            if weather_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weatherCode"));
                            }
                            weather_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AlexaWeatherItem {
                    date: date__.ok_or_else(|| serde::de::Error::missing_field("date"))?,
                    weekday: weekday__.ok_or_else(|| serde::de::Error::missing_field("weekday"))?,
                    high_temperature: high_temperature__.ok_or_else(|| serde::de::Error::missing_field("highTemperature"))?,
                    low_temperature: low_temperature__.ok_or_else(|| serde::de::Error::missing_field("lowTemperature"))?,
                    image: image__.ok_or_else(|| serde::de::Error::missing_field("image"))?,
                    weather_code: weather_code__.ok_or_else(|| serde::de::Error::missing_field("weatherCode"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaWeatherItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for alexa_weather_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AlexaWeatherItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for alexa_weather_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = alexa_weather_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AlexaWeatherItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<alexa_weather_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(alexa_weather_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AlexaWeatherItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AndroidIntent {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AndroidIntent", len)?;
        struct_ser.serialize_field("pkgName", &self.pkg_name)?;
        struct_ser.serialize_field("uri", &self.uri)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AndroidIntent {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pkg_name",
            "pkgName",
            "uri",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PkgName,
            Uri,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pkgName" | "pkg_name" => Ok(GeneratedField::PkgName),
                            "uri" => Ok(GeneratedField::Uri),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AndroidIntent;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AndroidIntent")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AndroidIntent, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pkg_name__ = None;
                let mut uri__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PkgName => {
                            if pkg_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pkgName"));
                            }
                            pkg_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Uri => {
                            if uri__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uri"));
                            }
                            uri__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AndroidIntent {
                    pkg_name: pkg_name__.ok_or_else(|| serde::de::Error::missing_field("pkgName"))?,
                    uri: uri__.ok_or_else(|| serde::de::Error::missing_field("uri"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AndroidIntent", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Apk {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Apk", len)?;
        let v = ApkType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                apk::Payload::PackageName(v) => {
                    struct_ser.serialize_field("packageName", v)?;
                }
                apk::Payload::Url(v) => {
                    struct_ser.serialize_field("url", v)?;
                }
                apk::Payload::ApkInfo(v) => {
                    struct_ser.serialize_field("apkInfo", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Apk {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "package_name",
            "packageName",
            "url",
            "apk_info",
            "apkInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            PackageName,
            Url,
            ApkInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "url" => Ok(GeneratedField::Url),
                            "apkInfo" | "apk_info" => Ok(GeneratedField::ApkInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Apk;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Apk")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Apk, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<ApkType>()? as i32);
                        }
                        GeneratedField::PackageName => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(apk::Payload::PackageName);
                        }
                        GeneratedField::Url => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("url"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(apk::Payload::Url);
                        }
                        GeneratedField::ApkInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apkInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(apk::Payload::ApkInfo)
;
                        }
                    }
                }
                Ok(Apk {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Apk", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for apk::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Apk.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for apk::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = apk::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Apk.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<apk::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(apk::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Apk.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ApkInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.ApkInfo", len)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        struct_ser.serialize_field("packageHash", &self.package_hash)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("versionCode", ToString::to_string(&self.version_code).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ApkInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_name",
            "packageName",
            "package_hash",
            "packageHash",
            "version_code",
            "versionCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageName,
            PackageHash,
            VersionCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "packageHash" | "package_hash" => Ok(GeneratedField::PackageHash),
                            "versionCode" | "version_code" => Ok(GeneratedField::VersionCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ApkInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ApkInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ApkInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_name__ = None;
                let mut package_hash__ = None;
                let mut version_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PackageHash => {
                            if package_hash__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageHash"));
                            }
                            package_hash__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VersionCode => {
                            if version_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionCode"));
                            }
                            version_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ApkInfo {
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                    package_hash: package_hash__.ok_or_else(|| serde::de::Error::missing_field("packageHash"))?,
                    version_code: version_code__.ok_or_else(|| serde::de::Error::missing_field("versionCode"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ApkInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ApkType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::App => "APP",
            Self::WatchFace => "WATCH_FACE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ApkType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "APP",
            "WATCH_FACE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ApkType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "APP" => Ok(ApkType::App),
                    "WATCH_FACE" => Ok(ApkType::WatchFace),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for App {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.hidden.is_some() {
            len += 1;
        }
        if self.persist.is_some() {
            len += 1;
        }
        if self.can_more.is_some() {
            len += 1;
        }
        if self.in_more.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.App", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        if let Some(v) = self.hidden.as_ref() {
            struct_ser.serialize_field("hidden", v)?;
        }
        if let Some(v) = self.persist.as_ref() {
            struct_ser.serialize_field("persist", v)?;
        }
        if let Some(v) = self.can_more.as_ref() {
            struct_ser.serialize_field("canMore", v)?;
        }
        if let Some(v) = self.in_more.as_ref() {
            struct_ser.serialize_field("inMore", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for App {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "hidden",
            "persist",
            "can_more",
            "canMore",
            "in_more",
            "inMore",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            Hidden,
            Persist,
            CanMore,
            InMore,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "hidden" => Ok(GeneratedField::Hidden),
                            "persist" => Ok(GeneratedField::Persist),
                            "canMore" | "can_more" => Ok(GeneratedField::CanMore),
                            "inMore" | "in_more" => Ok(GeneratedField::InMore),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = App;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.App")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<App, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut hidden__ = None;
                let mut persist__ = None;
                let mut can_more__ = None;
                let mut in_more__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Hidden => {
                            if hidden__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hidden"));
                            }
                            hidden__ = map_.next_value()?;
                        }
                        GeneratedField::Persist => {
                            if persist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("persist"));
                            }
                            persist__ = map_.next_value()?;
                        }
                        GeneratedField::CanMore => {
                            if can_more__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canMore"));
                            }
                            can_more__ = map_.next_value()?;
                        }
                        GeneratedField::InMore => {
                            if in_more__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inMore"));
                            }
                            in_more__ = map_.next_value()?;
                        }
                    }
                }
                Ok(App {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    hidden: hidden__,
                    persist: persist__,
                    can_more: can_more__,
                    in_more: in_more__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.App", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.App.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for app::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.App.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<app::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(app::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.App.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AppIconApply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.AppIconApply", len)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AppIconApply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_name",
            "packageName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageName,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AppIconApply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppIconApply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AppIconApply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AppIconApply {
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppIconApply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AppInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AppInfo", len)?;
        struct_ser.serialize_field("appType", &self.app_type)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AppInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_type",
            "appType",
            "enable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppType,
            Enable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appType" | "app_type" => Ok(GeneratedField::AppType),
                            "enable" => Ok(GeneratedField::Enable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AppInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AppInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_type__ = None;
                let mut enable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppType => {
                            if app_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appType"));
                            }
                            app_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AppInfo {
                    app_type: app_type__.ok_or_else(|| serde::de::Error::missing_field("appType"))?,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AppInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for app_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<app_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(app_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_info::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Notification => "NOTIFICATION",
            Self::Call => "CALL",
            Self::Wechat => "WECHAT",
            Self::Qq => "QQ",
            Self::Alipay => "ALIPAY",
            Self::Other => "OTHER",
            Self::Sms => "SMS",
            Self::Mail => "MAIL",
            Self::Weibo => "WEIBO",
            Self::Taobao => "TAOBAO",
            Self::Tiktok => "TIKTOK",
            Self::Dingding => "DINGDING",
            Self::Mihome => "MIHOME",
            Self::Xiaohongshu => "XIAOHONGSHU",
            Self::Pinduoduo => "PINDUODUO",
            Self::Kuaishou => "KUAISHOU",
            Self::Qqmusic => "QQMUSIC",
            Self::Didi => "DIDI",
            Self::Baidumap => "BAIDUMAP",
            Self::Gaodemap => "GAODEMAP",
            Self::Cloudmusic => "CLOUDMUSIC",
            Self::Kugou => "KUGOU",
            Self::Baidu => "BAIDU",
            Self::Qqmail => "QQMAIL",
            Self::Qqzone => "QQZONE",
            Self::Tencentnews => "TENCENTNEWS",
            Self::Toutiao => "TOUTIAO",
            Self::Wework => "WEWORK",
            Self::Meituan => "MEITUAN",
            Self::Keep => "KEEP",
            Self::Youku => "YOUKU",
            Self::Qqlive => "QQLIVE",
            Self::Iqiyi => "IQIYI",
            Self::Bilibili => "BILIBILI",
            Self::Tiktoklite => "TIKTOKLITE",
            Self::Kusishoulite => "KUSISHOULITE",
            Self::Ximalaya => "XIMALAYA",
            Self::Weishi => "WEISHI",
            Self::Dianping => "DIANPING",
            Self::Meituanwm => "MEITUANWM",
            Self::Eleme => "ELEME",
            Self::Zhihu => "ZHIHU",
            Self::Xianyu => "XIANYU",
            Self::Taobaolite => "TAOBAOLITE",
            Self::Jd => "JD",
            Self::Dewu => "DEWU",
            Self::Tmall => "TMALL",
            Self::Suning => "SUNING",
            Self::Ticket12306 => "TICKET12306",
            Self::Ccb => "CCB",
            Self::Unionpay => "UNIONPAY",
            Self::Cmb => "CMB",
            Self::Jdjr => "JDJR",
            Self::Cb => "CB",
            Self::Icbc => "ICBC",
            Self::Zssh => "ZSSH",
            Self::Abc => "ABC",
            Self::Jtbank => "JTBANK",
            Self::Weread => "WEREAD",
            Self::Shuqi => "SHUQI",
            Self::Qqbrowser => "QQBROWSER",
            Self::Ucbrowser => "UCBROWSER",
            Self::Soul => "SOUL",
            Self::Momo => "MOMO",
            Self::Tantan => "TANTAN",
            Self::Douban => "DOUBAN",
            Self::Tieba => "TIEBA",
            Self::Wuba => "WUBA",
            Self::Whatsapp => "WHATSAPP",
            Self::Viber => "VIBER",
            Self::Snapchat => "SNAPCHAT",
            Self::Skype => "SKYPE",
            Self::Telegram => "TELEGRAM",
            Self::Fbmessenger => "FBMESSENGER",
            Self::Discord => "DISCORD",
            Self::Kakao => "KAKAO",
            Self::Vkontakte => "VKONTAKTE",
            Self::Line => "LINE",
            Self::Twitter => "TWITTER",
            Self::Gmail => "GMAIL",
            Self::Outlook => "OUTLOOK",
            Self::Fb => "FB",
            Self::Naver => "NAVER",
            Self::Hangout => "HANGOUT",
            Self::Bip => "BIP",
            Self::Ok => "OK",
            Self::Sharechat => "SHARECHAT",
            Self::Mamba => "MAMBA",
            Self::Instagram => "INSTAGRAM",
            Self::Youtube => "YOUTUBE",
            Self::Wps => "WPS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for app_info::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NOTIFICATION",
            "CALL",
            "WECHAT",
            "QQ",
            "ALIPAY",
            "OTHER",
            "SMS",
            "MAIL",
            "WEIBO",
            "TAOBAO",
            "TIKTOK",
            "DINGDING",
            "MIHOME",
            "XIAOHONGSHU",
            "PINDUODUO",
            "KUAISHOU",
            "QQMUSIC",
            "DIDI",
            "BAIDUMAP",
            "GAODEMAP",
            "CLOUDMUSIC",
            "KUGOU",
            "BAIDU",
            "QQMAIL",
            "QQZONE",
            "TENCENTNEWS",
            "TOUTIAO",
            "WEWORK",
            "MEITUAN",
            "KEEP",
            "YOUKU",
            "QQLIVE",
            "IQIYI",
            "BILIBILI",
            "TIKTOKLITE",
            "KUSISHOULITE",
            "XIMALAYA",
            "WEISHI",
            "DIANPING",
            "MEITUANWM",
            "ELEME",
            "ZHIHU",
            "XIANYU",
            "TAOBAOLITE",
            "JD",
            "DEWU",
            "TMALL",
            "SUNING",
            "TICKET12306",
            "CCB",
            "UNIONPAY",
            "CMB",
            "JDJR",
            "CB",
            "ICBC",
            "ZSSH",
            "ABC",
            "JTBANK",
            "WEREAD",
            "SHUQI",
            "QQBROWSER",
            "UCBROWSER",
            "SOUL",
            "MOMO",
            "TANTAN",
            "DOUBAN",
            "TIEBA",
            "WUBA",
            "WHATSAPP",
            "VIBER",
            "SNAPCHAT",
            "SKYPE",
            "TELEGRAM",
            "FBMESSENGER",
            "DISCORD",
            "KAKAO",
            "VKONTAKTE",
            "LINE",
            "TWITTER",
            "GMAIL",
            "OUTLOOK",
            "FB",
            "NAVER",
            "HANGOUT",
            "BIP",
            "OK",
            "SHARECHAT",
            "MAMBA",
            "INSTAGRAM",
            "YOUTUBE",
            "WPS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_info::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NOTIFICATION" => Ok(app_info::Type::Notification),
                    "CALL" => Ok(app_info::Type::Call),
                    "WECHAT" => Ok(app_info::Type::Wechat),
                    "QQ" => Ok(app_info::Type::Qq),
                    "ALIPAY" => Ok(app_info::Type::Alipay),
                    "OTHER" => Ok(app_info::Type::Other),
                    "SMS" => Ok(app_info::Type::Sms),
                    "MAIL" => Ok(app_info::Type::Mail),
                    "WEIBO" => Ok(app_info::Type::Weibo),
                    "TAOBAO" => Ok(app_info::Type::Taobao),
                    "TIKTOK" => Ok(app_info::Type::Tiktok),
                    "DINGDING" => Ok(app_info::Type::Dingding),
                    "MIHOME" => Ok(app_info::Type::Mihome),
                    "XIAOHONGSHU" => Ok(app_info::Type::Xiaohongshu),
                    "PINDUODUO" => Ok(app_info::Type::Pinduoduo),
                    "KUAISHOU" => Ok(app_info::Type::Kuaishou),
                    "QQMUSIC" => Ok(app_info::Type::Qqmusic),
                    "DIDI" => Ok(app_info::Type::Didi),
                    "BAIDUMAP" => Ok(app_info::Type::Baidumap),
                    "GAODEMAP" => Ok(app_info::Type::Gaodemap),
                    "CLOUDMUSIC" => Ok(app_info::Type::Cloudmusic),
                    "KUGOU" => Ok(app_info::Type::Kugou),
                    "BAIDU" => Ok(app_info::Type::Baidu),
                    "QQMAIL" => Ok(app_info::Type::Qqmail),
                    "QQZONE" => Ok(app_info::Type::Qqzone),
                    "TENCENTNEWS" => Ok(app_info::Type::Tencentnews),
                    "TOUTIAO" => Ok(app_info::Type::Toutiao),
                    "WEWORK" => Ok(app_info::Type::Wework),
                    "MEITUAN" => Ok(app_info::Type::Meituan),
                    "KEEP" => Ok(app_info::Type::Keep),
                    "YOUKU" => Ok(app_info::Type::Youku),
                    "QQLIVE" => Ok(app_info::Type::Qqlive),
                    "IQIYI" => Ok(app_info::Type::Iqiyi),
                    "BILIBILI" => Ok(app_info::Type::Bilibili),
                    "TIKTOKLITE" => Ok(app_info::Type::Tiktoklite),
                    "KUSISHOULITE" => Ok(app_info::Type::Kusishoulite),
                    "XIMALAYA" => Ok(app_info::Type::Ximalaya),
                    "WEISHI" => Ok(app_info::Type::Weishi),
                    "DIANPING" => Ok(app_info::Type::Dianping),
                    "MEITUANWM" => Ok(app_info::Type::Meituanwm),
                    "ELEME" => Ok(app_info::Type::Eleme),
                    "ZHIHU" => Ok(app_info::Type::Zhihu),
                    "XIANYU" => Ok(app_info::Type::Xianyu),
                    "TAOBAOLITE" => Ok(app_info::Type::Taobaolite),
                    "JD" => Ok(app_info::Type::Jd),
                    "DEWU" => Ok(app_info::Type::Dewu),
                    "TMALL" => Ok(app_info::Type::Tmall),
                    "SUNING" => Ok(app_info::Type::Suning),
                    "TICKET12306" => Ok(app_info::Type::Ticket12306),
                    "CCB" => Ok(app_info::Type::Ccb),
                    "UNIONPAY" => Ok(app_info::Type::Unionpay),
                    "CMB" => Ok(app_info::Type::Cmb),
                    "JDJR" => Ok(app_info::Type::Jdjr),
                    "CB" => Ok(app_info::Type::Cb),
                    "ICBC" => Ok(app_info::Type::Icbc),
                    "ZSSH" => Ok(app_info::Type::Zssh),
                    "ABC" => Ok(app_info::Type::Abc),
                    "JTBANK" => Ok(app_info::Type::Jtbank),
                    "WEREAD" => Ok(app_info::Type::Weread),
                    "SHUQI" => Ok(app_info::Type::Shuqi),
                    "QQBROWSER" => Ok(app_info::Type::Qqbrowser),
                    "UCBROWSER" => Ok(app_info::Type::Ucbrowser),
                    "SOUL" => Ok(app_info::Type::Soul),
                    "MOMO" => Ok(app_info::Type::Momo),
                    "TANTAN" => Ok(app_info::Type::Tantan),
                    "DOUBAN" => Ok(app_info::Type::Douban),
                    "TIEBA" => Ok(app_info::Type::Tieba),
                    "WUBA" => Ok(app_info::Type::Wuba),
                    "WHATSAPP" => Ok(app_info::Type::Whatsapp),
                    "VIBER" => Ok(app_info::Type::Viber),
                    "SNAPCHAT" => Ok(app_info::Type::Snapchat),
                    "SKYPE" => Ok(app_info::Type::Skype),
                    "TELEGRAM" => Ok(app_info::Type::Telegram),
                    "FBMESSENGER" => Ok(app_info::Type::Fbmessenger),
                    "DISCORD" => Ok(app_info::Type::Discord),
                    "KAKAO" => Ok(app_info::Type::Kakao),
                    "VKONTAKTE" => Ok(app_info::Type::Vkontakte),
                    "LINE" => Ok(app_info::Type::Line),
                    "TWITTER" => Ok(app_info::Type::Twitter),
                    "GMAIL" => Ok(app_info::Type::Gmail),
                    "OUTLOOK" => Ok(app_info::Type::Outlook),
                    "FB" => Ok(app_info::Type::Fb),
                    "NAVER" => Ok(app_info::Type::Naver),
                    "HANGOUT" => Ok(app_info::Type::Hangout),
                    "BIP" => Ok(app_info::Type::Bip),
                    "OK" => Ok(app_info::Type::Ok),
                    "SHARECHAT" => Ok(app_info::Type::Sharechat),
                    "MAMBA" => Ok(app_info::Type::Mamba),
                    "INSTAGRAM" => Ok(app_info::Type::Instagram),
                    "YOUTUBE" => Ok(app_info::Type::Youtube),
                    "WPS" => Ok(app_info::Type::Wps),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AppInstaller {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.AppInstaller", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AppInstaller {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AppInstaller;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppInstaller")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AppInstaller, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(AppInstaller {
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppInstaller", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_installer::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.AppInstaller.Request", len)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        struct_ser.serialize_field("versionCode", &self.version_code)?;
        struct_ser.serialize_field("packageSize", &self.package_size)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for app_installer::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_name",
            "packageName",
            "version_code",
            "versionCode",
            "package_size",
            "packageSize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageName,
            VersionCode,
            PackageSize,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "versionCode" | "version_code" => Ok(GeneratedField::VersionCode),
                            "packageSize" | "package_size" => Ok(GeneratedField::PackageSize),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_installer::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppInstaller.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<app_installer::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_name__ = None;
                let mut version_code__ = None;
                let mut package_size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VersionCode => {
                            if version_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionCode"));
                            }
                            version_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::PackageSize => {
                            if package_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageSize"));
                            }
                            package_size__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(app_installer::Request {
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                    version_code: version_code__.ok_or_else(|| serde::de::Error::missing_field("versionCode"))?,
                    package_size: package_size__.ok_or_else(|| serde::de::Error::missing_field("packageSize"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppInstaller.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_installer::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AppInstaller.Response", len)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for app_installer::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prepare_status",
            "prepareStatus",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrepareStatus,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_installer::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppInstaller.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<app_installer::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prepare_status__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(app_installer::Response {
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppInstaller.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_installer::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AppInstaller.Result", len)?;
        let v = app_installer::result::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                app_installer::result::Payload::PackageName(v) => {
                    struct_ser.serialize_field("packageName", v)?;
                }
                app_installer::result::Payload::AppItem(v) => {
                    struct_ser.serialize_field("appItem", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for app_installer::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "package_name",
            "packageName",
            "app_item",
            "appItem",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            PackageName,
            AppItem,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "appItem" | "app_item" => Ok(GeneratedField::AppItem),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_installer::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppInstaller.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<app_installer::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<app_installer::result::Code>()? as i32);
                        }
                        GeneratedField::PackageName => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(app_installer::result::Payload::PackageName);
                        }
                        GeneratedField::AppItem => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appItem"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(app_installer::result::Payload::AppItem)
;
                        }
                    }
                }
                Ok(app_installer::Result {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppInstaller.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_installer::result::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::InstallSuccess => "INSTALL_SUCCESS",
            Self::InstallFailed => "INSTALL_FAILED",
            Self::VerifyFailed => "VERIFY_FAILED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for app_installer::result::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "INSTALL_SUCCESS",
            "INSTALL_FAILED",
            "VERIFY_FAILED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_installer::result::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "INSTALL_SUCCESS" => Ok(app_installer::result::Code::InstallSuccess),
                    "INSTALL_FAILED" => Ok(app_installer::result::Code::InstallFailed),
                    "VERIFY_FAILED" => Ok(app_installer::result::Code::VerifyFailed),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AppItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.AppItem", len)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("fingerprint", pbjson::private::base64::encode(&self.fingerprint).as_str())?;
        struct_ser.serialize_field("versionCode", &self.version_code)?;
        struct_ser.serialize_field("canRemove", &self.can_remove)?;
        struct_ser.serialize_field("appName", &self.app_name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AppItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_name",
            "packageName",
            "fingerprint",
            "version_code",
            "versionCode",
            "can_remove",
            "canRemove",
            "app_name",
            "appName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageName,
            Fingerprint,
            VersionCode,
            CanRemove,
            AppName,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "fingerprint" => Ok(GeneratedField::Fingerprint),
                            "versionCode" | "version_code" => Ok(GeneratedField::VersionCode),
                            "canRemove" | "can_remove" => Ok(GeneratedField::CanRemove),
                            "appName" | "app_name" => Ok(GeneratedField::AppName),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AppItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AppItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_name__ = None;
                let mut fingerprint__ = None;
                let mut version_code__ = None;
                let mut can_remove__ = None;
                let mut app_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fingerprint => {
                            if fingerprint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fingerprint"));
                            }
                            fingerprint__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::VersionCode => {
                            if version_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionCode"));
                            }
                            version_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CanRemove => {
                            if can_remove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canRemove"));
                            }
                            can_remove__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppName => {
                            if app_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appName"));
                            }
                            app_name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AppItem {
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                    fingerprint: fingerprint__.ok_or_else(|| serde::de::Error::missing_field("fingerprint"))?,
                    version_code: version_code__.ok_or_else(|| serde::de::Error::missing_field("versionCode"))?,
                    can_remove: can_remove__.ok_or_else(|| serde::de::Error::missing_field("canRemove"))?,
                    app_name: app_name__.ok_or_else(|| serde::de::Error::missing_field("appName"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AppItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for app_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<app_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(app_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AppLayout {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.support_layouts.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AppLayout", len)?;
        let v = app_layout::Layout::try_from(self.layout)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.layout)))?;
        struct_ser.serialize_field("layout", &v)?;
        if let Some(v) = self.support_layouts.as_ref() {
            struct_ser.serialize_field("supportLayouts", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AppLayout {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "layout",
            "support_layouts",
            "supportLayouts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Layout,
            SupportLayouts,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "layout" => Ok(GeneratedField::Layout),
                            "supportLayouts" | "support_layouts" => Ok(GeneratedField::SupportLayouts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AppLayout;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AppLayout")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AppLayout, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut layout__ = None;
                let mut support_layouts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Layout => {
                            if layout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("layout"));
                            }
                            layout__ = Some(map_.next_value::<app_layout::Layout>()? as i32);
                        }
                        GeneratedField::SupportLayouts => {
                            if support_layouts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportLayouts"));
                            }
                            support_layouts__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AppLayout {
                    layout: layout__.ok_or_else(|| serde::de::Error::missing_field("layout"))?,
                    support_layouts: support_layouts__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AppLayout", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for app_layout::Layout {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::List => "LIST",
            Self::Grid => "GRID",
            Self::GridText => "GRID_TEXT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for app_layout::Layout {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LIST",
            "GRID",
            "GRID_TEXT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = app_layout::Layout;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LIST" => Ok(app_layout::Layout::List),
                    "GRID" => Ok(app_layout::Layout::Grid),
                    "GRID_TEXT" => Ok(app_layout::Layout::GridText),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ApplicationOperate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.ApplicationOperate", len)?;
        let v = ApplictionOp::try_from(self.operation)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.operation)))?;
        struct_ser.serialize_field("operation", &v)?;
        struct_ser.serialize_field("keyword", &self.keyword)?;
        struct_ser.serialize_field("appPkgName", &self.app_pkg_name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ApplicationOperate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "operation",
            "keyword",
            "app_pkg_name",
            "appPkgName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Operation,
            Keyword,
            AppPkgName,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "operation" => Ok(GeneratedField::Operation),
                            "keyword" => Ok(GeneratedField::Keyword),
                            "appPkgName" | "app_pkg_name" => Ok(GeneratedField::AppPkgName),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ApplicationOperate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ApplicationOperate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ApplicationOperate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut operation__ = None;
                let mut keyword__ = None;
                let mut app_pkg_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Operation => {
                            if operation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operation"));
                            }
                            operation__ = Some(map_.next_value::<ApplictionOp>()? as i32);
                        }
                        GeneratedField::Keyword => {
                            if keyword__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyword"));
                            }
                            keyword__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppPkgName => {
                            if app_pkg_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appPkgName"));
                            }
                            app_pkg_name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ApplicationOperate {
                    operation: operation__.ok_or_else(|| serde::de::Error::missing_field("operation"))?,
                    keyword: keyword__.ok_or_else(|| serde::de::Error::missing_field("keyword"))?,
                    app_pkg_name: app_pkg_name__.ok_or_else(|| serde::de::Error::missing_field("appPkgName"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ApplicationOperate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ApplictionOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "ApplictionOp_UNKNOWN",
            Self::Open => "ApplictionOp_OPEN",
            Self::Install => "ApplictionOp_INSTALL",
            Self::Uninstall => "ApplictionOp_UNINSTALL",
            Self::Close => "ApplictionOp_CLOSE",
            Self::Search => "ApplictionOp_SEARCH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ApplictionOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ApplictionOp_UNKNOWN",
            "ApplictionOp_OPEN",
            "ApplictionOp_INSTALL",
            "ApplictionOp_UNINSTALL",
            "ApplictionOp_CLOSE",
            "ApplictionOp_SEARCH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ApplictionOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ApplictionOp_UNKNOWN" => Ok(ApplictionOp::Unknown),
                    "ApplictionOp_OPEN" => Ok(ApplictionOp::Open),
                    "ApplictionOp_INSTALL" => Ok(ApplictionOp::Install),
                    "ApplictionOp_UNINSTALL" => Ok(ApplictionOp::Uninstall),
                    "ApplictionOp_CLOSE" => Ok(ApplictionOp::Close),
                    "ApplictionOp_SEARCH" => Ok(ApplictionOp::Search),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AudioControl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.int_value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AudioControl", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        struct_ser.serialize_field("cmd", &self.cmd)?;
        if let Some(v) = self.int_value.as_ref() {
            struct_ser.serialize_field("intValue", v)?;
        }
        struct_ser.serialize_field("strValue", &self.str_value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AudioControl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "cmd",
            "int_value",
            "intValue",
            "str_value",
            "strValue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            Cmd,
            IntValue,
            StrValue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "cmd" => Ok(GeneratedField::Cmd),
                            "intValue" | "int_value" => Ok(GeneratedField::IntValue),
                            "strValue" | "str_value" => Ok(GeneratedField::StrValue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AudioControl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AudioControl")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AudioControl, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut cmd__ = None;
                let mut int_value__ = None;
                let mut str_value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::IntValue => {
                            if int_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intValue"));
                            }
                            int_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StrValue => {
                            if str_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strValue"));
                            }
                            str_value__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AudioControl {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                    int_value: int_value__,
                    str_value: str_value__.ok_or_else(|| serde::de::Error::missing_field("strValue"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AudioControl", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AudioData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 6;
        let mut struct_ser = serializer.serialize_struct("protocol.AudioData", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("currentPositon", &self.current_positon)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        struct_ser.serialize_field("volume", &self.volume)?;
        struct_ser.serialize_field("artist", &self.artist)?;
        struct_ser.serialize_field("album", &self.album)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AudioData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "current_positon",
            "currentPositon",
            "duration",
            "volume",
            "artist",
            "album",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            CurrentPositon,
            Duration,
            Volume,
            Artist,
            Album,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "currentPositon" | "current_positon" => Ok(GeneratedField::CurrentPositon),
                            "duration" => Ok(GeneratedField::Duration),
                            "volume" => Ok(GeneratedField::Volume),
                            "artist" => Ok(GeneratedField::Artist),
                            "album" => Ok(GeneratedField::Album),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AudioData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AudioData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AudioData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut current_positon__ = None;
                let mut duration__ = None;
                let mut volume__ = None;
                let mut artist__ = None;
                let mut album__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CurrentPositon => {
                            if current_positon__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPositon"));
                            }
                            current_positon__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Artist => {
                            if artist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("artist"));
                            }
                            artist__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Album => {
                            if album__.is_some() {
                                return Err(serde::de::Error::duplicate_field("album"));
                            }
                            album__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AudioData {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    current_positon: current_positon__.ok_or_else(|| serde::de::Error::missing_field("currentPositon"))?,
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    volume: volume__.ok_or_else(|| serde::de::Error::missing_field("volume"))?,
                    artist: artist__.ok_or_else(|| serde::de::Error::missing_field("artist"))?,
                    album: album__.ok_or_else(|| serde::de::Error::missing_field("album"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AudioData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AudioInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AudioInfo", len)?;
        struct_ser.serialize_field("state", &self.state)?;
        if let Some(v) = self.data.as_ref() {
            struct_ser.serialize_field("data", v)?;
        }
        struct_ser.serialize_field("outputId", &self.output_id)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AudioInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "state",
            "data",
            "output_id",
            "outputId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            Data,
            OutputId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            "data" => Ok(GeneratedField::Data),
                            "outputId" | "output_id" => Ok(GeneratedField::OutputId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AudioInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AudioInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AudioInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut data__ = None;
                let mut output_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = map_.next_value()?;
                        }
                        GeneratedField::OutputId => {
                            if output_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputId"));
                            }
                            output_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AudioInfo {
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    data: data__,
                    output_id: output_id__.ok_or_else(|| serde::de::Error::missing_field("outputId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AudioInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Auth {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Auth", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Auth {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Auth;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Auth")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Auth, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Auth {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Auth", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for auth::AppConfirm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Auth.AppConfirm", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appSign", pbjson::private::base64::encode(&self.app_sign).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("encryptCompanionDevice", pbjson::private::base64::encode(&self.encrypt_companion_device).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for auth::AppConfirm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_sign",
            "appSign",
            "encrypt_companion_device",
            "encryptCompanionDevice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppSign,
            EncryptCompanionDevice,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appSign" | "app_sign" => Ok(GeneratedField::AppSign),
                            "encryptCompanionDevice" | "encrypt_companion_device" => Ok(GeneratedField::EncryptCompanionDevice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = auth::AppConfirm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Auth.AppConfirm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<auth::AppConfirm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_sign__ = None;
                let mut encrypt_companion_device__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppSign => {
                            if app_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appSign"));
                            }
                            app_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::EncryptCompanionDevice => {
                            if encrypt_companion_device__.is_some() {
                                return Err(serde::de::Error::duplicate_field("encryptCompanionDevice"));
                            }
                            encrypt_companion_device__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(auth::AppConfirm {
                    app_sign: app_sign__.ok_or_else(|| serde::de::Error::missing_field("appSign"))?,
                    encrypt_companion_device: encrypt_companion_device__.ok_or_else(|| serde::de::Error::missing_field("encryptCompanionDevice"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Auth.AppConfirm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for auth::AppVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.app_device_id.is_some() {
            len += 1;
        }
        if self.check_dynamic_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Auth.AppVerify", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appRandom", pbjson::private::base64::encode(&self.app_random).as_str())?;
        if let Some(v) = self.app_device_id.as_ref() {
            struct_ser.serialize_field("appDeviceId", v)?;
        }
        if let Some(v) = self.check_dynamic_code.as_ref() {
            struct_ser.serialize_field("checkDynamicCode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for auth::AppVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_random",
            "appRandom",
            "app_device_id",
            "appDeviceId",
            "check_dynamic_code",
            "checkDynamicCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppRandom,
            AppDeviceId,
            CheckDynamicCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appRandom" | "app_random" => Ok(GeneratedField::AppRandom),
                            "appDeviceId" | "app_device_id" => Ok(GeneratedField::AppDeviceId),
                            "checkDynamicCode" | "check_dynamic_code" => Ok(GeneratedField::CheckDynamicCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = auth::AppVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Auth.AppVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<auth::AppVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_random__ = None;
                let mut app_device_id__ = None;
                let mut check_dynamic_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppRandom => {
                            if app_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appRandom"));
                            }
                            app_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AppDeviceId => {
                            if app_device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appDeviceId"));
                            }
                            app_device_id__ = map_.next_value()?;
                        }
                        GeneratedField::CheckDynamicCode => {
                            if check_dynamic_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkDynamicCode"));
                            }
                            check_dynamic_code__ = map_.next_value()?;
                        }
                    }
                }
                Ok(auth::AppVerify {
                    app_random: app_random__.ok_or_else(|| serde::de::Error::missing_field("appRandom"))?,
                    app_device_id: app_device_id__,
                    check_dynamic_code: check_dynamic_code__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Auth.AppVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for auth::DeviceConfirm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.device_capability.is_some() {
            len += 1;
        }
        if self.device_capability_2.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Auth.DeviceConfirm", len)?;
        struct_ser.serialize_field("confirmResult", &self.confirm_result)?;
        if let Some(v) = self.device_capability.as_ref() {
            struct_ser.serialize_field("deviceCapability", v)?;
        }
        if let Some(v) = self.device_capability_2.as_ref() {
            struct_ser.serialize_field("deviceCapability2", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for auth::DeviceConfirm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "confirm_result",
            "confirmResult",
            "device_capability",
            "deviceCapability",
            "device_capability_2",
            "deviceCapability2",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConfirmResult,
            DeviceCapability,
            DeviceCapability2,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "confirmResult" | "confirm_result" => Ok(GeneratedField::ConfirmResult),
                            "deviceCapability" | "device_capability" => Ok(GeneratedField::DeviceCapability),
                            "deviceCapability2" | "device_capability_2" => Ok(GeneratedField::DeviceCapability2),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = auth::DeviceConfirm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Auth.DeviceConfirm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<auth::DeviceConfirm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut confirm_result__ = None;
                let mut device_capability__ = None;
                let mut device_capability_2__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ConfirmResult => {
                            if confirm_result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("confirmResult"));
                            }
                            confirm_result__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DeviceCapability => {
                            if device_capability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceCapability"));
                            }
                            device_capability__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DeviceCapability2 => {
                            if device_capability_2__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceCapability2"));
                            }
                            device_capability_2__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(auth::DeviceConfirm {
                    confirm_result: confirm_result__.ok_or_else(|| serde::de::Error::missing_field("confirmResult"))?,
                    device_capability: device_capability__,
                    device_capability_2: device_capability_2__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Auth.DeviceConfirm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for auth::DeviceVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Auth.DeviceVerify", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceRandom", pbjson::private::base64::encode(&self.device_random).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceSign", pbjson::private::base64::encode(&self.device_sign).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for auth::DeviceVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_random",
            "deviceRandom",
            "device_sign",
            "deviceSign",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceRandom,
            DeviceSign,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceRandom" | "device_random" => Ok(GeneratedField::DeviceRandom),
                            "deviceSign" | "device_sign" => Ok(GeneratedField::DeviceSign),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = auth::DeviceVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Auth.DeviceVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<auth::DeviceVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_random__ = None;
                let mut device_sign__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceRandom => {
                            if device_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceRandom"));
                            }
                            device_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DeviceSign => {
                            if device_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceSign"));
                            }
                            device_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(auth::DeviceVerify {
                    device_random: device_random__.ok_or_else(|| serde::de::Error::missing_field("deviceRandom"))?,
                    device_sign: device_sign__.ok_or_else(|| serde::de::Error::missing_field("deviceSign"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Auth.DeviceVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AuthorizeUnlock {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.AuthorizeUnlock", len)?;
        let v = authorize_unlock::Device::try_from(self.device)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.device)))?;
        struct_ser.serialize_field("device", &v)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AuthorizeUnlock {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device",
            "enable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Device,
            Enable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "device" => Ok(GeneratedField::Device),
                            "enable" => Ok(GeneratedField::Enable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AuthorizeUnlock;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AuthorizeUnlock")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AuthorizeUnlock, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device__ = None;
                let mut enable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Device => {
                            if device__.is_some() {
                                return Err(serde::de::Error::duplicate_field("device"));
                            }
                            device__ = Some(map_.next_value::<authorize_unlock::Device>()? as i32);
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AuthorizeUnlock {
                    device: device__.ok_or_else(|| serde::de::Error::missing_field("device"))?,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AuthorizeUnlock", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for authorize_unlock::Device {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "UNKNOWN",
            Self::Laptop => "LAPTOP",
            Self::Phone => "PHONE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for authorize_unlock::Device {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UNKNOWN",
            "LAPTOP",
            "PHONE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = authorize_unlock::Device;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UNKNOWN" => Ok(authorize_unlock::Device::Unknown),
                    "LAPTOP" => Ok(authorize_unlock::Device::Laptop),
                    "PHONE" => Ok(authorize_unlock::Device::Phone),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for authorize_unlock::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.AuthorizeUnlock.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for authorize_unlock::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = authorize_unlock::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AuthorizeUnlock.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<authorize_unlock::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(authorize_unlock::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.AuthorizeUnlock.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AxisSensor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.AxisSensor", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("timestamp", ToString::to_string(&self.timestamp).as_str())?;
        struct_ser.serialize_field("x", &self.x)?;
        struct_ser.serialize_field("y", &self.y)?;
        struct_ser.serialize_field("z", &self.z)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AxisSensor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "x",
            "y",
            "z",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            X,
            Y,
            Z,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "x" => Ok(GeneratedField::X),
                            "y" => Ok(GeneratedField::Y),
                            "z" => Ok(GeneratedField::Z),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AxisSensor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.AxisSensor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AxisSensor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("x"));
                            }
                            x__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("y"));
                            }
                            y__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("z"));
                            }
                            z__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(AxisSensor {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    x: x__.ok_or_else(|| serde::de::Error::missing_field("x"))?,
                    y: y__.ok_or_else(|| serde::de::Error::missing_field("y"))?,
                    z: z__.ok_or_else(|| serde::de::Error::missing_field("z"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.AxisSensor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BalanceInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.BalanceInfo", len)?;
        struct_ser.serialize_field("aid", &self.aid)?;
        struct_ser.serialize_field("balance", &self.balance)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BalanceInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "aid",
            "balance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Aid,
            Balance,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aid" => Ok(GeneratedField::Aid),
                            "balance" => Ok(GeneratedField::Balance),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BalanceInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BalanceInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BalanceInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut aid__ = None;
                let mut balance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Aid => {
                            if aid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aid"));
                            }
                            aid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Balance => {
                            if balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balance"));
                            }
                            balance__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BalanceInfo {
                    aid: aid__.ok_or_else(|| serde::de::Error::missing_field("aid"))?,
                    balance: balance__.ok_or_else(|| serde::de::Error::missing_field("balance"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BalanceInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BasicCardData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.BasicCardData", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("uid", pbjson::private::base64::encode(&self.uid).as_str())?;
        struct_ser.serialize_field("sak", &self.sak)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("atqa", pbjson::private::base64::encode(&self.atqa).as_str())?;
        struct_ser.serialize_field("size", &self.size)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BasicCardData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "uid",
            "sak",
            "atqa",
            "size",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uid,
            Sak,
            Atqa,
            Size,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "uid" => Ok(GeneratedField::Uid),
                            "sak" => Ok(GeneratedField::Sak),
                            "atqa" => Ok(GeneratedField::Atqa),
                            "size" => Ok(GeneratedField::Size),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BasicCardData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicCardData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BasicCardData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uid__ = None;
                let mut sak__ = None;
                let mut atqa__ = None;
                let mut size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Sak => {
                            if sak__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sak"));
                            }
                            sak__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Atqa => {
                            if atqa__.is_some() {
                                return Err(serde::de::Error::duplicate_field("atqa"));
                            }
                            atqa__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BasicCardData {
                    uid: uid__.ok_or_else(|| serde::de::Error::missing_field("uid"))?,
                    sak: sak__.ok_or_else(|| serde::de::Error::missing_field("sak"))?,
                    atqa: atqa__.ok_or_else(|| serde::de::Error::missing_field("atqa"))?,
                    size: size__.ok_or_else(|| serde::de::Error::missing_field("size"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicCardData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BasicData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.distance.is_some() {
            len += 1;
        }
        if self.heart_rate.is_some() {
            len += 1;
        }
        if self.intensity.is_some() {
            len += 1;
        }
        if self.valid_stand.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BasicData", len)?;
        struct_ser.serialize_field("steps", &self.steps)?;
        struct_ser.serialize_field("calories", &self.calories)?;
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        if let Some(v) = self.heart_rate.as_ref() {
            struct_ser.serialize_field("heartRate", v)?;
        }
        if let Some(v) = self.intensity.as_ref() {
            struct_ser.serialize_field("intensity", v)?;
        }
        if let Some(v) = self.valid_stand.as_ref() {
            struct_ser.serialize_field("validStand", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BasicData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "steps",
            "calories",
            "distance",
            "heart_rate",
            "heartRate",
            "intensity",
            "valid_stand",
            "validStand",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Steps,
            Calories,
            Distance,
            HeartRate,
            Intensity,
            ValidStand,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "steps" => Ok(GeneratedField::Steps),
                            "calories" => Ok(GeneratedField::Calories),
                            "distance" => Ok(GeneratedField::Distance),
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "intensity" => Ok(GeneratedField::Intensity),
                            "validStand" | "valid_stand" => Ok(GeneratedField::ValidStand),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BasicData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BasicData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut steps__ = None;
                let mut calories__ = None;
                let mut distance__ = None;
                let mut heart_rate__ = None;
                let mut intensity__ = None;
                let mut valid_stand__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Steps => {
                            if steps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("steps"));
                            }
                            steps__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Intensity => {
                            if intensity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intensity"));
                            }
                            intensity__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidStand => {
                            if valid_stand__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validStand"));
                            }
                            valid_stand__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BasicData {
                    steps: steps__.ok_or_else(|| serde::de::Error::missing_field("steps"))?,
                    calories: calories__.ok_or_else(|| serde::de::Error::missing_field("calories"))?,
                    distance: distance__,
                    heart_rate: heart_rate__,
                    intensity: intensity__,
                    valid_stand: valid_stand__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BasicInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.BasicInfo", len)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("fingerprint", pbjson::private::base64::encode(&self.fingerprint).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BasicInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_name",
            "packageName",
            "fingerprint",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageName,
            Fingerprint,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "fingerprint" => Ok(GeneratedField::Fingerprint),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BasicInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BasicInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_name__ = None;
                let mut fingerprint__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fingerprint => {
                            if fingerprint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fingerprint"));
                            }
                            fingerprint__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BasicInfo {
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                    fingerprint: fingerprint__.ok_or_else(|| serde::de::Error::missing_field("fingerprint"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BasicStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.BasicStatus", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BasicStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BasicStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BasicStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(BasicStatus {
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Charging {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Start => "START",
            Self::Quit => "QUIT",
            Self::Finish => "FINISH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Charging {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "START",
            "QUIT",
            "FINISH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Charging;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "START" => Ok(basic_status::Charging::Start),
                    "QUIT" => Ok(basic_status::Charging::Quit),
                    "FINISH" => Ok(basic_status::Charging::Finish),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Present {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.battery.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BasicStatus.Present", len)?;
        struct_ser.serialize_field("isCharging", &self.is_charging)?;
        if let Some(v) = self.battery.as_ref() {
            struct_ser.serialize_field("battery", v)?;
        }
        struct_ser.serialize_field("isWearing", &self.is_wearing)?;
        struct_ser.serialize_field("isSleeping", &self.is_sleeping)?;
        struct_ser.serialize_field("sport", &self.sport)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Present {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_charging",
            "isCharging",
            "battery",
            "is_wearing",
            "isWearing",
            "is_sleeping",
            "isSleeping",
            "sport",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsCharging,
            Battery,
            IsWearing,
            IsSleeping,
            Sport,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isCharging" | "is_charging" => Ok(GeneratedField::IsCharging),
                            "battery" => Ok(GeneratedField::Battery),
                            "isWearing" | "is_wearing" => Ok(GeneratedField::IsWearing),
                            "isSleeping" | "is_sleeping" => Ok(GeneratedField::IsSleeping),
                            "sport" => Ok(GeneratedField::Sport),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Present;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicStatus.Present")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<basic_status::Present, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_charging__ = None;
                let mut battery__ = None;
                let mut is_wearing__ = None;
                let mut is_sleeping__ = None;
                let mut sport__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsCharging => {
                            if is_charging__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isCharging"));
                            }
                            is_charging__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Battery => {
                            if battery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("battery"));
                            }
                            battery__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsWearing => {
                            if is_wearing__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isWearing"));
                            }
                            is_wearing__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsSleeping => {
                            if is_sleeping__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isSleeping"));
                            }
                            is_sleeping__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sport => {
                            if sport__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sport"));
                            }
                            sport__ = map_.next_value()?;
                        }
                    }
                }
                Ok(basic_status::Present {
                    is_charging: is_charging__.ok_or_else(|| serde::de::Error::missing_field("isCharging"))?,
                    battery: battery__,
                    is_wearing: is_wearing__.ok_or_else(|| serde::de::Error::missing_field("isWearing"))?,
                    is_sleeping: is_sleeping__.ok_or_else(|| serde::de::Error::missing_field("isSleeping"))?,
                    sport: sport__.ok_or_else(|| serde::de::Error::missing_field("sport"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicStatus.Present", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Report {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.charging.is_some() {
            len += 1;
        }
        if self.wearing.is_some() {
            len += 1;
        }
        if self.sleeping.is_some() {
            len += 1;
        }
        if self.waring.is_some() {
            len += 1;
        }
        if self.sport.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BasicStatus.Report", len)?;
        if let Some(v) = self.charging.as_ref() {
            let v = basic_status::Charging::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("charging", &v)?;
        }
        if let Some(v) = self.wearing.as_ref() {
            let v = basic_status::Wearing::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("wearing", &v)?;
        }
        if let Some(v) = self.sleeping.as_ref() {
            let v = basic_status::Sleeping::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sleeping", &v)?;
        }
        if let Some(v) = self.waring.as_ref() {
            let v = basic_status::Warning::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("waring", &v)?;
        }
        if let Some(v) = self.sport.as_ref() {
            struct_ser.serialize_field("sport", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Report {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "charging",
            "wearing",
            "sleeping",
            "waring",
            "sport",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Charging,
            Wearing,
            Sleeping,
            Waring,
            Sport,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "charging" => Ok(GeneratedField::Charging),
                            "wearing" => Ok(GeneratedField::Wearing),
                            "sleeping" => Ok(GeneratedField::Sleeping),
                            "waring" => Ok(GeneratedField::Waring),
                            "sport" => Ok(GeneratedField::Sport),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Report;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicStatus.Report")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<basic_status::Report, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut charging__ = None;
                let mut wearing__ = None;
                let mut sleeping__ = None;
                let mut waring__ = None;
                let mut sport__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Charging => {
                            if charging__.is_some() {
                                return Err(serde::de::Error::duplicate_field("charging"));
                            }
                            charging__ = map_.next_value::<::std::option::Option<basic_status::Charging>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Wearing => {
                            if wearing__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearing"));
                            }
                            wearing__ = map_.next_value::<::std::option::Option<basic_status::Wearing>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Sleeping => {
                            if sleeping__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleeping"));
                            }
                            sleeping__ = map_.next_value::<::std::option::Option<basic_status::Sleeping>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Waring => {
                            if waring__.is_some() {
                                return Err(serde::de::Error::duplicate_field("waring"));
                            }
                            waring__ = map_.next_value::<::std::option::Option<basic_status::Warning>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Sport => {
                            if sport__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sport"));
                            }
                            sport__ = map_.next_value()?;
                        }
                    }
                }
                Ok(basic_status::Report {
                    charging: charging__,
                    wearing: wearing__,
                    sleeping: sleeping__,
                    waring: waring__,
                    sport: sport__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicStatus.Report", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Sleeping {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::In => "IN",
            Self::Out => "OUT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Sleeping {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IN",
            "OUT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Sleeping;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "IN" => Ok(basic_status::Sleeping::In),
                    "OUT" => Ok(basic_status::Sleeping::Out),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Sport {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.sport_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BasicStatus.Sport", len)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        if let Some(v) = self.sport_state.as_ref() {
            let v = SportState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sportState", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Sport {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_type",
            "sportType",
            "sport_state",
            "sportState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportType,
            SportState,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "sportState" | "sport_state" => Ok(GeneratedField::SportState),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Sport;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BasicStatus.Sport")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<basic_status::Sport, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_type__ = None;
                let mut sport_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::SportState => {
                            if sport_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportState"));
                            }
                            sport_state__ = map_.next_value::<::std::option::Option<SportState>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(basic_status::Sport {
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    sport_state: sport_state__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BasicStatus.Sport", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Warning {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::HeartRateHigh => "HEART_RATE_HIGH",
            Self::HeartRateLow => "HEART_RATE_LOW",
            Self::ActiveHeartRateHigh => "ACTIVE_HEART_RATE_HIGH",
            Self::ActiveHeartRateLow => "ACTIVE_HEART_RATE_LOW",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Warning {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HEART_RATE_HIGH",
            "HEART_RATE_LOW",
            "ACTIVE_HEART_RATE_HIGH",
            "ACTIVE_HEART_RATE_LOW",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Warning;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "HEART_RATE_HIGH" => Ok(basic_status::Warning::HeartRateHigh),
                    "HEART_RATE_LOW" => Ok(basic_status::Warning::HeartRateLow),
                    "ACTIVE_HEART_RATE_HIGH" => Ok(basic_status::Warning::ActiveHeartRateHigh),
                    "ACTIVE_HEART_RATE_LOW" => Ok(basic_status::Warning::ActiveHeartRateLow),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for basic_status::Wearing {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::On => "ON",
            Self::Off => "OFF",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for basic_status::Wearing {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ON",
            "OFF",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = basic_status::Wearing;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ON" => Ok(basic_status::Wearing::On),
                    "OFF" => Ok(basic_status::Wearing::Off),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BestSportData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.distance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BestSportData", len)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BestSportData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_type",
            "sportType",
            "duration",
            "distance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportType,
            Duration,
            Distance,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "duration" => Ok(GeneratedField::Duration),
                            "distance" => Ok(GeneratedField::Distance),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BestSportData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BestSportData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BestSportData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_type__ = None;
                let mut duration__ = None;
                let mut distance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BestSportData {
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    distance: distance__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BestSportData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for best_sport_data::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sport_data_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BestSportData.List", len)?;
        if !self.sport_data_list.is_empty() {
            struct_ser.serialize_field("sportDataList", &self.sport_data_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for best_sport_data::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_data_list",
            "sportDataList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportDataList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportDataList" | "sport_data_list" => Ok(GeneratedField::SportDataList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = best_sport_data::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BestSportData.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<best_sport_data::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_data_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportDataList => {
                            if sport_data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportDataList"));
                            }
                            sport_data_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(best_sport_data::List {
                    sport_data_list: sport_data_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.BestSportData.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BgImageResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.BgImageResult", len)?;
        let v = bg_image_result::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("backgroundImage", &self.background_image)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BgImageResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "id",
            "background_image",
            "backgroundImage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            Id,
            BackgroundImage,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "id" => Ok(GeneratedField::Id),
                            "backgroundImage" | "background_image" => Ok(GeneratedField::BackgroundImage),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BgImageResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BgImageResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BgImageResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut id__ = None;
                let mut background_image__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<bg_image_result::Code>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BackgroundImage => {
                            if background_image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImage"));
                            }
                            background_image__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BgImageResult {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    background_image: background_image__.ok_or_else(|| serde::de::Error::missing_field("backgroundImage"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BgImageResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bg_image_result::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Success => "SUCCESS",
            Self::ImageSaveFailed => "IMAGE_SAVE_FAILED",
            Self::ImageResolveFailed => "IMAGE_RESOLVE_FAILED",
            Self::NoWatchFaceMatched => "NO_WATCH_FACE_MATCHED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for bg_image_result::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUCCESS",
            "IMAGE_SAVE_FAILED",
            "IMAGE_RESOLVE_FAILED",
            "NO_WATCH_FACE_MATCHED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bg_image_result::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUCCESS" => Ok(bg_image_result::Code::Success),
                    "IMAGE_SAVE_FAILED" => Ok(bg_image_result::Code::ImageSaveFailed),
                    "IMAGE_RESOLVE_FAILED" => Ok(bg_image_result::Code::ImageResolveFailed),
                    "NO_WATCH_FACE_MATCHED" => Ok(bg_image_result::Code::NoWatchFaceMatched),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BindInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 6;
        let mut struct_ser = serializer.serialize_struct("protocol.BindInfo", len)?;
        struct_ser.serialize_field("bindKey", &self.bind_key)?;
        struct_ser.serialize_field("did", &self.did)?;
        struct_ser.serialize_field("model", &self.model)?;
        struct_ser.serialize_field("mac", &self.mac)?;
        struct_ser.serialize_field("sign", &self.sign)?;
        struct_ser.serialize_field("serialNumber", &self.serial_number)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bind_key",
            "bindKey",
            "did",
            "model",
            "mac",
            "sign",
            "serial_number",
            "serialNumber",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BindKey,
            Did,
            Model,
            Mac,
            Sign,
            SerialNumber,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bindKey" | "bind_key" => Ok(GeneratedField::BindKey),
                            "did" => Ok(GeneratedField::Did),
                            "model" => Ok(GeneratedField::Model),
                            "mac" => Ok(GeneratedField::Mac),
                            "sign" => Ok(GeneratedField::Sign),
                            "serialNumber" | "serial_number" => Ok(GeneratedField::SerialNumber),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bind_key__ = None;
                let mut did__ = None;
                let mut model__ = None;
                let mut mac__ = None;
                let mut sign__ = None;
                let mut serial_number__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BindKey => {
                            if bind_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindKey"));
                            }
                            bind_key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Did => {
                            if did__.is_some() {
                                return Err(serde::de::Error::duplicate_field("did"));
                            }
                            did__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Model => {
                            if model__.is_some() {
                                return Err(serde::de::Error::duplicate_field("model"));
                            }
                            model__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Mac => {
                            if mac__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mac"));
                            }
                            mac__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sign => {
                            if sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sign"));
                            }
                            sign__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SerialNumber => {
                            if serial_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serialNumber"));
                            }
                            serial_number__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BindInfo {
                    bind_key: bind_key__.ok_or_else(|| serde::de::Error::missing_field("bindKey"))?,
                    did: did__.ok_or_else(|| serde::de::Error::missing_field("did"))?,
                    model: model__.ok_or_else(|| serde::de::Error::missing_field("model"))?,
                    mac: mac__.ok_or_else(|| serde::de::Error::missing_field("mac"))?,
                    sign: sign__.ok_or_else(|| serde::de::Error::missing_field("sign"))?,
                    serial_number: serial_number__.ok_or_else(|| serde::de::Error::missing_field("serialNumber"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BindInfoV2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 7;
        let mut struct_ser = serializer.serialize_struct("protocol.BindInfoV2", len)?;
        let v = VerifyMode::try_from(self.verify_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.verify_mode)))?;
        struct_ser.serialize_field("verifyMode", &v)?;
        struct_ser.serialize_field("serialNumber", &self.serial_number)?;
        struct_ser.serialize_field("mac", &self.mac)?;
        struct_ser.serialize_field("model", &self.model)?;
        let v = OobMode::try_from(self.oob_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.oob_mode)))?;
        struct_ser.serialize_field("oobMode", &v)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceRandom", pbjson::private::base64::encode(&self.device_random).as_str())?;
        struct_ser.serialize_field("did", &self.did)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindInfoV2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "verify_mode",
            "verifyMode",
            "serial_number",
            "serialNumber",
            "mac",
            "model",
            "oob_mode",
            "oobMode",
            "device_random",
            "deviceRandom",
            "did",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VerifyMode,
            SerialNumber,
            Mac,
            Model,
            OobMode,
            DeviceRandom,
            Did,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "verifyMode" | "verify_mode" => Ok(GeneratedField::VerifyMode),
                            "serialNumber" | "serial_number" => Ok(GeneratedField::SerialNumber),
                            "mac" => Ok(GeneratedField::Mac),
                            "model" => Ok(GeneratedField::Model),
                            "oobMode" | "oob_mode" => Ok(GeneratedField::OobMode),
                            "deviceRandom" | "device_random" => Ok(GeneratedField::DeviceRandom),
                            "did" => Ok(GeneratedField::Did),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindInfoV2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindInfoV2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindInfoV2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut verify_mode__ = None;
                let mut serial_number__ = None;
                let mut mac__ = None;
                let mut model__ = None;
                let mut oob_mode__ = None;
                let mut device_random__ = None;
                let mut did__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VerifyMode => {
                            if verify_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verifyMode"));
                            }
                            verify_mode__ = Some(map_.next_value::<VerifyMode>()? as i32);
                        }
                        GeneratedField::SerialNumber => {
                            if serial_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serialNumber"));
                            }
                            serial_number__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Mac => {
                            if mac__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mac"));
                            }
                            mac__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Model => {
                            if model__.is_some() {
                                return Err(serde::de::Error::duplicate_field("model"));
                            }
                            model__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OobMode => {
                            if oob_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("oobMode"));
                            }
                            oob_mode__ = Some(map_.next_value::<OobMode>()? as i32);
                        }
                        GeneratedField::DeviceRandom => {
                            if device_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceRandom"));
                            }
                            device_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Did => {
                            if did__.is_some() {
                                return Err(serde::de::Error::duplicate_field("did"));
                            }
                            did__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BindInfoV2 {
                    verify_mode: verify_mode__.ok_or_else(|| serde::de::Error::missing_field("verifyMode"))?,
                    serial_number: serial_number__.ok_or_else(|| serde::de::Error::missing_field("serialNumber"))?,
                    mac: mac__.ok_or_else(|| serde::de::Error::missing_field("mac"))?,
                    model: model__.ok_or_else(|| serde::de::Error::missing_field("model"))?,
                    oob_mode: oob_mode__.ok_or_else(|| serde::de::Error::missing_field("oobMode"))?,
                    device_random: device_random__.ok_or_else(|| serde::de::Error::missing_field("deviceRandom"))?,
                    did: did__.ok_or_else(|| serde::de::Error::missing_field("did"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindInfoV2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BindLocal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.BindLocal", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindLocal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindLocal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindLocal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindLocal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(BindLocal {
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindLocal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_local::AppConfirm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.BindLocal.AppConfirm", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appRandom", pbjson::private::base64::encode(&self.app_random).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appSign", pbjson::private::base64::encode(&self.app_sign).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_local::AppConfirm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_random",
            "appRandom",
            "app_sign",
            "appSign",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppRandom,
            AppSign,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appRandom" | "app_random" => Ok(GeneratedField::AppRandom),
                            "appSign" | "app_sign" => Ok(GeneratedField::AppSign),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_local::AppConfirm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindLocal.AppConfirm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_local::AppConfirm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_random__ = None;
                let mut app_sign__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppRandom => {
                            if app_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appRandom"));
                            }
                            app_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AppSign => {
                            if app_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appSign"));
                            }
                            app_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_local::AppConfirm {
                    app_random: app_random__.ok_or_else(|| serde::de::Error::missing_field("appRandom"))?,
                    app_sign: app_sign__.ok_or_else(|| serde::de::Error::missing_field("appSign"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindLocal.AppConfirm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_local::AppVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.BindLocal.AppVerify", len)?;
        struct_ser.serialize_field("appDeviceId", &self.app_device_id)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appPublicKey", pbjson::private::base64::encode(&self.app_public_key).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_local::AppVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_device_id",
            "appDeviceId",
            "app_public_key",
            "appPublicKey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppDeviceId,
            AppPublicKey,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appDeviceId" | "app_device_id" => Ok(GeneratedField::AppDeviceId),
                            "appPublicKey" | "app_public_key" => Ok(GeneratedField::AppPublicKey),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_local::AppVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindLocal.AppVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_local::AppVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_device_id__ = None;
                let mut app_public_key__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppDeviceId => {
                            if app_device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appDeviceId"));
                            }
                            app_device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppPublicKey => {
                            if app_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appPublicKey"));
                            }
                            app_public_key__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_local::AppVerify {
                    app_device_id: app_device_id__.ok_or_else(|| serde::de::Error::missing_field("appDeviceId"))?,
                    app_public_key: app_public_key__.ok_or_else(|| serde::de::Error::missing_field("appPublicKey"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindLocal.AppVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_local::DeviceConfirm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.BindLocal.DeviceConfirm", len)?;
        struct_ser.serialize_field("confirmResult", &self.confirm_result)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_local::DeviceConfirm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "confirm_result",
            "confirmResult",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConfirmResult,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "confirmResult" | "confirm_result" => Ok(GeneratedField::ConfirmResult),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_local::DeviceConfirm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindLocal.DeviceConfirm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_local::DeviceConfirm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut confirm_result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ConfirmResult => {
                            if confirm_result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("confirmResult"));
                            }
                            confirm_result__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(bind_local::DeviceConfirm {
                    confirm_result: confirm_result__.ok_or_else(|| serde::de::Error::missing_field("confirmResult"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindLocal.DeviceConfirm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_local::DeviceVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.BindLocal.DeviceVerify", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("devicePublicKey", pbjson::private::base64::encode(&self.device_public_key).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceRandom", pbjson::private::base64::encode(&self.device_random).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceSign", pbjson::private::base64::encode(&self.device_sign).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_local::DeviceVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_public_key",
            "devicePublicKey",
            "device_random",
            "deviceRandom",
            "device_sign",
            "deviceSign",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DevicePublicKey,
            DeviceRandom,
            DeviceSign,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "devicePublicKey" | "device_public_key" => Ok(GeneratedField::DevicePublicKey),
                            "deviceRandom" | "device_random" => Ok(GeneratedField::DeviceRandom),
                            "deviceSign" | "device_sign" => Ok(GeneratedField::DeviceSign),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_local::DeviceVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindLocal.DeviceVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_local::DeviceVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_public_key__ = None;
                let mut device_random__ = None;
                let mut device_sign__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DevicePublicKey => {
                            if device_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("devicePublicKey"));
                            }
                            device_public_key__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DeviceRandom => {
                            if device_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceRandom"));
                            }
                            device_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DeviceSign => {
                            if device_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceSign"));
                            }
                            device_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_local::DeviceVerify {
                    device_public_key: device_public_key__.ok_or_else(|| serde::de::Error::missing_field("devicePublicKey"))?,
                    device_random: device_random__.ok_or_else(|| serde::de::Error::missing_field("deviceRandom"))?,
                    device_sign: device_sign__.ok_or_else(|| serde::de::Error::missing_field("deviceSign"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindLocal.DeviceVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_local::ResultInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.BindLocal.ResultInfo", len)?;
        struct_ser.serialize_field("userId", &self.user_id)?;
        struct_ser.serialize_field("companionDevice", &self.companion_device)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_local::ResultInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user_id",
            "userId",
            "companion_device",
            "companionDevice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UserId,
            CompanionDevice,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "userId" | "user_id" => Ok(GeneratedField::UserId),
                            "companionDevice" | "companion_device" => Ok(GeneratedField::CompanionDevice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_local::ResultInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindLocal.ResultInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_local::ResultInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user_id__ = None;
                let mut companion_device__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UserId => {
                            if user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userId"));
                            }
                            user_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CompanionDevice => {
                            if companion_device__.is_some() {
                                return Err(serde::de::Error::duplicate_field("companionDevice"));
                            }
                            companion_device__ = map_.next_value()?;
                        }
                    }
                }
                Ok(bind_local::ResultInfo {
                    user_id: user_id__.ok_or_else(|| serde::de::Error::missing_field("userId"))?,
                    companion_device: companion_device__.ok_or_else(|| serde::de::Error::missing_field("companionDevice"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindLocal.ResultInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BindPsk {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.BindPsk", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindPsk {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindPsk;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindPsk")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindPsk, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(BindPsk {
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindPsk", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_psk::AppConfirm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.BindPsk.AppConfirm", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appRandom", pbjson::private::base64::encode(&self.app_random).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("appSign", pbjson::private::base64::encode(&self.app_sign).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("bindKey", pbjson::private::base64::encode(&self.bind_key).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_psk::AppConfirm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_random",
            "appRandom",
            "app_sign",
            "appSign",
            "bind_key",
            "bindKey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppRandom,
            AppSign,
            BindKey,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appRandom" | "app_random" => Ok(GeneratedField::AppRandom),
                            "appSign" | "app_sign" => Ok(GeneratedField::AppSign),
                            "bindKey" | "bind_key" => Ok(GeneratedField::BindKey),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_psk::AppConfirm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindPsk.AppConfirm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_psk::AppConfirm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_random__ = None;
                let mut app_sign__ = None;
                let mut bind_key__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppRandom => {
                            if app_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appRandom"));
                            }
                            app_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AppSign => {
                            if app_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appSign"));
                            }
                            app_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::BindKey => {
                            if bind_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindKey"));
                            }
                            bind_key__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_psk::AppConfirm {
                    app_random: app_random__.ok_or_else(|| serde::de::Error::missing_field("appRandom"))?,
                    app_sign: app_sign__.ok_or_else(|| serde::de::Error::missing_field("appSign"))?,
                    bind_key: bind_key__.ok_or_else(|| serde::de::Error::missing_field("bindKey"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindPsk.AppConfirm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_psk::DeviceConfirm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.BindPsk.DeviceConfirm", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceRandom", pbjson::private::base64::encode(&self.device_random).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceSign", pbjson::private::base64::encode(&self.device_sign).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("bindSign", pbjson::private::base64::encode(&self.bind_sign).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_psk::DeviceConfirm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_random",
            "deviceRandom",
            "device_sign",
            "deviceSign",
            "bind_sign",
            "bindSign",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceRandom,
            DeviceSign,
            BindSign,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceRandom" | "device_random" => Ok(GeneratedField::DeviceRandom),
                            "deviceSign" | "device_sign" => Ok(GeneratedField::DeviceSign),
                            "bindSign" | "bind_sign" => Ok(GeneratedField::BindSign),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_psk::DeviceConfirm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindPsk.DeviceConfirm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_psk::DeviceConfirm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_random__ = None;
                let mut device_sign__ = None;
                let mut bind_sign__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceRandom => {
                            if device_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceRandom"));
                            }
                            device_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DeviceSign => {
                            if device_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceSign"));
                            }
                            device_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::BindSign => {
                            if bind_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bindSign"));
                            }
                            bind_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_psk::DeviceConfirm {
                    device_random: device_random__.ok_or_else(|| serde::de::Error::missing_field("deviceRandom"))?,
                    device_sign: device_sign__.ok_or_else(|| serde::de::Error::missing_field("deviceSign"))?,
                    bind_sign: bind_sign__.ok_or_else(|| serde::de::Error::missing_field("bindSign"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindPsk.DeviceConfirm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_psk::DeviceVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.BindPsk.DeviceVerify", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("devicePublicKey", pbjson::private::base64::encode(&self.device_public_key).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("deviceSign", pbjson::private::base64::encode(&self.device_sign).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_psk::DeviceVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_public_key",
            "devicePublicKey",
            "device_sign",
            "deviceSign",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DevicePublicKey,
            DeviceSign,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "devicePublicKey" | "device_public_key" => Ok(GeneratedField::DevicePublicKey),
                            "deviceSign" | "device_sign" => Ok(GeneratedField::DeviceSign),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_psk::DeviceVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindPsk.DeviceVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_psk::DeviceVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_public_key__ = None;
                let mut device_sign__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DevicePublicKey => {
                            if device_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("devicePublicKey"));
                            }
                            device_public_key__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DeviceSign => {
                            if device_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceSign"));
                            }
                            device_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_psk::DeviceVerify {
                    device_public_key: device_public_key__.ok_or_else(|| serde::de::Error::missing_field("devicePublicKey"))?,
                    device_sign: device_sign__.ok_or_else(|| serde::de::Error::missing_field("deviceSign"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindPsk.DeviceVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_psk::ResultInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.companion_device.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BindPsk.ResultInfo", len)?;
        struct_ser.serialize_field("userId", &self.user_id)?;
        if let Some(v) = self.companion_device.as_ref() {
            struct_ser.serialize_field("companionDevice", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_psk::ResultInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user_id",
            "userId",
            "companion_device",
            "companionDevice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UserId,
            CompanionDevice,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "userId" | "user_id" => Ok(GeneratedField::UserId),
                            "companionDevice" | "companion_device" => Ok(GeneratedField::CompanionDevice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_psk::ResultInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindPsk.ResultInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_psk::ResultInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user_id__ = None;
                let mut companion_device__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UserId => {
                            if user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userId"));
                            }
                            user_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CompanionDevice => {
                            if companion_device__.is_some() {
                                return Err(serde::de::Error::duplicate_field("companionDevice"));
                            }
                            companion_device__ = map_.next_value()?;
                        }
                    }
                }
                Ok(bind_psk::ResultInfo {
                    user_id: user_id__.ok_or_else(|| serde::de::Error::missing_field("userId"))?,
                    companion_device: companion_device__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindPsk.ResultInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bind_psk::ServerVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.BindPsk.ServerVerify", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("serverPublicKey", pbjson::private::base64::encode(&self.server_public_key).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("serverSign", pbjson::private::base64::encode(&self.server_sign).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("serverRandom", pbjson::private::base64::encode(&self.server_random).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for bind_psk::ServerVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "server_public_key",
            "serverPublicKey",
            "server_sign",
            "serverSign",
            "server_random",
            "serverRandom",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ServerPublicKey,
            ServerSign,
            ServerRandom,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "serverPublicKey" | "server_public_key" => Ok(GeneratedField::ServerPublicKey),
                            "serverSign" | "server_sign" => Ok(GeneratedField::ServerSign),
                            "serverRandom" | "server_random" => Ok(GeneratedField::ServerRandom),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bind_psk::ServerVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindPsk.ServerVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<bind_psk::ServerVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut server_public_key__ = None;
                let mut server_sign__ = None;
                let mut server_random__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ServerPublicKey => {
                            if server_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serverPublicKey"));
                            }
                            server_public_key__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ServerSign => {
                            if server_sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serverSign"));
                            }
                            server_sign__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ServerRandom => {
                            if server_random__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serverRandom"));
                            }
                            server_random__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(bind_psk::ServerVerify {
                    server_public_key: server_public_key__.ok_or_else(|| serde::de::Error::missing_field("serverPublicKey"))?,
                    server_sign: server_sign__.ok_or_else(|| serde::de::Error::missing_field("serverSign"))?,
                    server_random: server_random__.ok_or_else(|| serde::de::Error::missing_field("serverRandom"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindPsk.ServerVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BindResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.companion_device.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BindResult", len)?;
        struct_ser.serialize_field("userId", &self.user_id)?;
        struct_ser.serialize_field("token", &self.token)?;
        if let Some(v) = self.companion_device.as_ref() {
            struct_ser.serialize_field("companionDevice", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user_id",
            "userId",
            "token",
            "companion_device",
            "companionDevice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UserId,
            Token,
            CompanionDevice,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "userId" | "user_id" => Ok(GeneratedField::UserId),
                            "token" => Ok(GeneratedField::Token),
                            "companionDevice" | "companion_device" => Ok(GeneratedField::CompanionDevice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user_id__ = None;
                let mut token__ = None;
                let mut companion_device__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UserId => {
                            if user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userId"));
                            }
                            user_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("token"));
                            }
                            token__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CompanionDevice => {
                            if companion_device__.is_some() {
                                return Err(serde::de::Error::duplicate_field("companionDevice"));
                            }
                            companion_device__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BindResult {
                    user_id: user_id__.ok_or_else(|| serde::de::Error::missing_field("userId"))?,
                    token: token__.ok_or_else(|| serde::de::Error::missing_field("token"))?,
                    companion_device: companion_device__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BindResultV2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.BindResultV2", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("encryptResultInfo", pbjson::private::base64::encode(&self.encrypt_result_info).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindResultV2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "encrypt_result_info",
            "encryptResultInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EncryptResultInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "encryptResultInfo" | "encrypt_result_info" => Ok(GeneratedField::EncryptResultInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindResultV2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindResultV2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindResultV2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut encrypt_result_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EncryptResultInfo => {
                            if encrypt_result_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("encryptResultInfo"));
                            }
                            encrypt_result_info__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BindResultV2 {
                    encrypt_result_info: encrypt_result_info__.ok_or_else(|| serde::de::Error::missing_field("encryptResultInfo"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindResultV2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BindStartV2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.pid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BindStartV2", len)?;
        struct_ser.serialize_field("checkDynamicCode", &self.check_dynamic_code)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("hashUserId", pbjson::private::base64::encode(&self.hash_user_id).as_str())?;
        struct_ser.serialize_field("deviceName", &self.device_name)?;
        if let Some(v) = self.pid.as_ref() {
            struct_ser.serialize_field("pid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BindStartV2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "check_dynamic_code",
            "checkDynamicCode",
            "hash_user_id",
            "hashUserId",
            "device_name",
            "deviceName",
            "pid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CheckDynamicCode,
            HashUserId,
            DeviceName,
            Pid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "checkDynamicCode" | "check_dynamic_code" => Ok(GeneratedField::CheckDynamicCode),
                            "hashUserId" | "hash_user_id" => Ok(GeneratedField::HashUserId),
                            "deviceName" | "device_name" => Ok(GeneratedField::DeviceName),
                            "pid" => Ok(GeneratedField::Pid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BindStartV2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BindStartV2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BindStartV2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut check_dynamic_code__ = None;
                let mut hash_user_id__ = None;
                let mut device_name__ = None;
                let mut pid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CheckDynamicCode => {
                            if check_dynamic_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkDynamicCode"));
                            }
                            check_dynamic_code__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HashUserId => {
                            if hash_user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hashUserId"));
                            }
                            hash_user_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DeviceName => {
                            if device_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceName"));
                            }
                            device_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pid => {
                            if pid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pid"));
                            }
                            pid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BindStartV2 {
                    check_dynamic_code: check_dynamic_code__.ok_or_else(|| serde::de::Error::missing_field("checkDynamicCode"))?,
                    hash_user_id: hash_user_id__.ok_or_else(|| serde::de::Error::missing_field("hashUserId"))?,
                    device_name: device_name__.ok_or_else(|| serde::de::Error::missing_field("deviceName"))?,
                    pid: pid__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BindStartV2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BloodGlucose {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.alert.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BloodGlucose", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("timestamp", ToString::to_string(&self.timestamp).as_str())?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.serialize_field("status", &self.status)?;
        if let Some(v) = self.alert.as_ref() {
            struct_ser.serialize_field("alert", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BloodGlucose {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "value",
            "status",
            "alert",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Value,
            Status,
            Alert,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "value" => Ok(GeneratedField::Value),
                            "status" => Ok(GeneratedField::Status),
                            "alert" => Ok(GeneratedField::Alert),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BloodGlucose;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BloodGlucose")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BloodGlucose, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut value__ = None;
                let mut status__ = None;
                let mut alert__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Alert => {
                            if alert__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alert"));
                            }
                            alert__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BloodGlucose {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    alert: alert__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BloodGlucose", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BloodOxygenMonitor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.frequency.is_some() {
            len += 1;
        }
        if self.warning_non_sleep.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.BloodOxygenMonitor", len)?;
        struct_ser.serialize_field("supportAllDay", &self.support_all_day)?;
        let v = blood_oxygen_monitor::Mode::try_from(self.mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.mode)))?;
        struct_ser.serialize_field("mode", &v)?;
        if let Some(v) = self.frequency.as_ref() {
            struct_ser.serialize_field("frequency", v)?;
        }
        if let Some(v) = self.warning_non_sleep.as_ref() {
            struct_ser.serialize_field("warningNonSleep", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BloodOxygenMonitor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "support_all_day",
            "supportAllDay",
            "mode",
            "frequency",
            "warning_non_sleep",
            "warningNonSleep",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SupportAllDay,
            Mode,
            Frequency,
            WarningNonSleep,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "supportAllDay" | "support_all_day" => Ok(GeneratedField::SupportAllDay),
                            "mode" => Ok(GeneratedField::Mode),
                            "frequency" => Ok(GeneratedField::Frequency),
                            "warningNonSleep" | "warning_non_sleep" => Ok(GeneratedField::WarningNonSleep),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BloodOxygenMonitor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BloodOxygenMonitor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BloodOxygenMonitor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut support_all_day__ = None;
                let mut mode__ = None;
                let mut frequency__ = None;
                let mut warning_non_sleep__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SupportAllDay => {
                            if support_all_day__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportAllDay"));
                            }
                            support_all_day__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = Some(map_.next_value::<blood_oxygen_monitor::Mode>()? as i32);
                        }
                        GeneratedField::Frequency => {
                            if frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frequency"));
                            }
                            frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WarningNonSleep => {
                            if warning_non_sleep__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warningNonSleep"));
                            }
                            warning_non_sleep__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BloodOxygenMonitor {
                    support_all_day: support_all_day__.ok_or_else(|| serde::de::Error::missing_field("supportAllDay"))?,
                    mode: mode__.ok_or_else(|| serde::de::Error::missing_field("mode"))?,
                    frequency: frequency__,
                    warning_non_sleep: warning_non_sleep__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BloodOxygenMonitor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for blood_oxygen_monitor::Mode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Off => "OFF",
            Self::SleepOn => "SLEEP_ON",
            Self::AllDayOn => "ALL_DAY_ON",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for blood_oxygen_monitor::Mode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OFF",
            "SLEEP_ON",
            "ALL_DAY_ON",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = blood_oxygen_monitor::Mode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OFF" => Ok(blood_oxygen_monitor::Mode::Off),
                    "SLEEP_ON" => Ok(blood_oxygen_monitor::Mode::SleepOn),
                    "ALL_DAY_ON" => Ok(blood_oxygen_monitor::Mode::AllDayOn),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BondApply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.BondApply", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("hashUserId", pbjson::private::base64::encode(&self.hash_user_id).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BondApply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hash_user_id",
            "hashUserId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HashUserId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hashUserId" | "hash_user_id" => Ok(GeneratedField::HashUserId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BondApply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BondApply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BondApply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hash_user_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HashUserId => {
                            if hash_user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hashUserId"));
                            }
                            hash_user_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BondApply {
                    hash_user_id: hash_user_id__.ok_or_else(|| serde::de::Error::missing_field("hashUserId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BondApply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BondReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.BondReply", len)?;
        let v = bond_reply::Status::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BondReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BondReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BondReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BondReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<bond_reply::Status>()? as i32);
                        }
                    }
                }
                Ok(BondReply {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BondReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for bond_reply::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NotSupport => "NOT_SUPPORT",
            Self::BondSuccess => "BOND_SUCCESS",
            Self::BondFail => "BOND_FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for bond_reply::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NOT_SUPPORT",
            "BOND_SUCCESS",
            "BOND_FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = bond_reply::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NOT_SUPPORT" => Ok(bond_reply::Status::NotSupport),
                    "BOND_SUCCESS" => Ok(bond_reply::Status::BondSuccess),
                    "BOND_FAIL" => Ok(bond_reply::Status::BondFail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BrightnessControllerAjustBrightness {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.BrightnessControllerAjustBrightness", len)?;
        struct_ser.serialize_field("brightnessDelta", &self.brightness_delta)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BrightnessControllerAjustBrightness {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "brightness_delta",
            "brightnessDelta",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BrightnessDelta,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "brightnessDelta" | "brightness_delta" => Ok(GeneratedField::BrightnessDelta),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BrightnessControllerAjustBrightness;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.BrightnessControllerAjustBrightness")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BrightnessControllerAjustBrightness, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut brightness_delta__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BrightnessDelta => {
                            if brightness_delta__.is_some() {
                                return Err(serde::de::Error::duplicate_field("brightnessDelta"));
                            }
                            brightness_delta__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(BrightnessControllerAjustBrightness {
                    brightness_delta: brightness_delta__.ok_or_else(|| serde::de::Error::missing_field("brightnessDelta"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.BrightnessControllerAjustBrightness", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Cta {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.CTA", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Cta {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Cta;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CTA")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Cta, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Cta {
                })
            }
        }
        deserializer.deserialize_struct("protocol.CTA", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for cta::AppBehavior {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.CTA.AppBehavior", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("items", &self.items)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for cta::AppBehavior {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = cta::AppBehavior;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CTA.AppBehavior")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<cta::AppBehavior, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                    }
                }
                Ok(cta::AppBehavior {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CTA.AppBehavior", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for cta::AppInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.CTA.AppInfo", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("version", &self.version)?;
        struct_ser.serialize_field("updateTime", &self.update_time)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for cta::AppInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "version",
            "update_time",
            "updateTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            Version,
            UpdateTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "version" => Ok(GeneratedField::Version),
                            "updateTime" | "update_time" => Ok(GeneratedField::UpdateTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = cta::AppInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CTA.AppInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<cta::AppInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut version__ = None;
                let mut update_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UpdateTime => {
                            if update_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updateTime"));
                            }
                            update_time__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(cta::AppInfo {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    version: version__.ok_or_else(|| serde::de::Error::missing_field("version"))?,
                    update_time: update_time__.ok_or_else(|| serde::de::Error::missing_field("updateTime"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CTA.AppInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for cta::app_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CTA.AppInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for cta::app_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = cta::app_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CTA.AppInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<cta::app_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(cta::app_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CTA.AppInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Calendar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Calendar", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                calendar::Payload::CalendarInfo(v) => {
                    struct_ser.serialize_field("calendarInfo", v)?;
                }
                calendar::Payload::CalendarInfoList(v) => {
                    struct_ser.serialize_field("calendarInfoList", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Calendar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "calendar_info",
            "calendarInfo",
            "calendar_info_list",
            "calendarInfoList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CalendarInfo,
            CalendarInfoList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "calendarInfo" | "calendar_info" => Ok(GeneratedField::CalendarInfo),
                            "calendarInfoList" | "calendar_info_list" => Ok(GeneratedField::CalendarInfoList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Calendar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Calendar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Calendar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CalendarInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calendarInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(calendar::Payload::CalendarInfo)
;
                        }
                        GeneratedField::CalendarInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calendarInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(calendar::Payload::CalendarInfoList)
;
                        }
                    }
                }
                Ok(Calendar {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Calendar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for calendar::CalendarId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SyncCalendarInfo => "SYNC_CALENDAR_INFO",
            Self::SyncCalendarInfoList => "SYNC_CALENDAR_INFO_LIST",
            Self::WearRequest => "WEAR_REQUEST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for calendar::CalendarId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SYNC_CALENDAR_INFO",
            "SYNC_CALENDAR_INFO_LIST",
            "WEAR_REQUEST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = calendar::CalendarId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SYNC_CALENDAR_INFO" => Ok(calendar::CalendarId::SyncCalendarInfo),
                    "SYNC_CALENDAR_INFO_LIST" => Ok(calendar::CalendarId::SyncCalendarInfoList),
                    "WEAR_REQUEST" => Ok(calendar::CalendarId::WearRequest),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CalendarInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 7;
        let mut struct_ser = serializer.serialize_struct("protocol.CalendarInfo", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("description", &self.description)?;
        struct_ser.serialize_field("location", &self.location)?;
        struct_ser.serialize_field("start", &self.start)?;
        struct_ser.serialize_field("end", &self.end)?;
        struct_ser.serialize_field("allDay", &self.all_day)?;
        struct_ser.serialize_field("reminderMinutes", &self.reminder_minutes)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CalendarInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "description",
            "location",
            "start",
            "end",
            "all_day",
            "allDay",
            "reminder_minutes",
            "reminderMinutes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Description,
            Location,
            Start,
            End,
            AllDay,
            ReminderMinutes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "description" => Ok(GeneratedField::Description),
                            "location" => Ok(GeneratedField::Location),
                            "start" => Ok(GeneratedField::Start),
                            "end" => Ok(GeneratedField::End),
                            "allDay" | "all_day" => Ok(GeneratedField::AllDay),
                            "reminderMinutes" | "reminder_minutes" => Ok(GeneratedField::ReminderMinutes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CalendarInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CalendarInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CalendarInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut description__ = None;
                let mut location__ = None;
                let mut start__ = None;
                let mut end__ = None;
                let mut all_day__ = None;
                let mut reminder_minutes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Start => {
                            if start__.is_some() {
                                return Err(serde::de::Error::duplicate_field("start"));
                            }
                            start__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::End => {
                            if end__.is_some() {
                                return Err(serde::de::Error::duplicate_field("end"));
                            }
                            end__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AllDay => {
                            if all_day__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allDay"));
                            }
                            all_day__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReminderMinutes => {
                            if reminder_minutes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderMinutes"));
                            }
                            reminder_minutes__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CalendarInfo {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    description: description__.ok_or_else(|| serde::de::Error::missing_field("description"))?,
                    location: location__.ok_or_else(|| serde::de::Error::missing_field("location"))?,
                    start: start__.ok_or_else(|| serde::de::Error::missing_field("start"))?,
                    end: end__.ok_or_else(|| serde::de::Error::missing_field("end"))?,
                    all_day: all_day__.ok_or_else(|| serde::de::Error::missing_field("allDay"))?,
                    reminder_minutes: reminder_minutes__.ok_or_else(|| serde::de::Error::missing_field("reminderMinutes"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CalendarInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for calendar_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.disable.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CalendarInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.disable.as_ref() {
            struct_ser.serialize_field("disable", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for calendar_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "disable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            Disable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "disable" => Ok(GeneratedField::Disable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = calendar_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CalendarInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<calendar_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut disable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Disable => {
                            if disable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("disable"));
                            }
                            disable__ = map_.next_value()?;
                        }
                    }
                }
                Ok(calendar_info::List {
                    list: list__.unwrap_or_default(),
                    disable: disable__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CalendarInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CallType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Nothing => "NOTHING",
            Self::IncomingCall => "INCOMING_CALL",
            Self::MissedCall => "MISSED_CALL",
            Self::OutgoingCall => "OUTGOING_CALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CallType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NOTHING",
            "INCOMING_CALL",
            "MISSED_CALL",
            "OUTGOING_CALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CallType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NOTHING" => Ok(CallType::Nothing),
                    "INCOMING_CALL" => Ok(CallType::IncomingCall),
                    "MISSED_CALL" => Ok(CallType::MissedCall),
                    "OUTGOING_CALL" => Ok(CallType::OutgoingCall),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CardData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.CardData", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("uid", pbjson::private::base64::encode(&self.uid).as_str())?;
        struct_ser.serialize_field("sak", &self.sak)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("atqa", pbjson::private::base64::encode(&self.atqa).as_str())?;
        struct_ser.serialize_field("size", &self.size)?;
        struct_ser.serialize_field("content", &self.content)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CardData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "uid",
            "sak",
            "atqa",
            "size",
            "content",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uid,
            Sak,
            Atqa,
            Size,
            Content,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "uid" => Ok(GeneratedField::Uid),
                            "sak" => Ok(GeneratedField::Sak),
                            "atqa" => Ok(GeneratedField::Atqa),
                            "size" => Ok(GeneratedField::Size),
                            "content" => Ok(GeneratedField::Content),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CardData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CardData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uid__ = None;
                let mut sak__ = None;
                let mut atqa__ = None;
                let mut size__ = None;
                let mut content__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Sak => {
                            if sak__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sak"));
                            }
                            sak__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Atqa => {
                            if atqa__.is_some() {
                                return Err(serde::de::Error::duplicate_field("atqa"));
                            }
                            atqa__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CardData {
                    uid: uid__.ok_or_else(|| serde::de::Error::missing_field("uid"))?,
                    sak: sak__.ok_or_else(|| serde::de::Error::missing_field("sak"))?,
                    atqa: atqa__.ok_or_else(|| serde::de::Error::missing_field("atqa"))?,
                    size: size__.ok_or_else(|| serde::de::Error::missing_field("size"))?,
                    content: content__.ok_or_else(|| serde::de::Error::missing_field("content"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CardInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 6;
        if self.balance.is_some() {
            len += 1;
        }
        if self.support_hci.is_some() {
            len += 1;
        }
        if self.trade_length.is_some() {
            len += 1;
        }
        if self.trade_offset.is_some() {
            len += 1;
        }
        if self.balance_offset.is_some() {
            len += 1;
        }
        if !self.tlv_hci_rule.is_empty() {
            len += 1;
        }
        if !self.balance_command.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CardInfo", len)?;
        let v = IssueCardType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("aid", &self.aid)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("iconUrl", &self.icon_url)?;
        struct_ser.serialize_field("sid", &self.sid)?;
        if let Some(v) = self.balance.as_ref() {
            struct_ser.serialize_field("balance", v)?;
        }
        if let Some(v) = self.support_hci.as_ref() {
            struct_ser.serialize_field("supportHci", v)?;
        }
        if let Some(v) = self.trade_length.as_ref() {
            struct_ser.serialize_field("tradeLength", v)?;
        }
        if let Some(v) = self.trade_offset.as_ref() {
            struct_ser.serialize_field("tradeOffset", v)?;
        }
        if let Some(v) = self.balance_offset.as_ref() {
            struct_ser.serialize_field("balanceOffset", v)?;
        }
        if !self.tlv_hci_rule.is_empty() {
            struct_ser.serialize_field("tlvHciRule", &self.tlv_hci_rule)?;
        }
        if !self.balance_command.is_empty() {
            struct_ser.serialize_field("balanceCommand", &self.balance_command)?;
        }
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("carKeyId", pbjson::private::base64::encode(&self.car_key_id).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CardInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "aid",
            "name",
            "icon_url",
            "iconUrl",
            "sid",
            "balance",
            "support_hci",
            "supportHci",
            "trade_length",
            "tradeLength",
            "trade_offset",
            "tradeOffset",
            "balance_offset",
            "balanceOffset",
            "tlv_hci_rule",
            "tlvHciRule",
            "balance_command",
            "balanceCommand",
            "car_key_id",
            "carKeyId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Aid,
            Name,
            IconUrl,
            Sid,
            Balance,
            SupportHci,
            TradeLength,
            TradeOffset,
            BalanceOffset,
            TlvHciRule,
            BalanceCommand,
            CarKeyId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "aid" => Ok(GeneratedField::Aid),
                            "name" => Ok(GeneratedField::Name),
                            "iconUrl" | "icon_url" => Ok(GeneratedField::IconUrl),
                            "sid" => Ok(GeneratedField::Sid),
                            "balance" => Ok(GeneratedField::Balance),
                            "supportHci" | "support_hci" => Ok(GeneratedField::SupportHci),
                            "tradeLength" | "trade_length" => Ok(GeneratedField::TradeLength),
                            "tradeOffset" | "trade_offset" => Ok(GeneratedField::TradeOffset),
                            "balanceOffset" | "balance_offset" => Ok(GeneratedField::BalanceOffset),
                            "tlvHciRule" | "tlv_hci_rule" => Ok(GeneratedField::TlvHciRule),
                            "balanceCommand" | "balance_command" => Ok(GeneratedField::BalanceCommand),
                            "carKeyId" | "car_key_id" => Ok(GeneratedField::CarKeyId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CardInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CardInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut aid__ = None;
                let mut name__ = None;
                let mut icon_url__ = None;
                let mut sid__ = None;
                let mut balance__ = None;
                let mut support_hci__ = None;
                let mut trade_length__ = None;
                let mut trade_offset__ = None;
                let mut balance_offset__ = None;
                let mut tlv_hci_rule__ = None;
                let mut balance_command__ = None;
                let mut car_key_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<IssueCardType>()? as i32);
                        }
                        GeneratedField::Aid => {
                            if aid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aid"));
                            }
                            aid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IconUrl => {
                            if icon_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iconUrl"));
                            }
                            icon_url__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sid => {
                            if sid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sid"));
                            }
                            sid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Balance => {
                            if balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balance"));
                            }
                            balance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SupportHci => {
                            if support_hci__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportHci"));
                            }
                            support_hci__ = map_.next_value()?;
                        }
                        GeneratedField::TradeLength => {
                            if trade_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tradeLength"));
                            }
                            trade_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TradeOffset => {
                            if trade_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tradeOffset"));
                            }
                            trade_offset__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BalanceOffset => {
                            if balance_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceOffset"));
                            }
                            balance_offset__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TlvHciRule => {
                            if tlv_hci_rule__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tlvHciRule"));
                            }
                            tlv_hci_rule__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BalanceCommand => {
                            if balance_command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceCommand"));
                            }
                            balance_command__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CarKeyId => {
                            if car_key_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("carKeyId"));
                            }
                            car_key_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CardInfo {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    aid: aid__.ok_or_else(|| serde::de::Error::missing_field("aid"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    icon_url: icon_url__.ok_or_else(|| serde::de::Error::missing_field("iconUrl"))?,
                    sid: sid__.ok_or_else(|| serde::de::Error::missing_field("sid"))?,
                    balance: balance__,
                    support_hci: support_hci__,
                    trade_length: trade_length__,
                    trade_offset: trade_offset__,
                    balance_offset: balance_offset__,
                    tlv_hci_rule: tlv_hci_rule__.unwrap_or_default(),
                    balance_command: balance_command__.unwrap_or_default(),
                    car_key_id: car_key_id__.ok_or_else(|| serde::de::Error::missing_field("carKeyId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for card_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.full.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CardInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.full.as_ref() {
            struct_ser.serialize_field("full", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for card_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "full",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            Full,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "full" => Ok(GeneratedField::Full),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = card_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<card_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut full__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Full => {
                            if full__.is_some() {
                                return Err(serde::de::Error::duplicate_field("full"));
                            }
                            full__ = map_.next_value()?;
                        }
                    }
                }
                Ok(card_info::List {
                    list: list__.unwrap_or_default(),
                    full: full__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for card_info::TlvHciRule {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if !self.trade_amount_tags.is_empty() {
            len += 1;
        }
        if self.trade_amount_offset.is_some() {
            len += 1;
        }
        if !self.balance_tags.is_empty() {
            len += 1;
        }
        if self.balance_offset.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CardInfo.TlvHciRule", len)?;
        struct_ser.serialize_field("aid", &self.aid)?;
        struct_ser.serialize_field("dataOffset", &self.data_offset)?;
        struct_ser.serialize_field("hciPrefix", &self.hci_prefix)?;
        if !self.trade_amount_tags.is_empty() {
            struct_ser.serialize_field("tradeAmountTags", &self.trade_amount_tags)?;
        }
        if let Some(v) = self.trade_amount_offset.as_ref() {
            struct_ser.serialize_field("tradeAmountOffset", v)?;
        }
        if !self.balance_tags.is_empty() {
            struct_ser.serialize_field("balanceTags", &self.balance_tags)?;
        }
        if let Some(v) = self.balance_offset.as_ref() {
            struct_ser.serialize_field("balanceOffset", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for card_info::TlvHciRule {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "aid",
            "data_offset",
            "dataOffset",
            "hci_prefix",
            "hciPrefix",
            "trade_amount_tags",
            "tradeAmountTags",
            "trade_amount_offset",
            "tradeAmountOffset",
            "balance_tags",
            "balanceTags",
            "balance_offset",
            "balanceOffset",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Aid,
            DataOffset,
            HciPrefix,
            TradeAmountTags,
            TradeAmountOffset,
            BalanceTags,
            BalanceOffset,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aid" => Ok(GeneratedField::Aid),
                            "dataOffset" | "data_offset" => Ok(GeneratedField::DataOffset),
                            "hciPrefix" | "hci_prefix" => Ok(GeneratedField::HciPrefix),
                            "tradeAmountTags" | "trade_amount_tags" => Ok(GeneratedField::TradeAmountTags),
                            "tradeAmountOffset" | "trade_amount_offset" => Ok(GeneratedField::TradeAmountOffset),
                            "balanceTags" | "balance_tags" => Ok(GeneratedField::BalanceTags),
                            "balanceOffset" | "balance_offset" => Ok(GeneratedField::BalanceOffset),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = card_info::TlvHciRule;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardInfo.TlvHciRule")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<card_info::TlvHciRule, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut aid__ = None;
                let mut data_offset__ = None;
                let mut hci_prefix__ = None;
                let mut trade_amount_tags__ = None;
                let mut trade_amount_offset__ = None;
                let mut balance_tags__ = None;
                let mut balance_offset__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Aid => {
                            if aid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aid"));
                            }
                            aid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DataOffset => {
                            if data_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataOffset"));
                            }
                            data_offset__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HciPrefix => {
                            if hci_prefix__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hciPrefix"));
                            }
                            hci_prefix__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradeAmountTags => {
                            if trade_amount_tags__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tradeAmountTags"));
                            }
                            trade_amount_tags__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TradeAmountOffset => {
                            if trade_amount_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tradeAmountOffset"));
                            }
                            trade_amount_offset__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BalanceTags => {
                            if balance_tags__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceTags"));
                            }
                            balance_tags__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BalanceOffset => {
                            if balance_offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceOffset"));
                            }
                            balance_offset__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(card_info::TlvHciRule {
                    aid: aid__.ok_or_else(|| serde::de::Error::missing_field("aid"))?,
                    data_offset: data_offset__.ok_or_else(|| serde::de::Error::missing_field("dataOffset"))?,
                    hci_prefix: hci_prefix__.ok_or_else(|| serde::de::Error::missing_field("hciPrefix"))?,
                    trade_amount_tags: trade_amount_tags__.unwrap_or_default(),
                    trade_amount_offset: trade_amount_offset__,
                    balance_tags: balance_tags__.unwrap_or_default(),
                    balance_offset: balance_offset__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardInfo.TlvHciRule", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CardSwitcher {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.time.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CardSwitcher", len)?;
        struct_ser.serialize_field("aid", &self.aid)?;
        if !self.time.is_empty() {
            struct_ser.serialize_field("time", &self.time)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CardSwitcher {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "aid",
            "time",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Aid,
            Time,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aid" => Ok(GeneratedField::Aid),
                            "time" => Ok(GeneratedField::Time),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CardSwitcher;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardSwitcher")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CardSwitcher, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut aid__ = None;
                let mut time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Aid => {
                            if aid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aid"));
                            }
                            aid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            time__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CardSwitcher {
                    aid: aid__.ok_or_else(|| serde::de::Error::missing_field("aid"))?,
                    time: time__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardSwitcher", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for card_switcher::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CardSwitcher.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for card_switcher::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = card_switcher::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardSwitcher.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<card_switcher::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(card_switcher::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardSwitcher.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for card_switcher::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.CardSwitcher.Result", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.serialize_field("conflictAid", &self.conflict_aid)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for card_switcher::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "conflict_aid",
            "conflictAid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            ConflictAid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "conflictAid" | "conflict_aid" => Ok(GeneratedField::ConflictAid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = card_switcher::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardSwitcher.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<card_switcher::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut conflict_aid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ConflictAid => {
                            if conflict_aid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("conflictAid"));
                            }
                            conflict_aid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(card_switcher::Result {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    conflict_aid: conflict_aid__.ok_or_else(|| serde::de::Error::missing_field("conflictAid"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardSwitcher.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for card_switcher::result::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Success => "SUCCESS",
            Self::AidNotFound => "AID_NOT_FOUND",
            Self::TimeConflict => "TIME_CONFLICT",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for card_switcher::result::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUCCESS",
            "AID_NOT_FOUND",
            "TIME_CONFLICT",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = card_switcher::result::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUCCESS" => Ok(card_switcher::result::Code::Success),
                    "AID_NOT_FOUND" => Ok(card_switcher::result::Code::AidNotFound),
                    "TIME_CONFLICT" => Ok(card_switcher::result::Code::TimeConflict),
                    "FAIL" => Ok(card_switcher::result::Code::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for card_switcher::Smart {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.aid.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CardSwitcher.Smart", len)?;
        struct_ser.serialize_field("enabled", &self.enabled)?;
        if !self.aid.is_empty() {
            struct_ser.serialize_field("aid", &self.aid)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for card_switcher::Smart {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enabled",
            "aid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Enabled,
            Aid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enabled" => Ok(GeneratedField::Enabled),
                            "aid" => Ok(GeneratedField::Aid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = card_switcher::Smart;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CardSwitcher.Smart")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<card_switcher::Smart, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enabled__ = None;
                let mut aid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Enabled => {
                            if enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enabled"));
                            }
                            enabled__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aid => {
                            if aid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aid"));
                            }
                            aid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(card_switcher::Smart {
                    enabled: enabled__.ok_or_else(|| serde::de::Error::missing_field("enabled"))?,
                    aid: aid__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CardSwitcher.Smart", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Cert {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Cert", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Cert {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Cert;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Cert")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Cert, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Cert {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Cert", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for cert::DeviceRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Cert.DeviceRequest", len)?;
        struct_ser.serialize_field("payload", &self.payload)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for cert::DeviceRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "payload",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Payload,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "payload" => Ok(GeneratedField::Payload),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = cert::DeviceRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Cert.DeviceRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<cert::DeviceRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Payload => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("payload"));
                            }
                            payload__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(cert::DeviceRequest {
                    payload: payload__.ok_or_else(|| serde::de::Error::missing_field("payload"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Cert.DeviceRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for cert::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Cert.Response", len)?;
        struct_ser.serialize_field("errorCode", &self.error_code)?;
        struct_ser.serialize_field("result", &self.result)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for cert::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "error_code",
            "errorCode",
            "result",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrorCode,
            Result,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "errorCode" | "error_code" => Ok(GeneratedField::ErrorCode),
                            "result" => Ok(GeneratedField::Result),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = cert::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Cert.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<cert::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut error_code__ = None;
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrorCode => {
                            if error_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorCode"));
                            }
                            error_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(cert::Response {
                    error_code: error_code__.ok_or_else(|| serde::de::Error::missing_field("errorCode"))?,
                    result: result__.ok_or_else(|| serde::de::Error::missing_field("result"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Cert.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for cert::ServerRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Cert.ServerRequest", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for cert::ServerRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = cert::ServerRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Cert.ServerRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<cert::ServerRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(cert::ServerRequest {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Cert.ServerRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CityKey {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.CityKey", len)?;
        struct_ser.serialize_field("locationKey", &self.location_key)?;
        struct_ser.serialize_field("cityName", &self.city_name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CityKey {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "location_key",
            "locationKey",
            "city_name",
            "cityName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LocationKey,
            CityName,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "locationKey" | "location_key" => Ok(GeneratedField::LocationKey),
                            "cityName" | "city_name" => Ok(GeneratedField::CityName),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CityKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CityKey")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CityKey, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut location_key__ = None;
                let mut city_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LocationKey => {
                            if location_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("locationKey"));
                            }
                            location_key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CityName => {
                            if city_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cityName"));
                            }
                            city_name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CityKey {
                    location_key: location_key__.ok_or_else(|| serde::de::Error::missing_field("locationKey"))?,
                    city_name: city_name__.ok_or_else(|| serde::de::Error::missing_field("cityName"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CityKey", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for city_key::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CityKey.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for city_key::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = city_key::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CityKey.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<city_key::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(city_key::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CityKey.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Clock {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Clock", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                clock::Payload::ClockInfoList(v) => {
                    struct_ser.serialize_field("clockInfoList", v)?;
                }
                clock::Payload::ClockData(v) => {
                    struct_ser.serialize_field("clockData", v)?;
                }
                clock::Payload::ClockInfo(v) => {
                    struct_ser.serialize_field("clockInfo", v)?;
                }
                clock::Payload::Id(v) => {
                    struct_ser.serialize_field("id", v)?;
                }
                clock::Payload::ClockIdList(v) => {
                    struct_ser.serialize_field("clockIdList", v)?;
                }
                clock::Payload::Enable(v) => {
                    struct_ser.serialize_field("enable", v)?;
                }
                clock::Payload::ClockHoliday(v) => {
                    struct_ser.serialize_field("clockHoliday", v)?;
                }
                clock::Payload::ClockError(v) => {
                    let v = ClockError::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("clockError", &v)?;
                }
                clock::Payload::WorkAndRest(v) => {
                    struct_ser.serialize_field("workAndRest", v)?;
                }
                clock::Payload::ReminderInfoList(v) => {
                    struct_ser.serialize_field("reminderInfoList", v)?;
                }
                clock::Payload::WorldClockIdList(v) => {
                    struct_ser.serialize_field("worldClockIdList", v)?;
                }
                clock::Payload::WorldClockId(v) => {
                    struct_ser.serialize_field("worldClockId", v)?;
                }
                clock::Payload::WorldClockResult(v) => {
                    let v = WorldClockResult::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("worldClockResult", &v)?;
                }
                clock::Payload::ReminderData(v) => {
                    struct_ser.serialize_field("reminderData", v)?;
                }
                clock::Payload::ReminderInfo(v) => {
                    struct_ser.serialize_field("reminderInfo", v)?;
                }
                clock::Payload::PhoneAlarmOperation(v) => {
                    struct_ser.serialize_field("phoneAlarmOperation", v)?;
                }
                clock::Payload::ReminderIdList(v) => {
                    struct_ser.serialize_field("reminderIdList", v)?;
                }
                clock::Payload::ReminderMark(v) => {
                    struct_ser.serialize_field("reminderMark", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Clock {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "clock_info_list",
            "clockInfoList",
            "clock_data",
            "clockData",
            "clock_info",
            "clockInfo",
            "id",
            "clock_id_list",
            "clockIdList",
            "enable",
            "clock_holiday",
            "clockHoliday",
            "clock_error",
            "clockError",
            "work_and_rest",
            "workAndRest",
            "reminder_info_list",
            "reminderInfoList",
            "world_clock_id_list",
            "worldClockIdList",
            "world_clock_id",
            "worldClockId",
            "world_clock_result",
            "worldClockResult",
            "reminder_data",
            "reminderData",
            "reminder_info",
            "reminderInfo",
            "phone_alarm_operation",
            "phoneAlarmOperation",
            "reminder_id_list",
            "reminderIdList",
            "reminder_mark",
            "reminderMark",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ClockInfoList,
            ClockData,
            ClockInfo,
            Id,
            ClockIdList,
            Enable,
            ClockHoliday,
            ClockError,
            WorkAndRest,
            ReminderInfoList,
            WorldClockIdList,
            WorldClockId,
            WorldClockResult,
            ReminderData,
            ReminderInfo,
            PhoneAlarmOperation,
            ReminderIdList,
            ReminderMark,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "clockInfoList" | "clock_info_list" => Ok(GeneratedField::ClockInfoList),
                            "clockData" | "clock_data" => Ok(GeneratedField::ClockData),
                            "clockInfo" | "clock_info" => Ok(GeneratedField::ClockInfo),
                            "id" => Ok(GeneratedField::Id),
                            "clockIdList" | "clock_id_list" => Ok(GeneratedField::ClockIdList),
                            "enable" => Ok(GeneratedField::Enable),
                            "clockHoliday" | "clock_holiday" => Ok(GeneratedField::ClockHoliday),
                            "clockError" | "clock_error" => Ok(GeneratedField::ClockError),
                            "workAndRest" | "work_and_rest" => Ok(GeneratedField::WorkAndRest),
                            "reminderInfoList" | "reminder_info_list" => Ok(GeneratedField::ReminderInfoList),
                            "worldClockIdList" | "world_clock_id_list" => Ok(GeneratedField::WorldClockIdList),
                            "worldClockId" | "world_clock_id" => Ok(GeneratedField::WorldClockId),
                            "worldClockResult" | "world_clock_result" => Ok(GeneratedField::WorldClockResult),
                            "reminderData" | "reminder_data" => Ok(GeneratedField::ReminderData),
                            "reminderInfo" | "reminder_info" => Ok(GeneratedField::ReminderInfo),
                            "phoneAlarmOperation" | "phone_alarm_operation" => Ok(GeneratedField::PhoneAlarmOperation),
                            "reminderIdList" | "reminder_id_list" => Ok(GeneratedField::ReminderIdList),
                            "reminderMark" | "reminder_mark" => Ok(GeneratedField::ReminderMark),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Clock;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Clock")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Clock, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ClockInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ClockInfoList)
;
                        }
                        GeneratedField::ClockData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ClockData)
;
                        }
                        GeneratedField::ClockInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ClockInfo)
;
                        }
                        GeneratedField::Id => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| clock::Payload::Id(x.0));
                        }
                        GeneratedField::ClockIdList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockIdList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ClockIdList)
;
                        }
                        GeneratedField::Enable => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::Enable);
                        }
                        GeneratedField::ClockHoliday => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockHoliday"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ClockHoliday)
;
                        }
                        GeneratedField::ClockError => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockError"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<ClockError>>()?.map(|x| clock::Payload::ClockError(x as i32));
                        }
                        GeneratedField::WorkAndRest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("workAndRest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::WorkAndRest)
;
                        }
                        GeneratedField::ReminderInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ReminderInfoList)
;
                        }
                        GeneratedField::WorldClockIdList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("worldClockIdList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::WorldClockIdList)
;
                        }
                        GeneratedField::WorldClockId => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("worldClockId"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::WorldClockId);
                        }
                        GeneratedField::WorldClockResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("worldClockResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<WorldClockResult>>()?.map(|x| clock::Payload::WorldClockResult(x as i32));
                        }
                        GeneratedField::ReminderData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ReminderData)
;
                        }
                        GeneratedField::ReminderInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ReminderInfo)
;
                        }
                        GeneratedField::PhoneAlarmOperation => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneAlarmOperation"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::PhoneAlarmOperation)
;
                        }
                        GeneratedField::ReminderIdList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderIdList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ReminderIdList)
;
                        }
                        GeneratedField::ReminderMark => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderMark"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(clock::Payload::ReminderMark)
;
                        }
                    }
                }
                Ok(Clock {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Clock", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for clock::ClockId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GetClockList => "GET_CLOCK_LIST",
            Self::AddClock => "ADD_CLOCK",
            Self::UpdateClock => "UPDATE_CLOCK",
            Self::RemoveClock => "REMOVE_CLOCK",
            Self::RemoveClocks => "REMOVE_CLOCKS",
            Self::EnableOrDisableClock => "ENABLE_OR_DISABLE_CLOCK",
            Self::GetReminderList => "GET_REMINDER_LIST",
            Self::AddReminder => "ADD_REMINDER",
            Self::UpdateReminder => "UPDATE_REMINDER",
            Self::RemoveReminders => "REMOVE_REMINDERS",
            Self::SyncReminderList => "SYNC_REMINDER_LIST",
            Self::MarkReminder => "MARK_REMINDER",
            Self::RequestReminders => "REQUEST_REMINDERS",
            Self::SyncHoliday => "SYNC_HOLIDAY",
            Self::WearRequestHoliday => "WEAR_REQUEST_HOLIDAY",
            Self::GetWorkAndRest => "GET_WORK_AND_REST",
            Self::SetWorkAndRest => "SET_WORK_AND_REST",
            Self::GetWorldClockList => "GET_WORLD_CLOCK_LIST",
            Self::AddWorldClock => "ADD_WORLD_CLOCK",
            Self::RemoveWorldClock => "REMOVE_WORLD_CLOCK",
            Self::RemoveWorldClocks => "REMOVE_WORLD_CLOCKS",
            Self::PhoneAlarmOperation => "PHONE_ALARM_OPERATION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for clock::ClockId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GET_CLOCK_LIST",
            "ADD_CLOCK",
            "UPDATE_CLOCK",
            "REMOVE_CLOCK",
            "REMOVE_CLOCKS",
            "ENABLE_OR_DISABLE_CLOCK",
            "GET_REMINDER_LIST",
            "ADD_REMINDER",
            "UPDATE_REMINDER",
            "REMOVE_REMINDERS",
            "SYNC_REMINDER_LIST",
            "MARK_REMINDER",
            "REQUEST_REMINDERS",
            "SYNC_HOLIDAY",
            "WEAR_REQUEST_HOLIDAY",
            "GET_WORK_AND_REST",
            "SET_WORK_AND_REST",
            "GET_WORLD_CLOCK_LIST",
            "ADD_WORLD_CLOCK",
            "REMOVE_WORLD_CLOCK",
            "REMOVE_WORLD_CLOCKS",
            "PHONE_ALARM_OPERATION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = clock::ClockId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GET_CLOCK_LIST" => Ok(clock::ClockId::GetClockList),
                    "ADD_CLOCK" => Ok(clock::ClockId::AddClock),
                    "UPDATE_CLOCK" => Ok(clock::ClockId::UpdateClock),
                    "REMOVE_CLOCK" => Ok(clock::ClockId::RemoveClock),
                    "REMOVE_CLOCKS" => Ok(clock::ClockId::RemoveClocks),
                    "ENABLE_OR_DISABLE_CLOCK" => Ok(clock::ClockId::EnableOrDisableClock),
                    "GET_REMINDER_LIST" => Ok(clock::ClockId::GetReminderList),
                    "ADD_REMINDER" => Ok(clock::ClockId::AddReminder),
                    "UPDATE_REMINDER" => Ok(clock::ClockId::UpdateReminder),
                    "REMOVE_REMINDERS" => Ok(clock::ClockId::RemoveReminders),
                    "SYNC_REMINDER_LIST" => Ok(clock::ClockId::SyncReminderList),
                    "MARK_REMINDER" => Ok(clock::ClockId::MarkReminder),
                    "REQUEST_REMINDERS" => Ok(clock::ClockId::RequestReminders),
                    "SYNC_HOLIDAY" => Ok(clock::ClockId::SyncHoliday),
                    "WEAR_REQUEST_HOLIDAY" => Ok(clock::ClockId::WearRequestHoliday),
                    "GET_WORK_AND_REST" => Ok(clock::ClockId::GetWorkAndRest),
                    "SET_WORK_AND_REST" => Ok(clock::ClockId::SetWorkAndRest),
                    "GET_WORLD_CLOCK_LIST" => Ok(clock::ClockId::GetWorldClockList),
                    "ADD_WORLD_CLOCK" => Ok(clock::ClockId::AddWorldClock),
                    "REMOVE_WORLD_CLOCK" => Ok(clock::ClockId::RemoveWorldClock),
                    "REMOVE_WORLD_CLOCKS" => Ok(clock::ClockId::RemoveWorldClocks),
                    "PHONE_ALARM_OPERATION" => Ok(clock::ClockId::PhoneAlarmOperation),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ClockError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ExceedLimit => "EXCEED_LIMIT",
            Self::InvalidId => "INVALID_ID",
            Self::InvalidData => "INVALID_DATA",
            Self::NotSupportHoliday => "NOT_SUPPORT_HOLIDAY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ClockError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EXCEED_LIMIT",
            "INVALID_ID",
            "INVALID_DATA",
            "NOT_SUPPORT_HOLIDAY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClockError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EXCEED_LIMIT" => Ok(ClockError::ExceedLimit),
                    "INVALID_ID" => Ok(ClockError::InvalidId),
                    "INVALID_DATA" => Ok(ClockError::InvalidData),
                    "NOT_SUPPORT_HOLIDAY" => Ok(ClockError::NotSupportHoliday),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ClockHoliday {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.free_days.is_empty() {
            len += 1;
        }
        if !self.work_days.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ClockHoliday", len)?;
        struct_ser.serialize_field("year", &self.year)?;
        if !self.free_days.is_empty() {
            struct_ser.serialize_field("freeDays", &self.free_days)?;
        }
        if !self.work_days.is_empty() {
            struct_ser.serialize_field("workDays", &self.work_days)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClockHoliday {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "year",
            "free_days",
            "freeDays",
            "work_days",
            "workDays",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Year,
            FreeDays,
            WorkDays,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "year" => Ok(GeneratedField::Year),
                            "freeDays" | "free_days" => Ok(GeneratedField::FreeDays),
                            "workDays" | "work_days" => Ok(GeneratedField::WorkDays),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClockHoliday;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ClockHoliday")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClockHoliday, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut year__ = None;
                let mut free_days__ = None;
                let mut work_days__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Year => {
                            if year__.is_some() {
                                return Err(serde::de::Error::duplicate_field("year"));
                            }
                            year__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::FreeDays => {
                            if free_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("freeDays"));
                            }
                            free_days__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WorkDays => {
                            if work_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("workDays"));
                            }
                            work_days__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ClockHoliday {
                    year: year__.ok_or_else(|| serde::de::Error::missing_field("year"))?,
                    free_days: free_days__.unwrap_or_default(),
                    work_days: work_days__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ClockHoliday", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClockIdList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ClockIdList", len)?;
        if !self.id.is_empty() {
            struct_ser.serialize_field("id", &self.id)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClockIdList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClockIdList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ClockIdList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClockIdList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(ClockIdList {
                    id: id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ClockIdList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClockInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ClockInfo", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("data", &self.data)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClockInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClockInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ClockInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClockInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ClockInfo {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    data: data__.ok_or_else(|| serde::de::Error::missing_field("data"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ClockInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for clock_info::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.week_days.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ClockInfo.Data", len)?;
        struct_ser.serialize_field("time", &self.time)?;
        let v = ClockMode::try_from(self.clock_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.clock_mode)))?;
        struct_ser.serialize_field("clockMode", &v)?;
        if let Some(v) = self.week_days.as_ref() {
            struct_ser.serialize_field("weekDays", v)?;
        }
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.serialize_field("label", &self.label)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for clock_info::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "time",
            "clock_mode",
            "clockMode",
            "week_days",
            "weekDays",
            "enable",
            "label",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Time,
            ClockMode,
            WeekDays,
            Enable,
            Label,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "time" => Ok(GeneratedField::Time),
                            "clockMode" | "clock_mode" => Ok(GeneratedField::ClockMode),
                            "weekDays" | "week_days" => Ok(GeneratedField::WeekDays),
                            "enable" => Ok(GeneratedField::Enable),
                            "label" => Ok(GeneratedField::Label),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = clock_info::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ClockInfo.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<clock_info::Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut time__ = None;
                let mut clock_mode__ = None;
                let mut week_days__ = None;
                let mut enable__ = None;
                let mut label__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            time__ = map_.next_value()?;
                        }
                        GeneratedField::ClockMode => {
                            if clock_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockMode"));
                            }
                            clock_mode__ = Some(map_.next_value::<ClockMode>()? as i32);
                        }
                        GeneratedField::WeekDays => {
                            if week_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekDays"));
                            }
                            week_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Label => {
                            if label__.is_some() {
                                return Err(serde::de::Error::duplicate_field("label"));
                            }
                            label__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(clock_info::Data {
                    time: time__.ok_or_else(|| serde::de::Error::missing_field("time"))?,
                    clock_mode: clock_mode__.ok_or_else(|| serde::de::Error::missing_field("clockMode"))?,
                    week_days: week_days__,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                    label: label__.ok_or_else(|| serde::de::Error::missing_field("label"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ClockInfo.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for clock_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.support_max_clocks.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ClockInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.support_max_clocks.as_ref() {
            struct_ser.serialize_field("supportMaxClocks", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for clock_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "support_max_clocks",
            "supportMaxClocks",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            SupportMaxClocks,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "supportMaxClocks" | "support_max_clocks" => Ok(GeneratedField::SupportMaxClocks),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = clock_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ClockInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<clock_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut support_max_clocks__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportMaxClocks => {
                            if support_max_clocks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMaxClocks"));
                            }
                            support_max_clocks__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(clock_info::List {
                    list: list__.unwrap_or_default(),
                    support_max_clocks: support_max_clocks__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ClockInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClockMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ClockOnce => "CLOCK_ONCE",
            Self::ClockEveryDay => "CLOCK_EVERY_DAY",
            Self::ClockWorkday => "CLOCK_WORKDAY",
            Self::ClockHoliday => "CLOCK_HOLIDAY",
            Self::ClockMondayToFriday => "CLOCK_MONDAY_TO_FRIDAY",
            Self::ClockCustom => "CLOCK_CUSTOM",
            Self::ClockEveryWeek => "CLOCK_EVERY_WEEK",
            Self::ClockEveryMonth => "CLOCK_EVERY_MONTH",
            Self::ClockEveryYear => "CLOCK_EVERY_YEAR",
            Self::ClockNone => "CLOCK_NONE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ClockMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CLOCK_ONCE",
            "CLOCK_EVERY_DAY",
            "CLOCK_WORKDAY",
            "CLOCK_HOLIDAY",
            "CLOCK_MONDAY_TO_FRIDAY",
            "CLOCK_CUSTOM",
            "CLOCK_EVERY_WEEK",
            "CLOCK_EVERY_MONTH",
            "CLOCK_EVERY_YEAR",
            "CLOCK_NONE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClockMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CLOCK_ONCE" => Ok(ClockMode::ClockOnce),
                    "CLOCK_EVERY_DAY" => Ok(ClockMode::ClockEveryDay),
                    "CLOCK_WORKDAY" => Ok(ClockMode::ClockWorkday),
                    "CLOCK_HOLIDAY" => Ok(ClockMode::ClockHoliday),
                    "CLOCK_MONDAY_TO_FRIDAY" => Ok(ClockMode::ClockMondayToFriday),
                    "CLOCK_CUSTOM" => Ok(ClockMode::ClockCustom),
                    "CLOCK_EVERY_WEEK" => Ok(ClockMode::ClockEveryWeek),
                    "CLOCK_EVERY_MONTH" => Ok(ClockMode::ClockEveryMonth),
                    "CLOCK_EVERY_YEAR" => Ok(ClockMode::ClockEveryYear),
                    "CLOCK_NONE" => Ok(ClockMode::ClockNone),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CommandInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.CommandInfo", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("data", pbjson::private::base64::encode(&self.data).as_str())?;
        struct_ser.serialize_field("expectStatus", &self.expect_status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommandInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "data",
            "expect_status",
            "expectStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Data,
            ExpectStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "data" => Ok(GeneratedField::Data),
                            "expectStatus" | "expect_status" => Ok(GeneratedField::ExpectStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommandInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CommandInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommandInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut data__ = None;
                let mut expect_status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ExpectStatus => {
                            if expect_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectStatus"));
                            }
                            expect_status__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CommandInfo {
                    data: data__.ok_or_else(|| serde::de::Error::missing_field("data"))?,
                    expect_status: expect_status__.ok_or_else(|| serde::de::Error::missing_field("expectStatus"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CommandInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for command_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CommandInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for command_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = command_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CommandInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<command_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(command_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CommandInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompanionDevice {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.system_version.is_some() {
            len += 1;
        }
        if self.app_capability.is_some() {
            len += 1;
        }
        if self.region.is_some() {
            len += 1;
        }
        if self.server_prefix.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CompanionDevice", len)?;
        let v = companion_device::DeviceType::try_from(self.device_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.device_type)))?;
        struct_ser.serialize_field("deviceType", &v)?;
        if let Some(v) = self.system_version.as_ref() {
            struct_ser.serialize_field("systemVersion", v)?;
        }
        struct_ser.serialize_field("deviceName", &self.device_name)?;
        if let Some(v) = self.app_capability.as_ref() {
            struct_ser.serialize_field("appCapability", v)?;
        }
        if let Some(v) = self.region.as_ref() {
            struct_ser.serialize_field("region", v)?;
        }
        if let Some(v) = self.server_prefix.as_ref() {
            struct_ser.serialize_field("serverPrefix", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompanionDevice {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_type",
            "deviceType",
            "system_version",
            "systemVersion",
            "device_name",
            "deviceName",
            "app_capability",
            "appCapability",
            "region",
            "server_prefix",
            "serverPrefix",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceType,
            SystemVersion,
            DeviceName,
            AppCapability,
            Region,
            ServerPrefix,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceType" | "device_type" => Ok(GeneratedField::DeviceType),
                            "systemVersion" | "system_version" => Ok(GeneratedField::SystemVersion),
                            "deviceName" | "device_name" => Ok(GeneratedField::DeviceName),
                            "appCapability" | "app_capability" => Ok(GeneratedField::AppCapability),
                            "region" => Ok(GeneratedField::Region),
                            "serverPrefix" | "server_prefix" => Ok(GeneratedField::ServerPrefix),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompanionDevice;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CompanionDevice")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompanionDevice, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_type__ = None;
                let mut system_version__ = None;
                let mut device_name__ = None;
                let mut app_capability__ = None;
                let mut region__ = None;
                let mut server_prefix__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceType => {
                            if device_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceType"));
                            }
                            device_type__ = Some(map_.next_value::<companion_device::DeviceType>()? as i32);
                        }
                        GeneratedField::SystemVersion => {
                            if system_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemVersion"));
                            }
                            system_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DeviceName => {
                            if device_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceName"));
                            }
                            device_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppCapability => {
                            if app_capability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appCapability"));
                            }
                            app_capability__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Region => {
                            if region__.is_some() {
                                return Err(serde::de::Error::duplicate_field("region"));
                            }
                            region__ = map_.next_value()?;
                        }
                        GeneratedField::ServerPrefix => {
                            if server_prefix__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serverPrefix"));
                            }
                            server_prefix__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CompanionDevice {
                    device_type: device_type__.ok_or_else(|| serde::de::Error::missing_field("deviceType"))?,
                    system_version: system_version__,
                    device_name: device_name__.ok_or_else(|| serde::de::Error::missing_field("deviceName"))?,
                    app_capability: app_capability__,
                    region: region__,
                    server_prefix: server_prefix__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CompanionDevice", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for companion_device::DeviceType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Android => "ANDROID",
            Self::Ios => "IOS",
            Self::Vela => "VELA",
            Self::Other => "OTHER",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for companion_device::DeviceType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ANDROID",
            "IOS",
            "VELA",
            "OTHER",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = companion_device::DeviceType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ANDROID" => Ok(companion_device::DeviceType::Android),
                    "IOS" => Ok(companion_device::DeviceType::Ios),
                    "VELA" => Ok(companion_device::DeviceType::Vela),
                    "OTHER" => Ok(companion_device::DeviceType::Other),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CompressMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoCompress => "NO_COMPRESS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CompressMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_COMPRESS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompressMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_COMPRESS" => Ok(CompressMode::NoCompress),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Contact {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Contact", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                contact::Payload::EmergencyContact(v) => {
                    struct_ser.serialize_field("emergencyContact", v)?;
                }
                contact::Payload::Number(v) => {
                    struct_ser.serialize_field("number", v)?;
                }
                contact::Payload::ContactInfo(v) => {
                    struct_ser.serialize_field("contactInfo", v)?;
                }
                contact::Payload::ContactInfoList(v) => {
                    struct_ser.serialize_field("contactInfoList", v)?;
                }
                contact::Payload::MiuiSosRequest(v) => {
                    struct_ser.serialize_field("miuiSosRequest", v)?;
                }
                contact::Payload::MiuiSosResponse(v) => {
                    struct_ser.serialize_field("miuiSosResponse", v)?;
                }
                contact::Payload::HelpRequest(v) => {
                    struct_ser.serialize_field("helpRequest", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Contact {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "emergency_contact",
            "emergencyContact",
            "number",
            "contact_info",
            "contactInfo",
            "contact_info_list",
            "contactInfoList",
            "miui_sos_request",
            "miuiSosRequest",
            "miui_sos_response",
            "miuiSosResponse",
            "help_request",
            "helpRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EmergencyContact,
            Number,
            ContactInfo,
            ContactInfoList,
            MiuiSosRequest,
            MiuiSosResponse,
            HelpRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "emergencyContact" | "emergency_contact" => Ok(GeneratedField::EmergencyContact),
                            "number" => Ok(GeneratedField::Number),
                            "contactInfo" | "contact_info" => Ok(GeneratedField::ContactInfo),
                            "contactInfoList" | "contact_info_list" => Ok(GeneratedField::ContactInfoList),
                            "miuiSosRequest" | "miui_sos_request" => Ok(GeneratedField::MiuiSosRequest),
                            "miuiSosResponse" | "miui_sos_response" => Ok(GeneratedField::MiuiSosResponse),
                            "helpRequest" | "help_request" => Ok(GeneratedField::HelpRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Contact;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Contact")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Contact, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EmergencyContact => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("emergencyContact"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::EmergencyContact)
;
                        }
                        GeneratedField::Number => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("number"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::Number);
                        }
                        GeneratedField::ContactInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contactInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::ContactInfo)
;
                        }
                        GeneratedField::ContactInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contactInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::ContactInfoList)
;
                        }
                        GeneratedField::MiuiSosRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("miuiSosRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::MiuiSosRequest)
;
                        }
                        GeneratedField::MiuiSosResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("miuiSosResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::MiuiSosResponse)
;
                        }
                        GeneratedField::HelpRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("helpRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(contact::Payload::HelpRequest)
;
                        }
                    }
                }
                Ok(Contact {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Contact", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for contact::ContactId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GetEmergencyContact => "GET_EMERGENCY_CONTACT",
            Self::SetEmergencyContact => "SET_EMERGENCY_CONTACT",
            Self::RequestMiuiSos => "REQUEST_MIUI_SOS",
            Self::ResponseMiuiSos => "RESPONSE_MIUI_SOS",
            Self::ApplyFallHelp => "APPLY_FALL_HELP",
            Self::EndFallHelp => "END_FALL_HELP",
            Self::QueryContactInfo => "QUERY_CONTACT_INFO",
            Self::SendContactInfo => "SEND_CONTACT_INFO",
            Self::GetContactList => "GET_CONTACT_LIST",
            Self::AddContactList => "ADD_CONTACT_LIST",
            Self::RemoveContactList => "REMOVE_CONTACT_LIST",
            Self::SyncContactList => "SYNC_CONTACT_LIST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for contact::ContactId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GET_EMERGENCY_CONTACT",
            "SET_EMERGENCY_CONTACT",
            "REQUEST_MIUI_SOS",
            "RESPONSE_MIUI_SOS",
            "APPLY_FALL_HELP",
            "END_FALL_HELP",
            "QUERY_CONTACT_INFO",
            "SEND_CONTACT_INFO",
            "GET_CONTACT_LIST",
            "ADD_CONTACT_LIST",
            "REMOVE_CONTACT_LIST",
            "SYNC_CONTACT_LIST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = contact::ContactId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GET_EMERGENCY_CONTACT" => Ok(contact::ContactId::GetEmergencyContact),
                    "SET_EMERGENCY_CONTACT" => Ok(contact::ContactId::SetEmergencyContact),
                    "REQUEST_MIUI_SOS" => Ok(contact::ContactId::RequestMiuiSos),
                    "RESPONSE_MIUI_SOS" => Ok(contact::ContactId::ResponseMiuiSos),
                    "APPLY_FALL_HELP" => Ok(contact::ContactId::ApplyFallHelp),
                    "END_FALL_HELP" => Ok(contact::ContactId::EndFallHelp),
                    "QUERY_CONTACT_INFO" => Ok(contact::ContactId::QueryContactInfo),
                    "SEND_CONTACT_INFO" => Ok(contact::ContactId::SendContactInfo),
                    "GET_CONTACT_LIST" => Ok(contact::ContactId::GetContactList),
                    "ADD_CONTACT_LIST" => Ok(contact::ContactId::AddContactList),
                    "REMOVE_CONTACT_LIST" => Ok(contact::ContactId::RemoveContactList),
                    "SYNC_CONTACT_LIST" => Ok(contact::ContactId::SyncContactList),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ContactInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ContactInfo", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("number", &self.number)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ContactInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "number",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Number,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "number" => Ok(GeneratedField::Number),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ContactInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ContactInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ContactInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut number__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Number => {
                            if number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("number"));
                            }
                            number__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ContactInfo {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    number: number__.ok_or_else(|| serde::de::Error::missing_field("number"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ContactInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for contact_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.current_segment.is_some() {
            len += 1;
        }
        if self.total_segment.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ContactInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.current_segment.as_ref() {
            struct_ser.serialize_field("currentSegment", v)?;
        }
        if let Some(v) = self.total_segment.as_ref() {
            struct_ser.serialize_field("totalSegment", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for contact_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "current_segment",
            "currentSegment",
            "total_segment",
            "totalSegment",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            CurrentSegment,
            TotalSegment,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "currentSegment" | "current_segment" => Ok(GeneratedField::CurrentSegment),
                            "totalSegment" | "total_segment" => Ok(GeneratedField::TotalSegment),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = contact_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ContactInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<contact_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut current_segment__ = None;
                let mut total_segment__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CurrentSegment => {
                            if current_segment__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentSegment"));
                            }
                            current_segment__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalSegment => {
                            if total_segment__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalSegment"));
                            }
                            total_segment__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(contact_info::List {
                    list: list__.unwrap_or_default(),
                    current_segment: current_segment__,
                    total_segment: total_segment__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ContactInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ControlResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ControlResult", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ControlResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ControlResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ControlResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ControlResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ControlResult {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ControlResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Course {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Course", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("id", ToString::to_string(&self.id).as_str())?;
        if let Some(v) = self.detail.as_ref() {
            struct_ser.serialize_field("detail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Course {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "id",
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "id" => Ok(GeneratedField::Id),
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Course;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Course")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Course, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(Course {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    detail: detail__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Course", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for course::Detail {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.duration.is_some() {
            len += 1;
        }
        if self.distance.is_some() {
            len += 1;
        }
        if !self.parts.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Course.Detail", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", v)?;
        }
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        struct_ser.serialize_field("description", &self.description)?;
        if !self.parts.is_empty() {
            struct_ser.serialize_field("parts", &self.parts)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for course::Detail {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "duration",
            "distance",
            "description",
            "parts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Duration,
            Distance,
            Description,
            Parts,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "duration" => Ok(GeneratedField::Duration),
                            "distance" => Ok(GeneratedField::Distance),
                            "description" => Ok(GeneratedField::Description),
                            "parts" => Ok(GeneratedField::Parts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = course::Detail;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Course.Detail")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<course::Detail, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut duration__ = None;
                let mut distance__ = None;
                let mut description__ = None;
                let mut parts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Parts => {
                            if parts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parts"));
                            }
                            parts__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(course::Detail {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    duration: duration__,
                    distance: distance__,
                    description: description__.ok_or_else(|| serde::de::Error::missing_field("description"))?,
                    parts: parts__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Course.Detail", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for course::Part {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.target.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Course.Part", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        if let Some(v) = self.target.as_ref() {
            struct_ser.serialize_field("target", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for course::Part {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "duration",
            "target",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Duration,
            Target,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "duration" => Ok(GeneratedField::Duration),
                            "target" => Ok(GeneratedField::Target),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = course::Part;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Course.Part")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<course::Part, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut duration__ = None;
                let mut target__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("target"));
                            }
                            target__ = map_.next_value()?;
                        }
                    }
                }
                Ok(course::Part {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    target: target__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Course.Part", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for course::Target {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.value2.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Course.Target", len)?;
        let v = SportTargetType::try_from(self.target_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.target_type)))?;
        struct_ser.serialize_field("targetType", &v)?;
        struct_ser.serialize_field("value1", &self.value1)?;
        if let Some(v) = self.value2.as_ref() {
            struct_ser.serialize_field("value2", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for course::Target {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "target_type",
            "targetType",
            "value1",
            "value2",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetType,
            Value1,
            Value2,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "targetType" | "target_type" => Ok(GeneratedField::TargetType),
                            "value1" => Ok(GeneratedField::Value1),
                            "value2" => Ok(GeneratedField::Value2),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = course::Target;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Course.Target")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<course::Target, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_type__ = None;
                let mut value1__ = None;
                let mut value2__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetType => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetType"));
                            }
                            target_type__ = Some(map_.next_value::<SportTargetType>()? as i32);
                        }
                        GeneratedField::Value1 => {
                            if value1__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value1"));
                            }
                            value1__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Value2 => {
                            if value2__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value2"));
                            }
                            value2__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(course::Target {
                    target_type: target_type__.ok_or_else(|| serde::de::Error::missing_field("targetType"))?,
                    value1: value1__.ok_or_else(|| serde::de::Error::missing_field("value1"))?,
                    value2: value2__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Course.Target", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CourseTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.section_list.is_empty() {
            len += 1;
        }
        if !self.course_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CourseTable", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("timestamp", ToString::to_string(&self.timestamp).as_str())?;
        struct_ser.serialize_field("weekNumber", &self.week_number)?;
        if !self.section_list.is_empty() {
            struct_ser.serialize_field("sectionList", &self.section_list)?;
        }
        if !self.course_list.is_empty() {
            struct_ser.serialize_field("courseList", &self.course_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CourseTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "week_number",
            "weekNumber",
            "section_list",
            "sectionList",
            "course_list",
            "courseList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            WeekNumber,
            SectionList,
            CourseList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "weekNumber" | "week_number" => Ok(GeneratedField::WeekNumber),
                            "sectionList" | "section_list" => Ok(GeneratedField::SectionList),
                            "courseList" | "course_list" => Ok(GeneratedField::CourseList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CourseTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CourseTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CourseTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut week_number__ = None;
                let mut section_list__ = None;
                let mut course_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::WeekNumber => {
                            if week_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekNumber"));
                            }
                            week_number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SectionList => {
                            if section_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sectionList"));
                            }
                            section_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CourseList => {
                            if course_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("courseList"));
                            }
                            course_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CourseTable {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    week_number: week_number__.ok_or_else(|| serde::de::Error::missing_field("weekNumber"))?,
                    section_list: section_list__.unwrap_or_default(),
                    course_list: course_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.CourseTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for course_table::Course {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 6;
        let mut struct_ser = serializer.serialize_struct("protocol.CourseTable.Course", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("weeks", &self.weeks)?;
        struct_ser.serialize_field("days", &self.days)?;
        struct_ser.serialize_field("sections", &self.sections)?;
        struct_ser.serialize_field("teacher", &self.teacher)?;
        struct_ser.serialize_field("location", &self.location)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for course_table::Course {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "weeks",
            "days",
            "sections",
            "teacher",
            "location",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Weeks,
            Days,
            Sections,
            Teacher,
            Location,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "weeks" => Ok(GeneratedField::Weeks),
                            "days" => Ok(GeneratedField::Days),
                            "sections" => Ok(GeneratedField::Sections),
                            "teacher" => Ok(GeneratedField::Teacher),
                            "location" => Ok(GeneratedField::Location),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = course_table::Course;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CourseTable.Course")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<course_table::Course, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut weeks__ = None;
                let mut days__ = None;
                let mut sections__ = None;
                let mut teacher__ = None;
                let mut location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Weeks => {
                            if weeks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weeks"));
                            }
                            weeks__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Days => {
                            if days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("days"));
                            }
                            days__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Sections => {
                            if sections__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sections"));
                            }
                            sections__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Teacher => {
                            if teacher__.is_some() {
                                return Err(serde::de::Error::duplicate_field("teacher"));
                            }
                            teacher__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(course_table::Course {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    weeks: weeks__.ok_or_else(|| serde::de::Error::missing_field("weeks"))?,
                    days: days__.ok_or_else(|| serde::de::Error::missing_field("days"))?,
                    sections: sections__.ok_or_else(|| serde::de::Error::missing_field("sections"))?,
                    teacher: teacher__.ok_or_else(|| serde::de::Error::missing_field("teacher"))?,
                    location: location__.ok_or_else(|| serde::de::Error::missing_field("location"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CourseTable.Course", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for course_table::Section {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.CourseTable.Section", len)?;
        struct_ser.serialize_field("startTime", &self.start_time)?;
        struct_ser.serialize_field("endTime", &self.end_time)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for course_table::Section {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "start_time",
            "startTime",
            "end_time",
            "endTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StartTime,
            EndTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "startTime" | "start_time" => Ok(GeneratedField::StartTime),
                            "endTime" | "end_time" => Ok(GeneratedField::EndTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = course_table::Section;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CourseTable.Section")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<course_table::Section, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut start_time__ = None;
                let mut end_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = map_.next_value()?;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endTime"));
                            }
                            end_time__ = map_.next_value()?;
                        }
                    }
                }
                Ok(course_table::Section {
                    start_time: start_time__.ok_or_else(|| serde::de::Error::missing_field("startTime"))?,
                    end_time: end_time__.ok_or_else(|| serde::de::Error::missing_field("endTime"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CourseTable.Section", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CourseZone {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.CourseZone", len)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CourseZone {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CourseZone;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CourseZone")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CourseZone, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CourseZone {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CourseZone", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CrackCardData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.crack_sectors.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.CrackCardData", len)?;
        struct_ser.serialize_field("basicCardData", &self.basic_card_data)?;
        if !self.crack_sectors.is_empty() {
            struct_ser.serialize_field("crackSectors", &self.crack_sectors)?;
        }
        struct_ser.serialize_field("costTime", &self.cost_time)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CrackCardData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_card_data",
            "basicCardData",
            "crack_sectors",
            "crackSectors",
            "cost_time",
            "costTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicCardData,
            CrackSectors,
            CostTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicCardData" | "basic_card_data" => Ok(GeneratedField::BasicCardData),
                            "crackSectors" | "crack_sectors" => Ok(GeneratedField::CrackSectors),
                            "costTime" | "cost_time" => Ok(GeneratedField::CostTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CrackCardData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CrackCardData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CrackCardData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_card_data__ = None;
                let mut crack_sectors__ = None;
                let mut cost_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicCardData => {
                            if basic_card_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicCardData"));
                            }
                            basic_card_data__ = map_.next_value()?;
                        }
                        GeneratedField::CrackSectors => {
                            if crack_sectors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("crackSectors"));
                            }
                            crack_sectors__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CostTime => {
                            if cost_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("costTime"));
                            }
                            cost_time__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CrackCardData {
                    basic_card_data: basic_card_data__.ok_or_else(|| serde::de::Error::missing_field("basicCardData"))?,
                    crack_sectors: crack_sectors__.unwrap_or_default(),
                    cost_time: cost_time__.ok_or_else(|| serde::de::Error::missing_field("costTime"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CrackCardData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CrackSector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.CrackSector", len)?;
        struct_ser.serialize_field("sector", &self.sector)?;
        struct_ser.serialize_field("keyIndex", &self.key_index)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CrackSector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sector",
            "key_index",
            "keyIndex",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sector,
            KeyIndex,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sector" => Ok(GeneratedField::Sector),
                            "keyIndex" | "key_index" => Ok(GeneratedField::KeyIndex),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CrackSector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.CrackSector")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CrackSector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sector__ = None;
                let mut key_index__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sector => {
                            if sector__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sector"));
                            }
                            sector__ = map_.next_value()?;
                        }
                        GeneratedField::KeyIndex => {
                            if key_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyIndex"));
                            }
                            key_index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(CrackSector {
                    sector: sector__.ok_or_else(|| serde::de::Error::missing_field("sector"))?,
                    key_index: key_index__.ok_or_else(|| serde::de::Error::missing_field("keyIndex"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.CrackSector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.days.is_some() {
            len += 1;
        }
        if self.need_gps_info.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Data", len)?;
        let v = data::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("source", &self.source)?;
        if let Some(v) = self.days.as_ref() {
            struct_ser.serialize_field("days", v)?;
        }
        if let Some(v) = self.need_gps_info.as_ref() {
            struct_ser.serialize_field("needGpsInfo", v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "source",
            "days",
            "need_gps_info",
            "needGpsInfo",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Source,
            Days,
            NeedGpsInfo,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "source" => Ok(GeneratedField::Source),
                            "days" => Ok(GeneratedField::Days),
                            "needGpsInfo" | "need_gps_info" => Ok(GeneratedField::NeedGpsInfo),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut source__ = None;
                let mut days__ = None;
                let mut need_gps_info__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<data::Type>()? as i32);
                        }
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Days => {
                            if days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("days"));
                            }
                            days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NeedGpsInfo => {
                            if need_gps_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needGpsInfo"));
                            }
                            need_gps_info__ = map_.next_value()?;
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Data {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    source: source__.ok_or_else(|| serde::de::Error::missing_field("source"))?,
                    days: days__,
                    need_gps_info: need_gps_info__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for data::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Agps => "AGPS",
            Self::Beidou => "BEIDOU",
            Self::Galileo => "GALILEO",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for data::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AGPS",
            "BEIDOU",
            "GALILEO",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = data::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AGPS" => Ok(data::Type::Agps),
                    "BEIDOU" => Ok(data::Type::Beidou),
                    "GALILEO" => Ok(data::Type::Galileo),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Date {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.Date", len)?;
        struct_ser.serialize_field("year", &self.year)?;
        struct_ser.serialize_field("month", &self.month)?;
        struct_ser.serialize_field("day", &self.day)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Date {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "year",
            "month",
            "day",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Year,
            Month,
            Day,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "year" => Ok(GeneratedField::Year),
                            "month" => Ok(GeneratedField::Month),
                            "day" => Ok(GeneratedField::Day),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Date;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Date")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Date, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut year__ = None;
                let mut month__ = None;
                let mut day__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Year => {
                            if year__.is_some() {
                                return Err(serde::de::Error::duplicate_field("year"));
                            }
                            year__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Month => {
                            if month__.is_some() {
                                return Err(serde::de::Error::duplicate_field("month"));
                            }
                            month__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Day => {
                            if day__.is_some() {
                                return Err(serde::de::Error::duplicate_field("day"));
                            }
                            day__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Date {
                    year: year__.ok_or_else(|| serde::de::Error::missing_field("year"))?,
                    month: month__.ok_or_else(|| serde::de::Error::missing_field("month"))?,
                    day: day__.ok_or_else(|| serde::de::Error::missing_field("day"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Date", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DeviceInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.DeviceInfo", len)?;
        struct_ser.serialize_field("serialNumber", &self.serial_number)?;
        struct_ser.serialize_field("firmwareVersion", &self.firmware_version)?;
        struct_ser.serialize_field("imei", &self.imei)?;
        struct_ser.serialize_field("model", &self.model)?;
        struct_ser.serialize_field("productDevice", &self.product_device)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DeviceInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "serial_number",
            "serialNumber",
            "firmware_version",
            "firmwareVersion",
            "imei",
            "model",
            "product_device",
            "productDevice",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SerialNumber,
            FirmwareVersion,
            Imei,
            Model,
            ProductDevice,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "serialNumber" | "serial_number" => Ok(GeneratedField::SerialNumber),
                            "firmwareVersion" | "firmware_version" => Ok(GeneratedField::FirmwareVersion),
                            "imei" => Ok(GeneratedField::Imei),
                            "model" => Ok(GeneratedField::Model),
                            "productDevice" | "product_device" => Ok(GeneratedField::ProductDevice),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeviceInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DeviceInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DeviceInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut serial_number__ = None;
                let mut firmware_version__ = None;
                let mut imei__ = None;
                let mut model__ = None;
                let mut product_device__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SerialNumber => {
                            if serial_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("serialNumber"));
                            }
                            serial_number__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FirmwareVersion => {
                            if firmware_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firmwareVersion"));
                            }
                            firmware_version__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Imei => {
                            if imei__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imei"));
                            }
                            imei__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Model => {
                            if model__.is_some() {
                                return Err(serde::de::Error::duplicate_field("model"));
                            }
                            model__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ProductDevice => {
                            if product_device__.is_some() {
                                return Err(serde::de::Error::duplicate_field("productDevice"));
                            }
                            product_device__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DeviceInfo {
                    serial_number: serial_number__.ok_or_else(|| serde::de::Error::missing_field("serialNumber"))?,
                    firmware_version: firmware_version__.ok_or_else(|| serde::de::Error::missing_field("firmwareVersion"))?,
                    imei: imei__.ok_or_else(|| serde::de::Error::missing_field("imei"))?,
                    model: model__.ok_or_else(|| serde::de::Error::missing_field("model"))?,
                    product_device: product_device__.ok_or_else(|| serde::de::Error::missing_field("productDevice"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.DeviceInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DeviceItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.DeviceItem", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DeviceItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeviceItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DeviceItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DeviceItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DeviceItem {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.DeviceItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for device_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.DeviceItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for device_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = device_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DeviceItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<device_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(device_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.DeviceItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DeviceStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.DeviceStatus", len)?;
        struct_ser.serialize_field("battery", &self.battery)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DeviceStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "battery",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Battery,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "battery" => Ok(GeneratedField::Battery),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeviceStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DeviceStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DeviceStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut battery__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Battery => {
                            if battery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("battery"));
                            }
                            battery__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DeviceStatus {
                    battery: battery__.ok_or_else(|| serde::de::Error::missing_field("battery"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.DeviceStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for device_status::Battery {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.charge_status.is_some() {
            len += 1;
        }
        if self.charge_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.DeviceStatus.Battery", len)?;
        struct_ser.serialize_field("capacity", &self.capacity)?;
        if let Some(v) = self.charge_status.as_ref() {
            let v = device_status::battery::ChargeStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("chargeStatus", &v)?;
        }
        if let Some(v) = self.charge_info.as_ref() {
            struct_ser.serialize_field("chargeInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for device_status::Battery {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "capacity",
            "charge_status",
            "chargeStatus",
            "charge_info",
            "chargeInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Capacity,
            ChargeStatus,
            ChargeInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "capacity" => Ok(GeneratedField::Capacity),
                            "chargeStatus" | "charge_status" => Ok(GeneratedField::ChargeStatus),
                            "chargeInfo" | "charge_info" => Ok(GeneratedField::ChargeInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = device_status::Battery;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DeviceStatus.Battery")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<device_status::Battery, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut capacity__ = None;
                let mut charge_status__ = None;
                let mut charge_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capacity"));
                            }
                            capacity__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ChargeStatus => {
                            if charge_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chargeStatus"));
                            }
                            charge_status__ = map_.next_value::<::std::option::Option<device_status::battery::ChargeStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ChargeInfo => {
                            if charge_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chargeInfo"));
                            }
                            charge_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(device_status::Battery {
                    capacity: capacity__.ok_or_else(|| serde::de::Error::missing_field("capacity"))?,
                    charge_status: charge_status__,
                    charge_info: charge_info__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.DeviceStatus.Battery", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for device_status::battery::ChargeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.DeviceStatus.Battery.ChargeInfo", len)?;
        struct_ser.serialize_field("state", &self.state)?;
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for device_status::battery::ChargeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "state",
            "timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = device_status::battery::ChargeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DeviceStatus.Battery.ChargeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<device_status::battery::ChargeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(device_status::battery::ChargeInfo {
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    timestamp: timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.DeviceStatus.Battery.ChargeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for device_status::battery::ChargeStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "UNKNOWN",
            Self::Charging => "CHARGING",
            Self::NotCharging => "NOT_CHARGING",
            Self::Full => "FULL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for device_status::battery::ChargeStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UNKNOWN",
            "CHARGING",
            "NOT_CHARGING",
            "FULL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = device_status::battery::ChargeStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UNKNOWN" => Ok(device_status::battery::ChargeStatus::Unknown),
                    "CHARGING" => Ok(device_status::battery::ChargeStatus::Charging),
                    "NOT_CHARGING" => Ok(device_status::battery::ChargeStatus::NotCharging),
                    "FULL" => Ok(device_status::battery::ChargeStatus::Full),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DeviceType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AndroidPhone => "ANDROID_PHONE",
            Self::AndroidPad => "ANDROID_PAD",
            Self::AndroidTv => "ANDROID_TV",
            Self::WindowsPc => "WINDOWS_PC",
            Self::Soundbox => "SOUNDBOX",
            Self::SoundboxScreen => "SOUNDBOX_SCREEN",
            Self::Headset => "HEADSET",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for DeviceType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ANDROID_PHONE",
            "ANDROID_PAD",
            "ANDROID_TV",
            "WINDOWS_PC",
            "SOUNDBOX",
            "SOUNDBOX_SCREEN",
            "HEADSET",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DeviceType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ANDROID_PHONE" => Ok(DeviceType::AndroidPhone),
                    "ANDROID_PAD" => Ok(DeviceType::AndroidPad),
                    "ANDROID_TV" => Ok(DeviceType::AndroidTv),
                    "WINDOWS_PC" => Ok(DeviceType::WindowsPc),
                    "SOUNDBOX" => Ok(DeviceType::Soundbox),
                    "SOUNDBOX_SCREEN" => Ok(DeviceType::SoundboxScreen),
                    "HEADSET" => Ok(DeviceType::Headset),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DownloadProgress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.DownloadProgress", len)?;
        struct_ser.serialize_field("progress", &self.progress)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DownloadProgress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "progress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Progress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "progress" => Ok(GeneratedField::Progress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DownloadProgress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.DownloadProgress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DownloadProgress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("progress"));
                            }
                            progress__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(DownloadProgress {
                    progress: progress__.ok_or_else(|| serde::de::Error::missing_field("progress"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.DownloadProgress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EcgActivation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.ECGActivation", len)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EcgActivation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EcgActivation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ECGActivation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EcgActivation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EcgActivation {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ECGActivation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EcgData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.heart_rate.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ECGData", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("samplingData", pbjson::private::base64::encode(&self.sampling_data).as_str())?;
        if let Some(v) = self.heart_rate.as_ref() {
            struct_ser.serialize_field("heartRate", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EcgData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sampling_data",
            "samplingData",
            "heart_rate",
            "heartRate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SamplingData,
            HeartRate,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "samplingData" | "sampling_data" => Ok(GeneratedField::SamplingData),
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EcgData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ECGData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EcgData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sampling_data__ = None;
                let mut heart_rate__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SamplingData => {
                            if sampling_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("samplingData"));
                            }
                            sampling_data__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EcgData {
                    sampling_data: sampling_data__.ok_or_else(|| serde::de::Error::missing_field("samplingData"))?,
                    heart_rate: heart_rate__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ECGData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EcgRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.expected_duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ECGRequest", len)?;
        let v = ecg_request::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        let v = ecg_request::State::try_from(self.state)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.state)))?;
        struct_ser.serialize_field("state", &v)?;
        if let Some(v) = self.expected_duration.as_ref() {
            struct_ser.serialize_field("expectedDuration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EcgRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "state",
            "expected_duration",
            "expectedDuration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            State,
            ExpectedDuration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "state" => Ok(GeneratedField::State),
                            "expectedDuration" | "expected_duration" => Ok(GeneratedField::ExpectedDuration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EcgRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ECGRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EcgRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut state__ = None;
                let mut expected_duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<ecg_request::Type>()? as i32);
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value::<ecg_request::State>()? as i32);
                        }
                        GeneratedField::ExpectedDuration => {
                            if expected_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedDuration"));
                            }
                            expected_duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EcgRequest {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    expected_duration: expected_duration__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ECGRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ecg_request::State {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Start => "START",
            Self::Stop => "STOP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ecg_request::State {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "START",
            "STOP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ecg_request::State;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "START" => Ok(ecg_request::State::Start),
                    "STOP" => Ok(ecg_request::State::Stop),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ecg_request::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Handheld => "HANDHELD",
            Self::Fitting => "FITTING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ecg_request::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HANDHELD",
            "FITTING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ecg_request::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "HANDHELD" => Ok(ecg_request::Type::Handheld),
                    "FITTING" => Ok(ecg_request::Type::Fitting),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EcgResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.ECGResponse", len)?;
        let v = ecg_response::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EcgResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EcgResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ECGResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EcgResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<ecg_response::Code>()? as i32);
                        }
                    }
                }
                Ok(EcgResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ECGResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ecg_response::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ready => "READY",
            Self::Busy => "BUSY",
            Self::FallOff => "FALL_OFF",
            Self::InSport => "IN_SPORT",
            Self::Charging => "CHARGING",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ecg_response::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "READY",
            "BUSY",
            "FALL_OFF",
            "IN_SPORT",
            "CHARGING",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ecg_response::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "READY" => Ok(ecg_response::Code::Ready),
                    "BUSY" => Ok(ecg_response::Code::Busy),
                    "FALL_OFF" => Ok(ecg_response::Code::FallOff),
                    "IN_SPORT" => Ok(ecg_response::Code::InSport),
                    "CHARGING" => Ok(ecg_response::Code::Charging),
                    "FAIL" => Ok(ecg_response::Code::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EcgStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.ECGStatus", len)?;
        let v = ecg_status::Status::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EcgStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EcgStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ECGStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EcgStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<ecg_status::Status>()? as i32);
                        }
                    }
                }
                Ok(EcgStatus {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ECGStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ecg_status::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::FallOff => "FALL_OFF",
            Self::WearOn => "WEAR_ON",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ecg_status::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FALL_OFF",
            "WEAR_ON",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ecg_status::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "FALL_OFF" => Ok(ecg_status::Status::FallOff),
                    "WEAR_ON" => Ok(ecg_status::Status::WearOn),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EditRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 5;
        if self.background_image_size.is_some() {
            len += 1;
        }
        if !self.data_list.is_empty() {
            len += 1;
        }
        if !self.background_image_list.is_empty() {
            len += 1;
        }
        if !self.background_image_size_list.is_empty() {
            len += 1;
        }
        if !self.order_image_list.is_empty() {
            len += 1;
        }
        if self.delete_all_images.is_some() {
            len += 1;
        }
        if !self.slot_item_list.is_empty() {
            len += 1;
        }
        if self.foreground_color.is_some() {
            len += 1;
        }
        if self.style_color_index.is_some() {
            len += 1;
        }
        if self.image_group_list.is_some() {
            len += 1;
        }
        if self.literal.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.EditRequest", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("setCurrent", &self.set_current)?;
        struct_ser.serialize_field("backgroundColor", &self.background_color)?;
        struct_ser.serialize_field("backgroundImage", &self.background_image)?;
        if let Some(v) = self.background_image_size.as_ref() {
            struct_ser.serialize_field("backgroundImageSize", v)?;
        }
        struct_ser.serialize_field("style", &self.style)?;
        if !self.data_list.is_empty() {
            let v = self.data_list.iter().cloned().map(|v| {
                watch_face_slot::Data::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("dataList", &v)?;
        }
        if !self.background_image_list.is_empty() {
            struct_ser.serialize_field("backgroundImageList", &self.background_image_list)?;
        }
        if !self.background_image_size_list.is_empty() {
            struct_ser.serialize_field("backgroundImageSizeList", &self.background_image_size_list)?;
        }
        if !self.order_image_list.is_empty() {
            struct_ser.serialize_field("orderImageList", &self.order_image_list)?;
        }
        if let Some(v) = self.delete_all_images.as_ref() {
            struct_ser.serialize_field("deleteAllImages", v)?;
        }
        if !self.slot_item_list.is_empty() {
            struct_ser.serialize_field("slotItemList", &self.slot_item_list)?;
        }
        if let Some(v) = self.foreground_color.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("foregroundColor", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.style_color_index.as_ref() {
            struct_ser.serialize_field("styleColorIndex", v)?;
        }
        if let Some(v) = self.image_group_list.as_ref() {
            struct_ser.serialize_field("imageGroupList", v)?;
        }
        if let Some(v) = self.literal.as_ref() {
            struct_ser.serialize_field("literal", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EditRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "set_current",
            "setCurrent",
            "background_color",
            "backgroundColor",
            "background_image",
            "backgroundImage",
            "background_image_size",
            "backgroundImageSize",
            "style",
            "data_list",
            "dataList",
            "background_image_list",
            "backgroundImageList",
            "background_image_size_list",
            "backgroundImageSizeList",
            "order_image_list",
            "orderImageList",
            "delete_all_images",
            "deleteAllImages",
            "slot_item_list",
            "slotItemList",
            "foreground_color",
            "foregroundColor",
            "style_color_index",
            "styleColorIndex",
            "image_group_list",
            "imageGroupList",
            "literal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            SetCurrent,
            BackgroundColor,
            BackgroundImage,
            BackgroundImageSize,
            Style,
            DataList,
            BackgroundImageList,
            BackgroundImageSizeList,
            OrderImageList,
            DeleteAllImages,
            SlotItemList,
            ForegroundColor,
            StyleColorIndex,
            ImageGroupList,
            Literal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "setCurrent" | "set_current" => Ok(GeneratedField::SetCurrent),
                            "backgroundColor" | "background_color" => Ok(GeneratedField::BackgroundColor),
                            "backgroundImage" | "background_image" => Ok(GeneratedField::BackgroundImage),
                            "backgroundImageSize" | "background_image_size" => Ok(GeneratedField::BackgroundImageSize),
                            "style" => Ok(GeneratedField::Style),
                            "dataList" | "data_list" => Ok(GeneratedField::DataList),
                            "backgroundImageList" | "background_image_list" => Ok(GeneratedField::BackgroundImageList),
                            "backgroundImageSizeList" | "background_image_size_list" => Ok(GeneratedField::BackgroundImageSizeList),
                            "orderImageList" | "order_image_list" => Ok(GeneratedField::OrderImageList),
                            "deleteAllImages" | "delete_all_images" => Ok(GeneratedField::DeleteAllImages),
                            "slotItemList" | "slot_item_list" => Ok(GeneratedField::SlotItemList),
                            "foregroundColor" | "foreground_color" => Ok(GeneratedField::ForegroundColor),
                            "styleColorIndex" | "style_color_index" => Ok(GeneratedField::StyleColorIndex),
                            "imageGroupList" | "image_group_list" => Ok(GeneratedField::ImageGroupList),
                            "literal" => Ok(GeneratedField::Literal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EditRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.EditRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EditRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut set_current__ = None;
                let mut background_color__ = None;
                let mut background_image__ = None;
                let mut background_image_size__ = None;
                let mut style__ = None;
                let mut data_list__ = None;
                let mut background_image_list__ = None;
                let mut background_image_size_list__ = None;
                let mut order_image_list__ = None;
                let mut delete_all_images__ = None;
                let mut slot_item_list__ = None;
                let mut foreground_color__ = None;
                let mut style_color_index__ = None;
                let mut image_group_list__ = None;
                let mut literal__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SetCurrent => {
                            if set_current__.is_some() {
                                return Err(serde::de::Error::duplicate_field("setCurrent"));
                            }
                            set_current__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BackgroundColor => {
                            if background_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundColor"));
                            }
                            background_color__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BackgroundImage => {
                            if background_image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImage"));
                            }
                            background_image__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BackgroundImageSize => {
                            if background_image_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImageSize"));
                            }
                            background_image_size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Style => {
                            if style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("style"));
                            }
                            style__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DataList => {
                            if data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataList"));
                            }
                            data_list__ = Some(map_.next_value::<Vec<watch_face_slot::Data>>()?.into_iter().map(|x| x as i32).collect());
                        }
                        GeneratedField::BackgroundImageList => {
                            if background_image_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImageList"));
                            }
                            background_image_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BackgroundImageSizeList => {
                            if background_image_size_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImageSizeList"));
                            }
                            background_image_size_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::OrderImageList => {
                            if order_image_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("orderImageList"));
                            }
                            order_image_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DeleteAllImages => {
                            if delete_all_images__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deleteAllImages"));
                            }
                            delete_all_images__ = map_.next_value()?;
                        }
                        GeneratedField::SlotItemList => {
                            if slot_item_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("slotItemList"));
                            }
                            slot_item_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ForegroundColor => {
                            if foreground_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("foregroundColor"));
                            }
                            foreground_color__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StyleColorIndex => {
                            if style_color_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("styleColorIndex"));
                            }
                            style_color_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ImageGroupList => {
                            if image_group_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageGroupList"));
                            }
                            image_group_list__ = map_.next_value()?;
                        }
                        GeneratedField::Literal => {
                            if literal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("literal"));
                            }
                            literal__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EditRequest {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    set_current: set_current__.ok_or_else(|| serde::de::Error::missing_field("setCurrent"))?,
                    background_color: background_color__.ok_or_else(|| serde::de::Error::missing_field("backgroundColor"))?,
                    background_image: background_image__.ok_or_else(|| serde::de::Error::missing_field("backgroundImage"))?,
                    background_image_size: background_image_size__,
                    style: style__.ok_or_else(|| serde::de::Error::missing_field("style"))?,
                    data_list: data_list__.unwrap_or_default(),
                    background_image_list: background_image_list__.unwrap_or_default(),
                    background_image_size_list: background_image_size_list__.unwrap_or_default(),
                    order_image_list: order_image_list__.unwrap_or_default(),
                    delete_all_images: delete_all_images__,
                    slot_item_list: slot_item_list__.unwrap_or_default(),
                    foreground_color: foreground_color__,
                    style_color_index: style_color_index__,
                    image_group_list: image_group_list__,
                    literal: literal__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.EditRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EditResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.can_accept_image_count.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.EditResponse", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        let v = edit_response::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.can_accept_image_count.as_ref() {
            struct_ser.serialize_field("canAcceptImageCount", v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EditResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "code",
            "can_accept_image_count",
            "canAcceptImageCount",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Code,
            CanAcceptImageCount,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "code" => Ok(GeneratedField::Code),
                            "canAcceptImageCount" | "can_accept_image_count" => Ok(GeneratedField::CanAcceptImageCount),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EditResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.EditResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EditResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut code__ = None;
                let mut can_accept_image_count__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<edit_response::Code>()? as i32);
                        }
                        GeneratedField::CanAcceptImageCount => {
                            if can_accept_image_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canAcceptImageCount"));
                            }
                            can_accept_image_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EditResponse {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    can_accept_image_count: can_accept_image_count__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.EditResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for edit_response::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Success => "SUCCESS",
            Self::SuccessButLowStorage => "SUCCESS_BUT_LOW_STORAGE",
            Self::FailForLowStorage => "FAIL_FOR_LOW_STORAGE",
            Self::FailForInvalidParam => "FAIL_FOR_INVALID_PARAM",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for edit_response::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUCCESS",
            "SUCCESS_BUT_LOW_STORAGE",
            "FAIL_FOR_LOW_STORAGE",
            "FAIL_FOR_INVALID_PARAM",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = edit_response::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUCCESS" => Ok(edit_response::Code::Success),
                    "SUCCESS_BUT_LOW_STORAGE" => Ok(edit_response::Code::SuccessButLowStorage),
                    "FAIL_FOR_LOW_STORAGE" => Ok(edit_response::Code::FailForLowStorage),
                    "FAIL_FOR_INVALID_PARAM" => Ok(edit_response::Code::FailForInvalidParam),
                    "FAIL" => Ok(edit_response::Code::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EmergencyContact {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.contact_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.EmergencyContact", len)?;
        struct_ser.serialize_field("enabled", &self.enabled)?;
        if let Some(v) = self.contact_info.as_ref() {
            struct_ser.serialize_field("contactInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EmergencyContact {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enabled",
            "contact_info",
            "contactInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Enabled,
            ContactInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enabled" => Ok(GeneratedField::Enabled),
                            "contactInfo" | "contact_info" => Ok(GeneratedField::ContactInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EmergencyContact;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.EmergencyContact")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EmergencyContact, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enabled__ = None;
                let mut contact_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Enabled => {
                            if enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enabled"));
                            }
                            enabled__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ContactInfo => {
                            if contact_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contactInfo"));
                            }
                            contact_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EmergencyContact {
                    enabled: enabled__.ok_or_else(|| serde::de::Error::missing_field("enabled"))?,
                    contact_info: contact_info__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.EmergencyContact", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ErrorCode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoError => "NO_ERROR",
            Self::NotSupport => "NOT_SUPPORT",
            Self::DependencyNotReady => "DEPENDENCY_NOT_READY",
            Self::SetFailed => "SET_FAILED",
            Self::ParamError => "PARAM_ERROR",
            Self::BusyInOta => "BUSY_IN_OTA",
            Self::BusyInUploadLog => "BUSY_IN_UPLOAD_LOG",
            Self::BusyInA2dp => "BUSY_IN_A2DP",
            Self::Unknown => "UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ErrorCode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_ERROR",
            "NOT_SUPPORT",
            "DEPENDENCY_NOT_READY",
            "SET_FAILED",
            "PARAM_ERROR",
            "BUSY_IN_OTA",
            "BUSY_IN_UPLOAD_LOG",
            "BUSY_IN_A2DP",
            "UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ErrorCode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_ERROR" => Ok(ErrorCode::NoError),
                    "NOT_SUPPORT" => Ok(ErrorCode::NotSupport),
                    "DEPENDENCY_NOT_READY" => Ok(ErrorCode::DependencyNotReady),
                    "SET_FAILED" => Ok(ErrorCode::SetFailed),
                    "PARAM_ERROR" => Ok(ErrorCode::ParamError),
                    "BUSY_IN_OTA" => Ok(ErrorCode::BusyInOta),
                    "BUSY_IN_UPLOAD_LOG" => Ok(ErrorCode::BusyInUploadLog),
                    "BUSY_IN_A2DP" => Ok(ErrorCode::BusyInA2dp),
                    "UNKNOWN" => Ok(ErrorCode::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EuiccInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.EuiccInfo", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("eid", pbjson::private::base64::encode(&self.eid).as_str())?;
        struct_ser.serialize_field("imei", &self.imei)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EuiccInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "eid",
            "imei",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Eid,
            Imei,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "eid" => Ok(GeneratedField::Eid),
                            "imei" => Ok(GeneratedField::Imei),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EuiccInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.EuiccInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EuiccInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut eid__ = None;
                let mut imei__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Eid => {
                            if eid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eid"));
                            }
                            eid__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Imei => {
                            if imei__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imei"));
                            }
                            imei__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EuiccInfo {
                    eid: eid__.ok_or_else(|| serde::de::Error::missing_field("eid"))?,
                    imei: imei__.ok_or_else(|| serde::de::Error::missing_field("imei"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.EuiccInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecuteDeviceSkill {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.ExecuteDeviceSkill", len)?;
        struct_ser.serialize_field("intent", &self.intent)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecuteDeviceSkill {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "intent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Intent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "intent" => Ok(GeneratedField::Intent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecuteDeviceSkill;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ExecuteDeviceSkill")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecuteDeviceSkill, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut intent__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Intent => {
                            if intent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intent"));
                            }
                            intent__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ExecuteDeviceSkill {
                    intent: intent__.ok_or_else(|| serde::de::Error::missing_field("intent"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ExecuteDeviceSkill", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Factory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Factory", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                factory::Payload::Mode(v) => {
                    let v = FactoryMode::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("mode", &v)?;
                }
                factory::Payload::NfcList(v) => {
                    struct_ser.serialize_field("nfcList", v)?;
                }
                factory::Payload::File(v) => {
                    struct_ser.serialize_field("file", v)?;
                }
                factory::Payload::ImageRequest(v) => {
                    struct_ser.serialize_field("imageRequest", v)?;
                }
                factory::Payload::ImageResponse(v) => {
                    struct_ser.serialize_field("imageResponse", v)?;
                }
                factory::Payload::Brightness(v) => {
                    struct_ser.serialize_field("brightness", v)?;
                }
                factory::Payload::SelfCheckingRequest(v) => {
                    struct_ser.serialize_field("selfCheckingRequest", v)?;
                }
                factory::Payload::SelfCheckingResponse(v) => {
                    struct_ser.serialize_field("selfCheckingResponse", v)?;
                }
                factory::Payload::SelfCheckingResult(v) => {
                    struct_ser.serialize_field("selfCheckingResult", v)?;
                }
                factory::Payload::SensorCaptureRequest(v) => {
                    struct_ser.serialize_field("sensorCaptureRequest", v)?;
                }
                factory::Payload::SensorCaptureResponse(v) => {
                    struct_ser.serialize_field("sensorCaptureResponse", v)?;
                }
                factory::Payload::SensorConfirmRequest(v) => {
                    struct_ser.serialize_field("sensorConfirmRequest", v)?;
                }
                factory::Payload::SensorConfirmResponse(v) => {
                    struct_ser.serialize_field("sensorConfirmResponse", v)?;
                }
                factory::Payload::AppInfoList(v) => {
                    struct_ser.serialize_field("appInfoList", v)?;
                }
                factory::Payload::AppBehavior(v) => {
                    struct_ser.serialize_field("appBehavior", v)?;
                }
                factory::Payload::SensorReplayRequest(v) => {
                    struct_ser.serialize_field("sensorReplayRequest", v)?;
                }
                factory::Payload::SensorReplayResponse(v) => {
                    struct_ser.serialize_field("sensorReplayResponse", v)?;
                }
                factory::Payload::SelfCheckingStepRequest(v) => {
                    struct_ser.serialize_field("selfCheckingStepRequest", v)?;
                }
                factory::Payload::SelfCheckingStepResult(v) => {
                    struct_ser.serialize_field("selfCheckingStepResult", v)?;
                }
                factory::Payload::Attp(v) => {
                    struct_ser.serialize_field("attp", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Factory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mode",
            "nfc_list",
            "nfcList",
            "file",
            "image_request",
            "imageRequest",
            "image_response",
            "imageResponse",
            "brightness",
            "self_checking_request",
            "selfCheckingRequest",
            "self_checking_response",
            "selfCheckingResponse",
            "self_checking_result",
            "selfCheckingResult",
            "sensor_capture_request",
            "sensorCaptureRequest",
            "sensor_capture_response",
            "sensorCaptureResponse",
            "sensor_confirm_request",
            "sensorConfirmRequest",
            "sensor_confirm_response",
            "sensorConfirmResponse",
            "app_info_list",
            "appInfoList",
            "app_behavior",
            "appBehavior",
            "sensor_replay_request",
            "sensorReplayRequest",
            "sensor_replay_response",
            "sensorReplayResponse",
            "self_checking_step_request",
            "selfCheckingStepRequest",
            "self_checking_step_result",
            "selfCheckingStepResult",
            "attp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mode,
            NfcList,
            File,
            ImageRequest,
            ImageResponse,
            Brightness,
            SelfCheckingRequest,
            SelfCheckingResponse,
            SelfCheckingResult,
            SensorCaptureRequest,
            SensorCaptureResponse,
            SensorConfirmRequest,
            SensorConfirmResponse,
            AppInfoList,
            AppBehavior,
            SensorReplayRequest,
            SensorReplayResponse,
            SelfCheckingStepRequest,
            SelfCheckingStepResult,
            Attp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mode" => Ok(GeneratedField::Mode),
                            "nfcList" | "nfc_list" => Ok(GeneratedField::NfcList),
                            "file" => Ok(GeneratedField::File),
                            "imageRequest" | "image_request" => Ok(GeneratedField::ImageRequest),
                            "imageResponse" | "image_response" => Ok(GeneratedField::ImageResponse),
                            "brightness" => Ok(GeneratedField::Brightness),
                            "selfCheckingRequest" | "self_checking_request" => Ok(GeneratedField::SelfCheckingRequest),
                            "selfCheckingResponse" | "self_checking_response" => Ok(GeneratedField::SelfCheckingResponse),
                            "selfCheckingResult" | "self_checking_result" => Ok(GeneratedField::SelfCheckingResult),
                            "sensorCaptureRequest" | "sensor_capture_request" => Ok(GeneratedField::SensorCaptureRequest),
                            "sensorCaptureResponse" | "sensor_capture_response" => Ok(GeneratedField::SensorCaptureResponse),
                            "sensorConfirmRequest" | "sensor_confirm_request" => Ok(GeneratedField::SensorConfirmRequest),
                            "sensorConfirmResponse" | "sensor_confirm_response" => Ok(GeneratedField::SensorConfirmResponse),
                            "appInfoList" | "app_info_list" => Ok(GeneratedField::AppInfoList),
                            "appBehavior" | "app_behavior" => Ok(GeneratedField::AppBehavior),
                            "sensorReplayRequest" | "sensor_replay_request" => Ok(GeneratedField::SensorReplayRequest),
                            "sensorReplayResponse" | "sensor_replay_response" => Ok(GeneratedField::SensorReplayResponse),
                            "selfCheckingStepRequest" | "self_checking_step_request" => Ok(GeneratedField::SelfCheckingStepRequest),
                            "selfCheckingStepResult" | "self_checking_step_result" => Ok(GeneratedField::SelfCheckingStepResult),
                            "attp" => Ok(GeneratedField::Attp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Factory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Factory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Factory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<FactoryMode>>()?.map(|x| factory::Payload::Mode(x as i32));
                        }
                        GeneratedField::NfcList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nfcList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::NfcList)
;
                        }
                        GeneratedField::File => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("file"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::File)
;
                        }
                        GeneratedField::ImageRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::ImageRequest)
;
                        }
                        GeneratedField::ImageResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::ImageResponse)
;
                        }
                        GeneratedField::Brightness => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("brightness"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| factory::Payload::Brightness(x.0));
                        }
                        GeneratedField::SelfCheckingRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selfCheckingRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SelfCheckingRequest)
;
                        }
                        GeneratedField::SelfCheckingResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selfCheckingResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SelfCheckingResponse)
;
                        }
                        GeneratedField::SelfCheckingResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selfCheckingResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SelfCheckingResult)
;
                        }
                        GeneratedField::SensorCaptureRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorCaptureRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SensorCaptureRequest)
;
                        }
                        GeneratedField::SensorCaptureResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorCaptureResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SensorCaptureResponse)
;
                        }
                        GeneratedField::SensorConfirmRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorConfirmRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SensorConfirmRequest)
;
                        }
                        GeneratedField::SensorConfirmResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorConfirmResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SensorConfirmResponse)
;
                        }
                        GeneratedField::AppInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::AppInfoList)
;
                        }
                        GeneratedField::AppBehavior => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appBehavior"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::AppBehavior)
;
                        }
                        GeneratedField::SensorReplayRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorReplayRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SensorReplayRequest)
;
                        }
                        GeneratedField::SensorReplayResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorReplayResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SensorReplayResponse)
;
                        }
                        GeneratedField::SelfCheckingStepRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selfCheckingStepRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SelfCheckingStepRequest)
;
                        }
                        GeneratedField::SelfCheckingStepResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selfCheckingStepResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::SelfCheckingStepResult)
;
                        }
                        GeneratedField::Attp => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("attp"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(factory::Payload::Attp);
                        }
                    }
                }
                Ok(Factory {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Factory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for factory::FactoryId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SetMode => "SET_MODE",
            Self::GetMode => "GET_MODE",
            Self::ConfigNfc => "CONFIG_NFC",
            Self::DumpFile => "DUMP_FILE",
            Self::PreviewImage => "PREVIEW_IMAGE",
            Self::DumpMedia => "DUMP_MEDIA",
            Self::SetBrightness => "SET_BRIGHTNESS",
            Self::SelfCheckingRequest => "SELF_CHECKING_REQUEST",
            Self::ReportSelfCheckingResult => "REPORT_SELF_CHECKING_RESULT",
            Self::SelfCheckingStepRequest => "SELF_CHECKING_STEP_REQUEST",
            Self::ReportSelfCheckingStepResult => "REPORT_SELF_CHECKING_STEP_RESULT",
            Self::SensorCaptureRequest => "SENSOR_CAPTURE_REQUEST",
            Self::SensorConfirmRequest => "SENSOR_CONFIRM_REQUEST",
            Self::SensorReplayRequest => "SENSOR_REPLAY_REQUEST",
            Self::GetAppInfoList => "GET_APP_INFO_LIST",
            Self::SubscribeAppBehavior => "SUBSCRIBE_APP_BEHAVIOR",
            Self::UnsubscribeAppBehavior => "UNSUBSCRIBE_APP_BEHAVIOR",
            Self::ReportAppBehavior => "REPORT_APP_BEHAVIOR",
            Self::SetAttp => "SET_ATTP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for factory::FactoryId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_MODE",
            "GET_MODE",
            "CONFIG_NFC",
            "DUMP_FILE",
            "PREVIEW_IMAGE",
            "DUMP_MEDIA",
            "SET_BRIGHTNESS",
            "SELF_CHECKING_REQUEST",
            "REPORT_SELF_CHECKING_RESULT",
            "SELF_CHECKING_STEP_REQUEST",
            "REPORT_SELF_CHECKING_STEP_RESULT",
            "SENSOR_CAPTURE_REQUEST",
            "SENSOR_CONFIRM_REQUEST",
            "SENSOR_REPLAY_REQUEST",
            "GET_APP_INFO_LIST",
            "SUBSCRIBE_APP_BEHAVIOR",
            "UNSUBSCRIBE_APP_BEHAVIOR",
            "REPORT_APP_BEHAVIOR",
            "SET_ATTP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = factory::FactoryId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_MODE" => Ok(factory::FactoryId::SetMode),
                    "GET_MODE" => Ok(factory::FactoryId::GetMode),
                    "CONFIG_NFC" => Ok(factory::FactoryId::ConfigNfc),
                    "DUMP_FILE" => Ok(factory::FactoryId::DumpFile),
                    "PREVIEW_IMAGE" => Ok(factory::FactoryId::PreviewImage),
                    "DUMP_MEDIA" => Ok(factory::FactoryId::DumpMedia),
                    "SET_BRIGHTNESS" => Ok(factory::FactoryId::SetBrightness),
                    "SELF_CHECKING_REQUEST" => Ok(factory::FactoryId::SelfCheckingRequest),
                    "REPORT_SELF_CHECKING_RESULT" => Ok(factory::FactoryId::ReportSelfCheckingResult),
                    "SELF_CHECKING_STEP_REQUEST" => Ok(factory::FactoryId::SelfCheckingStepRequest),
                    "REPORT_SELF_CHECKING_STEP_RESULT" => Ok(factory::FactoryId::ReportSelfCheckingStepResult),
                    "SENSOR_CAPTURE_REQUEST" => Ok(factory::FactoryId::SensorCaptureRequest),
                    "SENSOR_CONFIRM_REQUEST" => Ok(factory::FactoryId::SensorConfirmRequest),
                    "SENSOR_REPLAY_REQUEST" => Ok(factory::FactoryId::SensorReplayRequest),
                    "GET_APP_INFO_LIST" => Ok(factory::FactoryId::GetAppInfoList),
                    "SUBSCRIBE_APP_BEHAVIOR" => Ok(factory::FactoryId::SubscribeAppBehavior),
                    "UNSUBSCRIBE_APP_BEHAVIOR" => Ok(factory::FactoryId::UnsubscribeAppBehavior),
                    "REPORT_APP_BEHAVIOR" => Ok(factory::FactoryId::ReportAppBehavior),
                    "SET_ATTP" => Ok(factory::FactoryId::SetAttp),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for FactoryMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::User => "USER",
            Self::Userdebug => "USERDEBUG",
            Self::Eng => "ENG",
            Self::SeleChecking => "SELE_CHECKING",
            Self::MedicalMeter => "MEDICAL_METER",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for FactoryMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "USER",
            "USERDEBUG",
            "ENG",
            "SELE_CHECKING",
            "MEDICAL_METER",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FactoryMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "USER" => Ok(FactoryMode::User),
                    "USERDEBUG" => Ok(FactoryMode::Userdebug),
                    "ENG" => Ok(FactoryMode::Eng),
                    "SELE_CHECKING" => Ok(FactoryMode::SeleChecking),
                    "MEDICAL_METER" => Ok(FactoryMode::MedicalMeter),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for FileInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.FileInfo", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("isAppend", &self.is_append)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("data", pbjson::private::base64::encode(&self.data).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FileInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "is_append",
            "isAppend",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            IsAppend,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "isAppend" | "is_append" => Ok(GeneratedField::IsAppend),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FileInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.FileInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FileInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut is_append__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsAppend => {
                            if is_append__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isAppend"));
                            }
                            is_append__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(FileInfo {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    is_append: is_append__.ok_or_else(|| serde::de::Error::missing_field("isAppend"))?,
                    data: data__.ok_or_else(|| serde::de::Error::missing_field("data"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.FileInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FindMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::FindStart => "FIND_START",
            Self::FindStop => "FIND_STOP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for FindMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FIND_START",
            "FIND_STOP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FindMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "FIND_START" => Ok(FindMode::FindStart),
                    "FIND_STOP" => Ok(FindMode::FindStop),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Fitness {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Fitness", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                fitness::Payload::UserProfile(v) => {
                    struct_ser.serialize_field("userProfile", v)?;
                }
                fitness::Payload::Ids(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("ids", pbjson::private::base64::encode(&v).as_str())?;
                }
                fitness::Payload::Id(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("id", pbjson::private::base64::encode(&v).as_str())?;
                }
                fitness::Payload::RemainingSportDataList(v) => {
                    struct_ser.serialize_field("remainingSportDataList", v)?;
                }
                fitness::Payload::SyncParam(v) => {
                    struct_ser.serialize_field("syncParam", v)?;
                }
                fitness::Payload::BloodOxygenMonitor(v) => {
                    struct_ser.serialize_field("bloodOxygenMonitor", v)?;
                }
                fitness::Payload::HeartRateMonitor(v) => {
                    struct_ser.serialize_field("heartRateMonitor", v)?;
                }
                fitness::Payload::SedentaryReminder(v) => {
                    struct_ser.serialize_field("sedentaryReminder", v)?;
                }
                fitness::Payload::PressureMonitor(v) => {
                    struct_ser.serialize_field("pressureMonitor", v)?;
                }
                fitness::Payload::MeasureReminder(v) => {
                    struct_ser.serialize_field("measureReminder", v)?;
                }
                fitness::Payload::SectionList(v) => {
                    struct_ser.serialize_field("sectionList", v)?;
                }
                fitness::Payload::VitalityReminder(v) => {
                    struct_ser.serialize_field("vitalityReminder", v)?;
                }
                fitness::Payload::ActivityReminder(v) => {
                    struct_ser.serialize_field("activityReminder", v)?;
                }
                fitness::Payload::WearSensorData(v) => {
                    struct_ser.serialize_field("wearSensorData", v)?;
                }
                fitness::Payload::PressurCalibrateResponse(v) => {
                    struct_ser.serialize_field("pressurCalibrateResponse", v)?;
                }
                fitness::Payload::EvaluationResult(v) => {
                    struct_ser.serialize_field("evaluationResult", v)?;
                }
                fitness::Payload::CalibrationResult(v) => {
                    struct_ser.serialize_field("calibrationResult", v)?;
                }
                fitness::Payload::SportRequest(v) => {
                    struct_ser.serialize_field("sportRequest", v)?;
                }
                fitness::Payload::SportResponse(v) => {
                    struct_ser.serialize_field("sportResponse", v)?;
                }
                fitness::Payload::PhoneSportData(v) => {
                    struct_ser.serialize_field("phoneSportData", v)?;
                }
                fitness::Payload::WearSportData(v) => {
                    struct_ser.serialize_field("wearSportData", v)?;
                }
                fitness::Payload::SportStatus(v) => {
                    struct_ser.serialize_field("sportStatus", v)?;
                }
                fitness::Payload::SportPreRequest(v) => {
                    struct_ser.serialize_field("sportPreRequest", v)?;
                }
                fitness::Payload::SportPreResponse(v) => {
                    struct_ser.serialize_field("sportPreResponse", v)?;
                }
                fitness::Payload::EcgRequest(v) => {
                    struct_ser.serialize_field("ecgRequest", v)?;
                }
                fitness::Payload::EcgResponse(v) => {
                    struct_ser.serialize_field("ecgResponse", v)?;
                }
                fitness::Payload::EcgData(v) => {
                    struct_ser.serialize_field("ecgData", v)?;
                }
                fitness::Payload::EcgStatus(v) => {
                    struct_ser.serialize_field("ecgStatus", v)?;
                }
                fitness::Payload::WomenHealth(v) => {
                    struct_ser.serialize_field("womenHealth", v)?;
                }
                fitness::Payload::ForcastOn(v) => {
                    struct_ser.serialize_field("forcastOn", v)?;
                }
                fitness::Payload::ReminderList(v) => {
                    struct_ser.serialize_field("reminderList", v)?;
                }
                fitness::Payload::SleepResult(v) => {
                    struct_ser.serialize_field("sleepResult", v)?;
                }
                fitness::Payload::GoalStatus(v) => {
                    struct_ser.serialize_field("goalStatus", v)?;
                }
                fitness::Payload::BasicData(v) => {
                    struct_ser.serialize_field("basicData", v)?;
                }
                fitness::Payload::PhoneSportDataV2d(v) => {
                    struct_ser.serialize_field("phoneSportDataV2d", v)?;
                }
                fitness::Payload::PhoneSportDataV2a(v) => {
                    struct_ser.serialize_field("phoneSportDataV2a", v)?;
                }
                fitness::Payload::WearSportDataV2a(v) => {
                    struct_ser.serialize_field("wearSportDataV2a", v)?;
                }
                fitness::Payload::VitalityDataList(v) => {
                    struct_ser.serialize_field("vitalityDataList", v)?;
                }
                fitness::Payload::SportDataList(v) => {
                    struct_ser.serialize_field("sportDataList", v)?;
                }
                fitness::Payload::EcgActivation(v) => {
                    struct_ser.serialize_field("ecgActivation", v)?;
                }
                fitness::Payload::MotionInteract(v) => {
                    struct_ser.serialize_field("motionInteract", v)?;
                }
                fitness::Payload::NaviRouteList(v) => {
                    struct_ser.serialize_field("naviRouteList", v)?;
                }
                fitness::Payload::NaviRouteAddReqeust(v) => {
                    struct_ser.serialize_field("naviRouteAddReqeust", v)?;
                }
                fitness::Payload::NaviRouteAddResponse(v) => {
                    struct_ser.serialize_field("naviRouteAddResponse", v)?;
                }
                fitness::Payload::GymRequest(v) => {
                    struct_ser.serialize_field("gymRequest", v)?;
                }
                fitness::Payload::GymResponse(v) => {
                    struct_ser.serialize_field("gymResponse", v)?;
                }
                fitness::Payload::GymAssist(v) => {
                    struct_ser.serialize_field("gymAssist", v)?;
                }
                fitness::Payload::GymData(v) => {
                    struct_ser.serialize_field("gymData", v)?;
                }
                fitness::Payload::GymSettingList(v) => {
                    struct_ser.serialize_field("gymSettingList", v)?;
                }
                fitness::Payload::NaviRouteAddResult(v) => {
                    struct_ser.serialize_field("naviRouteAddResult", v)?;
                }
                fitness::Payload::NaviRouteRemoveReqeust(v) => {
                    struct_ser.serialize_field("naviRouteRemoveReqeust", v)?;
                }
                fitness::Payload::NaviRouteRemoveResponse(v) => {
                    struct_ser.serialize_field("naviRouteRemoveResponse", v)?;
                }
                fitness::Payload::SleepRegularity(v) => {
                    struct_ser.serialize_field("sleepRegularity", v)?;
                }
                fitness::Payload::SleepDisorder(v) => {
                    struct_ser.serialize_field("sleepDisorder", v)?;
                }
                fitness::Payload::ResearchApp(v) => {
                    struct_ser.serialize_field("researchApp", v)?;
                }
                fitness::Payload::ResearchAppList(v) => {
                    struct_ser.serialize_field("researchAppList", v)?;
                }
                fitness::Payload::ResearchDeviceList(v) => {
                    struct_ser.serialize_field("researchDeviceList", v)?;
                }
                fitness::Payload::ResearchCaliRequest(v) => {
                    struct_ser.serialize_field("researchCaliRequest", v)?;
                }
                fitness::Payload::ResearchCaliResponse(v) => {
                    struct_ser.serialize_field("researchCaliResponse", v)?;
                }
                fitness::Payload::ResearchBpSetting(v) => {
                    struct_ser.serialize_field("researchBpSetting", v)?;
                }
                fitness::Payload::PhoneControlData(v) => {
                    struct_ser.serialize_field("phoneControlData", v)?;
                }
                fitness::Payload::WearControlData(v) => {
                    struct_ser.serialize_field("wearControlData", v)?;
                }
                fitness::Payload::Training(v) => {
                    struct_ser.serialize_field("training", v)?;
                }
                fitness::Payload::BpgCaliRequest(v) => {
                    struct_ser.serialize_field("bpgCaliRequest", v)?;
                }
                fitness::Payload::BpgCaliStatus(v) => {
                    struct_ser.serialize_field("bpgCaliStatus", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Fitness {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user_profile",
            "userProfile",
            "ids",
            "id",
            "remaining_sport_data_list",
            "remainingSportDataList",
            "sync_param",
            "syncParam",
            "blood_oxygen_monitor",
            "bloodOxygenMonitor",
            "heart_rate_monitor",
            "heartRateMonitor",
            "sedentary_reminder",
            "sedentaryReminder",
            "pressure_monitor",
            "pressureMonitor",
            "measure_reminder",
            "measureReminder",
            "section_list",
            "sectionList",
            "vitality_reminder",
            "vitalityReminder",
            "activity_reminder",
            "activityReminder",
            "wear_sensor_data",
            "wearSensorData",
            "pressur_calibrate_response",
            "pressurCalibrateResponse",
            "evaluation_result",
            "evaluationResult",
            "calibration_result",
            "calibrationResult",
            "sport_request",
            "sportRequest",
            "sport_response",
            "sportResponse",
            "phone_sport_data",
            "phoneSportData",
            "wear_sport_data",
            "wearSportData",
            "sport_status",
            "sportStatus",
            "sport_pre_request",
            "sportPreRequest",
            "sport_pre_response",
            "sportPreResponse",
            "ecg_request",
            "ecgRequest",
            "ecg_response",
            "ecgResponse",
            "ecg_data",
            "ecgData",
            "ecg_status",
            "ecgStatus",
            "women_health",
            "womenHealth",
            "forcast_on",
            "forcastOn",
            "reminder_list",
            "reminderList",
            "sleep_result",
            "sleepResult",
            "goal_status",
            "goalStatus",
            "basic_data",
            "basicData",
            "phone_sport_data_v2d",
            "phoneSportDataV2d",
            "phone_sport_data_v2a",
            "phoneSportDataV2a",
            "wear_sport_data_v2a",
            "wearSportDataV2a",
            "vitality_data_list",
            "vitalityDataList",
            "sport_data_list",
            "sportDataList",
            "ecg_activation",
            "ecgActivation",
            "motion_interact",
            "motionInteract",
            "navi_route_list",
            "naviRouteList",
            "navi_route_add_reqeust",
            "naviRouteAddReqeust",
            "navi_route_add_response",
            "naviRouteAddResponse",
            "gym_request",
            "gymRequest",
            "gym_response",
            "gymResponse",
            "gym_assist",
            "gymAssist",
            "gym_data",
            "gymData",
            "gym_setting_list",
            "gymSettingList",
            "navi_route_add_result",
            "naviRouteAddResult",
            "navi_route_remove_reqeust",
            "naviRouteRemoveReqeust",
            "navi_route_remove_response",
            "naviRouteRemoveResponse",
            "sleep_regularity",
            "sleepRegularity",
            "sleep_disorder",
            "sleepDisorder",
            "research_app",
            "researchApp",
            "research_app_list",
            "researchAppList",
            "research_device_list",
            "researchDeviceList",
            "research_cali_request",
            "researchCaliRequest",
            "research_cali_response",
            "researchCaliResponse",
            "research_bp_setting",
            "researchBpSetting",
            "phone_control_data",
            "phoneControlData",
            "wear_control_data",
            "wearControlData",
            "training",
            "bpg_cali_request",
            "bpgCaliRequest",
            "bpg_cali_status",
            "bpgCaliStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UserProfile,
            Ids,
            Id,
            RemainingSportDataList,
            SyncParam,
            BloodOxygenMonitor,
            HeartRateMonitor,
            SedentaryReminder,
            PressureMonitor,
            MeasureReminder,
            SectionList,
            VitalityReminder,
            ActivityReminder,
            WearSensorData,
            PressurCalibrateResponse,
            EvaluationResult,
            CalibrationResult,
            SportRequest,
            SportResponse,
            PhoneSportData,
            WearSportData,
            SportStatus,
            SportPreRequest,
            SportPreResponse,
            EcgRequest,
            EcgResponse,
            EcgData,
            EcgStatus,
            WomenHealth,
            ForcastOn,
            ReminderList,
            SleepResult,
            GoalStatus,
            BasicData,
            PhoneSportDataV2d,
            PhoneSportDataV2a,
            WearSportDataV2a,
            VitalityDataList,
            SportDataList,
            EcgActivation,
            MotionInteract,
            NaviRouteList,
            NaviRouteAddReqeust,
            NaviRouteAddResponse,
            GymRequest,
            GymResponse,
            GymAssist,
            GymData,
            GymSettingList,
            NaviRouteAddResult,
            NaviRouteRemoveReqeust,
            NaviRouteRemoveResponse,
            SleepRegularity,
            SleepDisorder,
            ResearchApp,
            ResearchAppList,
            ResearchDeviceList,
            ResearchCaliRequest,
            ResearchCaliResponse,
            ResearchBpSetting,
            PhoneControlData,
            WearControlData,
            Training,
            BpgCaliRequest,
            BpgCaliStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "userProfile" | "user_profile" => Ok(GeneratedField::UserProfile),
                            "ids" => Ok(GeneratedField::Ids),
                            "id" => Ok(GeneratedField::Id),
                            "remainingSportDataList" | "remaining_sport_data_list" => Ok(GeneratedField::RemainingSportDataList),
                            "syncParam" | "sync_param" => Ok(GeneratedField::SyncParam),
                            "bloodOxygenMonitor" | "blood_oxygen_monitor" => Ok(GeneratedField::BloodOxygenMonitor),
                            "heartRateMonitor" | "heart_rate_monitor" => Ok(GeneratedField::HeartRateMonitor),
                            "sedentaryReminder" | "sedentary_reminder" => Ok(GeneratedField::SedentaryReminder),
                            "pressureMonitor" | "pressure_monitor" => Ok(GeneratedField::PressureMonitor),
                            "measureReminder" | "measure_reminder" => Ok(GeneratedField::MeasureReminder),
                            "sectionList" | "section_list" => Ok(GeneratedField::SectionList),
                            "vitalityReminder" | "vitality_reminder" => Ok(GeneratedField::VitalityReminder),
                            "activityReminder" | "activity_reminder" => Ok(GeneratedField::ActivityReminder),
                            "wearSensorData" | "wear_sensor_data" => Ok(GeneratedField::WearSensorData),
                            "pressurCalibrateResponse" | "pressur_calibrate_response" => Ok(GeneratedField::PressurCalibrateResponse),
                            "evaluationResult" | "evaluation_result" => Ok(GeneratedField::EvaluationResult),
                            "calibrationResult" | "calibration_result" => Ok(GeneratedField::CalibrationResult),
                            "sportRequest" | "sport_request" => Ok(GeneratedField::SportRequest),
                            "sportResponse" | "sport_response" => Ok(GeneratedField::SportResponse),
                            "phoneSportData" | "phone_sport_data" => Ok(GeneratedField::PhoneSportData),
                            "wearSportData" | "wear_sport_data" => Ok(GeneratedField::WearSportData),
                            "sportStatus" | "sport_status" => Ok(GeneratedField::SportStatus),
                            "sportPreRequest" | "sport_pre_request" => Ok(GeneratedField::SportPreRequest),
                            "sportPreResponse" | "sport_pre_response" => Ok(GeneratedField::SportPreResponse),
                            "ecgRequest" | "ecg_request" => Ok(GeneratedField::EcgRequest),
                            "ecgResponse" | "ecg_response" => Ok(GeneratedField::EcgResponse),
                            "ecgData" | "ecg_data" => Ok(GeneratedField::EcgData),
                            "ecgStatus" | "ecg_status" => Ok(GeneratedField::EcgStatus),
                            "womenHealth" | "women_health" => Ok(GeneratedField::WomenHealth),
                            "forcastOn" | "forcast_on" => Ok(GeneratedField::ForcastOn),
                            "reminderList" | "reminder_list" => Ok(GeneratedField::ReminderList),
                            "sleepResult" | "sleep_result" => Ok(GeneratedField::SleepResult),
                            "goalStatus" | "goal_status" => Ok(GeneratedField::GoalStatus),
                            "basicData" | "basic_data" => Ok(GeneratedField::BasicData),
                            "phoneSportDataV2d" | "phone_sport_data_v2d" => Ok(GeneratedField::PhoneSportDataV2d),
                            "phoneSportDataV2a" | "phone_sport_data_v2a" => Ok(GeneratedField::PhoneSportDataV2a),
                            "wearSportDataV2a" | "wear_sport_data_v2a" => Ok(GeneratedField::WearSportDataV2a),
                            "vitalityDataList" | "vitality_data_list" => Ok(GeneratedField::VitalityDataList),
                            "sportDataList" | "sport_data_list" => Ok(GeneratedField::SportDataList),
                            "ecgActivation" | "ecg_activation" => Ok(GeneratedField::EcgActivation),
                            "motionInteract" | "motion_interact" => Ok(GeneratedField::MotionInteract),
                            "naviRouteList" | "navi_route_list" => Ok(GeneratedField::NaviRouteList),
                            "naviRouteAddReqeust" | "navi_route_add_reqeust" => Ok(GeneratedField::NaviRouteAddReqeust),
                            "naviRouteAddResponse" | "navi_route_add_response" => Ok(GeneratedField::NaviRouteAddResponse),
                            "gymRequest" | "gym_request" => Ok(GeneratedField::GymRequest),
                            "gymResponse" | "gym_response" => Ok(GeneratedField::GymResponse),
                            "gymAssist" | "gym_assist" => Ok(GeneratedField::GymAssist),
                            "gymData" | "gym_data" => Ok(GeneratedField::GymData),
                            "gymSettingList" | "gym_setting_list" => Ok(GeneratedField::GymSettingList),
                            "naviRouteAddResult" | "navi_route_add_result" => Ok(GeneratedField::NaviRouteAddResult),
                            "naviRouteRemoveReqeust" | "navi_route_remove_reqeust" => Ok(GeneratedField::NaviRouteRemoveReqeust),
                            "naviRouteRemoveResponse" | "navi_route_remove_response" => Ok(GeneratedField::NaviRouteRemoveResponse),
                            "sleepRegularity" | "sleep_regularity" => Ok(GeneratedField::SleepRegularity),
                            "sleepDisorder" | "sleep_disorder" => Ok(GeneratedField::SleepDisorder),
                            "researchApp" | "research_app" => Ok(GeneratedField::ResearchApp),
                            "researchAppList" | "research_app_list" => Ok(GeneratedField::ResearchAppList),
                            "researchDeviceList" | "research_device_list" => Ok(GeneratedField::ResearchDeviceList),
                            "researchCaliRequest" | "research_cali_request" => Ok(GeneratedField::ResearchCaliRequest),
                            "researchCaliResponse" | "research_cali_response" => Ok(GeneratedField::ResearchCaliResponse),
                            "researchBpSetting" | "research_bp_setting" => Ok(GeneratedField::ResearchBpSetting),
                            "phoneControlData" | "phone_control_data" => Ok(GeneratedField::PhoneControlData),
                            "wearControlData" | "wear_control_data" => Ok(GeneratedField::WearControlData),
                            "training" => Ok(GeneratedField::Training),
                            "bpgCaliRequest" | "bpg_cali_request" => Ok(GeneratedField::BpgCaliRequest),
                            "bpgCaliStatus" | "bpg_cali_status" => Ok(GeneratedField::BpgCaliStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Fitness;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Fitness")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Fitness, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UserProfile => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userProfile"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::UserProfile)
;
                        }
                        GeneratedField::Ids => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| fitness::Payload::Ids(x.0));
                        }
                        GeneratedField::Id => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| fitness::Payload::Id(x.0));
                        }
                        GeneratedField::RemainingSportDataList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remainingSportDataList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::RemainingSportDataList)
;
                        }
                        GeneratedField::SyncParam => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("syncParam"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SyncParam)
;
                        }
                        GeneratedField::BloodOxygenMonitor => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bloodOxygenMonitor"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::BloodOxygenMonitor)
;
                        }
                        GeneratedField::HeartRateMonitor => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRateMonitor"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::HeartRateMonitor)
;
                        }
                        GeneratedField::SedentaryReminder => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sedentaryReminder"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SedentaryReminder)
;
                        }
                        GeneratedField::PressureMonitor => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pressureMonitor"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::PressureMonitor)
;
                        }
                        GeneratedField::MeasureReminder => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("measureReminder"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::MeasureReminder)
;
                        }
                        GeneratedField::SectionList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sectionList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SectionList)
;
                        }
                        GeneratedField::VitalityReminder => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vitalityReminder"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::VitalityReminder)
;
                        }
                        GeneratedField::ActivityReminder => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activityReminder"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ActivityReminder)
;
                        }
                        GeneratedField::WearSensorData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearSensorData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::WearSensorData)
;
                        }
                        GeneratedField::PressurCalibrateResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pressurCalibrateResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::PressurCalibrateResponse)
;
                        }
                        GeneratedField::EvaluationResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("evaluationResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::EvaluationResult)
;
                        }
                        GeneratedField::CalibrationResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calibrationResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::CalibrationResult)
;
                        }
                        GeneratedField::SportRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SportRequest)
;
                        }
                        GeneratedField::SportResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SportResponse)
;
                        }
                        GeneratedField::PhoneSportData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneSportData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::PhoneSportData)
;
                        }
                        GeneratedField::WearSportData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearSportData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::WearSportData)
;
                        }
                        GeneratedField::SportStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SportStatus)
;
                        }
                        GeneratedField::SportPreRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportPreRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SportPreRequest)
;
                        }
                        GeneratedField::SportPreResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportPreResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SportPreResponse)
;
                        }
                        GeneratedField::EcgRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ecgRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::EcgRequest)
;
                        }
                        GeneratedField::EcgResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ecgResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::EcgResponse)
;
                        }
                        GeneratedField::EcgData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ecgData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::EcgData)
;
                        }
                        GeneratedField::EcgStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ecgStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::EcgStatus)
;
                        }
                        GeneratedField::WomenHealth => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("womenHealth"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::WomenHealth)
;
                        }
                        GeneratedField::ForcastOn => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("forcastOn"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ForcastOn);
                        }
                        GeneratedField::ReminderList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ReminderList)
;
                        }
                        GeneratedField::SleepResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SleepResult)
;
                        }
                        GeneratedField::GoalStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("goalStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::GoalStatus)
;
                        }
                        GeneratedField::BasicData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::BasicData)
;
                        }
                        GeneratedField::PhoneSportDataV2d => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneSportDataV2d"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::PhoneSportDataV2d)
;
                        }
                        GeneratedField::PhoneSportDataV2a => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneSportDataV2a"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::PhoneSportDataV2a)
;
                        }
                        GeneratedField::WearSportDataV2a => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearSportDataV2a"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::WearSportDataV2a)
;
                        }
                        GeneratedField::VitalityDataList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vitalityDataList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::VitalityDataList)
;
                        }
                        GeneratedField::SportDataList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportDataList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SportDataList)
;
                        }
                        GeneratedField::EcgActivation => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ecgActivation"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::EcgActivation)
;
                        }
                        GeneratedField::MotionInteract => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("motionInteract"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::MotionInteract)
;
                        }
                        GeneratedField::NaviRouteList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRouteList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::NaviRouteList)
;
                        }
                        GeneratedField::NaviRouteAddReqeust => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRouteAddReqeust"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::NaviRouteAddReqeust)
;
                        }
                        GeneratedField::NaviRouteAddResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRouteAddResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::NaviRouteAddResponse)
;
                        }
                        GeneratedField::GymRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::GymRequest)
;
                        }
                        GeneratedField::GymResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::GymResponse)
;
                        }
                        GeneratedField::GymAssist => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymAssist"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::GymAssist)
;
                        }
                        GeneratedField::GymData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::GymData)
;
                        }
                        GeneratedField::GymSettingList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymSettingList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::GymSettingList)
;
                        }
                        GeneratedField::NaviRouteAddResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRouteAddResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::NaviRouteAddResult)
;
                        }
                        GeneratedField::NaviRouteRemoveReqeust => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRouteRemoveReqeust"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::NaviRouteRemoveReqeust)
;
                        }
                        GeneratedField::NaviRouteRemoveResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRouteRemoveResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::NaviRouteRemoveResponse)
;
                        }
                        GeneratedField::SleepRegularity => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepRegularity"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SleepRegularity)
;
                        }
                        GeneratedField::SleepDisorder => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepDisorder"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::SleepDisorder)
;
                        }
                        GeneratedField::ResearchApp => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchApp"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ResearchApp)
;
                        }
                        GeneratedField::ResearchAppList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchAppList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ResearchAppList)
;
                        }
                        GeneratedField::ResearchDeviceList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchDeviceList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ResearchDeviceList)
;
                        }
                        GeneratedField::ResearchCaliRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchCaliRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ResearchCaliRequest)
;
                        }
                        GeneratedField::ResearchCaliResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchCaliResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ResearchCaliResponse)
;
                        }
                        GeneratedField::ResearchBpSetting => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchBpSetting"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::ResearchBpSetting)
;
                        }
                        GeneratedField::PhoneControlData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneControlData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::PhoneControlData)
;
                        }
                        GeneratedField::WearControlData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearControlData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::WearControlData)
;
                        }
                        GeneratedField::Training => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("training"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::Training)
;
                        }
                        GeneratedField::BpgCaliRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bpgCaliRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::BpgCaliRequest)
;
                        }
                        GeneratedField::BpgCaliStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bpgCaliStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(fitness::Payload::BpgCaliStatus)
;
                        }
                    }
                }
                Ok(Fitness {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Fitness", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for fitness::FitnessId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SetUserProfile => "SET_USER_PROFILE",
            Self::RequestUserProfile => "REQUEST_USER_PROFILE",
            Self::GetTodayFitnessIds => "GET_TODAY_FITNESS_IDS",
            Self::GetHistoryFitnessIds => "GET_HISTORY_FITNESS_IDS",
            Self::RequestFitnessIds => "REQUEST_FITNESS_IDS",
            Self::RequestFitnessId => "REQUEST_FITNESS_ID",
            Self::ConfirmFitnessId => "CONFIRM_FITNESS_ID",
            Self::GetRemainingSportData => "GET_REMAINING_SPORT_DATA",
            Self::GetBloodOxygenMonitor => "GET_BLOOD_OXYGEN_MONITOR",
            Self::SetBloodOxygenMonitor => "SET_BLOOD_OXYGEN_MONITOR",
            Self::GetHeartRateMonitor => "GET_HEART_RATE_MONITOR",
            Self::SetHeartRateMonitor => "SET_HEART_RATE_MONITOR",
            Self::GetSedentaryReminder => "GET_SEDENTARY_REMINDER",
            Self::SetSedentaryReminder => "SET_SEDENTARY_REMINDER",
            Self::GetPressureMonitor => "GET_PRESSURE_MONITOR",
            Self::SetPressureMonitor => "SET_PRESSURE_MONITOR",
            Self::GetBloodPressureReminder => "GET_BLOOD_PRESSURE_REMINDER",
            Self::SetBloodPressureReminder => "SET_BLOOD_PRESSURE_REMINDER",
            Self::GetEcgReminder => "GET_ECG_REMINDER",
            Self::SetEcgReminder => "SET_ECG_REMINDER",
            Self::CheckEcgActivation => "CHECK_ECG_ACTIVATION",
            Self::ActivateEcg => "ACTIVATE_ECG",
            Self::DeactivateEcg => "DEACTIVATE_ECG",
            Self::StartPressureCalibrate => "START_PRESSURE_CALIBRATE",
            Self::StopPressureCalibrate => "STOP_PRESSURE_CALIBRATE",
            Self::CompletePressureCalibrate => "COMPLETE_PRESSURE_CALIBRATE",
            Self::SportRequest => "SPORT_REQUEST",
            Self::PhoneSportData => "PHONE_SPORT_DATA",
            Self::WearSportData => "WEAR_SPORT_DATA",
            Self::GetSportStatus => "GET_SPORT_STATUS",
            Self::SportPreRequest => "SPORT_PRE_REQUEST",
            Self::EcgRequest => "ECG_REQUEST",
            Self::ReportEcgData => "REPORT_ECG_DATA",
            Self::ReportEcgStatus => "REPORT_ECG_STATUS",
            Self::GetWomenHealth => "GET_WOMEN_HEALTH",
            Self::RequestWomenHealth => "REQUEST_WOMEN_HEALTH",
            Self::SyncWomenHealth => "SYNC_WOMEN_HEALTH",
            Self::SetWomenHealthForcast => "SET_WOMEN_HEALTH_FORCAST",
            Self::SetWomenHealthReminder => "SET_WOMEN_HEALTH_REMINDER",
            Self::SyncSleepResult => "SYNC_SLEEP_RESULT",
            Self::GetGoalStatus => "GET_GOAL_STATUS",
            Self::SetGoalStatus => "SET_GOAL_STATUS",
            Self::GetBasicData => "GET_BASIC_DATA",
            Self::RegisterBasicDataReport => "REGISTER_BASIC_DATA_REPORT",
            Self::UnregisterBasicDataReport => "UNREGISTER_BASIC_DATA_REPORT",
            Self::ReportBasicData => "REPORT_BASIC_DATA",
            Self::SyncVitalityData => "SYNC_VITALITY_DATA",
            Self::SyncBestSportData => "SYNC_BEST_SPORT_DATA",
            Self::GetVitalityReminder => "GET_VITALITY_REMINDER",
            Self::SetVitalityReminder => "SET_VITALITY_REMINDER",
            Self::GetActivityReminder => "GET_ACTIVITY_REMINDER",
            Self::SetActivityReminder => "SET_ACTIVITY_REMINDER",
            Self::PhoneSportDataV2d => "PHONE_SPORT_DATA_V2D",
            Self::PhoneSportDataV2a => "PHONE_SPORT_DATA_V2A",
            Self::WearSportDataV2a => "WEAR_SPORT_DATA_V2A",
            Self::WearSensorData => "WEAR_SENSOR_DATA",
            Self::MotionInteract => "MOTION_INTERACT",
            Self::PhoneControlData => "PHONE_CONTROL_DATA",
            Self::WearControlData => "WEAR_CONTROL_DATA",
            Self::GymRequest => "GYM_REQUEST",
            Self::GymAssist => "GYM_ASSIST",
            Self::GymData => "GYM_DATA",
            Self::GetGymSettings => "GET_GYM_SETTINGS",
            Self::SetGymSettings => "SET_GYM_SETTINGS",
            Self::GetNaviRoutes => "GET_NAVI_ROUTES",
            Self::AddNaviRoute => "ADD_NAVI_ROUTE",
            Self::ReportAddRouteResult => "REPORT_ADD_ROUTE_RESULT",
            Self::RemoveNaveRoutes => "REMOVE_NAVE_ROUTES",
            Self::GetSleepRegularity => "GET_SLEEP_REGULARITY",
            Self::SetSleepRegularity => "SET_SLEEP_REGULARITY",
            Self::GetSleepDisorder => "GET_SLEEP_DISORDER",
            Self::SetSleepDisorder => "SET_SLEEP_DISORDER",
            Self::SetResearchUserProfile => "SET_RESEARCH_USER_PROFILE",
            Self::GetTodayResearchIds => "GET_TODAY_RESEARCH_IDS",
            Self::GetHistoryResearchIds => "GET_HISTORY_RESEARCH_IDS",
            Self::RequestResearchIds => "REQUEST_RESEARCH_IDS",
            Self::RequestResearchId => "REQUEST_RESEARCH_ID",
            Self::ConfirmResearchId => "CONFIRM_RESEARCH_ID",
            Self::UpdateAppResearch => "UPDATE_APP_RESEARCH",
            Self::SyncAppResearchList => "SYNC_APP_RESEARCH_LIST",
            Self::GetDeviceResearchList => "GET_DEVICE_RESEARCH_LIST",
            Self::RequestResearchCalibration => "REQUEST_RESEARCH_CALIBRATION",
            Self::ReportResearchCalibrationStep1 => "REPORT_RESEARCH_CALIBRATION_STEP1",
            Self::ReportResearchCalibrationStep2 => "REPORT_RESEARCH_CALIBRATION_STEP2",
            Self::ReportResearchCalibration => "REPORT_RESEARCH_CALIBRATION",
            Self::SetBpResearch => "SET_BP_RESEARCH",
            Self::RequestBpgCalibration => "REQUEST_BPG_CALIBRATION",
            Self::GetBpgCalibStatus => "GET_BPG_CALIB_STATUS",
            Self::GetTrainingStatus => "GET_TRAINING_STATUS",
            Self::SyncTrainingPlan => "SYNC_TRAINING_PLAN",
            Self::StopTrainingPlan => "STOP_TRAINING_PLAN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for fitness::FitnessId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SET_USER_PROFILE",
            "REQUEST_USER_PROFILE",
            "GET_TODAY_FITNESS_IDS",
            "GET_HISTORY_FITNESS_IDS",
            "REQUEST_FITNESS_IDS",
            "REQUEST_FITNESS_ID",
            "CONFIRM_FITNESS_ID",
            "GET_REMAINING_SPORT_DATA",
            "GET_BLOOD_OXYGEN_MONITOR",
            "SET_BLOOD_OXYGEN_MONITOR",
            "GET_HEART_RATE_MONITOR",
            "SET_HEART_RATE_MONITOR",
            "GET_SEDENTARY_REMINDER",
            "SET_SEDENTARY_REMINDER",
            "GET_PRESSURE_MONITOR",
            "SET_PRESSURE_MONITOR",
            "GET_BLOOD_PRESSURE_REMINDER",
            "SET_BLOOD_PRESSURE_REMINDER",
            "GET_ECG_REMINDER",
            "SET_ECG_REMINDER",
            "CHECK_ECG_ACTIVATION",
            "ACTIVATE_ECG",
            "DEACTIVATE_ECG",
            "START_PRESSURE_CALIBRATE",
            "STOP_PRESSURE_CALIBRATE",
            "COMPLETE_PRESSURE_CALIBRATE",
            "SPORT_REQUEST",
            "PHONE_SPORT_DATA",
            "WEAR_SPORT_DATA",
            "GET_SPORT_STATUS",
            "SPORT_PRE_REQUEST",
            "ECG_REQUEST",
            "REPORT_ECG_DATA",
            "REPORT_ECG_STATUS",
            "GET_WOMEN_HEALTH",
            "REQUEST_WOMEN_HEALTH",
            "SYNC_WOMEN_HEALTH",
            "SET_WOMEN_HEALTH_FORCAST",
            "SET_WOMEN_HEALTH_REMINDER",
            "SYNC_SLEEP_RESULT",
            "GET_GOAL_STATUS",
            "SET_GOAL_STATUS",
            "GET_BASIC_DATA",
            "REGISTER_BASIC_DATA_REPORT",
            "UNREGISTER_BASIC_DATA_REPORT",
            "REPORT_BASIC_DATA",
            "SYNC_VITALITY_DATA",
            "SYNC_BEST_SPORT_DATA",
            "GET_VITALITY_REMINDER",
            "SET_VITALITY_REMINDER",
            "GET_ACTIVITY_REMINDER",
            "SET_ACTIVITY_REMINDER",
            "PHONE_SPORT_DATA_V2D",
            "PHONE_SPORT_DATA_V2A",
            "WEAR_SPORT_DATA_V2A",
            "WEAR_SENSOR_DATA",
            "MOTION_INTERACT",
            "PHONE_CONTROL_DATA",
            "WEAR_CONTROL_DATA",
            "GYM_REQUEST",
            "GYM_ASSIST",
            "GYM_DATA",
            "GET_GYM_SETTINGS",
            "SET_GYM_SETTINGS",
            "GET_NAVI_ROUTES",
            "ADD_NAVI_ROUTE",
            "REPORT_ADD_ROUTE_RESULT",
            "REMOVE_NAVE_ROUTES",
            "GET_SLEEP_REGULARITY",
            "SET_SLEEP_REGULARITY",
            "GET_SLEEP_DISORDER",
            "SET_SLEEP_DISORDER",
            "SET_RESEARCH_USER_PROFILE",
            "GET_TODAY_RESEARCH_IDS",
            "GET_HISTORY_RESEARCH_IDS",
            "REQUEST_RESEARCH_IDS",
            "REQUEST_RESEARCH_ID",
            "CONFIRM_RESEARCH_ID",
            "UPDATE_APP_RESEARCH",
            "SYNC_APP_RESEARCH_LIST",
            "GET_DEVICE_RESEARCH_LIST",
            "REQUEST_RESEARCH_CALIBRATION",
            "REPORT_RESEARCH_CALIBRATION_STEP1",
            "REPORT_RESEARCH_CALIBRATION_STEP2",
            "REPORT_RESEARCH_CALIBRATION",
            "SET_BP_RESEARCH",
            "REQUEST_BPG_CALIBRATION",
            "GET_BPG_CALIB_STATUS",
            "GET_TRAINING_STATUS",
            "SYNC_TRAINING_PLAN",
            "STOP_TRAINING_PLAN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = fitness::FitnessId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SET_USER_PROFILE" => Ok(fitness::FitnessId::SetUserProfile),
                    "REQUEST_USER_PROFILE" => Ok(fitness::FitnessId::RequestUserProfile),
                    "GET_TODAY_FITNESS_IDS" => Ok(fitness::FitnessId::GetTodayFitnessIds),
                    "GET_HISTORY_FITNESS_IDS" => Ok(fitness::FitnessId::GetHistoryFitnessIds),
                    "REQUEST_FITNESS_IDS" => Ok(fitness::FitnessId::RequestFitnessIds),
                    "REQUEST_FITNESS_ID" => Ok(fitness::FitnessId::RequestFitnessId),
                    "CONFIRM_FITNESS_ID" => Ok(fitness::FitnessId::ConfirmFitnessId),
                    "GET_REMAINING_SPORT_DATA" => Ok(fitness::FitnessId::GetRemainingSportData),
                    "GET_BLOOD_OXYGEN_MONITOR" => Ok(fitness::FitnessId::GetBloodOxygenMonitor),
                    "SET_BLOOD_OXYGEN_MONITOR" => Ok(fitness::FitnessId::SetBloodOxygenMonitor),
                    "GET_HEART_RATE_MONITOR" => Ok(fitness::FitnessId::GetHeartRateMonitor),
                    "SET_HEART_RATE_MONITOR" => Ok(fitness::FitnessId::SetHeartRateMonitor),
                    "GET_SEDENTARY_REMINDER" => Ok(fitness::FitnessId::GetSedentaryReminder),
                    "SET_SEDENTARY_REMINDER" => Ok(fitness::FitnessId::SetSedentaryReminder),
                    "GET_PRESSURE_MONITOR" => Ok(fitness::FitnessId::GetPressureMonitor),
                    "SET_PRESSURE_MONITOR" => Ok(fitness::FitnessId::SetPressureMonitor),
                    "GET_BLOOD_PRESSURE_REMINDER" => Ok(fitness::FitnessId::GetBloodPressureReminder),
                    "SET_BLOOD_PRESSURE_REMINDER" => Ok(fitness::FitnessId::SetBloodPressureReminder),
                    "GET_ECG_REMINDER" => Ok(fitness::FitnessId::GetEcgReminder),
                    "SET_ECG_REMINDER" => Ok(fitness::FitnessId::SetEcgReminder),
                    "CHECK_ECG_ACTIVATION" => Ok(fitness::FitnessId::CheckEcgActivation),
                    "ACTIVATE_ECG" => Ok(fitness::FitnessId::ActivateEcg),
                    "DEACTIVATE_ECG" => Ok(fitness::FitnessId::DeactivateEcg),
                    "START_PRESSURE_CALIBRATE" => Ok(fitness::FitnessId::StartPressureCalibrate),
                    "STOP_PRESSURE_CALIBRATE" => Ok(fitness::FitnessId::StopPressureCalibrate),
                    "COMPLETE_PRESSURE_CALIBRATE" => Ok(fitness::FitnessId::CompletePressureCalibrate),
                    "SPORT_REQUEST" => Ok(fitness::FitnessId::SportRequest),
                    "PHONE_SPORT_DATA" => Ok(fitness::FitnessId::PhoneSportData),
                    "WEAR_SPORT_DATA" => Ok(fitness::FitnessId::WearSportData),
                    "GET_SPORT_STATUS" => Ok(fitness::FitnessId::GetSportStatus),
                    "SPORT_PRE_REQUEST" => Ok(fitness::FitnessId::SportPreRequest),
                    "ECG_REQUEST" => Ok(fitness::FitnessId::EcgRequest),
                    "REPORT_ECG_DATA" => Ok(fitness::FitnessId::ReportEcgData),
                    "REPORT_ECG_STATUS" => Ok(fitness::FitnessId::ReportEcgStatus),
                    "GET_WOMEN_HEALTH" => Ok(fitness::FitnessId::GetWomenHealth),
                    "REQUEST_WOMEN_HEALTH" => Ok(fitness::FitnessId::RequestWomenHealth),
                    "SYNC_WOMEN_HEALTH" => Ok(fitness::FitnessId::SyncWomenHealth),
                    "SET_WOMEN_HEALTH_FORCAST" => Ok(fitness::FitnessId::SetWomenHealthForcast),
                    "SET_WOMEN_HEALTH_REMINDER" => Ok(fitness::FitnessId::SetWomenHealthReminder),
                    "SYNC_SLEEP_RESULT" => Ok(fitness::FitnessId::SyncSleepResult),
                    "GET_GOAL_STATUS" => Ok(fitness::FitnessId::GetGoalStatus),
                    "SET_GOAL_STATUS" => Ok(fitness::FitnessId::SetGoalStatus),
                    "GET_BASIC_DATA" => Ok(fitness::FitnessId::GetBasicData),
                    "REGISTER_BASIC_DATA_REPORT" => Ok(fitness::FitnessId::RegisterBasicDataReport),
                    "UNREGISTER_BASIC_DATA_REPORT" => Ok(fitness::FitnessId::UnregisterBasicDataReport),
                    "REPORT_BASIC_DATA" => Ok(fitness::FitnessId::ReportBasicData),
                    "SYNC_VITALITY_DATA" => Ok(fitness::FitnessId::SyncVitalityData),
                    "SYNC_BEST_SPORT_DATA" => Ok(fitness::FitnessId::SyncBestSportData),
                    "GET_VITALITY_REMINDER" => Ok(fitness::FitnessId::GetVitalityReminder),
                    "SET_VITALITY_REMINDER" => Ok(fitness::FitnessId::SetVitalityReminder),
                    "GET_ACTIVITY_REMINDER" => Ok(fitness::FitnessId::GetActivityReminder),
                    "SET_ACTIVITY_REMINDER" => Ok(fitness::FitnessId::SetActivityReminder),
                    "PHONE_SPORT_DATA_V2D" => Ok(fitness::FitnessId::PhoneSportDataV2d),
                    "PHONE_SPORT_DATA_V2A" => Ok(fitness::FitnessId::PhoneSportDataV2a),
                    "WEAR_SPORT_DATA_V2A" => Ok(fitness::FitnessId::WearSportDataV2a),
                    "WEAR_SENSOR_DATA" => Ok(fitness::FitnessId::WearSensorData),
                    "MOTION_INTERACT" => Ok(fitness::FitnessId::MotionInteract),
                    "PHONE_CONTROL_DATA" => Ok(fitness::FitnessId::PhoneControlData),
                    "WEAR_CONTROL_DATA" => Ok(fitness::FitnessId::WearControlData),
                    "GYM_REQUEST" => Ok(fitness::FitnessId::GymRequest),
                    "GYM_ASSIST" => Ok(fitness::FitnessId::GymAssist),
                    "GYM_DATA" => Ok(fitness::FitnessId::GymData),
                    "GET_GYM_SETTINGS" => Ok(fitness::FitnessId::GetGymSettings),
                    "SET_GYM_SETTINGS" => Ok(fitness::FitnessId::SetGymSettings),
                    "GET_NAVI_ROUTES" => Ok(fitness::FitnessId::GetNaviRoutes),
                    "ADD_NAVI_ROUTE" => Ok(fitness::FitnessId::AddNaviRoute),
                    "REPORT_ADD_ROUTE_RESULT" => Ok(fitness::FitnessId::ReportAddRouteResult),
                    "REMOVE_NAVE_ROUTES" => Ok(fitness::FitnessId::RemoveNaveRoutes),
                    "GET_SLEEP_REGULARITY" => Ok(fitness::FitnessId::GetSleepRegularity),
                    "SET_SLEEP_REGULARITY" => Ok(fitness::FitnessId::SetSleepRegularity),
                    "GET_SLEEP_DISORDER" => Ok(fitness::FitnessId::GetSleepDisorder),
                    "SET_SLEEP_DISORDER" => Ok(fitness::FitnessId::SetSleepDisorder),
                    "SET_RESEARCH_USER_PROFILE" => Ok(fitness::FitnessId::SetResearchUserProfile),
                    "GET_TODAY_RESEARCH_IDS" => Ok(fitness::FitnessId::GetTodayResearchIds),
                    "GET_HISTORY_RESEARCH_IDS" => Ok(fitness::FitnessId::GetHistoryResearchIds),
                    "REQUEST_RESEARCH_IDS" => Ok(fitness::FitnessId::RequestResearchIds),
                    "REQUEST_RESEARCH_ID" => Ok(fitness::FitnessId::RequestResearchId),
                    "CONFIRM_RESEARCH_ID" => Ok(fitness::FitnessId::ConfirmResearchId),
                    "UPDATE_APP_RESEARCH" => Ok(fitness::FitnessId::UpdateAppResearch),
                    "SYNC_APP_RESEARCH_LIST" => Ok(fitness::FitnessId::SyncAppResearchList),
                    "GET_DEVICE_RESEARCH_LIST" => Ok(fitness::FitnessId::GetDeviceResearchList),
                    "REQUEST_RESEARCH_CALIBRATION" => Ok(fitness::FitnessId::RequestResearchCalibration),
                    "REPORT_RESEARCH_CALIBRATION_STEP1" => Ok(fitness::FitnessId::ReportResearchCalibrationStep1),
                    "REPORT_RESEARCH_CALIBRATION_STEP2" => Ok(fitness::FitnessId::ReportResearchCalibrationStep2),
                    "REPORT_RESEARCH_CALIBRATION" => Ok(fitness::FitnessId::ReportResearchCalibration),
                    "SET_BP_RESEARCH" => Ok(fitness::FitnessId::SetBpResearch),
                    "REQUEST_BPG_CALIBRATION" => Ok(fitness::FitnessId::RequestBpgCalibration),
                    "GET_BPG_CALIB_STATUS" => Ok(fitness::FitnessId::GetBpgCalibStatus),
                    "GET_TRAINING_STATUS" => Ok(fitness::FitnessId::GetTrainingStatus),
                    "SYNC_TRAINING_PLAN" => Ok(fitness::FitnessId::SyncTrainingPlan),
                    "STOP_TRAINING_PLAN" => Ok(fitness::FitnessId::StopTrainingPlan),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for FontResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.FontResult", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FontResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FontResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.FontResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FontResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FontResult {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.FontResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ForceUpgrade {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ForceUpgrade", len)?;
        struct_ser.serialize_field("force", &self.force)?;
        struct_ser.serialize_field("firmwareVersion", &self.firmware_version)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ForceUpgrade {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "force",
            "firmware_version",
            "firmwareVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Force,
            FirmwareVersion,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "force" => Ok(GeneratedField::Force),
                            "firmwareVersion" | "firmware_version" => Ok(GeneratedField::FirmwareVersion),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ForceUpgrade;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ForceUpgrade")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ForceUpgrade, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut force__ = None;
                let mut firmware_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Force => {
                            if force__.is_some() {
                                return Err(serde::de::Error::duplicate_field("force"));
                            }
                            force__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FirmwareVersion => {
                            if firmware_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firmwareVersion"));
                            }
                            firmware_version__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ForceUpgrade {
                    force: force__.ok_or_else(|| serde::de::Error::missing_field("force"))?,
                    firmware_version: firmware_version__.ok_or_else(|| serde::de::Error::missing_field("firmwareVersion"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ForceUpgrade", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Function {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Setting => "SETTING",
            Self::Fitness => "FITNESS",
            Self::HeartRate => "HEART_RATE",
            Self::Pressure => "PRESSURE",
            Self::Energy => "ENERGY",
            Self::Sleep => "SLEEP",
            Self::Breath => "BREATH",
            Self::AnaerobicThreshold => "ANAEROBIC_THRESHOLD",
            Self::Calendar => "CALENDAR",
            Self::Clock => "CLOCK",
            Self::Stopwatch => "STOPWATCH",
            Self::TimeKeeping => "TIME_KEEPING",
            Self::Weather => "WEATHER",
            Self::Stock => "STOCK",
            Self::AppList => "APP_LIST",
            Self::SportList => "SPORT_LIST",
            Self::Home => "HOME",
            Self::MusicController => "MUSIC_CONTROLLER",
            Self::VoiceAssistant => "VOICE_ASSISTANT",
            Self::BloodOxygen => "BLOOD_OXYGEN",
            Self::ControlCenter => "CONTROL_CENTER",
            Self::WomenHealth => "WOMEN_HEALTH",
            Self::System => "SYSTEM",
            Self::Temperature => "TEMPERATURE",
            Self::BloodPressure => "BLOOD_PRESSURE",
            Self::Ecg => "ECG",
            Self::Event => "EVENT",
            Self::Mihome => "MIHOME",
            Self::Activity => "ACTIVITY",
            Self::SportRecord => "SPORT_RECORD",
            Self::Share => "SHARE",
            Self::TodoList => "TODO_LIST",
            Self::Phone => "PHONE",
            Self::LactateThreshold => "LACTATE_THRESHOLD",
            Self::Compass => "COMPASS",
            Self::Alipay => "ALIPAY",
            Self::Card => "CARD",
            Self::Door => "DOOR",
            Self::Bus => "BUS",
            Self::Bank => "BANK",
            Self::WechatPay => "WECHAT_PAY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for Function {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SETTING",
            "FITNESS",
            "HEART_RATE",
            "PRESSURE",
            "ENERGY",
            "SLEEP",
            "BREATH",
            "ANAEROBIC_THRESHOLD",
            "CALENDAR",
            "CLOCK",
            "STOPWATCH",
            "TIME_KEEPING",
            "WEATHER",
            "STOCK",
            "APP_LIST",
            "SPORT_LIST",
            "HOME",
            "MUSIC_CONTROLLER",
            "VOICE_ASSISTANT",
            "BLOOD_OXYGEN",
            "CONTROL_CENTER",
            "WOMEN_HEALTH",
            "SYSTEM",
            "TEMPERATURE",
            "BLOOD_PRESSURE",
            "ECG",
            "EVENT",
            "MIHOME",
            "ACTIVITY",
            "SPORT_RECORD",
            "SHARE",
            "TODO_LIST",
            "PHONE",
            "LACTATE_THRESHOLD",
            "COMPASS",
            "ALIPAY",
            "CARD",
            "DOOR",
            "BUS",
            "BANK",
            "WECHAT_PAY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Function;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SETTING" => Ok(Function::Setting),
                    "FITNESS" => Ok(Function::Fitness),
                    "HEART_RATE" => Ok(Function::HeartRate),
                    "PRESSURE" => Ok(Function::Pressure),
                    "ENERGY" => Ok(Function::Energy),
                    "SLEEP" => Ok(Function::Sleep),
                    "BREATH" => Ok(Function::Breath),
                    "ANAEROBIC_THRESHOLD" => Ok(Function::AnaerobicThreshold),
                    "CALENDAR" => Ok(Function::Calendar),
                    "CLOCK" => Ok(Function::Clock),
                    "STOPWATCH" => Ok(Function::Stopwatch),
                    "TIME_KEEPING" => Ok(Function::TimeKeeping),
                    "WEATHER" => Ok(Function::Weather),
                    "STOCK" => Ok(Function::Stock),
                    "APP_LIST" => Ok(Function::AppList),
                    "SPORT_LIST" => Ok(Function::SportList),
                    "HOME" => Ok(Function::Home),
                    "MUSIC_CONTROLLER" => Ok(Function::MusicController),
                    "VOICE_ASSISTANT" => Ok(Function::VoiceAssistant),
                    "BLOOD_OXYGEN" => Ok(Function::BloodOxygen),
                    "CONTROL_CENTER" => Ok(Function::ControlCenter),
                    "WOMEN_HEALTH" => Ok(Function::WomenHealth),
                    "SYSTEM" => Ok(Function::System),
                    "TEMPERATURE" => Ok(Function::Temperature),
                    "BLOOD_PRESSURE" => Ok(Function::BloodPressure),
                    "ECG" => Ok(Function::Ecg),
                    "EVENT" => Ok(Function::Event),
                    "MIHOME" => Ok(Function::Mihome),
                    "ACTIVITY" => Ok(Function::Activity),
                    "SPORT_RECORD" => Ok(Function::SportRecord),
                    "SHARE" => Ok(Function::Share),
                    "TODO_LIST" => Ok(Function::TodoList),
                    "PHONE" => Ok(Function::Phone),
                    "LACTATE_THRESHOLD" => Ok(Function::LactateThreshold),
                    "COMPASS" => Ok(Function::Compass),
                    "ALIPAY" => Ok(Function::Alipay),
                    "CARD" => Ok(Function::Card),
                    "DOOR" => Ok(Function::Door),
                    "BUS" => Ok(Function::Bus),
                    "BANK" => Ok(Function::Bank),
                    "WECHAT_PAY" => Ok(Function::WechatPay),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GymAssist {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.heart_rate.is_some() {
            len += 1;
        }
        if self.adjust_speed.is_some() {
            len += 1;
        }
        if self.adjust_pace.is_some() {
            len += 1;
        }
        if self.adjust_resistance_level.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.GYMAssist", len)?;
        if let Some(v) = self.heart_rate.as_ref() {
            struct_ser.serialize_field("heartRate", v)?;
        }
        if let Some(v) = self.adjust_speed.as_ref() {
            struct_ser.serialize_field("adjustSpeed", v)?;
        }
        if let Some(v) = self.adjust_pace.as_ref() {
            struct_ser.serialize_field("adjustPace", v)?;
        }
        if let Some(v) = self.adjust_resistance_level.as_ref() {
            struct_ser.serialize_field("adjustResistanceLevel", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GymAssist {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "heart_rate",
            "heartRate",
            "adjust_speed",
            "adjustSpeed",
            "adjust_pace",
            "adjustPace",
            "adjust_resistance_level",
            "adjustResistanceLevel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HeartRate,
            AdjustSpeed,
            AdjustPace,
            AdjustResistanceLevel,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "adjustSpeed" | "adjust_speed" => Ok(GeneratedField::AdjustSpeed),
                            "adjustPace" | "adjust_pace" => Ok(GeneratedField::AdjustPace),
                            "adjustResistanceLevel" | "adjust_resistance_level" => Ok(GeneratedField::AdjustResistanceLevel),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GymAssist;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GYMAssist")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GymAssist, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut heart_rate__ = None;
                let mut adjust_speed__ = None;
                let mut adjust_pace__ = None;
                let mut adjust_resistance_level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AdjustSpeed => {
                            if adjust_speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adjustSpeed"));
                            }
                            adjust_speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AdjustPace => {
                            if adjust_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adjustPace"));
                            }
                            adjust_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AdjustResistanceLevel => {
                            if adjust_resistance_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("adjustResistanceLevel"));
                            }
                            adjust_resistance_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GymAssist {
                    heart_rate: heart_rate__,
                    adjust_speed: adjust_speed__,
                    adjust_pace: adjust_pace__,
                    adjust_resistance_level: adjust_resistance_level__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.GYMAssist", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GymCapability {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GymSaveData => "GYM_SAVE_DATA",
            Self::GymReceiveAssist => "GYM_RECEIVE_ASSIST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for GymCapability {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GYM_SAVE_DATA",
            "GYM_RECEIVE_ASSIST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GymCapability;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GYM_SAVE_DATA" => Ok(GymCapability::GymSaveData),
                    "GYM_RECEIVE_ASSIST" => Ok(GymCapability::GymReceiveAssist),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GymData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.calories.is_some() {
            len += 1;
        }
        if self.heart_rate.is_some() {
            len += 1;
        }
        if self.distance.is_some() {
            len += 1;
        }
        if self.steps.is_some() {
            len += 1;
        }
        if self.step_frequency.is_some() {
            len += 1;
        }
        if self.current_pace.is_some() {
            len += 1;
        }
        if self.speed.is_some() {
            len += 1;
        }
        if self.current_rpm.is_some() {
            len += 1;
        }
        if self.revolution_count.is_some() {
            len += 1;
        }
        if self.current_power.is_some() {
            len += 1;
        }
        if self.current_resistance_level.is_some() {
            len += 1;
        }
        if self.jump_count.is_some() {
            len += 1;
        }
        if self.jump_height.is_some() {
            len += 1;
        }
        if self.stumble_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.GYMData", len)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        if let Some(v) = self.calories.as_ref() {
            struct_ser.serialize_field("calories", v)?;
        }
        if let Some(v) = self.heart_rate.as_ref() {
            struct_ser.serialize_field("heartRate", v)?;
        }
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        if let Some(v) = self.steps.as_ref() {
            struct_ser.serialize_field("steps", v)?;
        }
        if let Some(v) = self.step_frequency.as_ref() {
            struct_ser.serialize_field("stepFrequency", v)?;
        }
        if let Some(v) = self.current_pace.as_ref() {
            struct_ser.serialize_field("currentPace", v)?;
        }
        if let Some(v) = self.speed.as_ref() {
            struct_ser.serialize_field("speed", v)?;
        }
        if let Some(v) = self.current_rpm.as_ref() {
            struct_ser.serialize_field("currentRpm", v)?;
        }
        if let Some(v) = self.revolution_count.as_ref() {
            struct_ser.serialize_field("revolutionCount", v)?;
        }
        if let Some(v) = self.current_power.as_ref() {
            struct_ser.serialize_field("currentPower", v)?;
        }
        if let Some(v) = self.current_resistance_level.as_ref() {
            struct_ser.serialize_field("currentResistanceLevel", v)?;
        }
        if let Some(v) = self.jump_count.as_ref() {
            struct_ser.serialize_field("jumpCount", v)?;
        }
        if let Some(v) = self.jump_height.as_ref() {
            struct_ser.serialize_field("jumpHeight", v)?;
        }
        if let Some(v) = self.stumble_count.as_ref() {
            struct_ser.serialize_field("stumbleCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GymData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "duration",
            "calories",
            "heart_rate",
            "heartRate",
            "distance",
            "steps",
            "step_frequency",
            "stepFrequency",
            "current_pace",
            "currentPace",
            "speed",
            "current_rpm",
            "currentRpm",
            "revolution_count",
            "revolutionCount",
            "current_power",
            "currentPower",
            "current_resistance_level",
            "currentResistanceLevel",
            "jump_count",
            "jumpCount",
            "jump_height",
            "jumpHeight",
            "stumble_count",
            "stumbleCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Duration,
            Calories,
            HeartRate,
            Distance,
            Steps,
            StepFrequency,
            CurrentPace,
            Speed,
            CurrentRpm,
            RevolutionCount,
            CurrentPower,
            CurrentResistanceLevel,
            JumpCount,
            JumpHeight,
            StumbleCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "duration" => Ok(GeneratedField::Duration),
                            "calories" => Ok(GeneratedField::Calories),
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "distance" => Ok(GeneratedField::Distance),
                            "steps" => Ok(GeneratedField::Steps),
                            "stepFrequency" | "step_frequency" => Ok(GeneratedField::StepFrequency),
                            "currentPace" | "current_pace" => Ok(GeneratedField::CurrentPace),
                            "speed" => Ok(GeneratedField::Speed),
                            "currentRpm" | "current_rpm" => Ok(GeneratedField::CurrentRpm),
                            "revolutionCount" | "revolution_count" => Ok(GeneratedField::RevolutionCount),
                            "currentPower" | "current_power" => Ok(GeneratedField::CurrentPower),
                            "currentResistanceLevel" | "current_resistance_level" => Ok(GeneratedField::CurrentResistanceLevel),
                            "jumpCount" | "jump_count" => Ok(GeneratedField::JumpCount),
                            "jumpHeight" | "jump_height" => Ok(GeneratedField::JumpHeight),
                            "stumbleCount" | "stumble_count" => Ok(GeneratedField::StumbleCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GymData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GYMData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GymData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut duration__ = None;
                let mut calories__ = None;
                let mut heart_rate__ = None;
                let mut distance__ = None;
                let mut steps__ = None;
                let mut step_frequency__ = None;
                let mut current_pace__ = None;
                let mut speed__ = None;
                let mut current_rpm__ = None;
                let mut revolution_count__ = None;
                let mut current_power__ = None;
                let mut current_resistance_level__ = None;
                let mut jump_count__ = None;
                let mut jump_height__ = None;
                let mut stumble_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Steps => {
                            if steps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("steps"));
                            }
                            steps__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StepFrequency => {
                            if step_frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stepFrequency"));
                            }
                            step_frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentPace => {
                            if current_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPace"));
                            }
                            current_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Speed => {
                            if speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speed"));
                            }
                            speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentRpm => {
                            if current_rpm__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentRpm"));
                            }
                            current_rpm__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RevolutionCount => {
                            if revolution_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("revolutionCount"));
                            }
                            revolution_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentPower => {
                            if current_power__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPower"));
                            }
                            current_power__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentResistanceLevel => {
                            if current_resistance_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentResistanceLevel"));
                            }
                            current_resistance_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::JumpCount => {
                            if jump_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jumpCount"));
                            }
                            jump_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::JumpHeight => {
                            if jump_height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jumpHeight"));
                            }
                            jump_height__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StumbleCount => {
                            if stumble_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stumbleCount"));
                            }
                            stumble_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GymData {
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    calories: calories__,
                    heart_rate: heart_rate__,
                    distance: distance__,
                    steps: steps__,
                    step_frequency: step_frequency__,
                    current_pace: current_pace__,
                    speed: speed__,
                    current_rpm: current_rpm__,
                    revolution_count: revolution_count__,
                    current_power: current_power__,
                    current_resistance_level: current_resistance_level__,
                    jump_count: jump_count__,
                    jump_height: jump_height__,
                    stumble_count: stumble_count__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.GYMData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GymRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 5;
        if self.main_sport_type.is_some() {
            len += 1;
        }
        if !self.sport_target_list.is_empty() {
            len += 1;
        }
        if self.sport_course.is_some() {
            len += 1;
        }
        if self.gym_capability.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.GYMRequest", len)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("timezone", &self.timezone)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        if let Some(v) = self.main_sport_type.as_ref() {
            let v = SportType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("mainSportType", &v)?;
        }
        let v = SportState::try_from(self.state)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.state)))?;
        struct_ser.serialize_field("state", &v)?;
        if !self.sport_target_list.is_empty() {
            struct_ser.serialize_field("sportTargetList", &self.sport_target_list)?;
        }
        if let Some(v) = self.sport_course.as_ref() {
            struct_ser.serialize_field("sportCourse", v)?;
        }
        if let Some(v) = self.gym_capability.as_ref() {
            struct_ser.serialize_field("gymCapability", v)?;
        }
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("ids", pbjson::private::base64::encode(&self.ids).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GymRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "timezone",
            "sport_type",
            "sportType",
            "main_sport_type",
            "mainSportType",
            "state",
            "sport_target_list",
            "sportTargetList",
            "sport_course",
            "sportCourse",
            "gym_capability",
            "gymCapability",
            "ids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Timezone,
            SportType,
            MainSportType,
            State,
            SportTargetList,
            SportCourse,
            GymCapability,
            Ids,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "timezone" => Ok(GeneratedField::Timezone),
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "mainSportType" | "main_sport_type" => Ok(GeneratedField::MainSportType),
                            "state" => Ok(GeneratedField::State),
                            "sportTargetList" | "sport_target_list" => Ok(GeneratedField::SportTargetList),
                            "sportCourse" | "sport_course" => Ok(GeneratedField::SportCourse),
                            "gymCapability" | "gym_capability" => Ok(GeneratedField::GymCapability),
                            "ids" => Ok(GeneratedField::Ids),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GymRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GYMRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GymRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut timezone__ = None;
                let mut sport_type__ = None;
                let mut main_sport_type__ = None;
                let mut state__ = None;
                let mut sport_target_list__ = None;
                let mut sport_course__ = None;
                let mut gym_capability__ = None;
                let mut ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Timezone => {
                            if timezone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timezone"));
                            }
                            timezone__ = map_.next_value()?;
                        }
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::MainSportType => {
                            if main_sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainSportType"));
                            }
                            main_sport_type__ = map_.next_value::<::std::option::Option<SportType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value::<SportState>()? as i32);
                        }
                        GeneratedField::SportTargetList => {
                            if sport_target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportTargetList"));
                            }
                            sport_target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SportCourse => {
                            if sport_course__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportCourse"));
                            }
                            sport_course__ = map_.next_value()?;
                        }
                        GeneratedField::GymCapability => {
                            if gym_capability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymCapability"));
                            }
                            gym_capability__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Ids => {
                            if ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(GymRequest {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    timezone: timezone__.ok_or_else(|| serde::de::Error::missing_field("timezone"))?,
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    main_sport_type: main_sport_type__,
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    sport_target_list: sport_target_list__.unwrap_or_default(),
                    sport_course: sport_course__,
                    gym_capability: gym_capability__,
                    ids: ids__.ok_or_else(|| serde::de::Error::missing_field("ids"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.GYMRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GymResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.gym_capability.is_some() {
            len += 1;
        }
        if self.sport_status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.GYMResponse", len)?;
        let v = gym_response::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.gym_capability.as_ref() {
            struct_ser.serialize_field("gymCapability", v)?;
        }
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("ids", pbjson::private::base64::encode(&self.ids).as_str())?;
        if let Some(v) = self.sport_status.as_ref() {
            struct_ser.serialize_field("sportStatus", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GymResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "gym_capability",
            "gymCapability",
            "ids",
            "sport_status",
            "sportStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            GymCapability,
            Ids,
            SportStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "gymCapability" | "gym_capability" => Ok(GeneratedField::GymCapability),
                            "ids" => Ok(GeneratedField::Ids),
                            "sportStatus" | "sport_status" => Ok(GeneratedField::SportStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GymResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GYMResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GymResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut gym_capability__ = None;
                let mut ids__ = None;
                let mut sport_status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<gym_response::Code>()? as i32);
                        }
                        GeneratedField::GymCapability => {
                            if gym_capability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gymCapability"));
                            }
                            gym_capability__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Ids => {
                            if ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SportStatus => {
                            if sport_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportStatus"));
                            }
                            sport_status__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GymResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    gym_capability: gym_capability__,
                    ids: ids__.ok_or_else(|| serde::de::Error::missing_field("ids"))?,
                    sport_status: sport_status__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.GYMResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for gym_response::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ok => "OK",
            Self::Busy => "BUSY",
            Self::TypeNotMatch => "TYPE_NOT_MATCH",
            Self::SportNotSupport => "SPORT_NOT_SUPPORT",
            Self::LowBattery => "LOW_BATTERY",
            Self::ChildLock => "CHILD_LOCK",
            Self::SafetyLock => "SAFETY_LOCK",
            Self::DeviceLock => "DEVICE_LOCK",
            Self::DeviceInDebugMode => "DEVICE_IN_DEBUG_MODE",
            Self::DeviceInOta => "DEVICE_IN_OTA",
            Self::Unknown => "UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for gym_response::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OK",
            "BUSY",
            "TYPE_NOT_MATCH",
            "SPORT_NOT_SUPPORT",
            "LOW_BATTERY",
            "CHILD_LOCK",
            "SAFETY_LOCK",
            "DEVICE_LOCK",
            "DEVICE_IN_DEBUG_MODE",
            "DEVICE_IN_OTA",
            "UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = gym_response::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OK" => Ok(gym_response::Code::Ok),
                    "BUSY" => Ok(gym_response::Code::Busy),
                    "TYPE_NOT_MATCH" => Ok(gym_response::Code::TypeNotMatch),
                    "SPORT_NOT_SUPPORT" => Ok(gym_response::Code::SportNotSupport),
                    "LOW_BATTERY" => Ok(gym_response::Code::LowBattery),
                    "CHILD_LOCK" => Ok(gym_response::Code::ChildLock),
                    "SAFETY_LOCK" => Ok(gym_response::Code::SafetyLock),
                    "DEVICE_LOCK" => Ok(gym_response::Code::DeviceLock),
                    "DEVICE_IN_DEBUG_MODE" => Ok(gym_response::Code::DeviceInDebugMode),
                    "DEVICE_IN_OTA" => Ok(gym_response::Code::DeviceInOta),
                    "UNKNOWN" => Ok(gym_response::Code::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GymSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.GYMSetting", len)?;
        let v = gym_setting::Key::try_from(self.key)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.key)))?;
        struct_ser.serialize_field("key", &v)?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GymSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GymSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GYMSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GymSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = Some(map_.next_value::<gym_setting::Key>()? as i32);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(GymSetting {
                    key: key__.ok_or_else(|| serde::de::Error::missing_field("key"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.GYMSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for gym_setting::Key {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ChildLock => "CHILD_LOCK",
            Self::SafetyLock => "SAFETY_LOCK",
            Self::DeviceLock => "DEVICE_LOCK",
            Self::DeviceInDebugMode => "DEVICE_IN_DEBUG_MODE",
            Self::SpeedUpLimit => "SPEED_UP_LIMIT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for gym_setting::Key {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CHILD_LOCK",
            "SAFETY_LOCK",
            "DEVICE_LOCK",
            "DEVICE_IN_DEBUG_MODE",
            "SPEED_UP_LIMIT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = gym_setting::Key;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CHILD_LOCK" => Ok(gym_setting::Key::ChildLock),
                    "SAFETY_LOCK" => Ok(gym_setting::Key::SafetyLock),
                    "DEVICE_LOCK" => Ok(gym_setting::Key::DeviceLock),
                    "DEVICE_IN_DEBUG_MODE" => Ok(gym_setting::Key::DeviceInDebugMode),
                    "SPEED_UP_LIMIT" => Ok(gym_setting::Key::SpeedUpLimit),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for gym_setting::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.GYMSetting.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for gym_setting::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = gym_setting::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GYMSetting.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<gym_setting::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(gym_setting::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.GYMSetting.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Gnss {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Gnss", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                gnss::Payload::Days(v) => {
                    struct_ser.serialize_field("days", v)?;
                }
                gnss::Payload::Data(v) => {
                    struct_ser.serialize_field("data", v)?;
                }
                gnss::Payload::GpsInfo(v) => {
                    struct_ser.serialize_field("gpsInfo", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Gnss {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "days",
            "data",
            "gps_info",
            "gpsInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Days,
            Data,
            GpsInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "days" => Ok(GeneratedField::Days),
                            "data" => Ok(GeneratedField::Data),
                            "gpsInfo" | "gps_info" => Ok(GeneratedField::GpsInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Gnss;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Gnss")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Gnss, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Days => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("days"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| gnss::Payload::Days(x.0));
                        }
                        GeneratedField::Data => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(gnss::Payload::Data)
;
                        }
                        GeneratedField::GpsInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gpsInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(gnss::Payload::GpsInfo)
;
                        }
                    }
                }
                Ok(Gnss {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Gnss", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for gnss::GnssId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::RequestOnline => "REQUEST_ONLINE",
            Self::RequestOffline => "REQUEST_OFFLINE",
            Self::RequestGpsInfo => "REQUEST_GPS_INFO",
            Self::SendGpsInfo => "SEND_GPS_INFO",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for gnss::GnssId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "REQUEST_ONLINE",
            "REQUEST_OFFLINE",
            "REQUEST_GPS_INFO",
            "SEND_GPS_INFO",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = gnss::GnssId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "REQUEST_ONLINE" => Ok(gnss::GnssId::RequestOnline),
                    "REQUEST_OFFLINE" => Ok(gnss::GnssId::RequestOffline),
                    "REQUEST_GPS_INFO" => Ok(gnss::GnssId::RequestGpsInfo),
                    "SEND_GPS_INFO" => Ok(gnss::GnssId::SendGpsInfo),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Goal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Goal", len)?;
        let v = goal::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Goal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Goal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Goal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Goal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<goal::Type>()? as i32);
                        }
                    }
                }
                Ok(Goal {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Goal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for goal::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.current_goals.is_empty() {
            len += 1;
        }
        if !self.supported_goals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Goal.Status", len)?;
        if !self.current_goals.is_empty() {
            struct_ser.serialize_field("currentGoals", &self.current_goals)?;
        }
        if !self.supported_goals.is_empty() {
            struct_ser.serialize_field("supportedGoals", &self.supported_goals)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for goal::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "current_goals",
            "currentGoals",
            "supported_goals",
            "supportedGoals",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurrentGoals,
            SupportedGoals,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "currentGoals" | "current_goals" => Ok(GeneratedField::CurrentGoals),
                            "supportedGoals" | "supported_goals" => Ok(GeneratedField::SupportedGoals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = goal::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Goal.Status")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<goal::Status, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut current_goals__ = None;
                let mut supported_goals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurrentGoals => {
                            if current_goals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentGoals"));
                            }
                            current_goals__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportedGoals => {
                            if supported_goals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportedGoals"));
                            }
                            supported_goals__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(goal::Status {
                    current_goals: current_goals__.unwrap_or_default(),
                    supported_goals: supported_goals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Goal.Status", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for goal::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Step => "STEP",
            Self::Calorie => "CALORIE",
            Self::Intensity => "INTENSITY",
            Self::Stand => "STAND",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for goal::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "STEP",
            "CALORIE",
            "INTENSITY",
            "STAND",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = goal::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "STEP" => Ok(goal::Type::Step),
                    "CALORIE" => Ok(goal::Type::Calorie),
                    "INTENSITY" => Ok(goal::Type::Intensity),
                    "STAND" => Ok(goal::Type::Stand),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GpsAccuracy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GpsLow => "GPS_LOW",
            Self::GpsMedium => "GPS_MEDIUM",
            Self::GpsHigh => "GPS_HIGH",
            Self::GpsUnknown => "GPS_UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for GpsAccuracy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GPS_LOW",
            "GPS_MEDIUM",
            "GPS_HIGH",
            "GPS_UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GpsAccuracy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GPS_LOW" => Ok(GpsAccuracy::GpsLow),
                    "GPS_MEDIUM" => Ok(GpsAccuracy::GpsMedium),
                    "GPS_HIGH" => Ok(GpsAccuracy::GpsHigh),
                    "GPS_UNKNOWN" => Ok(GpsAccuracy::GpsUnknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GpsInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.altitude.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.GpsInfo", len)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("longitude", &self.longitude)?;
        struct_ser.serialize_field("latitude", &self.latitude)?;
        if let Some(v) = self.altitude.as_ref() {
            struct_ser.serialize_field("altitude", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GpsInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "longitude",
            "latitude",
            "altitude",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Longitude,
            Latitude,
            Altitude,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "longitude" => Ok(GeneratedField::Longitude),
                            "latitude" => Ok(GeneratedField::Latitude),
                            "altitude" => Ok(GeneratedField::Altitude),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GpsInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.GpsInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GpsInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut longitude__ = None;
                let mut latitude__ = None;
                let mut altitude__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Longitude => {
                            if longitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("longitude"));
                            }
                            longitude__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Latitude => {
                            if latitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("latitude"));
                            }
                            latitude__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Altitude => {
                            if altitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("altitude"));
                            }
                            altitude__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GpsInfo {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    longitude: longitude__.ok_or_else(|| serde::de::Error::missing_field("longitude"))?,
                    latitude: latitude__.ok_or_else(|| serde::de::Error::missing_field("latitude"))?,
                    altitude: altitude__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.GpsInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HeadsetControl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.voice_mode.is_some() {
            len += 1;
        }
        if self.multi_connection.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.HeadsetControl", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        if let Some(v) = self.voice_mode.as_ref() {
            struct_ser.serialize_field("voiceMode", v)?;
        }
        if let Some(v) = self.multi_connection.as_ref() {
            struct_ser.serialize_field("multiConnection", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HeadsetControl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "voice_mode",
            "voiceMode",
            "multi_connection",
            "multiConnection",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            VoiceMode,
            MultiConnection,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "voiceMode" | "voice_mode" => Ok(GeneratedField::VoiceMode),
                            "multiConnection" | "multi_connection" => Ok(GeneratedField::MultiConnection),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HeadsetControl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HeadsetControl")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HeadsetControl, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut voice_mode__ = None;
                let mut multi_connection__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VoiceMode => {
                            if voice_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("voiceMode"));
                            }
                            voice_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MultiConnection => {
                            if multi_connection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multiConnection"));
                            }
                            multi_connection__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(HeadsetControl {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    voice_mode: voice_mode__,
                    multi_connection: multi_connection__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HeadsetControl", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HeadsetInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.HeadsetInfo", len)?;
        struct_ser.serialize_field("voiceMode", &self.voice_mode)?;
        struct_ser.serialize_field("multiConnection", &self.multi_connection)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HeadsetInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "voice_mode",
            "voiceMode",
            "multi_connection",
            "multiConnection",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VoiceMode,
            MultiConnection,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "voiceMode" | "voice_mode" => Ok(GeneratedField::VoiceMode),
                            "multiConnection" | "multi_connection" => Ok(GeneratedField::MultiConnection),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HeadsetInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HeadsetInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HeadsetInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut voice_mode__ = None;
                let mut multi_connection__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VoiceMode => {
                            if voice_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("voiceMode"));
                            }
                            voice_mode__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MultiConnection => {
                            if multi_connection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multiConnection"));
                            }
                            multi_connection__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(HeadsetInfo {
                    voice_mode: voice_mode__.ok_or_else(|| serde::de::Error::missing_field("voiceMode"))?,
                    multi_connection: multi_connection__.ok_or_else(|| serde::de::Error::missing_field("multiConnection"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HeadsetInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HeartRateMonitor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.support_intelligent_monitor.is_some() {
            len += 1;
        }
        if self.warning_low.is_some() {
            len += 1;
        }
        if self.abnormal_cardiac.is_some() {
            len += 1;
        }
        if self.assit_sleep.is_some() {
            len += 1;
        }
        if self.sleep_breathe_quality.is_some() {
            len += 1;
        }
        if self.warning_sport.is_some() {
            len += 1;
        }
        if self.sleep_breathe_rate.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.HeartRateMonitor", len)?;
        let v = heart_rate_monitor::Mode::try_from(self.mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.mode)))?;
        struct_ser.serialize_field("mode", &v)?;
        struct_ser.serialize_field("frequency", &self.frequency)?;
        if let Some(v) = self.support_intelligent_monitor.as_ref() {
            struct_ser.serialize_field("supportIntelligentMonitor", v)?;
        }
        struct_ser.serialize_field("warning", &self.warning)?;
        struct_ser.serialize_field("warningValue", &self.warning_value)?;
        if let Some(v) = self.warning_low.as_ref() {
            struct_ser.serialize_field("warningLow", v)?;
        }
        if let Some(v) = self.abnormal_cardiac.as_ref() {
            let v = OptionalSwitcher::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("abnormalCardiac", &v)?;
        }
        if let Some(v) = self.assit_sleep.as_ref() {
            struct_ser.serialize_field("assitSleep", v)?;
        }
        if let Some(v) = self.sleep_breathe_quality.as_ref() {
            let v = OptionalSwitcher::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sleepBreatheQuality", &v)?;
        }
        if let Some(v) = self.warning_sport.as_ref() {
            struct_ser.serialize_field("warningSport", v)?;
        }
        if let Some(v) = self.sleep_breathe_rate.as_ref() {
            let v = OptionalSwitcher::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sleepBreatheRate", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HeartRateMonitor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mode",
            "frequency",
            "support_intelligent_monitor",
            "supportIntelligentMonitor",
            "warning",
            "warning_value",
            "warningValue",
            "warning_low",
            "warningLow",
            "abnormal_cardiac",
            "abnormalCardiac",
            "assit_sleep",
            "assitSleep",
            "sleep_breathe_quality",
            "sleepBreatheQuality",
            "warning_sport",
            "warningSport",
            "sleep_breathe_rate",
            "sleepBreatheRate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mode,
            Frequency,
            SupportIntelligentMonitor,
            Warning,
            WarningValue,
            WarningLow,
            AbnormalCardiac,
            AssitSleep,
            SleepBreatheQuality,
            WarningSport,
            SleepBreatheRate,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mode" => Ok(GeneratedField::Mode),
                            "frequency" => Ok(GeneratedField::Frequency),
                            "supportIntelligentMonitor" | "support_intelligent_monitor" => Ok(GeneratedField::SupportIntelligentMonitor),
                            "warning" => Ok(GeneratedField::Warning),
                            "warningValue" | "warning_value" => Ok(GeneratedField::WarningValue),
                            "warningLow" | "warning_low" => Ok(GeneratedField::WarningLow),
                            "abnormalCardiac" | "abnormal_cardiac" => Ok(GeneratedField::AbnormalCardiac),
                            "assitSleep" | "assit_sleep" => Ok(GeneratedField::AssitSleep),
                            "sleepBreatheQuality" | "sleep_breathe_quality" => Ok(GeneratedField::SleepBreatheQuality),
                            "warningSport" | "warning_sport" => Ok(GeneratedField::WarningSport),
                            "sleepBreatheRate" | "sleep_breathe_rate" => Ok(GeneratedField::SleepBreatheRate),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HeartRateMonitor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HeartRateMonitor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HeartRateMonitor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mode__ = None;
                let mut frequency__ = None;
                let mut support_intelligent_monitor__ = None;
                let mut warning__ = None;
                let mut warning_value__ = None;
                let mut warning_low__ = None;
                let mut abnormal_cardiac__ = None;
                let mut assit_sleep__ = None;
                let mut sleep_breathe_quality__ = None;
                let mut warning_sport__ = None;
                let mut sleep_breathe_rate__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = Some(map_.next_value::<heart_rate_monitor::Mode>()? as i32);
                        }
                        GeneratedField::Frequency => {
                            if frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frequency"));
                            }
                            frequency__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SupportIntelligentMonitor => {
                            if support_intelligent_monitor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportIntelligentMonitor"));
                            }
                            support_intelligent_monitor__ = map_.next_value()?;
                        }
                        GeneratedField::Warning => {
                            if warning__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warning"));
                            }
                            warning__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WarningValue => {
                            if warning_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warningValue"));
                            }
                            warning_value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::WarningLow => {
                            if warning_low__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warningLow"));
                            }
                            warning_low__ = map_.next_value()?;
                        }
                        GeneratedField::AbnormalCardiac => {
                            if abnormal_cardiac__.is_some() {
                                return Err(serde::de::Error::duplicate_field("abnormalCardiac"));
                            }
                            abnormal_cardiac__ = map_.next_value::<::std::option::Option<OptionalSwitcher>>()?.map(|x| x as i32);
                        }
                        GeneratedField::AssitSleep => {
                            if assit_sleep__.is_some() {
                                return Err(serde::de::Error::duplicate_field("assitSleep"));
                            }
                            assit_sleep__ = map_.next_value()?;
                        }
                        GeneratedField::SleepBreatheQuality => {
                            if sleep_breathe_quality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepBreatheQuality"));
                            }
                            sleep_breathe_quality__ = map_.next_value::<::std::option::Option<OptionalSwitcher>>()?.map(|x| x as i32);
                        }
                        GeneratedField::WarningSport => {
                            if warning_sport__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warningSport"));
                            }
                            warning_sport__ = map_.next_value()?;
                        }
                        GeneratedField::SleepBreatheRate => {
                            if sleep_breathe_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepBreatheRate"));
                            }
                            sleep_breathe_rate__ = map_.next_value::<::std::option::Option<OptionalSwitcher>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(HeartRateMonitor {
                    mode: mode__.ok_or_else(|| serde::de::Error::missing_field("mode"))?,
                    frequency: frequency__.ok_or_else(|| serde::de::Error::missing_field("frequency"))?,
                    support_intelligent_monitor: support_intelligent_monitor__,
                    warning: warning__.ok_or_else(|| serde::de::Error::missing_field("warning"))?,
                    warning_value: warning_value__.ok_or_else(|| serde::de::Error::missing_field("warningValue"))?,
                    warning_low: warning_low__,
                    abnormal_cardiac: abnormal_cardiac__,
                    assit_sleep: assit_sleep__,
                    sleep_breathe_quality: sleep_breathe_quality__,
                    warning_sport: warning_sport__,
                    sleep_breathe_rate: sleep_breathe_rate__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HeartRateMonitor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for heart_rate_monitor::AssistSleep {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.HeartRateMonitor.AssistSleep", len)?;
        struct_ser.serialize_field("on", &self.on)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for heart_rate_monitor::AssistSleep {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "on",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            On,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "on" => Ok(GeneratedField::On),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = heart_rate_monitor::AssistSleep;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HeartRateMonitor.AssistSleep")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<heart_rate_monitor::AssistSleep, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut on__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::On => {
                            if on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("on"));
                            }
                            on__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(heart_rate_monitor::AssistSleep {
                    on: on__.ok_or_else(|| serde::de::Error::missing_field("on"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HeartRateMonitor.AssistSleep", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for heart_rate_monitor::Mode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Auto => "AUTO",
            Self::Off => "OFF",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for heart_rate_monitor::Mode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AUTO",
            "OFF",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = heart_rate_monitor::Mode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "AUTO" => Ok(heart_rate_monitor::Mode::Auto),
                    "OFF" => Ok(heart_rate_monitor::Mode::Off),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for HeartRateSection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::HrNone => "HR_NONE",
            Self::WarmUp => "WARM_UP",
            Self::FatBurning => "FAT_BURNING",
            Self::Aerobic => "AEROBIC",
            Self::Anaerobic => "ANAEROBIC",
            Self::Extreme => "EXTREME",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for HeartRateSection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HR_NONE",
            "WARM_UP",
            "FAT_BURNING",
            "AEROBIC",
            "ANAEROBIC",
            "EXTREME",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HeartRateSection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "HR_NONE" => Ok(HeartRateSection::HrNone),
                    "WARM_UP" => Ok(HeartRateSection::WarmUp),
                    "FAT_BURNING" => Ok(HeartRateSection::FatBurning),
                    "AEROBIC" => Ok(HeartRateSection::Aerobic),
                    "ANAEROBIC" => Ok(HeartRateSection::Anaerobic),
                    "EXTREME" => Ok(HeartRateSection::Extreme),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for HelpRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sms_number.is_empty() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.HelpRequest", len)?;
        if !self.sms_number.is_empty() {
            struct_ser.serialize_field("smsNumber", &self.sms_number)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HelpRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sms_number",
            "smsNumber",
            "reason",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SmsNumber,
            Reason,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "smsNumber" | "sms_number" => Ok(GeneratedField::SmsNumber),
                            "reason" => Ok(GeneratedField::Reason),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HelpRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HelpRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HelpRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sms_number__ = None;
                let mut reason__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SmsNumber => {
                            if sms_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("smsNumber"));
                            }
                            sms_number__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(HelpRequest {
                    sms_number: sms_number__.unwrap_or_default(),
                    reason: reason__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HelpRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HidStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.HidStatus", len)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HidStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Enable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enable" => Ok(GeneratedField::Enable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HidStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HidStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HidStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(HidStatus {
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HidStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HttpRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.HttpRequest", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("xid", ToString::to_string(&self.xid).as_str())?;
        struct_ser.serialize_field("url", &self.url)?;
        struct_ser.serialize_field("payload", &self.payload)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HttpRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xid",
            "url",
            "payload",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xid,
            Url,
            Payload,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xid" => Ok(GeneratedField::Xid),
                            "url" => Ok(GeneratedField::Url),
                            "payload" => Ok(GeneratedField::Payload),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HttpRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HttpRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HttpRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xid__ = None;
                let mut url__ = None;
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xid => {
                            if xid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xid"));
                            }
                            xid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Url => {
                            if url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("url"));
                            }
                            url__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Payload => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("payload"));
                            }
                            payload__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(HttpRequest {
                    xid: xid__.ok_or_else(|| serde::de::Error::missing_field("xid"))?,
                    url: url__.ok_or_else(|| serde::de::Error::missing_field("url"))?,
                    payload: payload__.ok_or_else(|| serde::de::Error::missing_field("payload"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HttpRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HttpResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.HttpResponse", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("xid", ToString::to_string(&self.xid).as_str())?;
        struct_ser.serialize_field("statusCode", &self.status_code)?;
        struct_ser.serialize_field("result", &self.result)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HttpResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "xid",
            "status_code",
            "statusCode",
            "result",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Xid,
            StatusCode,
            Result,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "xid" => Ok(GeneratedField::Xid),
                            "statusCode" | "status_code" => Ok(GeneratedField::StatusCode),
                            "result" => Ok(GeneratedField::Result),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HttpResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.HttpResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HttpResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut xid__ = None;
                let mut status_code__ = None;
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Xid => {
                            if xid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("xid"));
                            }
                            xid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::StatusCode => {
                            if status_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("statusCode"));
                            }
                            status_code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(HttpResponse {
                    xid: xid__.ok_or_else(|| serde::de::Error::missing_field("xid"))?,
                    status_code: status_code__.ok_or_else(|| serde::de::Error::missing_field("statusCode"))?,
                    result: result__.ok_or_else(|| serde::de::Error::missing_field("result"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.HttpResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ImageFormat {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Rgb565 => "RGB_565",
            Self::Rgb565Swap => "RGB_565_SWAP",
            Self::Argb8888Le => "ARGB_8888_LE",
            Self::Argb8888 => "ARGB_8888",
            Self::Rgb888 => "RGB888",
            Self::Argb8565Le => "ARGB_8565_LE",
            Self::Argb8565 => "ARGB_8565",
            Self::Jpeg => "JPEG",
            Self::Png => "PNG",
            Self::Gif => "GIF",
            Self::Vector => "VECTOR",
            Self::Mp4 => "MP4",
            Self::Ezip => "EZIP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ImageFormat {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RGB_565",
            "RGB_565_SWAP",
            "ARGB_8888_LE",
            "ARGB_8888",
            "RGB888",
            "ARGB_8565_LE",
            "ARGB_8565",
            "JPEG",
            "PNG",
            "GIF",
            "VECTOR",
            "MP4",
            "EZIP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ImageFormat;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "RGB_565" => Ok(ImageFormat::Rgb565),
                    "RGB_565_SWAP" => Ok(ImageFormat::Rgb565Swap),
                    "ARGB_8888_LE" => Ok(ImageFormat::Argb8888Le),
                    "ARGB_8888" => Ok(ImageFormat::Argb8888),
                    "RGB888" => Ok(ImageFormat::Rgb888),
                    "ARGB_8565_LE" => Ok(ImageFormat::Argb8565Le),
                    "ARGB_8565" => Ok(ImageFormat::Argb8565),
                    "JPEG" => Ok(ImageFormat::Jpeg),
                    "PNG" => Ok(ImageFormat::Png),
                    "GIF" => Ok(ImageFormat::Gif),
                    "VECTOR" => Ok(ImageFormat::Vector),
                    "MP4" => Ok(ImageFormat::Mp4),
                    "EZIP" => Ok(ImageFormat::Ezip),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for InstallCode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::VersionDowngrade => "VERSION_DOWNGRADE",
            Self::LatestVersion => "LATEST_VERSION",
            Self::ApkNotFound => "APK_NOT_FOUND",
            Self::WaitingDownload => "WAITING_DOWNLOAD",
            Self::Downloading => "DOWNLOADING",
            Self::DownloadFailed => "DOWNLOAD_FAILED",
            Self::Installing => "INSTALLING",
            Self::InstallSuccess => "INSTALL_SUCCESS",
            Self::InstallFailed => "INSTALL_FAILED",
            Self::Cancelled => "CANCELLED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for InstallCode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VERSION_DOWNGRADE",
            "LATEST_VERSION",
            "APK_NOT_FOUND",
            "WAITING_DOWNLOAD",
            "DOWNLOADING",
            "DOWNLOAD_FAILED",
            "INSTALLING",
            "INSTALL_SUCCESS",
            "INSTALL_FAILED",
            "CANCELLED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InstallCode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "VERSION_DOWNGRADE" => Ok(InstallCode::VersionDowngrade),
                    "LATEST_VERSION" => Ok(InstallCode::LatestVersion),
                    "APK_NOT_FOUND" => Ok(InstallCode::ApkNotFound),
                    "WAITING_DOWNLOAD" => Ok(InstallCode::WaitingDownload),
                    "DOWNLOADING" => Ok(InstallCode::Downloading),
                    "DOWNLOAD_FAILED" => Ok(InstallCode::DownloadFailed),
                    "INSTALLING" => Ok(InstallCode::Installing),
                    "INSTALL_SUCCESS" => Ok(InstallCode::InstallSuccess),
                    "INSTALL_FAILED" => Ok(InstallCode::InstallFailed),
                    "CANCELLED" => Ok(InstallCode::Cancelled),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for InstallProgress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.download_progress.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.InstallProgress", len)?;
        let v = InstallCode::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        if let Some(v) = self.download_progress.as_ref() {
            struct_ser.serialize_field("downloadProgress", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InstallProgress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "package_name",
            "packageName",
            "download_progress",
            "downloadProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            PackageName,
            DownloadProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "downloadProgress" | "download_progress" => Ok(GeneratedField::DownloadProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InstallProgress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.InstallProgress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InstallProgress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut package_name__ = None;
                let mut download_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<InstallCode>()? as i32);
                        }
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DownloadProgress => {
                            if download_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("downloadProgress"));
                            }
                            download_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(InstallProgress {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                    download_progress: download_progress__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.InstallProgress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InstallResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.support_edit.is_some() {
            len += 1;
        }
        if self.support_image_format.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.InstallResult", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        let v = install_result::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.support_edit.as_ref() {
            struct_ser.serialize_field("supportEdit", v)?;
        }
        if let Some(v) = self.support_image_format.as_ref() {
            let v = ImageFormat::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("supportImageFormat", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InstallResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "code",
            "support_edit",
            "supportEdit",
            "support_image_format",
            "supportImageFormat",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Code,
            SupportEdit,
            SupportImageFormat,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "code" => Ok(GeneratedField::Code),
                            "supportEdit" | "support_edit" => Ok(GeneratedField::SupportEdit),
                            "supportImageFormat" | "support_image_format" => Ok(GeneratedField::SupportImageFormat),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InstallResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.InstallResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InstallResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut code__ = None;
                let mut support_edit__ = None;
                let mut support_image_format__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<install_result::Code>()? as i32);
                        }
                        GeneratedField::SupportEdit => {
                            if support_edit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportEdit"));
                            }
                            support_edit__ = map_.next_value()?;
                        }
                        GeneratedField::SupportImageFormat => {
                            if support_image_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportImageFormat"));
                            }
                            support_image_format__ = map_.next_value::<::std::option::Option<ImageFormat>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(InstallResult {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    support_edit: support_edit__,
                    support_image_format: support_image_format__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.InstallResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for install_result::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::VerifyFailed => "VERIFY_FAILED",
            Self::InstallFailed => "INSTALL_FAILED",
            Self::InstallSuccess => "INSTALL_SUCCESS",
            Self::InstallUsed => "INSTALL_USED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for install_result::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VERIFY_FAILED",
            "INSTALL_FAILED",
            "INSTALL_SUCCESS",
            "INSTALL_USED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = install_result::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "VERIFY_FAILED" => Ok(install_result::Code::VerifyFailed),
                    "INSTALL_FAILED" => Ok(install_result::Code::InstallFailed),
                    "INSTALL_SUCCESS" => Ok(install_result::Code::InstallSuccess),
                    "INSTALL_USED" => Ok(install_result::Code::InstallUsed),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Interconnection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Interconnection", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                interconnection::Payload::PhoneStatus(v) => {
                    struct_ser.serialize_field("phoneStatus", v)?;
                }
                interconnection::Payload::ShareDevices(v) => {
                    struct_ser.serialize_field("shareDevices", v)?;
                }
                interconnection::Payload::ShareDevice(v) => {
                    struct_ser.serialize_field("shareDevice", v)?;
                }
                interconnection::Payload::AudioControl(v) => {
                    struct_ser.serialize_field("audioControl", v)?;
                }
                interconnection::Payload::TvControl(v) => {
                    struct_ser.serialize_field("tvControl", v)?;
                }
                interconnection::Payload::HeadsetControl(v) => {
                    struct_ser.serialize_field("headsetControl", v)?;
                }
                interconnection::Payload::ControlResult(v) => {
                    struct_ser.serialize_field("controlResult", v)?;
                }
                interconnection::Payload::ProjectionDevices(v) => {
                    struct_ser.serialize_field("projectionDevices", v)?;
                }
                interconnection::Payload::ProjectionRequest(v) => {
                    struct_ser.serialize_field("projectionRequest", v)?;
                }
                interconnection::Payload::ProjectionResponse(v) => {
                    struct_ser.serialize_field("projectionResponse", v)?;
                }
                interconnection::Payload::ProjectionData(v) => {
                    struct_ser.serialize_field("projectionData", v)?;
                }
                interconnection::Payload::RequestInfo(v) => {
                    struct_ser.serialize_field("requestInfo", v)?;
                }
                interconnection::Payload::ProjectionReport(v) => {
                    struct_ser.serialize_field("projectionReport", v)?;
                }
                interconnection::Payload::ProjectionMembers(v) => {
                    struct_ser.serialize_field("projectionMembers", v)?;
                }
                interconnection::Payload::CourseZone(v) => {
                    struct_ser.serialize_field("courseZone", v)?;
                }
                interconnection::Payload::PhoneUsage(v) => {
                    struct_ser.serialize_field("phoneUsage", v)?;
                }
                interconnection::Payload::PhoneTrace(v) => {
                    struct_ser.serialize_field("phoneTrace", v)?;
                }
                interconnection::Payload::MishowSlideRequest(v) => {
                    struct_ser.serialize_field("mishowSlideRequest", v)?;
                }
                interconnection::Payload::MishowDemo(v) => {
                    struct_ser.serialize_field("mishowDemo", v)?;
                }
                interconnection::Payload::MisDevices(v) => {
                    struct_ser.serialize_field("misDevices", v)?;
                }
                interconnection::Payload::WearSpecBasic(v) => {
                    struct_ser.serialize_field("wearSpecBasic", v)?;
                }
                interconnection::Payload::MisPayload(v) => {
                    struct_ser.serialize_field("misPayload", v)?;
                }
                interconnection::Payload::CertServerRequest(v) => {
                    struct_ser.serialize_field("certServerRequest", v)?;
                }
                interconnection::Payload::CertDeviceRequest(v) => {
                    struct_ser.serialize_field("certDeviceRequest", v)?;
                }
                interconnection::Payload::CertResponse(v) => {
                    struct_ser.serialize_field("certResponse", v)?;
                }
                interconnection::Payload::PropRequest(v) => {
                    struct_ser.serialize_field("propRequest", v)?;
                }
                interconnection::Payload::PropResponse(v) => {
                    struct_ser.serialize_field("propResponse", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Interconnection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "phone_status",
            "phoneStatus",
            "share_devices",
            "shareDevices",
            "share_device",
            "shareDevice",
            "audio_control",
            "audioControl",
            "tv_control",
            "tvControl",
            "headset_control",
            "headsetControl",
            "control_result",
            "controlResult",
            "projection_devices",
            "projectionDevices",
            "projection_request",
            "projectionRequest",
            "projection_response",
            "projectionResponse",
            "projection_data",
            "projectionData",
            "request_info",
            "requestInfo",
            "projection_report",
            "projectionReport",
            "projection_members",
            "projectionMembers",
            "course_zone",
            "courseZone",
            "phone_usage",
            "phoneUsage",
            "phone_trace",
            "phoneTrace",
            "mishow_slide_request",
            "mishowSlideRequest",
            "mishow_demo",
            "mishowDemo",
            "mis_devices",
            "misDevices",
            "wear_spec_basic",
            "wearSpecBasic",
            "mis_payload",
            "misPayload",
            "cert_server_request",
            "certServerRequest",
            "cert_device_request",
            "certDeviceRequest",
            "cert_response",
            "certResponse",
            "prop_request",
            "propRequest",
            "prop_response",
            "propResponse",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PhoneStatus,
            ShareDevices,
            ShareDevice,
            AudioControl,
            TvControl,
            HeadsetControl,
            ControlResult,
            ProjectionDevices,
            ProjectionRequest,
            ProjectionResponse,
            ProjectionData,
            RequestInfo,
            ProjectionReport,
            ProjectionMembers,
            CourseZone,
            PhoneUsage,
            PhoneTrace,
            MishowSlideRequest,
            MishowDemo,
            MisDevices,
            WearSpecBasic,
            MisPayload,
            CertServerRequest,
            CertDeviceRequest,
            CertResponse,
            PropRequest,
            PropResponse,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "phoneStatus" | "phone_status" => Ok(GeneratedField::PhoneStatus),
                            "shareDevices" | "share_devices" => Ok(GeneratedField::ShareDevices),
                            "shareDevice" | "share_device" => Ok(GeneratedField::ShareDevice),
                            "audioControl" | "audio_control" => Ok(GeneratedField::AudioControl),
                            "tvControl" | "tv_control" => Ok(GeneratedField::TvControl),
                            "headsetControl" | "headset_control" => Ok(GeneratedField::HeadsetControl),
                            "controlResult" | "control_result" => Ok(GeneratedField::ControlResult),
                            "projectionDevices" | "projection_devices" => Ok(GeneratedField::ProjectionDevices),
                            "projectionRequest" | "projection_request" => Ok(GeneratedField::ProjectionRequest),
                            "projectionResponse" | "projection_response" => Ok(GeneratedField::ProjectionResponse),
                            "projectionData" | "projection_data" => Ok(GeneratedField::ProjectionData),
                            "requestInfo" | "request_info" => Ok(GeneratedField::RequestInfo),
                            "projectionReport" | "projection_report" => Ok(GeneratedField::ProjectionReport),
                            "projectionMembers" | "projection_members" => Ok(GeneratedField::ProjectionMembers),
                            "courseZone" | "course_zone" => Ok(GeneratedField::CourseZone),
                            "phoneUsage" | "phone_usage" => Ok(GeneratedField::PhoneUsage),
                            "phoneTrace" | "phone_trace" => Ok(GeneratedField::PhoneTrace),
                            "mishowSlideRequest" | "mishow_slide_request" => Ok(GeneratedField::MishowSlideRequest),
                            "mishowDemo" | "mishow_demo" => Ok(GeneratedField::MishowDemo),
                            "misDevices" | "mis_devices" => Ok(GeneratedField::MisDevices),
                            "wearSpecBasic" | "wear_spec_basic" => Ok(GeneratedField::WearSpecBasic),
                            "misPayload" | "mis_payload" => Ok(GeneratedField::MisPayload),
                            "certServerRequest" | "cert_server_request" => Ok(GeneratedField::CertServerRequest),
                            "certDeviceRequest" | "cert_device_request" => Ok(GeneratedField::CertDeviceRequest),
                            "certResponse" | "cert_response" => Ok(GeneratedField::CertResponse),
                            "propRequest" | "prop_request" => Ok(GeneratedField::PropRequest),
                            "propResponse" | "prop_response" => Ok(GeneratedField::PropResponse),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Interconnection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Interconnection")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Interconnection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PhoneStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::PhoneStatus)
;
                        }
                        GeneratedField::ShareDevices => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shareDevices"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ShareDevices)
;
                        }
                        GeneratedField::ShareDevice => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shareDevice"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ShareDevice)
;
                        }
                        GeneratedField::AudioControl => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("audioControl"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::AudioControl)
;
                        }
                        GeneratedField::TvControl => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tvControl"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::TvControl)
;
                        }
                        GeneratedField::HeadsetControl => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("headsetControl"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::HeadsetControl)
;
                        }
                        GeneratedField::ControlResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("controlResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ControlResult)
;
                        }
                        GeneratedField::ProjectionDevices => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectionDevices"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ProjectionDevices)
;
                        }
                        GeneratedField::ProjectionRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectionRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ProjectionRequest)
;
                        }
                        GeneratedField::ProjectionResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectionResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ProjectionResponse)
;
                        }
                        GeneratedField::ProjectionData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectionData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ProjectionData)
;
                        }
                        GeneratedField::RequestInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requestInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::RequestInfo)
;
                        }
                        GeneratedField::ProjectionReport => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectionReport"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ProjectionReport)
;
                        }
                        GeneratedField::ProjectionMembers => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectionMembers"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::ProjectionMembers)
;
                        }
                        GeneratedField::CourseZone => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("courseZone"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::CourseZone)
;
                        }
                        GeneratedField::PhoneUsage => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneUsage"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::PhoneUsage)
;
                        }
                        GeneratedField::PhoneTrace => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneTrace"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::PhoneTrace)
;
                        }
                        GeneratedField::MishowSlideRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mishowSlideRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::MishowSlideRequest)
;
                        }
                        GeneratedField::MishowDemo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mishowDemo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::MishowDemo)
;
                        }
                        GeneratedField::MisDevices => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("misDevices"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::MisDevices)
;
                        }
                        GeneratedField::WearSpecBasic => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearSpecBasic"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::WearSpecBasic)
;
                        }
                        GeneratedField::MisPayload => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("misPayload"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::MisPayload)
;
                        }
                        GeneratedField::CertServerRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("certServerRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::CertServerRequest)
;
                        }
                        GeneratedField::CertDeviceRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("certDeviceRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::CertDeviceRequest)
;
                        }
                        GeneratedField::CertResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("certResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::CertResponse)
;
                        }
                        GeneratedField::PropRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("propRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::PropRequest)
;
                        }
                        GeneratedField::PropResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("propResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(interconnection::Payload::PropResponse)
;
                        }
                    }
                }
                Ok(Interconnection {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Interconnection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for interconnection::InterconnectionId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::RequestPhoneStatus => "REQUEST_PHONE_STATUS",
            Self::SyncPhoneStatus => "SYNC_PHONE_STATUS",
            Self::RegisterPhoneUsage => "REGISTER_PHONE_USAGE",
            Self::UnregisterPhoneUsage => "UNREGISTER_PHONE_USAGE",
            Self::SendPhoneUsage => "SEND_PHONE_USAGE",
            Self::StartPhoneTrace => "START_PHONE_TRACE",
            Self::FinishPhoneTrace => "FINISH_PHONE_TRACE",
            Self::SendPhoneTrace => "SEND_PHONE_TRACE",
            Self::ReqeustShareDevices => "REQEUST_SHARE_DEVICES",
            Self::SyncShareDevices => "SYNC_SHARE_DEVICES",
            Self::UpdateShareDevice => "UPDATE_SHARE_DEVICE",
            Self::ControlAudio => "CONTROL_AUDIO",
            Self::ControlTv => "CONTROL_TV",
            Self::ControlHeadset => "CONTROL_HEADSET",
            Self::SendControlResult => "SEND_CONTROL_RESULT",
            Self::RequestProjectionDevices => "REQUEST_PROJECTION_DEVICES",
            Self::SyncProjectionDevices => "SYNC_PROJECTION_DEVICES",
            Self::RequestProjection => "REQUEST_PROJECTION",
            Self::SendProjectionResponse => "SEND_PROJECTION_RESPONSE",
            Self::ReportProjectionData => "REPORT_PROJECTION_DATA",
            Self::ReportProjectionReport => "REPORT_PROJECTION_REPORT",
            Self::NotifyProjectionMembers => "NOTIFY_PROJECTION_MEMBERS",
            Self::EnterCourseZone => "ENTER_COURSE_ZONE",
            Self::StartSlideShow => "START_SLIDE_SHOW",
            Self::StopSlideShow => "STOP_SLIDE_SHOW",
            Self::StartDemoShow => "START_DEMO_SHOW",
            Self::StopDemoShow => "STOP_DEMO_SHOW",
            Self::SubscribeMisDevice => "SUBSCRIBE_MIS_DEVICE",
            Self::UnsubscribeMisDevice => "UNSUBSCRIBE_MIS_DEVICE",
            Self::SyncMisDevice => "SYNC_MIS_DEVICE",
            Self::PublishMisSpec => "PUBLISH_MIS_SPEC",
            Self::ReportMisSpec => "REPORT_MIS_SPEC",
            Self::GetWearSpecBasic => "GET_WEAR_SPEC_BASIC",
            Self::SendMisPacket => "SEND_MIS_PACKET",
            Self::RequestServerCert => "REQUEST_SERVER_CERT",
            Self::ResponseServerCert => "RESPONSE_SERVER_CERT",
            Self::RequestDeviceCert => "REQUEST_DEVICE_CERT",
            Self::ResponseDeviceCert => "RESPONSE_DEVICE_CERT",
            Self::RequestProps => "REQUEST_PROPS",
            Self::ResponseProps => "RESPONSE_PROPS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for interconnection::InterconnectionId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "REQUEST_PHONE_STATUS",
            "SYNC_PHONE_STATUS",
            "REGISTER_PHONE_USAGE",
            "UNREGISTER_PHONE_USAGE",
            "SEND_PHONE_USAGE",
            "START_PHONE_TRACE",
            "FINISH_PHONE_TRACE",
            "SEND_PHONE_TRACE",
            "REQEUST_SHARE_DEVICES",
            "SYNC_SHARE_DEVICES",
            "UPDATE_SHARE_DEVICE",
            "CONTROL_AUDIO",
            "CONTROL_TV",
            "CONTROL_HEADSET",
            "SEND_CONTROL_RESULT",
            "REQUEST_PROJECTION_DEVICES",
            "SYNC_PROJECTION_DEVICES",
            "REQUEST_PROJECTION",
            "SEND_PROJECTION_RESPONSE",
            "REPORT_PROJECTION_DATA",
            "REPORT_PROJECTION_REPORT",
            "NOTIFY_PROJECTION_MEMBERS",
            "ENTER_COURSE_ZONE",
            "START_SLIDE_SHOW",
            "STOP_SLIDE_SHOW",
            "START_DEMO_SHOW",
            "STOP_DEMO_SHOW",
            "SUBSCRIBE_MIS_DEVICE",
            "UNSUBSCRIBE_MIS_DEVICE",
            "SYNC_MIS_DEVICE",
            "PUBLISH_MIS_SPEC",
            "REPORT_MIS_SPEC",
            "GET_WEAR_SPEC_BASIC",
            "SEND_MIS_PACKET",
            "REQUEST_SERVER_CERT",
            "RESPONSE_SERVER_CERT",
            "REQUEST_DEVICE_CERT",
            "RESPONSE_DEVICE_CERT",
            "REQUEST_PROPS",
            "RESPONSE_PROPS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = interconnection::InterconnectionId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "REQUEST_PHONE_STATUS" => Ok(interconnection::InterconnectionId::RequestPhoneStatus),
                    "SYNC_PHONE_STATUS" => Ok(interconnection::InterconnectionId::SyncPhoneStatus),
                    "REGISTER_PHONE_USAGE" => Ok(interconnection::InterconnectionId::RegisterPhoneUsage),
                    "UNREGISTER_PHONE_USAGE" => Ok(interconnection::InterconnectionId::UnregisterPhoneUsage),
                    "SEND_PHONE_USAGE" => Ok(interconnection::InterconnectionId::SendPhoneUsage),
                    "START_PHONE_TRACE" => Ok(interconnection::InterconnectionId::StartPhoneTrace),
                    "FINISH_PHONE_TRACE" => Ok(interconnection::InterconnectionId::FinishPhoneTrace),
                    "SEND_PHONE_TRACE" => Ok(interconnection::InterconnectionId::SendPhoneTrace),
                    "REQEUST_SHARE_DEVICES" => Ok(interconnection::InterconnectionId::ReqeustShareDevices),
                    "SYNC_SHARE_DEVICES" => Ok(interconnection::InterconnectionId::SyncShareDevices),
                    "UPDATE_SHARE_DEVICE" => Ok(interconnection::InterconnectionId::UpdateShareDevice),
                    "CONTROL_AUDIO" => Ok(interconnection::InterconnectionId::ControlAudio),
                    "CONTROL_TV" => Ok(interconnection::InterconnectionId::ControlTv),
                    "CONTROL_HEADSET" => Ok(interconnection::InterconnectionId::ControlHeadset),
                    "SEND_CONTROL_RESULT" => Ok(interconnection::InterconnectionId::SendControlResult),
                    "REQUEST_PROJECTION_DEVICES" => Ok(interconnection::InterconnectionId::RequestProjectionDevices),
                    "SYNC_PROJECTION_DEVICES" => Ok(interconnection::InterconnectionId::SyncProjectionDevices),
                    "REQUEST_PROJECTION" => Ok(interconnection::InterconnectionId::RequestProjection),
                    "SEND_PROJECTION_RESPONSE" => Ok(interconnection::InterconnectionId::SendProjectionResponse),
                    "REPORT_PROJECTION_DATA" => Ok(interconnection::InterconnectionId::ReportProjectionData),
                    "REPORT_PROJECTION_REPORT" => Ok(interconnection::InterconnectionId::ReportProjectionReport),
                    "NOTIFY_PROJECTION_MEMBERS" => Ok(interconnection::InterconnectionId::NotifyProjectionMembers),
                    "ENTER_COURSE_ZONE" => Ok(interconnection::InterconnectionId::EnterCourseZone),
                    "START_SLIDE_SHOW" => Ok(interconnection::InterconnectionId::StartSlideShow),
                    "STOP_SLIDE_SHOW" => Ok(interconnection::InterconnectionId::StopSlideShow),
                    "START_DEMO_SHOW" => Ok(interconnection::InterconnectionId::StartDemoShow),
                    "STOP_DEMO_SHOW" => Ok(interconnection::InterconnectionId::StopDemoShow),
                    "SUBSCRIBE_MIS_DEVICE" => Ok(interconnection::InterconnectionId::SubscribeMisDevice),
                    "UNSUBSCRIBE_MIS_DEVICE" => Ok(interconnection::InterconnectionId::UnsubscribeMisDevice),
                    "SYNC_MIS_DEVICE" => Ok(interconnection::InterconnectionId::SyncMisDevice),
                    "PUBLISH_MIS_SPEC" => Ok(interconnection::InterconnectionId::PublishMisSpec),
                    "REPORT_MIS_SPEC" => Ok(interconnection::InterconnectionId::ReportMisSpec),
                    "GET_WEAR_SPEC_BASIC" => Ok(interconnection::InterconnectionId::GetWearSpecBasic),
                    "SEND_MIS_PACKET" => Ok(interconnection::InterconnectionId::SendMisPacket),
                    "REQUEST_SERVER_CERT" => Ok(interconnection::InterconnectionId::RequestServerCert),
                    "RESPONSE_SERVER_CERT" => Ok(interconnection::InterconnectionId::ResponseServerCert),
                    "REQUEST_DEVICE_CERT" => Ok(interconnection::InterconnectionId::RequestDeviceCert),
                    "RESPONSE_DEVICE_CERT" => Ok(interconnection::InterconnectionId::ResponseDeviceCert),
                    "REQUEST_PROPS" => Ok(interconnection::InterconnectionId::RequestProps),
                    "RESPONSE_PROPS" => Ok(interconnection::InterconnectionId::ResponseProps),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for IssueCard {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.need_read_card.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.IssueCard", len)?;
        let v = IssueCardStatus::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = IssueCardType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.need_read_card.as_ref() {
            struct_ser.serialize_field("needReadCard", v)?;
        }
        struct_ser.serialize_field("iconUrl", &self.icon_url)?;
        struct_ser.serialize_field("sid", &self.sid)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IssueCard {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
            "type",
            "need_read_card",
            "needReadCard",
            "icon_url",
            "iconUrl",
            "sid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            Type,
            NeedReadCard,
            IconUrl,
            Sid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "type" => Ok(GeneratedField::Type),
                            "needReadCard" | "need_read_card" => Ok(GeneratedField::NeedReadCard),
                            "iconUrl" | "icon_url" => Ok(GeneratedField::IconUrl),
                            "sid" => Ok(GeneratedField::Sid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IssueCard;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.IssueCard")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IssueCard, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut r#type__ = None;
                let mut need_read_card__ = None;
                let mut icon_url__ = None;
                let mut sid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<IssueCardStatus>()? as i32);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<IssueCardType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::NeedReadCard => {
                            if need_read_card__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needReadCard"));
                            }
                            need_read_card__ = map_.next_value()?;
                        }
                        GeneratedField::IconUrl => {
                            if icon_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iconUrl"));
                            }
                            icon_url__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sid => {
                            if sid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sid"));
                            }
                            sid__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(IssueCard {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    r#type: r#type__,
                    need_read_card: need_read_card__,
                    icon_url: icon_url__.ok_or_else(|| serde::de::Error::missing_field("iconUrl"))?,
                    sid: sid__.ok_or_else(|| serde::de::Error::missing_field("sid"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.IssueCard", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IssueCardStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Start => "START",
            Self::Continue => "CONTINUE",
            Self::Success => "SUCCESS",
            Self::Failure => "FAILURE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for IssueCardStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "START",
            "CONTINUE",
            "SUCCESS",
            "FAILURE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IssueCardStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "START" => Ok(IssueCardStatus::Start),
                    "CONTINUE" => Ok(IssueCardStatus::Continue),
                    "SUCCESS" => Ok(IssueCardStatus::Success),
                    "FAILURE" => Ok(IssueCardStatus::Failure),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for IssueCardType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DoorCard => "DOOR_CARD",
            Self::BusCard => "BUS_CARD",
            Self::UnionPayCard => "UNION_PAY_CARD",
            Self::CloudCard => "CLOUD_CARD",
            Self::MasterCard => "MASTER_CARD",
            Self::CarKey => "CAR_KEY",
            Self::CarKeyIccoa => "CAR_KEY_ICCOA",
            Self::CarKeyByd => "CAR_KEY_BYD",
            Self::EasyCard => "EASY_CARD",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for IssueCardType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DOOR_CARD",
            "BUS_CARD",
            "UNION_PAY_CARD",
            "CLOUD_CARD",
            "MASTER_CARD",
            "CAR_KEY",
            "CAR_KEY_ICCOA",
            "CAR_KEY_BYD",
            "EASY_CARD",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IssueCardType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DOOR_CARD" => Ok(IssueCardType::DoorCard),
                    "BUS_CARD" => Ok(IssueCardType::BusCard),
                    "UNION_PAY_CARD" => Ok(IssueCardType::UnionPayCard),
                    "CLOUD_CARD" => Ok(IssueCardType::CloudCard),
                    "MASTER_CARD" => Ok(IssueCardType::MasterCard),
                    "CAR_KEY" => Ok(IssueCardType::CarKey),
                    "CAR_KEY_ICCOA" => Ok(IssueCardType::CarKeyIccoa),
                    "CAR_KEY_BYD" => Ok(IssueCardType::CarKeyByd),
                    "EASY_CARD" => Ok(IssueCardType::EasyCard),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for KeyValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.KeyValue", len)?;
        struct_ser.serialize_field("key", &self.key)?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for KeyValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = KeyValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.KeyValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<KeyValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(KeyValue {
                    key: key__.ok_or_else(|| serde::de::Error::missing_field("key"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.KeyValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for KeyValueStr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.KeyValueStr", len)?;
        struct_ser.serialize_field("key", &self.key)?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for KeyValueStr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = KeyValueStr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.KeyValueStr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<KeyValueStr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(KeyValueStr {
                    key: key__.ok_or_else(|| serde::de::Error::missing_field("key"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.KeyValueStr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Llm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.LLM", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Llm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Llm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Llm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Llm {
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::DeclarationContent {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LLM.DeclarationContent", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::DeclarationContent {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::DeclarationContent;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.DeclarationContent")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::DeclarationContent, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(llm::DeclarationContent {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.DeclarationContent", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::IllegalContent {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LLM.IllegalContent", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::IllegalContent {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::IllegalContent;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.IllegalContent")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::IllegalContent, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(llm::IllegalContent {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.IllegalContent", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::IssueImage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.LLM.IssueImage", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::IssueImage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::IssueImage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.IssueImage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::IssueImage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(llm::IssueImage {
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.IssueImage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::issue_image::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LLM.IssueImage.Request", len)?;
        struct_ser.serialize_field("sessionId", &self.session_id)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::issue_image::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "session_id",
            "sessionId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SessionId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sessionId" | "session_id" => Ok(GeneratedField::SessionId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::issue_image::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.IssueImage.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::issue_image::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut session_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SessionId => {
                            if session_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sessionId"));
                            }
                            session_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(llm::issue_image::Request {
                    session_id: session_id__.ok_or_else(|| serde::de::Error::missing_field("sessionId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.IssueImage.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::issue_image::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.support_image_format.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.LLM.IssueImage.Response", len)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.support_image_format.as_ref() {
            let v = ImageFormat::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("supportImageFormat", &v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::issue_image::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prepare_status",
            "prepareStatus",
            "support_image_format",
            "supportImageFormat",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrepareStatus,
            SupportImageFormat,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "supportImageFormat" | "support_image_format" => Ok(GeneratedField::SupportImageFormat),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::issue_image::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.IssueImage.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::issue_image::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prepare_status__ = None;
                let mut support_image_format__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::SupportImageFormat => {
                            if support_image_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportImageFormat"));
                            }
                            support_image_format__ = map_.next_value::<::std::option::Option<ImageFormat>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(llm::issue_image::Response {
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    support_image_format: support_image_format__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.IssueImage.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::LoadingCard {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LLM.LoadingCard", len)?;
        struct_ser.serialize_field("timeout", &self.timeout)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::LoadingCard {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timeout",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timeout,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timeout" => Ok(GeneratedField::Timeout),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::LoadingCard;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.LoadingCard")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::LoadingCard, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timeout__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timeout => {
                            if timeout__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timeout"));
                            }
                            timeout__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(llm::LoadingCard {
                    timeout: timeout__.ok_or_else(|| serde::de::Error::missing_field("timeout"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.LoadingCard", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for llm::ToastStream {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LLM.ToastStream", len)?;
        struct_ser.serialize_field("markdownText", &self.markdown_text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for llm::ToastStream {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "markdown_text",
            "markdownText",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarkdownText,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "markdownText" | "markdown_text" => Ok(GeneratedField::MarkdownText),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = llm::ToastStream;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LLM.ToastStream")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<llm::ToastStream, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut markdown_text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarkdownText => {
                            if markdown_text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("markdownText"));
                            }
                            markdown_text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(llm::ToastStream {
                    markdown_text: markdown_text__.ok_or_else(|| serde::de::Error::missing_field("markdownText"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LLM.ToastStream", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Language {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Language", len)?;
        struct_ser.serialize_field("locale", &self.locale)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Language {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "locale",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Locale,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "locale" => Ok(GeneratedField::Locale),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Language;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Language")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Language, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut locale__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Locale => {
                            if locale__.is_some() {
                                return Err(serde::de::Error::duplicate_field("locale"));
                            }
                            locale__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Language {
                    locale: locale__.ok_or_else(|| serde::de::Error::missing_field("locale"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Language", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LaunchInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.LaunchInfo", len)?;
        struct_ser.serialize_field("basicInfo", &self.basic_info)?;
        struct_ser.serialize_field("uri", &self.uri)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LaunchInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_info",
            "basicInfo",
            "uri",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicInfo,
            Uri,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "uri" => Ok(GeneratedField::Uri),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LaunchInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LaunchInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LaunchInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_info__ = None;
                let mut uri__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicInfo => {
                            if basic_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            basic_info__ = map_.next_value()?;
                        }
                        GeneratedField::Uri => {
                            if uri__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uri"));
                            }
                            uri__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(LaunchInfo {
                    basic_info: basic_info__.ok_or_else(|| serde::de::Error::missing_field("basicInfo"))?,
                    uri: uri__.ok_or_else(|| serde::de::Error::missing_field("uri"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LaunchInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LauncherLaunchApp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LauncherLaunchApp", len)?;
        struct_ser.serialize_field("intent", &self.intent)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LauncherLaunchApp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "intent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Intent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "intent" => Ok(GeneratedField::Intent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LauncherLaunchApp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LauncherLaunchApp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LauncherLaunchApp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut intent__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Intent => {
                            if intent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("intent"));
                            }
                            intent__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LauncherLaunchApp {
                    intent: intent__.ok_or_else(|| serde::de::Error::missing_field("intent"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LauncherLaunchApp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LimitValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.LimitValue", len)?;
        struct_ser.serialize_field("current", &self.current)?;
        struct_ser.serialize_field("max", &self.max)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LimitValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "current",
            "max",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Current,
            Max,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "current" => Ok(GeneratedField::Current),
                            "max" => Ok(GeneratedField::Max),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LimitValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LimitValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LimitValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut current__ = None;
                let mut max__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Current => {
                            if current__.is_some() {
                                return Err(serde::de::Error::duplicate_field("current"));
                            }
                            current__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Max => {
                            if max__.is_some() {
                                return Err(serde::de::Error::duplicate_field("max"));
                            }
                            max__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(LimitValue {
                    current: current__.ok_or_else(|| serde::de::Error::missing_field("current"))?,
                    max: max__.ok_or_else(|| serde::de::Error::missing_field("max"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LimitValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListsItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.ListsItem", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListsItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "text",
            "skill_description",
            "skillDescription",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Text,
            SkillDescription,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "text" => Ok(GeneratedField::Text),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListsItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ListsItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListsItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut text__ = None;
                let mut skill_description__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ListsItem {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ListsItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for lists_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ListsItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for lists_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = lists_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ListsItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<lists_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(lists_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ListsItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LockScreen {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.locked.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.LockScreen", len)?;
        let v = lock_screen::Status::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        struct_ser.serialize_field("pwd", &self.pwd)?;
        if let Some(v) = self.locked.as_ref() {
            struct_ser.serialize_field("locked", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LockScreen {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
            "pwd",
            "locked",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            Pwd,
            Locked,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "pwd" => Ok(GeneratedField::Pwd),
                            "locked" => Ok(GeneratedField::Locked),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LockScreen;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LockScreen")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LockScreen, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut pwd__ = None;
                let mut locked__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<lock_screen::Status>()? as i32);
                        }
                        GeneratedField::Pwd => {
                            if pwd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pwd"));
                            }
                            pwd__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Locked => {
                            if locked__.is_some() {
                                return Err(serde::de::Error::duplicate_field("locked"));
                            }
                            locked__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LockScreen {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    pwd: pwd__.ok_or_else(|| serde::de::Error::missing_field("pwd"))?,
                    locked: locked__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LockScreen", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for lock_screen::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Disabled => "DISABLED",
            Self::Enabled => "ENABLED",
            Self::EnabledAndRequired => "ENABLED_AND_REQUIRED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for lock_screen::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DISABLED",
            "ENABLED",
            "ENABLED_AND_REQUIRED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = lock_screen::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DISABLED" => Ok(lock_screen::Status::Disabled),
                    "ENABLED" => Ok(lock_screen::Status::Enabled),
                    "ENABLED_AND_REQUIRED" => Ok(lock_screen::Status::EnabledAndRequired),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Login {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Login", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Login {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Login;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Login")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Login, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Login {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Login", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for login::PassTokenApply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.Login.PassTokenApply", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("transactionId", ToString::to_string(&self.transaction_id).as_str())?;
        struct_ser.serialize_field("ua", &self.ua)?;
        struct_ser.serialize_field("nonce", &self.nonce)?;
        struct_ser.serialize_field("sign", &self.sign)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for login::PassTokenApply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction_id",
            "transactionId",
            "ua",
            "nonce",
            "sign",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TransactionId,
            Ua,
            Nonce,
            Sign,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transactionId" | "transaction_id" => Ok(GeneratedField::TransactionId),
                            "ua" => Ok(GeneratedField::Ua),
                            "nonce" => Ok(GeneratedField::Nonce),
                            "sign" => Ok(GeneratedField::Sign),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = login::PassTokenApply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Login.PassTokenApply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<login::PassTokenApply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction_id__ = None;
                let mut ua__ = None;
                let mut nonce__ = None;
                let mut sign__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TransactionId => {
                            if transaction_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactionId"));
                            }
                            transaction_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Ua => {
                            if ua__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ua"));
                            }
                            ua__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Nonce => {
                            if nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonce"));
                            }
                            nonce__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sign => {
                            if sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sign"));
                            }
                            sign__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(login::PassTokenApply {
                    transaction_id: transaction_id__.ok_or_else(|| serde::de::Error::missing_field("transactionId"))?,
                    ua: ua__.ok_or_else(|| serde::de::Error::missing_field("ua"))?,
                    nonce: nonce__.ok_or_else(|| serde::de::Error::missing_field("nonce"))?,
                    sign: sign__.ok_or_else(|| serde::de::Error::missing_field("sign"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Login.PassTokenApply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for login::PassTokenReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Login.PassTokenReply", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("transactionId", ToString::to_string(&self.transaction_id).as_str())?;
        struct_ser.serialize_field("loginData", &self.login_data)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for login::PassTokenReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction_id",
            "transactionId",
            "login_data",
            "loginData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TransactionId,
            LoginData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transactionId" | "transaction_id" => Ok(GeneratedField::TransactionId),
                            "loginData" | "login_data" => Ok(GeneratedField::LoginData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = login::PassTokenReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Login.PassTokenReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<login::PassTokenReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction_id__ = None;
                let mut login_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TransactionId => {
                            if transaction_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactionId"));
                            }
                            transaction_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::LoginData => {
                            if login_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("loginData"));
                            }
                            login_data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(login::PassTokenReply {
                    transaction_id: transaction_id__.ok_or_else(|| serde::de::Error::missing_field("transactionId"))?,
                    login_data: login_data__.ok_or_else(|| serde::de::Error::missing_field("loginData"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Login.PassTokenReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for login::StatusChange {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Login.StatusChange", len)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for login::StatusChange {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = login::StatusChange;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Login.StatusChange")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<login::StatusChange, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(login::StatusChange {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Login.StatusChange", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LowLatency {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.LowLatency", len)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LowLatency {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "duration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Duration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "duration" => Ok(GeneratedField::Duration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LowLatency;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.LowLatency")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LowLatency, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(LowLatency {
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.LowLatency", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Lpa {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Lpa", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                lpa::Payload::Data(v) => {
                    struct_ser.serialize_field("data", v)?;
                }
                lpa::Payload::EuiccInfo(v) => {
                    struct_ser.serialize_field("euiccInfo", v)?;
                }
                lpa::Payload::ProfileList(v) => {
                    struct_ser.serialize_field("profileList", v)?;
                }
                lpa::Payload::ProfileOperator(v) => {
                    struct_ser.serialize_field("profileOperator", v)?;
                }
                lpa::Payload::OperateResult(v) => {
                    struct_ser.serialize_field("operateResult", v)?;
                }
                lpa::Payload::ProfilePrepare(v) => {
                    struct_ser.serialize_field("profilePrepare", v)?;
                }
                lpa::Payload::ProfileDownload(v) => {
                    struct_ser.serialize_field("profileDownload", v)?;
                }
                lpa::Payload::DownloadResult(v) => {
                    struct_ser.serialize_field("downloadResult", v)?;
                }
                lpa::Payload::HttpRequest(v) => {
                    struct_ser.serialize_field("httpRequest", v)?;
                }
                lpa::Payload::HttpResponse(v) => {
                    struct_ser.serialize_field("httpResponse", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Lpa {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "data",
            "euicc_info",
            "euiccInfo",
            "profile_list",
            "profileList",
            "profile_operator",
            "profileOperator",
            "operate_result",
            "operateResult",
            "profile_prepare",
            "profilePrepare",
            "profile_download",
            "profileDownload",
            "download_result",
            "downloadResult",
            "http_request",
            "httpRequest",
            "http_response",
            "httpResponse",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Data,
            EuiccInfo,
            ProfileList,
            ProfileOperator,
            OperateResult,
            ProfilePrepare,
            ProfileDownload,
            DownloadResult,
            HttpRequest,
            HttpResponse,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "data" => Ok(GeneratedField::Data),
                            "euiccInfo" | "euicc_info" => Ok(GeneratedField::EuiccInfo),
                            "profileList" | "profile_list" => Ok(GeneratedField::ProfileList),
                            "profileOperator" | "profile_operator" => Ok(GeneratedField::ProfileOperator),
                            "operateResult" | "operate_result" => Ok(GeneratedField::OperateResult),
                            "profilePrepare" | "profile_prepare" => Ok(GeneratedField::ProfilePrepare),
                            "profileDownload" | "profile_download" => Ok(GeneratedField::ProfileDownload),
                            "downloadResult" | "download_result" => Ok(GeneratedField::DownloadResult),
                            "httpRequest" | "http_request" => Ok(GeneratedField::HttpRequest),
                            "httpResponse" | "http_response" => Ok(GeneratedField::HttpResponse),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Lpa;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Lpa")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Lpa, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Data => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::Data);
                        }
                        GeneratedField::EuiccInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("euiccInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::EuiccInfo)
;
                        }
                        GeneratedField::ProfileList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("profileList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::ProfileList)
;
                        }
                        GeneratedField::ProfileOperator => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("profileOperator"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::ProfileOperator)
;
                        }
                        GeneratedField::OperateResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operateResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::OperateResult)
;
                        }
                        GeneratedField::ProfilePrepare => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("profilePrepare"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::ProfilePrepare)
;
                        }
                        GeneratedField::ProfileDownload => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("profileDownload"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::ProfileDownload)
;
                        }
                        GeneratedField::DownloadResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("downloadResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::DownloadResult)
;
                        }
                        GeneratedField::HttpRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("httpRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::HttpRequest)
;
                        }
                        GeneratedField::HttpResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("httpResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(lpa::Payload::HttpResponse)
;
                        }
                    }
                }
                Ok(Lpa {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Lpa", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for lpa::LpaId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Command => "COMMAND",
            Self::GetEuiccInfo => "GET_EUICC_INFO",
            Self::GetProfileList => "GET_PROFILE_LIST",
            Self::OperateProfile => "OPERATE_PROFILE",
            Self::ReportOperateResult => "REPORT_OPERATE_RESULT",
            Self::PrepareDownloadProfile => "PREPARE_DOWNLOAD_PROFILE",
            Self::DownloadProfile => "DOWNLOAD_PROFILE",
            Self::ReportDownloadProgress => "REPORT_DOWNLOAD_PROGRESS",
            Self::RequestHttp => "REQUEST_HTTP",
            Self::ResponseHttp => "RESPONSE_HTTP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for lpa::LpaId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COMMAND",
            "GET_EUICC_INFO",
            "GET_PROFILE_LIST",
            "OPERATE_PROFILE",
            "REPORT_OPERATE_RESULT",
            "PREPARE_DOWNLOAD_PROFILE",
            "DOWNLOAD_PROFILE",
            "REPORT_DOWNLOAD_PROGRESS",
            "REQUEST_HTTP",
            "RESPONSE_HTTP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = lpa::LpaId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COMMAND" => Ok(lpa::LpaId::Command),
                    "GET_EUICC_INFO" => Ok(lpa::LpaId::GetEuiccInfo),
                    "GET_PROFILE_LIST" => Ok(lpa::LpaId::GetProfileList),
                    "OPERATE_PROFILE" => Ok(lpa::LpaId::OperateProfile),
                    "REPORT_OPERATE_RESULT" => Ok(lpa::LpaId::ReportOperateResult),
                    "PREPARE_DOWNLOAD_PROFILE" => Ok(lpa::LpaId::PrepareDownloadProfile),
                    "DOWNLOAD_PROFILE" => Ok(lpa::LpaId::DownloadProfile),
                    "REPORT_DOWNLOAD_PROGRESS" => Ok(lpa::LpaId::ReportDownloadProgress),
                    "REQUEST_HTTP" => Ok(lpa::LpaId::RequestHttp),
                    "RESPONSE_HTTP" => Ok(lpa::LpaId::ResponseHttp),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Market {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Market", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                market::Payload::Apk(v) => {
                    struct_ser.serialize_field("apk", v)?;
                }
                market::Payload::ApkList(v) => {
                    struct_ser.serialize_field("apkList", v)?;
                }
                market::Payload::InstallProgress(v) => {
                    struct_ser.serialize_field("installProgress", v)?;
                }
                market::Payload::MarketMessage(v) => {
                    struct_ser.serialize_field("marketMessage", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Market {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "apk",
            "apk_list",
            "apkList",
            "install_progress",
            "installProgress",
            "market_message",
            "marketMessage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Apk,
            ApkList,
            InstallProgress,
            MarketMessage,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "apk" => Ok(GeneratedField::Apk),
                            "apkList" | "apk_list" => Ok(GeneratedField::ApkList),
                            "installProgress" | "install_progress" => Ok(GeneratedField::InstallProgress),
                            "marketMessage" | "market_message" => Ok(GeneratedField::MarketMessage),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Market;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Market")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Market, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Apk => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apk"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(market::Payload::Apk)
;
                        }
                        GeneratedField::ApkList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("apkList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(market::Payload::ApkList)
;
                        }
                        GeneratedField::InstallProgress => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("installProgress"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(market::Payload::InstallProgress)
;
                        }
                        GeneratedField::MarketMessage => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("marketMessage"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(market::Payload::MarketMessage)
;
                        }
                    }
                }
                Ok(Market {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Market", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for market::MarketId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::TryInstallApk => "TRY_INSTALL_APK",
            Self::TryInstallApks => "TRY_INSTALL_APKS",
            Self::ReportInstallProgress => "REPORT_INSTALL_PROGRESS",
            Self::TryInstallApkNew => "TRY_INSTALL_APK_NEW",
            Self::TryInstallApksNew => "TRY_INSTALL_APKS_NEW",
            Self::SendPhoneMessage => "SEND_PHONE_MESSAGE",
            Self::SendWearMessage => "SEND_WEAR_MESSAGE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for market::MarketId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TRY_INSTALL_APK",
            "TRY_INSTALL_APKS",
            "REPORT_INSTALL_PROGRESS",
            "TRY_INSTALL_APK_NEW",
            "TRY_INSTALL_APKS_NEW",
            "SEND_PHONE_MESSAGE",
            "SEND_WEAR_MESSAGE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = market::MarketId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TRY_INSTALL_APK" => Ok(market::MarketId::TryInstallApk),
                    "TRY_INSTALL_APKS" => Ok(market::MarketId::TryInstallApks),
                    "REPORT_INSTALL_PROGRESS" => Ok(market::MarketId::ReportInstallProgress),
                    "TRY_INSTALL_APK_NEW" => Ok(market::MarketId::TryInstallApkNew),
                    "TRY_INSTALL_APKS_NEW" => Ok(market::MarketId::TryInstallApksNew),
                    "SEND_PHONE_MESSAGE" => Ok(market::MarketId::SendPhoneMessage),
                    "SEND_WEAR_MESSAGE" => Ok(market::MarketId::SendWearMessage),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MarketMessage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.MarketMessage", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("content", pbjson::private::base64::encode(&self.content).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MarketMessage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "content",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Content,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "content" => Ok(GeneratedField::Content),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarketMessage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MarketMessage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MarketMessage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut content__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MarketMessage {
                    content: content__.ok_or_else(|| serde::de::Error::missing_field("content"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MarketMessage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Mass {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Mass", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                mass::Payload::PrepareRequest(v) => {
                    struct_ser.serialize_field("prepareRequest", v)?;
                }
                mass::Payload::PrepareResponse(v) => {
                    struct_ser.serialize_field("prepareResponse", v)?;
                }
                mass::Payload::MassControl(v) => {
                    struct_ser.serialize_field("massControl", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Mass {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prepare_request",
            "prepareRequest",
            "prepare_response",
            "prepareResponse",
            "mass_control",
            "massControl",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrepareRequest,
            PrepareResponse,
            MassControl,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prepareRequest" | "prepare_request" => Ok(GeneratedField::PrepareRequest),
                            "prepareResponse" | "prepare_response" => Ok(GeneratedField::PrepareResponse),
                            "massControl" | "mass_control" => Ok(GeneratedField::MassControl),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Mass;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Mass")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Mass, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrepareRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(mass::Payload::PrepareRequest)
;
                        }
                        GeneratedField::PrepareResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(mass::Payload::PrepareResponse)
;
                        }
                        GeneratedField::MassControl => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("massControl"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(mass::Payload::MassControl)
;
                        }
                    }
                }
                Ok(Mass {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Mass", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mass::MassId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Prepare => "PREPARE",
            Self::Control => "CONTROL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for mass::MassId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PREPARE",
            "CONTROL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mass::MassId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PREPARE" => Ok(mass::MassId::Prepare),
                    "CONTROL" => Ok(mass::MassId::Control),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MassControl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.MassControl", len)?;
        let v = mass_control::Op::try_from(self.op)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op)))?;
        struct_ser.serialize_field("op", &v)?;
        struct_ser.serialize_field("dataType", &self.data_type)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("dataId", pbjson::private::base64::encode(&self.data_id).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MassControl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "op",
            "data_type",
            "dataType",
            "data_id",
            "dataId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Op,
            DataType,
            DataId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "op" => Ok(GeneratedField::Op),
                            "dataType" | "data_type" => Ok(GeneratedField::DataType),
                            "dataId" | "data_id" => Ok(GeneratedField::DataId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MassControl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MassControl")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MassControl, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op__ = None;
                let mut data_type__ = None;
                let mut data_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Op => {
                            if op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("op"));
                            }
                            op__ = Some(map_.next_value::<mass_control::Op>()? as i32);
                        }
                        GeneratedField::DataType => {
                            if data_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataType"));
                            }
                            data_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DataId => {
                            if data_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataId"));
                            }
                            data_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MassControl {
                    op: op__.ok_or_else(|| serde::de::Error::missing_field("op"))?,
                    data_type: data_type__.ok_or_else(|| serde::de::Error::missing_field("dataType"))?,
                    data_id: data_id__.ok_or_else(|| serde::de::Error::missing_field("dataId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MassControl", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mass_control::Op {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Pause => "PAUSE",
            Self::Cancel => "CANCEL",
            Self::Error => "ERROR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for mass_control::Op {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PAUSE",
            "CANCEL",
            "ERROR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mass_control::Op;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PAUSE" => Ok(mass_control::Op::Pause),
                    "CANCEL" => Ok(mass_control::Op::Cancel),
                    "ERROR" => Ok(mass_control::Op::Error),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MeasureReminder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.category.is_some() {
            len += 1;
        }
        if self.clock_mode.is_some() {
            len += 1;
        }
        if self.week_days.is_some() {
            len += 1;
        }
        if !self.times.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.MeasureReminder", len)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        if let Some(v) = self.category.as_ref() {
            let v = measure_reminder::Category::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("category", &v)?;
        }
        if let Some(v) = self.clock_mode.as_ref() {
            let v = ClockMode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("clockMode", &v)?;
        }
        if let Some(v) = self.week_days.as_ref() {
            struct_ser.serialize_field("weekDays", v)?;
        }
        if !self.times.is_empty() {
            struct_ser.serialize_field("times", &self.times)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MeasureReminder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enable",
            "category",
            "clock_mode",
            "clockMode",
            "week_days",
            "weekDays",
            "times",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Enable,
            Category,
            ClockMode,
            WeekDays,
            Times,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enable" => Ok(GeneratedField::Enable),
                            "category" => Ok(GeneratedField::Category),
                            "clockMode" | "clock_mode" => Ok(GeneratedField::ClockMode),
                            "weekDays" | "week_days" => Ok(GeneratedField::WeekDays),
                            "times" => Ok(GeneratedField::Times),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MeasureReminder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MeasureReminder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MeasureReminder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enable__ = None;
                let mut category__ = None;
                let mut clock_mode__ = None;
                let mut week_days__ = None;
                let mut times__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Category => {
                            if category__.is_some() {
                                return Err(serde::de::Error::duplicate_field("category"));
                            }
                            category__ = map_.next_value::<::std::option::Option<measure_reminder::Category>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ClockMode => {
                            if clock_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockMode"));
                            }
                            clock_mode__ = map_.next_value::<::std::option::Option<ClockMode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::WeekDays => {
                            if week_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekDays"));
                            }
                            week_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Times => {
                            if times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("times"));
                            }
                            times__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MeasureReminder {
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                    category: category__,
                    clock_mode: clock_mode__,
                    week_days: week_days__,
                    times: times__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.MeasureReminder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for measure_reminder::Category {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Normal => "NORMAL",
            Self::Mild => "MILD",
            Self::Serious => "SERIOUS",
            Self::Unknown => "UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for measure_reminder::Category {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NORMAL",
            "MILD",
            "SERIOUS",
            "UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = measure_reminder::Category;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NORMAL" => Ok(measure_reminder::Category::Normal),
                    "MILD" => Ok(measure_reminder::Category::Mild),
                    "SERIOUS" => Ok(measure_reminder::Category::Serious),
                    "UNKNOWN" => Ok(measure_reminder::Category::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Media {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Media", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                media::Payload::PlayerInfo(v) => {
                    struct_ser.serialize_field("playerInfo", v)?;
                }
                media::Payload::PlayerControl(v) => {
                    struct_ser.serialize_field("playerControl", v)?;
                }
                media::Payload::SongSummary(v) => {
                    struct_ser.serialize_field("songSummary", v)?;
                }
                media::Payload::SonglistRequest(v) => {
                    struct_ser.serialize_field("songlistRequest", v)?;
                }
                media::Payload::SonglistResponse(v) => {
                    struct_ser.serialize_field("songlistResponse", v)?;
                }
                media::Payload::SongGetRequest(v) => {
                    struct_ser.serialize_field("songGetRequest", v)?;
                }
                media::Payload::SongGetResponse(v) => {
                    struct_ser.serialize_field("songGetResponse", v)?;
                }
                media::Payload::SongAddRequest(v) => {
                    struct_ser.serialize_field("songAddRequest", v)?;
                }
                media::Payload::SongAddResponse(v) => {
                    struct_ser.serialize_field("songAddResponse", v)?;
                }
                media::Payload::SongReportResult(v) => {
                    struct_ser.serialize_field("songReportResult", v)?;
                }
                media::Payload::SongRemoveRequest(v) => {
                    struct_ser.serialize_field("songRemoveRequest", v)?;
                }
                media::Payload::SongRemoveResponse(v) => {
                    struct_ser.serialize_field("songRemoveResponse", v)?;
                }
                media::Payload::MediaFileSummary(v) => {
                    struct_ser.serialize_field("mediaFileSummary", v)?;
                }
                media::Payload::MediaFileList(v) => {
                    struct_ser.serialize_field("mediaFileList", v)?;
                }
                media::Payload::MediaFileIdentifier(v) => {
                    struct_ser.serialize_field("mediaFileIdentifier", v)?;
                }
                media::Payload::MediaFileIdentifiers(v) => {
                    struct_ser.serialize_field("mediaFileIdentifiers", v)?;
                }
                media::Payload::RecordRequest(v) => {
                    struct_ser.serialize_field("recordRequest", v)?;
                }
                media::Payload::RecordResponse(v) => {
                    struct_ser.serialize_field("recordResponse", v)?;
                }
                media::Payload::RecordStatus(v) => {
                    struct_ser.serialize_field("recordStatus", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Media {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "player_info",
            "playerInfo",
            "player_control",
            "playerControl",
            "song_summary",
            "songSummary",
            "songlist_request",
            "songlistRequest",
            "songlist_response",
            "songlistResponse",
            "song_get_request",
            "songGetRequest",
            "song_get_response",
            "songGetResponse",
            "song_add_request",
            "songAddRequest",
            "song_add_response",
            "songAddResponse",
            "song_report_result",
            "songReportResult",
            "song_remove_request",
            "songRemoveRequest",
            "song_remove_response",
            "songRemoveResponse",
            "media_file_summary",
            "mediaFileSummary",
            "media_file_list",
            "mediaFileList",
            "media_file_identifier",
            "mediaFileIdentifier",
            "media_file_identifiers",
            "mediaFileIdentifiers",
            "record_request",
            "recordRequest",
            "record_response",
            "recordResponse",
            "record_status",
            "recordStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayerInfo,
            PlayerControl,
            SongSummary,
            SonglistRequest,
            SonglistResponse,
            SongGetRequest,
            SongGetResponse,
            SongAddRequest,
            SongAddResponse,
            SongReportResult,
            SongRemoveRequest,
            SongRemoveResponse,
            MediaFileSummary,
            MediaFileList,
            MediaFileIdentifier,
            MediaFileIdentifiers,
            RecordRequest,
            RecordResponse,
            RecordStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "playerInfo" | "player_info" => Ok(GeneratedField::PlayerInfo),
                            "playerControl" | "player_control" => Ok(GeneratedField::PlayerControl),
                            "songSummary" | "song_summary" => Ok(GeneratedField::SongSummary),
                            "songlistRequest" | "songlist_request" => Ok(GeneratedField::SonglistRequest),
                            "songlistResponse" | "songlist_response" => Ok(GeneratedField::SonglistResponse),
                            "songGetRequest" | "song_get_request" => Ok(GeneratedField::SongGetRequest),
                            "songGetResponse" | "song_get_response" => Ok(GeneratedField::SongGetResponse),
                            "songAddRequest" | "song_add_request" => Ok(GeneratedField::SongAddRequest),
                            "songAddResponse" | "song_add_response" => Ok(GeneratedField::SongAddResponse),
                            "songReportResult" | "song_report_result" => Ok(GeneratedField::SongReportResult),
                            "songRemoveRequest" | "song_remove_request" => Ok(GeneratedField::SongRemoveRequest),
                            "songRemoveResponse" | "song_remove_response" => Ok(GeneratedField::SongRemoveResponse),
                            "mediaFileSummary" | "media_file_summary" => Ok(GeneratedField::MediaFileSummary),
                            "mediaFileList" | "media_file_list" => Ok(GeneratedField::MediaFileList),
                            "mediaFileIdentifier" | "media_file_identifier" => Ok(GeneratedField::MediaFileIdentifier),
                            "mediaFileIdentifiers" | "media_file_identifiers" => Ok(GeneratedField::MediaFileIdentifiers),
                            "recordRequest" | "record_request" => Ok(GeneratedField::RecordRequest),
                            "recordResponse" | "record_response" => Ok(GeneratedField::RecordResponse),
                            "recordStatus" | "record_status" => Ok(GeneratedField::RecordStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Media;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Media")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Media, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayerInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("playerInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::PlayerInfo)
;
                        }
                        GeneratedField::PlayerControl => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("playerControl"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::PlayerControl)
;
                        }
                        GeneratedField::SongSummary => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songSummary"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongSummary)
;
                        }
                        GeneratedField::SonglistRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songlistRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SonglistRequest)
;
                        }
                        GeneratedField::SonglistResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songlistResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SonglistResponse)
;
                        }
                        GeneratedField::SongGetRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songGetRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongGetRequest)
;
                        }
                        GeneratedField::SongGetResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songGetResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongGetResponse)
;
                        }
                        GeneratedField::SongAddRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songAddRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongAddRequest)
;
                        }
                        GeneratedField::SongAddResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songAddResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongAddResponse)
;
                        }
                        GeneratedField::SongReportResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songReportResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongReportResult)
;
                        }
                        GeneratedField::SongRemoveRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songRemoveRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongRemoveRequest)
;
                        }
                        GeneratedField::SongRemoveResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songRemoveResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::SongRemoveResponse)
;
                        }
                        GeneratedField::MediaFileSummary => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaFileSummary"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::MediaFileSummary)
;
                        }
                        GeneratedField::MediaFileList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaFileList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::MediaFileList)
;
                        }
                        GeneratedField::MediaFileIdentifier => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaFileIdentifier"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::MediaFileIdentifier)
;
                        }
                        GeneratedField::MediaFileIdentifiers => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaFileIdentifiers"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::MediaFileIdentifiers)
;
                        }
                        GeneratedField::RecordRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recordRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::RecordRequest)
;
                        }
                        GeneratedField::RecordResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recordResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::RecordResponse)
;
                        }
                        GeneratedField::RecordStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recordStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(media::Payload::RecordStatus)
;
                        }
                    }
                }
                Ok(Media {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Media", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media::MediaId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::WearRequest => "WEAR_REQUEST",
            Self::SyncPlayerInfo => "SYNC_PLAYER_INFO",
            Self::ControlPlayer => "CONTROL_PLAYER",
            Self::GetSongSummary => "GET_SONG_SUMMARY",
            Self::AddSonglist => "ADD_SONGLIST",
            Self::RemoveSonglist => "REMOVE_SONGLIST",
            Self::RenameSonglist => "RENAME_SONGLIST",
            Self::QuerySongForSonglist => "QUERY_SONG_FOR_SONGLIST",
            Self::AddSongToSonglist => "ADD_SONG_TO_SONGLIST",
            Self::RemoveSongFromSonglist => "REMOVE_SONG_FROM_SONGLIST",
            Self::GetSong => "GET_SONG",
            Self::AddSong => "ADD_SONG",
            Self::ReportSongResult => "REPORT_SONG_RESULT",
            Self::RemoveSong => "REMOVE_SONG",
            Self::GetMediaFileSummary => "GET_MEDIA_FILE_SUMMARY",
            Self::SyncMediaFileList => "SYNC_MEDIA_FILE_LIST",
            Self::ReportMediaFileList => "REPORT_MEDIA_FILE_LIST",
            Self::RequestMediaFile => "REQUEST_MEDIA_FILE",
            Self::RequestMediaFileList => "REQUEST_MEDIA_FILE_LIST",
            Self::ConfirmMediaFile => "CONFIRM_MEDIA_FILE",
            Self::RequestRecord => "REQUEST_RECORD",
            Self::GetRecordStatus => "GET_RECORD_STATUS",
            Self::ReportRecordStatus => "REPORT_RECORD_STATUS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for media::MediaId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WEAR_REQUEST",
            "SYNC_PLAYER_INFO",
            "CONTROL_PLAYER",
            "GET_SONG_SUMMARY",
            "ADD_SONGLIST",
            "REMOVE_SONGLIST",
            "RENAME_SONGLIST",
            "QUERY_SONG_FOR_SONGLIST",
            "ADD_SONG_TO_SONGLIST",
            "REMOVE_SONG_FROM_SONGLIST",
            "GET_SONG",
            "ADD_SONG",
            "REPORT_SONG_RESULT",
            "REMOVE_SONG",
            "GET_MEDIA_FILE_SUMMARY",
            "SYNC_MEDIA_FILE_LIST",
            "REPORT_MEDIA_FILE_LIST",
            "REQUEST_MEDIA_FILE",
            "REQUEST_MEDIA_FILE_LIST",
            "CONFIRM_MEDIA_FILE",
            "REQUEST_RECORD",
            "GET_RECORD_STATUS",
            "REPORT_RECORD_STATUS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media::MediaId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "WEAR_REQUEST" => Ok(media::MediaId::WearRequest),
                    "SYNC_PLAYER_INFO" => Ok(media::MediaId::SyncPlayerInfo),
                    "CONTROL_PLAYER" => Ok(media::MediaId::ControlPlayer),
                    "GET_SONG_SUMMARY" => Ok(media::MediaId::GetSongSummary),
                    "ADD_SONGLIST" => Ok(media::MediaId::AddSonglist),
                    "REMOVE_SONGLIST" => Ok(media::MediaId::RemoveSonglist),
                    "RENAME_SONGLIST" => Ok(media::MediaId::RenameSonglist),
                    "QUERY_SONG_FOR_SONGLIST" => Ok(media::MediaId::QuerySongForSonglist),
                    "ADD_SONG_TO_SONGLIST" => Ok(media::MediaId::AddSongToSonglist),
                    "REMOVE_SONG_FROM_SONGLIST" => Ok(media::MediaId::RemoveSongFromSonglist),
                    "GET_SONG" => Ok(media::MediaId::GetSong),
                    "ADD_SONG" => Ok(media::MediaId::AddSong),
                    "REPORT_SONG_RESULT" => Ok(media::MediaId::ReportSongResult),
                    "REMOVE_SONG" => Ok(media::MediaId::RemoveSong),
                    "GET_MEDIA_FILE_SUMMARY" => Ok(media::MediaId::GetMediaFileSummary),
                    "SYNC_MEDIA_FILE_LIST" => Ok(media::MediaId::SyncMediaFileList),
                    "REPORT_MEDIA_FILE_LIST" => Ok(media::MediaId::ReportMediaFileList),
                    "REQUEST_MEDIA_FILE" => Ok(media::MediaId::RequestMediaFile),
                    "REQUEST_MEDIA_FILE_LIST" => Ok(media::MediaId::RequestMediaFileList),
                    "CONFIRM_MEDIA_FILE" => Ok(media::MediaId::ConfirmMediaFile),
                    "REQUEST_RECORD" => Ok(media::MediaId::RequestRecord),
                    "GET_RECORD_STATUS" => Ok(media::MediaId::GetRecordStatus),
                    "REPORT_RECORD_STATUS" => Ok(media::MediaId::ReportRecordStatus),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MediaConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.MediaConfig", len)?;
        struct_ser.serialize_field("imgWidth", &self.img_width)?;
        struct_ser.serialize_field("imgHeight", &self.img_height)?;
        struct_ser.serialize_field("imgFormat", &self.img_format)?;
        struct_ser.serialize_field("standbyFreq", &self.standby_freq)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MediaConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "img_width",
            "imgWidth",
            "img_height",
            "imgHeight",
            "img_format",
            "imgFormat",
            "standby_freq",
            "standbyFreq",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ImgWidth,
            ImgHeight,
            ImgFormat,
            StandbyFreq,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "imgWidth" | "img_width" => Ok(GeneratedField::ImgWidth),
                            "imgHeight" | "img_height" => Ok(GeneratedField::ImgHeight),
                            "imgFormat" | "img_format" => Ok(GeneratedField::ImgFormat),
                            "standbyFreq" | "standby_freq" => Ok(GeneratedField::StandbyFreq),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MediaConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaConfig")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MediaConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut img_width__ = None;
                let mut img_height__ = None;
                let mut img_format__ = None;
                let mut standby_freq__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ImgWidth => {
                            if img_width__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imgWidth"));
                            }
                            img_width__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ImgHeight => {
                            if img_height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imgHeight"));
                            }
                            img_height__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ImgFormat => {
                            if img_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imgFormat"));
                            }
                            img_format__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::StandbyFreq => {
                            if standby_freq__.is_some() {
                                return Err(serde::de::Error::duplicate_field("standbyFreq"));
                            }
                            standby_freq__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MediaConfig {
                    img_width: img_width__.ok_or_else(|| serde::de::Error::missing_field("imgWidth"))?,
                    img_height: img_height__.ok_or_else(|| serde::de::Error::missing_field("imgHeight"))?,
                    img_format: img_format__.ok_or_else(|| serde::de::Error::missing_field("imgFormat"))?,
                    standby_freq: standby_freq__.ok_or_else(|| serde::de::Error::missing_field("standbyFreq"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MediaErrorType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::MediaErrorOk => "Media_ERROR_OK",
            Self::MediaErrorUnsupportSystem => "Media_ERROR_UNSUPPORT_SYSTEM",
            Self::MediaErrorNoPermission => "Media_ERROR_NO_PERMISSION",
            Self::MediaErrorNoMusic => "Media_ERROR_NO_MUSIC",
            Self::MediaErrorAlreadyPlayingOnPlay => "Media_ERROR_ALREADY_PLAYING_ON_PLAY",
            Self::MediaErrorAlreadyPausedOnPause => "Media_ERROR_ALREADY_PAUSED_ON_PAUSE",
            Self::MediaErrorAlreadyMaxOnRaiseVolume => "Media_ERROR_ALREADY_MAX_ON_RAISE_VOLUME",
            Self::MediaErrorAlreadyMinOnLowerVolume => "Media_ERROR_ALREADY_MIN_ON_LOWER_VOLUME",
            Self::MediaErrorAlreadyPausedOnAdjustVolume => "Media_ERROR_ALREADY_PAUSED_ON_ADJUST_VOLUME",
            Self::MediaErrorAlreadyPausedOnSetVolume => "Media_ERROR_ALREADY_PAUSED_ON_SET_VOLUME",
            Self::MediaErrorAlreadyPausedOnSetMute => "Media_ERROR_ALREADY_PAUSED_ON_SET_MUTE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for MediaErrorType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Media_ERROR_OK",
            "Media_ERROR_UNSUPPORT_SYSTEM",
            "Media_ERROR_NO_PERMISSION",
            "Media_ERROR_NO_MUSIC",
            "Media_ERROR_ALREADY_PLAYING_ON_PLAY",
            "Media_ERROR_ALREADY_PAUSED_ON_PAUSE",
            "Media_ERROR_ALREADY_MAX_ON_RAISE_VOLUME",
            "Media_ERROR_ALREADY_MIN_ON_LOWER_VOLUME",
            "Media_ERROR_ALREADY_PAUSED_ON_ADJUST_VOLUME",
            "Media_ERROR_ALREADY_PAUSED_ON_SET_VOLUME",
            "Media_ERROR_ALREADY_PAUSED_ON_SET_MUTE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MediaErrorType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Media_ERROR_OK" => Ok(MediaErrorType::MediaErrorOk),
                    "Media_ERROR_UNSUPPORT_SYSTEM" => Ok(MediaErrorType::MediaErrorUnsupportSystem),
                    "Media_ERROR_NO_PERMISSION" => Ok(MediaErrorType::MediaErrorNoPermission),
                    "Media_ERROR_NO_MUSIC" => Ok(MediaErrorType::MediaErrorNoMusic),
                    "Media_ERROR_ALREADY_PLAYING_ON_PLAY" => Ok(MediaErrorType::MediaErrorAlreadyPlayingOnPlay),
                    "Media_ERROR_ALREADY_PAUSED_ON_PAUSE" => Ok(MediaErrorType::MediaErrorAlreadyPausedOnPause),
                    "Media_ERROR_ALREADY_MAX_ON_RAISE_VOLUME" => Ok(MediaErrorType::MediaErrorAlreadyMaxOnRaiseVolume),
                    "Media_ERROR_ALREADY_MIN_ON_LOWER_VOLUME" => Ok(MediaErrorType::MediaErrorAlreadyMinOnLowerVolume),
                    "Media_ERROR_ALREADY_PAUSED_ON_ADJUST_VOLUME" => Ok(MediaErrorType::MediaErrorAlreadyPausedOnAdjustVolume),
                    "Media_ERROR_ALREADY_PAUSED_ON_SET_VOLUME" => Ok(MediaErrorType::MediaErrorAlreadyPausedOnSetVolume),
                    "Media_ERROR_ALREADY_PAUSED_ON_SET_MUTE" => Ok(MediaErrorType::MediaErrorAlreadyPausedOnSetMute),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MediaFile {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.MediaFile", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MediaFile {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MediaFile;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaFile")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MediaFile, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MediaFile {
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaFile", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media_file::Identifier {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.MediaFile.Identifier", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("thumbnail", &self.thumbnail)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for media_file::Identifier {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "thumbnail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Thumbnail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "thumbnail" => Ok(GeneratedField::Thumbnail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media_file::Identifier;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaFile.Identifier")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<media_file::Identifier, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut thumbnail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Thumbnail => {
                            if thumbnail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("thumbnail"));
                            }
                            thumbnail__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(media_file::Identifier {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    thumbnail: thumbnail__.ok_or_else(|| serde::de::Error::missing_field("thumbnail"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaFile.Identifier", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media_file::identifier::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.MediaFile.Identifier.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for media_file::identifier::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media_file::identifier::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaFile.Identifier.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<media_file::identifier::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(media_file::identifier::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaFile.Identifier.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media_file::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.MediaFile.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for media_file::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media_file::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaFile.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<media_file::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(media_file::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaFile.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media_file::Summary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.MediaFile.Summary", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for media_file::Summary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media_file::Summary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaFile.Summary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<media_file::Summary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(media_file::Summary {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaFile.Summary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media_file::summary::Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.MediaFile.Summary.Item", len)?;
        let v = media_file::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("count", &self.count)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for media_file::summary::Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "count",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Count,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "count" => Ok(GeneratedField::Count),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media_file::summary::Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MediaFile.Summary.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<media_file::summary::Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<media_file::Type>()? as i32);
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("count"));
                            }
                            count__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(media_file::summary::Item {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    count: count__.ok_or_else(|| serde::de::Error::missing_field("count"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MediaFile.Summary.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for media_file::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Jpeg => "JPEG",
            Self::Png => "PNG",
            Self::Mp4 => "MP4",
            Self::Quicktime => "QUICKTIME",
            Self::Pcm => "PCM",
            Self::Opus => "OPUS",
            Self::Sbc => "SBC",
            Self::Msbc => "MSBC",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for media_file::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "JPEG",
            "PNG",
            "MP4",
            "QUICKTIME",
            "PCM",
            "OPUS",
            "SBC",
            "MSBC",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = media_file::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "JPEG" => Ok(media_file::Type::Jpeg),
                    "PNG" => Ok(media_file::Type::Png),
                    "MP4" => Ok(media_file::Type::Mp4),
                    "QUICKTIME" => Ok(media_file::Type::Quicktime),
                    "PCM" => Ok(media_file::Type::Pcm),
                    "OPUS" => Ok(media_file::Type::Opus),
                    "SBC" => Ok(media_file::Type::Sbc),
                    "MSBC" => Ok(media_file::Type::Msbc),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MessageContent {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.MessageContent", len)?;
        struct_ser.serialize_field("basicInfo", &self.basic_info)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("content", pbjson::private::base64::encode(&self.content).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MessageContent {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_info",
            "basicInfo",
            "content",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicInfo,
            Content,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "content" => Ok(GeneratedField::Content),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MessageContent;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MessageContent")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MessageContent, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_info__ = None;
                let mut content__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicInfo => {
                            if basic_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            basic_info__ = map_.next_value()?;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MessageContent {
                    basic_info: basic_info__.ok_or_else(|| serde::de::Error::missing_field("basicInfo"))?,
                    content: content__.ok_or_else(|| serde::de::Error::missing_field("content"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MessageContent", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MiHome {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.MiHome", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("id", ToString::to_string(&self.id).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("uid", ToString::to_string(&self.uid).as_str())?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MiHome {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "uid",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Uid,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "uid" => Ok(GeneratedField::Uid),
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MiHome;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MiHome, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut uid__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MiHome {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    uid: uid__.ok_or_else(|| serde::de::Error::missing_field("uid"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.MiHome.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(mi_home::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.MiHome.Request", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(mi_home::Request {
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::Scene {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.MiHome.Scene", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::Scene {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::Scene;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.Scene")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::Scene, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(mi_home::Scene {
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.Scene", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::scene::Executor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.MiHome.Scene.Executor", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("id", ToString::to_string(&self.id).as_str())?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::scene::Executor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::scene::Executor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.Scene.Executor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::scene::Executor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(mi_home::scene::Executor {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.Scene.Executor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::scene::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.MiHome.Scene.List", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("homeId", ToString::to_string(&self.home_id).as_str())?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::scene::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "home_id",
            "homeId",
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomeId,
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "homeId" | "home_id" => Ok(GeneratedField::HomeId),
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::scene::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.Scene.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::scene::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut home_id__ = None;
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomeId => {
                            if home_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("homeId"));
                            }
                            home_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(mi_home::scene::List {
                    home_id: home_id__.ok_or_else(|| serde::de::Error::missing_field("homeId"))?,
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.Scene.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::scene::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.MiHome.Scene.Request", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("homeId", ToString::to_string(&self.home_id).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("uid", ToString::to_string(&self.uid).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::scene::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "home_id",
            "homeId",
            "uid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomeId,
            Uid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "homeId" | "home_id" => Ok(GeneratedField::HomeId),
                            "uid" => Ok(GeneratedField::Uid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::scene::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.Scene.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::scene::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut home_id__ = None;
                let mut uid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomeId => {
                            if home_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("homeId"));
                            }
                            home_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(mi_home::scene::Request {
                    home_id: home_id__.ok_or_else(|| serde::de::Error::missing_field("homeId"))?,
                    uid: uid__.ok_or_else(|| serde::de::Error::missing_field("uid"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.Scene.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_home::scene::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.MiHome.Scene.Result", len)?;
        struct_ser.serialize_field("result", &self.result)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_home::scene::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "result",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Result,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "result" => Ok(GeneratedField::Result),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_home::scene::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiHome.Scene.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_home::scene::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(mi_home::scene::Result {
                    result: result__.ok_or_else(|| serde::de::Error::missing_field("result"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiHome.Scene.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MiShow {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.MiShow", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MiShow {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MiShow;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiShow")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MiShow, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MiShow {
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiShow", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_show::Demo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.MiShow.Demo", len)?;
        struct_ser.serialize_field("show", &self.show)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_show::Demo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "show",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Show,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "show" => Ok(GeneratedField::Show),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_show::Demo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiShow.Demo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_show::Demo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut show__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Show => {
                            if show__.is_some() {
                                return Err(serde::de::Error::duplicate_field("show"));
                            }
                            show__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(mi_show::Demo {
                    show: show__.ok_or_else(|| serde::de::Error::missing_field("show"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiShow.Demo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mi_show::SlideRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.MiShow.SlideRequest", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("timestamp", ToString::to_string(&self.timestamp).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mi_show::SlideRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mi_show::SlideRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiShow.SlideRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mi_show::SlideRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(mi_show::SlideRequest {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiShow.SlideRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Mis {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Mis", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Mis {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Mis;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Mis")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Mis, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Mis {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Mis", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mis::Device {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.Mis.Device", len)?;
        struct_ser.serialize_field("did", &self.did)?;
        struct_ser.serialize_field("pdid", &self.pdid)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mis::Device {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "did",
            "pdid",
            "status",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Did,
            Pdid,
            Status,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "did" => Ok(GeneratedField::Did),
                            "pdid" => Ok(GeneratedField::Pdid),
                            "status" => Ok(GeneratedField::Status),
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mis::Device;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Mis.Device")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mis::Device, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut did__ = None;
                let mut pdid__ = None;
                let mut status__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Did => {
                            if did__.is_some() {
                                return Err(serde::de::Error::duplicate_field("did"));
                            }
                            did__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Pdid => {
                            if pdid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pdid"));
                            }
                            pdid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(mis::Device {
                    did: did__.ok_or_else(|| serde::de::Error::missing_field("did"))?,
                    pdid: pdid__.ok_or_else(|| serde::de::Error::missing_field("pdid"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Mis.Device", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mis::device::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.car_owner.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Mis.Device.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.car_owner.as_ref() {
            struct_ser.serialize_field("carOwner", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mis::device::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "car_owner",
            "carOwner",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            CarOwner,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "carOwner" | "car_owner" => Ok(GeneratedField::CarOwner),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mis::device::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Mis.Device.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mis::device::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut car_owner__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CarOwner => {
                            if car_owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("carOwner"));
                            }
                            car_owner__ = map_.next_value()?;
                        }
                    }
                }
                Ok(mis::device::List {
                    list: list__.unwrap_or_default(),
                    car_owner: car_owner__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Mis.Device.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mis::Payload {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Mis.Payload", len)?;
        struct_ser.serialize_field("spec", &self.spec)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("packet", pbjson::private::base64::encode(&self.packet).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mis::Payload {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "spec",
            "packet",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Spec,
            Packet,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "spec" => Ok(GeneratedField::Spec),
                            "packet" => Ok(GeneratedField::Packet),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mis::Payload;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Mis.Payload")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mis::Payload, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut spec__ = None;
                let mut packet__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Spec => {
                            if spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("spec"));
                            }
                            spec__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Packet => {
                            if packet__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packet"));
                            }
                            packet__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(mis::Payload {
                    spec: spec__.ok_or_else(|| serde::de::Error::missing_field("spec"))?,
                    packet: packet__.ok_or_else(|| serde::de::Error::missing_field("packet"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Mis.Payload", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for mis::WearSpecBasic {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Mis.WearSpecBasic", len)?;
        struct_ser.serialize_field("deviceInfo", &self.device_info)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for mis::WearSpecBasic {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_info",
            "deviceInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceInfo" | "device_info" => Ok(GeneratedField::DeviceInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = mis::WearSpecBasic;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Mis.WearSpecBasic")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<mis::WearSpecBasic, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceInfo => {
                            if device_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceInfo"));
                            }
                            device_info__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(mis::WearSpecBasic {
                    device_info: device_info__.ok_or_else(|| serde::de::Error::missing_field("deviceInfo"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Mis.WearSpecBasic", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MiuiSos {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.MiuiSOS", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MiuiSos {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MiuiSos;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiuiSOS")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MiuiSos, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(MiuiSos {
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiuiSOS", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for miui_sos::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.MiuiSOS.Request", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for miui_sos::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = miui_sos::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiuiSOS.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<miui_sos::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(miui_sos::Request {
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiuiSOS.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for miui_sos::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.MiuiSOS.Response", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for miui_sos::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = miui_sos::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MiuiSOS.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<miui_sos::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(miui_sos::Response {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MiuiSOS.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MotionInteract {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.MotionInteract", len)?;
        struct_ser.serialize_field("vibrateLevel", &self.vibrate_level)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MotionInteract {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "vibrate_level",
            "vibrateLevel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VibrateLevel,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "vibrateLevel" | "vibrate_level" => Ok(GeneratedField::VibrateLevel),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MotionInteract;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MotionInteract")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MotionInteract, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut vibrate_level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VibrateLevel => {
                            if vibrate_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibrateLevel"));
                            }
                            vibrate_level__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MotionInteract {
                    vibrate_level: vibrate_level__.ok_or_else(|| serde::de::Error::missing_field("vibrateLevel"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MotionInteract", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MultiModal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.MultiModal", len)?;
        struct_ser.serialize_field("requestInfo", &self.request_info)?;
        struct_ser.serialize_field("cmd", &self.cmd)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultiModal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "request_info",
            "requestInfo",
            "cmd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RequestInfo,
            Cmd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "requestInfo" | "request_info" => Ok(GeneratedField::RequestInfo),
                            "cmd" => Ok(GeneratedField::Cmd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultiModal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.MultiModal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultiModal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request_info__ = None;
                let mut cmd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RequestInfo => {
                            if request_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requestInfo"));
                            }
                            request_info__ = map_.next_value()?;
                        }
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(MultiModal {
                    request_info: request_info__.ok_or_else(|| serde::de::Error::missing_field("requestInfo"))?,
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.MultiModal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NaviRoute {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("distance", &self.distance)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NaviRoute {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "distance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            Distance,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "distance" => Ok(GeneratedField::Distance),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NaviRoute;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NaviRoute, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut distance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NaviRoute {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    distance: distance__.ok_or_else(|| serde::de::Error::missing_field("distance"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for navi_route::AddRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute.AddRequest", len)?;
        struct_ser.serialize_field("naviRoute", &self.navi_route)?;
        struct_ser.serialize_field("routeSize", &self.route_size)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for navi_route::AddRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "navi_route",
            "naviRoute",
            "route_size",
            "routeSize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NaviRoute,
            RouteSize,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "naviRoute" | "navi_route" => Ok(GeneratedField::NaviRoute),
                            "routeSize" | "route_size" => Ok(GeneratedField::RouteSize),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = navi_route::AddRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute.AddRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<navi_route::AddRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut navi_route__ = None;
                let mut route_size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NaviRoute => {
                            if navi_route__.is_some() {
                                return Err(serde::de::Error::duplicate_field("naviRoute"));
                            }
                            navi_route__ = map_.next_value()?;
                        }
                        GeneratedField::RouteSize => {
                            if route_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("routeSize"));
                            }
                            route_size__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(navi_route::AddRequest {
                    navi_route: navi_route__.ok_or_else(|| serde::de::Error::missing_field("naviRoute"))?,
                    route_size: route_size__.ok_or_else(|| serde::de::Error::missing_field("routeSize"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute.AddRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for navi_route::AddResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute.AddResponse", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for navi_route::AddResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "prepare_status",
            "prepareStatus",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            PrepareStatus,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = navi_route::AddResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute.AddResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<navi_route::AddResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut prepare_status__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(navi_route::AddResponse {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute.AddResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for navi_route::AddResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute.AddResult", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for navi_route::AddResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = navi_route::AddResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute.AddResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<navi_route::AddResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(navi_route::AddResult {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute.AddResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for navi_route::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.serialize_field("supportedMaxNumber", &self.supported_max_number)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for navi_route::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "supported_max_number",
            "supportedMaxNumber",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            SupportedMaxNumber,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "supportedMaxNumber" | "supported_max_number" => Ok(GeneratedField::SupportedMaxNumber),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = navi_route::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<navi_route::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut supported_max_number__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportedMaxNumber => {
                            if supported_max_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportedMaxNumber"));
                            }
                            supported_max_number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(navi_route::List {
                    list: list__.unwrap_or_default(),
                    supported_max_number: supported_max_number__.ok_or_else(|| serde::de::Error::missing_field("supportedMaxNumber"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for navi_route::RemoveRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.router_id_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute.RemoveRequest", len)?;
        if !self.router_id_list.is_empty() {
            struct_ser.serialize_field("routerIdList", &self.router_id_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for navi_route::RemoveRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "router_id_list",
            "routerIdList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RouterIdList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "routerIdList" | "router_id_list" => Ok(GeneratedField::RouterIdList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = navi_route::RemoveRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute.RemoveRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<navi_route::RemoveRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut router_id_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RouterIdList => {
                            if router_id_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("routerIdList"));
                            }
                            router_id_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(navi_route::RemoveRequest {
                    router_id_list: router_id_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute.RemoveRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for navi_route::RemoveResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.NaviRoute.RemoveResponse", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for navi_route::RemoveResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = navi_route::RemoveResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NaviRoute.RemoveResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<navi_route::RemoveResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(navi_route::RemoveResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NaviRoute.RemoveResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NetworkProxy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.NetworkProxy", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NetworkProxy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NetworkProxy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NetworkProxy")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NetworkProxy, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(NetworkProxy {
                })
            }
        }
        deserializer.deserialize_struct("protocol.NetworkProxy", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for network_proxy::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.NetworkProxy.Request", len)?;
        let v = network_proxy::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for network_proxy::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = network_proxy::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NetworkProxy.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<network_proxy::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<network_proxy::Type>()? as i32);
                        }
                    }
                }
                Ok(network_proxy::Request {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NetworkProxy.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for network_proxy::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Pan => "PAN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for network_proxy::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PAN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = network_proxy::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PAN" => Ok(network_proxy::Type::Pan),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for NetworkStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.NetworkStatus", len)?;
        struct_ser.serialize_field("capability", &self.capability)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NetworkStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "capability",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Capability,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "capability" => Ok(GeneratedField::Capability),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NetworkStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NetworkStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NetworkStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut capability__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Capability => {
                            if capability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capability"));
                            }
                            capability__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NetworkStatus {
                    capability: capability__.ok_or_else(|| serde::de::Error::missing_field("capability"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NetworkStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Nfc {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Nfc", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                nfc::Payload::Command(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("command", pbjson::private::base64::encode(&v).as_str())?;
                }
                nfc::Payload::IssueCard(v) => {
                    struct_ser.serialize_field("issueCard", v)?;
                }
                nfc::Payload::CardData(v) => {
                    struct_ser.serialize_field("cardData", v)?;
                }
                nfc::Payload::CardInfo(v) => {
                    struct_ser.serialize_field("cardInfo", v)?;
                }
                nfc::Payload::CardInfoList(v) => {
                    struct_ser.serialize_field("cardInfoList", v)?;
                }
                nfc::Payload::Aid(v) => {
                    struct_ser.serialize_field("aid", v)?;
                }
                nfc::Payload::BalanceInfo(v) => {
                    struct_ser.serialize_field("balanceInfo", v)?;
                }
                nfc::Payload::Config(v) => {
                    struct_ser.serialize_field("config", v)?;
                }
                nfc::Payload::CommandInfoList(v) => {
                    struct_ser.serialize_field("commandInfoList", v)?;
                }
                nfc::Payload::Capability(v) => {
                    struct_ser.serialize_field("capability", v)?;
                }
                nfc::Payload::CardSwitcherList(v) => {
                    struct_ser.serialize_field("cardSwitcherList", v)?;
                }
                nfc::Payload::CardSwitcher(v) => {
                    struct_ser.serialize_field("cardSwitcher", v)?;
                }
                nfc::Payload::CardSwitcherResult(v) => {
                    struct_ser.serialize_field("cardSwitcherResult", v)?;
                }
                nfc::Payload::SuperCardData(v) => {
                    struct_ser.serialize_field("superCardData", v)?;
                }
                nfc::Payload::ProbeRequest(v) => {
                    struct_ser.serialize_field("probeRequest", v)?;
                }
                nfc::Payload::ProbeResponse(v) => {
                    struct_ser.serialize_field("probeResponse", v)?;
                }
                nfc::Payload::KeyList(v) => {
                    struct_ser.serialize_field("keyList", v)?;
                }
                nfc::Payload::CrackCardData(v) => {
                    struct_ser.serialize_field("crackCardData", v)?;
                }
                nfc::Payload::CardSwitcherSmart(v) => {
                    struct_ser.serialize_field("cardSwitcherSmart", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Nfc {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "command",
            "issue_card",
            "issueCard",
            "card_data",
            "cardData",
            "card_info",
            "cardInfo",
            "card_info_list",
            "cardInfoList",
            "aid",
            "balance_info",
            "balanceInfo",
            "config",
            "command_info_list",
            "commandInfoList",
            "capability",
            "card_switcher_list",
            "cardSwitcherList",
            "card_switcher",
            "cardSwitcher",
            "card_switcher_result",
            "cardSwitcherResult",
            "super_card_data",
            "superCardData",
            "probe_request",
            "probeRequest",
            "probe_response",
            "probeResponse",
            "key_list",
            "keyList",
            "crack_card_data",
            "crackCardData",
            "card_switcher_smart",
            "cardSwitcherSmart",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Command,
            IssueCard,
            CardData,
            CardInfo,
            CardInfoList,
            Aid,
            BalanceInfo,
            Config,
            CommandInfoList,
            Capability,
            CardSwitcherList,
            CardSwitcher,
            CardSwitcherResult,
            SuperCardData,
            ProbeRequest,
            ProbeResponse,
            KeyList,
            CrackCardData,
            CardSwitcherSmart,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "command" => Ok(GeneratedField::Command),
                            "issueCard" | "issue_card" => Ok(GeneratedField::IssueCard),
                            "cardData" | "card_data" => Ok(GeneratedField::CardData),
                            "cardInfo" | "card_info" => Ok(GeneratedField::CardInfo),
                            "cardInfoList" | "card_info_list" => Ok(GeneratedField::CardInfoList),
                            "aid" => Ok(GeneratedField::Aid),
                            "balanceInfo" | "balance_info" => Ok(GeneratedField::BalanceInfo),
                            "config" => Ok(GeneratedField::Config),
                            "commandInfoList" | "command_info_list" => Ok(GeneratedField::CommandInfoList),
                            "capability" => Ok(GeneratedField::Capability),
                            "cardSwitcherList" | "card_switcher_list" => Ok(GeneratedField::CardSwitcherList),
                            "cardSwitcher" | "card_switcher" => Ok(GeneratedField::CardSwitcher),
                            "cardSwitcherResult" | "card_switcher_result" => Ok(GeneratedField::CardSwitcherResult),
                            "superCardData" | "super_card_data" => Ok(GeneratedField::SuperCardData),
                            "probeRequest" | "probe_request" => Ok(GeneratedField::ProbeRequest),
                            "probeResponse" | "probe_response" => Ok(GeneratedField::ProbeResponse),
                            "keyList" | "key_list" => Ok(GeneratedField::KeyList),
                            "crackCardData" | "crack_card_data" => Ok(GeneratedField::CrackCardData),
                            "cardSwitcherSmart" | "card_switcher_smart" => Ok(GeneratedField::CardSwitcherSmart),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Nfc;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Nfc")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Nfc, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Command => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| nfc::Payload::Command(x.0));
                        }
                        GeneratedField::IssueCard => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("issueCard"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::IssueCard)
;
                        }
                        GeneratedField::CardData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardData)
;
                        }
                        GeneratedField::CardInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardInfo)
;
                        }
                        GeneratedField::CardInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardInfoList)
;
                        }
                        GeneratedField::Aid => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aid"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::Aid);
                        }
                        GeneratedField::BalanceInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::BalanceInfo)
;
                        }
                        GeneratedField::Config => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("config"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::Config);
                        }
                        GeneratedField::CommandInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commandInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CommandInfoList)
;
                        }
                        GeneratedField::Capability => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("capability"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| nfc::Payload::Capability(x.0));
                        }
                        GeneratedField::CardSwitcherList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardSwitcherList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardSwitcherList)
;
                        }
                        GeneratedField::CardSwitcher => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardSwitcher"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardSwitcher)
;
                        }
                        GeneratedField::CardSwitcherResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardSwitcherResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardSwitcherResult)
;
                        }
                        GeneratedField::SuperCardData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("superCardData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::SuperCardData)
;
                        }
                        GeneratedField::ProbeRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("probeRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::ProbeRequest)
;
                        }
                        GeneratedField::ProbeResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("probeResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::ProbeResponse)
;
                        }
                        GeneratedField::KeyList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::KeyList)
;
                        }
                        GeneratedField::CrackCardData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("crackCardData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CrackCardData)
;
                        }
                        GeneratedField::CardSwitcherSmart => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cardSwitcherSmart"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(nfc::Payload::CardSwitcherSmart)
;
                        }
                    }
                }
                Ok(Nfc {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Nfc", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for nfc::NfcId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Command => "COMMAND",
            Self::IssueCard => "ISSUE_CARD",
            Self::AddCard => "ADD_CARD",
            Self::DelCard => "DEL_CARD",
            Self::SyncCardList => "SYNC_CARD_LIST",
            Self::SetDefaultCard => "SET_DEFAULT_CARD",
            Self::GetDefaultCard => "GET_DEFAULT_CARD",
            Self::SetBalance => "SET_BALANCE",
            Self::GetBalance => "GET_BALANCE",
            Self::SetConfig => "SET_CONFIG",
            Self::CapabilitySet => "CAPABILITY_SET",
            Self::CommandBatch => "COMMAND_BATCH",
            Self::GetCardSwitcherTime => "GET_CARD_SWITCHER_TIME",
            Self::UpdateCardSwitcherTime => "UPDATE_CARD_SWITCHER_TIME",
            Self::AddCardSwitcherTime => "ADD_CARD_SWITCHER_TIME",
            Self::RemoveCardSwitcherTime => "REMOVE_CARD_SWITCHER_TIME",
            Self::GetCardSwitcherSmart => "GET_CARD_SWITCHER_SMART",
            Self::SetCardSwitcherSmart => "SET_CARD_SWITCHER_SMART",
            Self::NotifyCardStick => "NOTIFY_CARD_STICK",
            Self::OpenTai => "OPEN_TAI",
            Self::ProbeSector => "PROBE_SECTOR",
            Self::CloseTai => "CLOSE_TAI",
            Self::CrackSectors => "CRACK_SECTORS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for nfc::NfcId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COMMAND",
            "ISSUE_CARD",
            "ADD_CARD",
            "DEL_CARD",
            "SYNC_CARD_LIST",
            "SET_DEFAULT_CARD",
            "GET_DEFAULT_CARD",
            "SET_BALANCE",
            "GET_BALANCE",
            "SET_CONFIG",
            "CAPABILITY_SET",
            "COMMAND_BATCH",
            "GET_CARD_SWITCHER_TIME",
            "UPDATE_CARD_SWITCHER_TIME",
            "ADD_CARD_SWITCHER_TIME",
            "REMOVE_CARD_SWITCHER_TIME",
            "GET_CARD_SWITCHER_SMART",
            "SET_CARD_SWITCHER_SMART",
            "NOTIFY_CARD_STICK",
            "OPEN_TAI",
            "PROBE_SECTOR",
            "CLOSE_TAI",
            "CRACK_SECTORS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = nfc::NfcId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COMMAND" => Ok(nfc::NfcId::Command),
                    "ISSUE_CARD" => Ok(nfc::NfcId::IssueCard),
                    "ADD_CARD" => Ok(nfc::NfcId::AddCard),
                    "DEL_CARD" => Ok(nfc::NfcId::DelCard),
                    "SYNC_CARD_LIST" => Ok(nfc::NfcId::SyncCardList),
                    "SET_DEFAULT_CARD" => Ok(nfc::NfcId::SetDefaultCard),
                    "GET_DEFAULT_CARD" => Ok(nfc::NfcId::GetDefaultCard),
                    "SET_BALANCE" => Ok(nfc::NfcId::SetBalance),
                    "GET_BALANCE" => Ok(nfc::NfcId::GetBalance),
                    "SET_CONFIG" => Ok(nfc::NfcId::SetConfig),
                    "CAPABILITY_SET" => Ok(nfc::NfcId::CapabilitySet),
                    "COMMAND_BATCH" => Ok(nfc::NfcId::CommandBatch),
                    "GET_CARD_SWITCHER_TIME" => Ok(nfc::NfcId::GetCardSwitcherTime),
                    "UPDATE_CARD_SWITCHER_TIME" => Ok(nfc::NfcId::UpdateCardSwitcherTime),
                    "ADD_CARD_SWITCHER_TIME" => Ok(nfc::NfcId::AddCardSwitcherTime),
                    "REMOVE_CARD_SWITCHER_TIME" => Ok(nfc::NfcId::RemoveCardSwitcherTime),
                    "GET_CARD_SWITCHER_SMART" => Ok(nfc::NfcId::GetCardSwitcherSmart),
                    "SET_CARD_SWITCHER_SMART" => Ok(nfc::NfcId::SetCardSwitcherSmart),
                    "NOTIFY_CARD_STICK" => Ok(nfc::NfcId::NotifyCardStick),
                    "OPEN_TAI" => Ok(nfc::NfcId::OpenTai),
                    "PROBE_SECTOR" => Ok(nfc::NfcId::ProbeSector),
                    "CLOSE_TAI" => Ok(nfc::NfcId::CloseTai),
                    "CRACK_SECTORS" => Ok(nfc::NfcId::CrackSectors),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for NfcInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.NfcInfo", len)?;
        struct_ser.serialize_field("key", &self.key)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("value", pbjson::private::base64::encode(&self.value).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NfcInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "key" => Ok(GeneratedField::Key),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NfcInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NfcInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NfcInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(NfcInfo {
                    key: key__.ok_or_else(|| serde::de::Error::missing_field("key"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NfcInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for nfc_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NfcInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for nfc_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = nfc_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NfcInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<nfc_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(nfc_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.NfcInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NightMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.start_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NightMode", len)?;
        let v = night_mode::Mode::try_from(self.mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.mode)))?;
        struct_ser.serialize_field("mode", &v)?;
        if let Some(v) = self.start_time.as_ref() {
            struct_ser.serialize_field("startTime", v)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            struct_ser.serialize_field("endTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NightMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mode",
            "start_time",
            "startTime",
            "end_time",
            "endTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mode,
            StartTime,
            EndTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mode" => Ok(GeneratedField::Mode),
                            "startTime" | "start_time" => Ok(GeneratedField::StartTime),
                            "endTime" | "end_time" => Ok(GeneratedField::EndTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NightMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NightMode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NightMode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mode__ = None;
                let mut start_time__ = None;
                let mut end_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = Some(map_.next_value::<night_mode::Mode>()? as i32);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = map_.next_value()?;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endTime"));
                            }
                            end_time__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NightMode {
                    mode: mode__.ok_or_else(|| serde::de::Error::missing_field("mode"))?,
                    start_time: start_time__,
                    end_time: end_time__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NightMode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for night_mode::Mode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Off => "OFF",
            Self::SunsetOn => "SUNSET_ON",
            Self::TimingOn => "TIMING_ON",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for night_mode::Mode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OFF",
            "SUNSET_ON",
            "TIMING_ON",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = night_mode::Mode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OFF" => Ok(night_mode::Mode::Off),
                    "SUNSET_ON" => Ok(night_mode::Mode::SunsetOn),
                    "TIMING_ON" => Ok(night_mode::Mode::TimingOn),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Notification {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Notification", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                notification::Payload::Data(v) => {
                    struct_ser.serialize_field("data", v)?;
                }
                notification::Payload::Id(v) => {
                    struct_ser.serialize_field("id", v)?;
                }
                notification::Payload::DataList(v) => {
                    struct_ser.serialize_field("dataList", v)?;
                }
                notification::Payload::IdList(v) => {
                    struct_ser.serialize_field("idList", v)?;
                }
                notification::Payload::AppInfo(v) => {
                    struct_ser.serialize_field("appInfo", v)?;
                }
                notification::Payload::AppInfoList(v) => {
                    struct_ser.serialize_field("appInfoList", v)?;
                }
                notification::Payload::EnableAutoScreen(v) => {
                    struct_ser.serialize_field("enableAutoScreen", v)?;
                }
                notification::Payload::ReplyMsgTarget(v) => {
                    let v = reply_msg::Target::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("replyMsgTarget", &v)?;
                }
                notification::Payload::ReplyMsg(v) => {
                    struct_ser.serialize_field("replyMsg", v)?;
                }
                notification::Payload::ReplyMsgRemoval(v) => {
                    struct_ser.serialize_field("replyMsgRemoval", v)?;
                }
                notification::Payload::ReplyMsgResult(v) => {
                    let v = reply_msg::Result::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("replyMsgResult", &v)?;
                }
                notification::Payload::ReplyRequest(v) => {
                    struct_ser.serialize_field("replyRequest", v)?;
                }
                notification::Payload::ReplyResult(v) => {
                    let v = ReplyResult::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("replyResult", &v)?;
                }
                notification::Payload::AppIconRequest(v) => {
                    struct_ser.serialize_field("appIconRequest", v)?;
                }
                notification::Payload::AppIconResponse(v) => {
                    struct_ser.serialize_field("appIconResponse", v)?;
                }
                notification::Payload::AppIconApply(v) => {
                    struct_ser.serialize_field("appIconApply", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Notification {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "data",
            "id",
            "data_list",
            "dataList",
            "id_list",
            "idList",
            "app_info",
            "appInfo",
            "app_info_list",
            "appInfoList",
            "enable_auto_screen",
            "enableAutoScreen",
            "reply_msg_target",
            "replyMsgTarget",
            "reply_msg",
            "replyMsg",
            "reply_msg_removal",
            "replyMsgRemoval",
            "reply_msg_result",
            "replyMsgResult",
            "reply_request",
            "replyRequest",
            "reply_result",
            "replyResult",
            "app_icon_request",
            "appIconRequest",
            "app_icon_response",
            "appIconResponse",
            "app_icon_apply",
            "appIconApply",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Data,
            Id,
            DataList,
            IdList,
            AppInfo,
            AppInfoList,
            EnableAutoScreen,
            ReplyMsgTarget,
            ReplyMsg,
            ReplyMsgRemoval,
            ReplyMsgResult,
            ReplyRequest,
            ReplyResult,
            AppIconRequest,
            AppIconResponse,
            AppIconApply,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "data" => Ok(GeneratedField::Data),
                            "id" => Ok(GeneratedField::Id),
                            "dataList" | "data_list" => Ok(GeneratedField::DataList),
                            "idList" | "id_list" => Ok(GeneratedField::IdList),
                            "appInfo" | "app_info" => Ok(GeneratedField::AppInfo),
                            "appInfoList" | "app_info_list" => Ok(GeneratedField::AppInfoList),
                            "enableAutoScreen" | "enable_auto_screen" => Ok(GeneratedField::EnableAutoScreen),
                            "replyMsgTarget" | "reply_msg_target" => Ok(GeneratedField::ReplyMsgTarget),
                            "replyMsg" | "reply_msg" => Ok(GeneratedField::ReplyMsg),
                            "replyMsgRemoval" | "reply_msg_removal" => Ok(GeneratedField::ReplyMsgRemoval),
                            "replyMsgResult" | "reply_msg_result" => Ok(GeneratedField::ReplyMsgResult),
                            "replyRequest" | "reply_request" => Ok(GeneratedField::ReplyRequest),
                            "replyResult" | "reply_result" => Ok(GeneratedField::ReplyResult),
                            "appIconRequest" | "app_icon_request" => Ok(GeneratedField::AppIconRequest),
                            "appIconResponse" | "app_icon_response" => Ok(GeneratedField::AppIconResponse),
                            "appIconApply" | "app_icon_apply" => Ok(GeneratedField::AppIconApply),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Notification;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Notification")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Notification, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Data => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::Data)
;
                        }
                        GeneratedField::Id => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::Id)
;
                        }
                        GeneratedField::DataList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::DataList)
;
                        }
                        GeneratedField::IdList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("idList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::IdList)
;
                        }
                        GeneratedField::AppInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::AppInfo)
;
                        }
                        GeneratedField::AppInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::AppInfoList)
;
                        }
                        GeneratedField::EnableAutoScreen => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enableAutoScreen"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::EnableAutoScreen);
                        }
                        GeneratedField::ReplyMsgTarget => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replyMsgTarget"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<reply_msg::Target>>()?.map(|x| notification::Payload::ReplyMsgTarget(x as i32));
                        }
                        GeneratedField::ReplyMsg => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replyMsg"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::ReplyMsg)
;
                        }
                        GeneratedField::ReplyMsgRemoval => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replyMsgRemoval"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::ReplyMsgRemoval)
;
                        }
                        GeneratedField::ReplyMsgResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replyMsgResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<reply_msg::Result>>()?.map(|x| notification::Payload::ReplyMsgResult(x as i32));
                        }
                        GeneratedField::ReplyRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replyRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::ReplyRequest)
;
                        }
                        GeneratedField::ReplyResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("replyResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<ReplyResult>>()?.map(|x| notification::Payload::ReplyResult(x as i32));
                        }
                        GeneratedField::AppIconRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appIconRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::AppIconRequest)
;
                        }
                        GeneratedField::AppIconResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appIconResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::AppIconResponse)
;
                        }
                        GeneratedField::AppIconApply => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appIconApply"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(notification::Payload::AppIconApply)
;
                        }
                    }
                }
                Ok(Notification {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Notification", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notification::NotificationId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AddNotify => "ADD_NOTIFY",
            Self::RemoveNotify => "REMOVE_NOTIFY",
            Self::OpenNotify => "OPEN_NOTIFY",
            Self::HangUp => "HANG_UP",
            Self::IncomingCallMute => "INCOMING_CALL_MUTE",
            Self::GetAppList => "GET_APP_LIST",
            Self::SetApp => "SET_APP",
            Self::GetAutoScreen => "GET_AUTO_SCREEN",
            Self::SetAutoScreen => "SET_AUTO_SCREEN",
            Self::GetReplyMsg => "GET_REPLY_MSG",
            Self::AddReplyMsg => "ADD_REPLY_MSG",
            Self::RemoveReplyMsg => "REMOVE_REPLY_MSG",
            Self::UpdateReplyMsg => "UPDATE_REPLY_MSG",
            Self::ReplyMsgRequest => "REPLY_MSG_REQUEST",
            Self::ReplyMsgResult => "REPLY_MSG_RESULT",
            Self::PrepareAppIcon => "PREPARE_APP_ICON",
            Self::AppIconApply => "APP_ICON_APPLY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for notification::NotificationId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ADD_NOTIFY",
            "REMOVE_NOTIFY",
            "OPEN_NOTIFY",
            "HANG_UP",
            "INCOMING_CALL_MUTE",
            "GET_APP_LIST",
            "SET_APP",
            "GET_AUTO_SCREEN",
            "SET_AUTO_SCREEN",
            "GET_REPLY_MSG",
            "ADD_REPLY_MSG",
            "REMOVE_REPLY_MSG",
            "UPDATE_REPLY_MSG",
            "REPLY_MSG_REQUEST",
            "REPLY_MSG_RESULT",
            "PREPARE_APP_ICON",
            "APP_ICON_APPLY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notification::NotificationId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ADD_NOTIFY" => Ok(notification::NotificationId::AddNotify),
                    "REMOVE_NOTIFY" => Ok(notification::NotificationId::RemoveNotify),
                    "OPEN_NOTIFY" => Ok(notification::NotificationId::OpenNotify),
                    "HANG_UP" => Ok(notification::NotificationId::HangUp),
                    "INCOMING_CALL_MUTE" => Ok(notification::NotificationId::IncomingCallMute),
                    "GET_APP_LIST" => Ok(notification::NotificationId::GetAppList),
                    "SET_APP" => Ok(notification::NotificationId::SetApp),
                    "GET_AUTO_SCREEN" => Ok(notification::NotificationId::GetAutoScreen),
                    "SET_AUTO_SCREEN" => Ok(notification::NotificationId::SetAutoScreen),
                    "GET_REPLY_MSG" => Ok(notification::NotificationId::GetReplyMsg),
                    "ADD_REPLY_MSG" => Ok(notification::NotificationId::AddReplyMsg),
                    "REMOVE_REPLY_MSG" => Ok(notification::NotificationId::RemoveReplyMsg),
                    "UPDATE_REPLY_MSG" => Ok(notification::NotificationId::UpdateReplyMsg),
                    "REPLY_MSG_REQUEST" => Ok(notification::NotificationId::ReplyMsgRequest),
                    "REPLY_MSG_RESULT" => Ok(notification::NotificationId::ReplyMsgResult),
                    "PREPARE_APP_ICON" => Ok(notification::NotificationId::PrepareAppIcon),
                    "APP_ICON_APPLY" => Ok(notification::NotificationId::AppIconApply),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 10;
        if self.call_type.is_some() {
            len += 1;
        }
        if self.support_reply.is_some() {
            len += 1;
        }
        if self.support_open.is_some() {
            len += 1;
        }
        if self.focus.is_some() {
            len += 1;
        }
        if self.focus_v2.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData", len)?;
        struct_ser.serialize_field("appId", &self.app_id)?;
        struct_ser.serialize_field("appName", &self.app_name)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("subTitle", &self.sub_title)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.serialize_field("date", &self.date)?;
        struct_ser.serialize_field("uid", &self.uid)?;
        struct_ser.serialize_field("appGroup", &self.app_group)?;
        struct_ser.serialize_field("key", &self.key)?;
        if let Some(v) = self.call_type.as_ref() {
            let v = CallType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("callType", &v)?;
        }
        struct_ser.serialize_field("callNumber", &self.call_number)?;
        if let Some(v) = self.support_reply.as_ref() {
            struct_ser.serialize_field("supportReply", v)?;
        }
        if let Some(v) = self.support_open.as_ref() {
            struct_ser.serialize_field("supportOpen", v)?;
        }
        if let Some(v) = self.focus.as_ref() {
            struct_ser.serialize_field("focus", v)?;
        }
        if let Some(v) = self.focus_v2.as_ref() {
            struct_ser.serialize_field("focusV2", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_id",
            "appId",
            "app_name",
            "appName",
            "title",
            "sub_title",
            "subTitle",
            "text",
            "date",
            "uid",
            "app_group",
            "appGroup",
            "key",
            "call_type",
            "callType",
            "call_number",
            "callNumber",
            "support_reply",
            "supportReply",
            "support_open",
            "supportOpen",
            "focus",
            "focus_v2",
            "focusV2",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppId,
            AppName,
            Title,
            SubTitle,
            Text,
            Date,
            Uid,
            AppGroup,
            Key,
            CallType,
            CallNumber,
            SupportReply,
            SupportOpen,
            Focus,
            FocusV2,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appId" | "app_id" => Ok(GeneratedField::AppId),
                            "appName" | "app_name" => Ok(GeneratedField::AppName),
                            "title" => Ok(GeneratedField::Title),
                            "subTitle" | "sub_title" => Ok(GeneratedField::SubTitle),
                            "text" => Ok(GeneratedField::Text),
                            "date" => Ok(GeneratedField::Date),
                            "uid" => Ok(GeneratedField::Uid),
                            "appGroup" | "app_group" => Ok(GeneratedField::AppGroup),
                            "key" => Ok(GeneratedField::Key),
                            "callType" | "call_type" => Ok(GeneratedField::CallType),
                            "callNumber" | "call_number" => Ok(GeneratedField::CallNumber),
                            "supportReply" | "support_reply" => Ok(GeneratedField::SupportReply),
                            "supportOpen" | "support_open" => Ok(GeneratedField::SupportOpen),
                            "focus" => Ok(GeneratedField::Focus),
                            "focusV2" | "focus_v2" => Ok(GeneratedField::FocusV2),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut app_id__ = None;
                let mut app_name__ = None;
                let mut title__ = None;
                let mut sub_title__ = None;
                let mut text__ = None;
                let mut date__ = None;
                let mut uid__ = None;
                let mut app_group__ = None;
                let mut key__ = None;
                let mut call_type__ = None;
                let mut call_number__ = None;
                let mut support_reply__ = None;
                let mut support_open__ = None;
                let mut focus__ = None;
                let mut focus_v2__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppId => {
                            if app_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appId"));
                            }
                            app_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppName => {
                            if app_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appName"));
                            }
                            app_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubTitle => {
                            if sub_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subTitle"));
                            }
                            sub_title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Date => {
                            if date__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            date__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AppGroup => {
                            if app_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appGroup"));
                            }
                            app_group__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CallType => {
                            if call_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("callType"));
                            }
                            call_type__ = map_.next_value::<::std::option::Option<CallType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CallNumber => {
                            if call_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("callNumber"));
                            }
                            call_number__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportReply => {
                            if support_reply__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportReply"));
                            }
                            support_reply__ = map_.next_value()?;
                        }
                        GeneratedField::SupportOpen => {
                            if support_open__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportOpen"));
                            }
                            support_open__ = map_.next_value()?;
                        }
                        GeneratedField::Focus => {
                            if focus__.is_some() {
                                return Err(serde::de::Error::duplicate_field("focus"));
                            }
                            focus__ = map_.next_value()?;
                        }
                        GeneratedField::FocusV2 => {
                            if focus_v2__.is_some() {
                                return Err(serde::de::Error::duplicate_field("focusV2"));
                            }
                            focus_v2__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyData {
                    app_id: app_id__.ok_or_else(|| serde::de::Error::missing_field("appId"))?,
                    app_name: app_name__.ok_or_else(|| serde::de::Error::missing_field("appName"))?,
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    sub_title: sub_title__.ok_or_else(|| serde::de::Error::missing_field("subTitle"))?,
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                    date: date__.ok_or_else(|| serde::de::Error::missing_field("date"))?,
                    uid: uid__.ok_or_else(|| serde::de::Error::missing_field("uid"))?,
                    app_group: app_group__.ok_or_else(|| serde::de::Error::missing_field("appGroup"))?,
                    key: key__.ok_or_else(|| serde::de::Error::missing_field("key"))?,
                    call_type: call_type__,
                    call_number: call_number__.ok_or_else(|| serde::de::Error::missing_field("callNumber"))?,
                    support_reply: support_reply__,
                    support_open: support_open__,
                    focus: focus__,
                    focus_v2: focus_v2__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_data::Focus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.progress.is_some() {
            len += 1;
        }
        if self.updatable.is_some() {
            len += 1;
        }
        if self.sequence.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData.Focus", len)?;
        struct_ser.serialize_field("style", &self.style)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("content", &self.content)?;
        struct_ser.serialize_field("desc", &self.desc)?;
        if let Some(v) = self.progress.as_ref() {
            struct_ser.serialize_field("progress", v)?;
        }
        if let Some(v) = self.updatable.as_ref() {
            struct_ser.serialize_field("updatable", v)?;
        }
        if let Some(v) = self.sequence.as_ref() {
            struct_ser.serialize_field("sequence", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_data::Focus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "style",
            "title",
            "content",
            "desc",
            "progress",
            "updatable",
            "sequence",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Style,
            Title,
            Content,
            Desc,
            Progress,
            Updatable,
            Sequence,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "style" => Ok(GeneratedField::Style),
                            "title" => Ok(GeneratedField::Title),
                            "content" => Ok(GeneratedField::Content),
                            "desc" => Ok(GeneratedField::Desc),
                            "progress" => Ok(GeneratedField::Progress),
                            "updatable" => Ok(GeneratedField::Updatable),
                            "sequence" => Ok(GeneratedField::Sequence),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_data::Focus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData.Focus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_data::Focus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut style__ = None;
                let mut title__ = None;
                let mut content__ = None;
                let mut desc__ = None;
                let mut progress__ = None;
                let mut updatable__ = None;
                let mut sequence__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Style => {
                            if style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("style"));
                            }
                            style__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = map_.next_value()?;
                        }
                        GeneratedField::Desc => {
                            if desc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("desc"));
                            }
                            desc__ = map_.next_value()?;
                        }
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("progress"));
                            }
                            progress__ = map_.next_value()?;
                        }
                        GeneratedField::Updatable => {
                            if updatable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updatable"));
                            }
                            updatable__ = map_.next_value()?;
                        }
                        GeneratedField::Sequence => {
                            if sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequence"));
                            }
                            sequence__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(notify_data::Focus {
                    style: style__.ok_or_else(|| serde::de::Error::missing_field("style"))?,
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    content: content__.ok_or_else(|| serde::de::Error::missing_field("content"))?,
                    desc: desc__.ok_or_else(|| serde::de::Error::missing_field("desc"))?,
                    progress: progress__,
                    updatable: updatable__,
                    sequence: sequence__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData.Focus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_data::FocusV2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.hint_info.is_some() {
            len += 1;
        }
        if self.progress.is_some() {
            len += 1;
        }
        if self.updatable.is_some() {
            len += 1;
        }
        if self.sequence.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData.FocusV2", len)?;
        struct_ser.serialize_field("scene", &self.scene)?;
        struct_ser.serialize_field("ticker", &self.ticker)?;
        struct_ser.serialize_field("basicInfo", &self.basic_info)?;
        if let Some(v) = self.hint_info.as_ref() {
            struct_ser.serialize_field("hintInfo", v)?;
        }
        if let Some(v) = self.progress.as_ref() {
            struct_ser.serialize_field("progress", v)?;
        }
        if let Some(v) = self.updatable.as_ref() {
            struct_ser.serialize_field("updatable", v)?;
        }
        if let Some(v) = self.sequence.as_ref() {
            struct_ser.serialize_field("sequence", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_data::FocusV2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scene",
            "ticker",
            "basic_info",
            "basicInfo",
            "hint_info",
            "hintInfo",
            "progress",
            "updatable",
            "sequence",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scene,
            Ticker,
            BasicInfo,
            HintInfo,
            Progress,
            Updatable,
            Sequence,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scene" => Ok(GeneratedField::Scene),
                            "ticker" => Ok(GeneratedField::Ticker),
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "hintInfo" | "hint_info" => Ok(GeneratedField::HintInfo),
                            "progress" => Ok(GeneratedField::Progress),
                            "updatable" => Ok(GeneratedField::Updatable),
                            "sequence" => Ok(GeneratedField::Sequence),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_data::FocusV2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData.FocusV2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_data::FocusV2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene__ = None;
                let mut ticker__ = None;
                let mut basic_info__ = None;
                let mut hint_info__ = None;
                let mut progress__ = None;
                let mut updatable__ = None;
                let mut sequence__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scene => {
                            if scene__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scene"));
                            }
                            scene__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Ticker => {
                            if ticker__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticker"));
                            }
                            ticker__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BasicInfo => {
                            if basic_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            basic_info__ = map_.next_value()?;
                        }
                        GeneratedField::HintInfo => {
                            if hint_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hintInfo"));
                            }
                            hint_info__ = map_.next_value()?;
                        }
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("progress"));
                            }
                            progress__ = map_.next_value()?;
                        }
                        GeneratedField::Updatable => {
                            if updatable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updatable"));
                            }
                            updatable__ = map_.next_value()?;
                        }
                        GeneratedField::Sequence => {
                            if sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequence"));
                            }
                            sequence__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(notify_data::FocusV2 {
                    scene: scene__.ok_or_else(|| serde::de::Error::missing_field("scene"))?,
                    ticker: ticker__.ok_or_else(|| serde::de::Error::missing_field("ticker"))?,
                    basic_info: basic_info__.ok_or_else(|| serde::de::Error::missing_field("basicInfo"))?,
                    hint_info: hint_info__,
                    progress: progress__,
                    updatable: updatable__,
                    sequence: sequence__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData.FocusV2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_data::Info {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.sub_title.is_some() {
            len += 1;
        }
        if self.content.is_some() {
            len += 1;
        }
        if self.sub_content.is_some() {
            len += 1;
        }
        if self.special_title.is_some() {
            len += 1;
        }
        if self.special_title_bg.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData.Info", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        if let Some(v) = self.sub_title.as_ref() {
            struct_ser.serialize_field("subTitle", v)?;
        }
        if let Some(v) = self.content.as_ref() {
            struct_ser.serialize_field("content", v)?;
        }
        if let Some(v) = self.sub_content.as_ref() {
            struct_ser.serialize_field("subContent", v)?;
        }
        if let Some(v) = self.special_title.as_ref() {
            struct_ser.serialize_field("specialTitle", v)?;
        }
        if let Some(v) = self.special_title_bg.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("specialTitleBg", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_data::Info {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "sub_title",
            "subTitle",
            "content",
            "sub_content",
            "subContent",
            "special_title",
            "specialTitle",
            "special_title_bg",
            "specialTitleBg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            SubTitle,
            Content,
            SubContent,
            SpecialTitle,
            SpecialTitleBg,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "subTitle" | "sub_title" => Ok(GeneratedField::SubTitle),
                            "content" => Ok(GeneratedField::Content),
                            "subContent" | "sub_content" => Ok(GeneratedField::SubContent),
                            "specialTitle" | "special_title" => Ok(GeneratedField::SpecialTitle),
                            "specialTitleBg" | "special_title_bg" => Ok(GeneratedField::SpecialTitleBg),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_data::Info;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData.Info")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_data::Info, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut sub_title__ = None;
                let mut content__ = None;
                let mut sub_content__ = None;
                let mut special_title__ = None;
                let mut special_title_bg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::SubTitle => {
                            if sub_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subTitle"));
                            }
                            sub_title__ = map_.next_value()?;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = map_.next_value()?;
                        }
                        GeneratedField::SubContent => {
                            if sub_content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subContent"));
                            }
                            sub_content__ = map_.next_value()?;
                        }
                        GeneratedField::SpecialTitle => {
                            if special_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("specialTitle"));
                            }
                            special_title__ = map_.next_value()?;
                        }
                        GeneratedField::SpecialTitleBg => {
                            if special_title_bg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("specialTitleBg"));
                            }
                            special_title_bg__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(notify_data::Info {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    sub_title: sub_title__,
                    content: content__,
                    sub_content: sub_content__,
                    special_title: special_title__,
                    special_title_bg: special_title_bg__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData.Info", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_data::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_data::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_data::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_data::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(notify_data::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_data::Progress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.color.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData.Progress", len)?;
        struct_ser.serialize_field("sectionCount", &self.section_count)?;
        struct_ser.serialize_field("progress", &self.progress)?;
        if let Some(v) = self.color.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("color", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_data::Progress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "section_count",
            "sectionCount",
            "progress",
            "color",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SectionCount,
            Progress,
            Color,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sectionCount" | "section_count" => Ok(GeneratedField::SectionCount),
                            "progress" => Ok(GeneratedField::Progress),
                            "color" => Ok(GeneratedField::Color),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_data::Progress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData.Progress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_data::Progress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut section_count__ = None;
                let mut progress__ = None;
                let mut color__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SectionCount => {
                            if section_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sectionCount"));
                            }
                            section_count__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("progress"));
                            }
                            progress__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Color => {
                            if color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("color"));
                            }
                            color__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(notify_data::Progress {
                    section_count: section_count__.ok_or_else(|| serde::de::Error::missing_field("sectionCount"))?,
                    progress: progress__.ok_or_else(|| serde::de::Error::missing_field("progress"))?,
                    color: color__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData.Progress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_data::Text {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.color.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyData.Text", len)?;
        struct_ser.serialize_field("chars", &self.chars)?;
        if let Some(v) = self.color.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("color", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_data::Text {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "chars",
            "color",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Chars,
            Color,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "chars" => Ok(GeneratedField::Chars),
                            "color" => Ok(GeneratedField::Color),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_data::Text;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyData.Text")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_data::Text, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut chars__ = None;
                let mut color__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Chars => {
                            if chars__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chars"));
                            }
                            chars__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Color => {
                            if color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("color"));
                            }
                            color__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(notify_data::Text {
                    chars: chars__.ok_or_else(|| serde::de::Error::missing_field("chars"))?,
                    color: color__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyData.Text", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyId", len)?;
        struct_ser.serialize_field("uid", &self.uid)?;
        struct_ser.serialize_field("appId", &self.app_id)?;
        struct_ser.serialize_field("appGroup", &self.app_group)?;
        struct_ser.serialize_field("key", &self.key)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "uid",
            "app_id",
            "appId",
            "app_group",
            "appGroup",
            "key",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uid,
            AppId,
            AppGroup,
            Key,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "uid" => Ok(GeneratedField::Uid),
                            "appId" | "app_id" => Ok(GeneratedField::AppId),
                            "appGroup" | "app_group" => Ok(GeneratedField::AppGroup),
                            "key" => Ok(GeneratedField::Key),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyId")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyId, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uid__ = None;
                let mut app_id__ = None;
                let mut app_group__ = None;
                let mut key__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uid => {
                            if uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uid"));
                            }
                            uid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AppId => {
                            if app_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appId"));
                            }
                            app_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppGroup => {
                            if app_group__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appGroup"));
                            }
                            app_group__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("key"));
                            }
                            key__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(NotifyId {
                    uid: uid__.ok_or_else(|| serde::de::Error::missing_field("uid"))?,
                    app_id: app_id__.ok_or_else(|| serde::de::Error::missing_field("appId"))?,
                    app_group: app_group__.ok_or_else(|| serde::de::Error::missing_field("appGroup"))?,
                    key: key__.ok_or_else(|| serde::de::Error::missing_field("key"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyId", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for notify_id::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.NotifyId.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for notify_id::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = notify_id::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.NotifyId.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<notify_id::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(notify_id::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.NotifyId.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OobMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoOob => "NO_OOB",
            Self::NumericComparison => "NUMERIC_COMPARISON",
            Self::DynamicCode => "DYNAMIC_CODE",
            Self::ButtonConfirm => "BUTTON_CONFIRM",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for OobMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_OOB",
            "NUMERIC_COMPARISON",
            "DYNAMIC_CODE",
            "BUTTON_CONFIRM",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OobMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_OOB" => Ok(OobMode::NoOob),
                    "NUMERIC_COMPARISON" => Ok(OobMode::NumericComparison),
                    "DYNAMIC_CODE" => Ok(OobMode::DynamicCode),
                    "BUTTON_CONFIRM" => Ok(OobMode::ButtonConfirm),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for OperateResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.OperateResult", len)?;
        struct_ser.serialize_field("success", &self.success)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OperateResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "success",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "success" => Ok(GeneratedField::Success),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OperateResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.OperateResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OperateResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(OperateResult {
                    success: success__.ok_or_else(|| serde::de::Error::missing_field("success"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.OperateResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OptionalSwitcher {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoFeature => "NO_FEATURE",
            Self::On => "ON",
            Self::Off => "OFF",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for OptionalSwitcher {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_FEATURE",
            "ON",
            "OFF",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OptionalSwitcher;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_FEATURE" => Ok(OptionalSwitcher::NoFeature),
                    "ON" => Ok(OptionalSwitcher::On),
                    "OFF" => Ok(OptionalSwitcher::Off),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Order {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::HeadResident => "HEAD_RESIDENT",
            Self::Highest => "HIGHEST",
            Self::Lowest => "LOWEST",
            Self::Resident => "RESIDENT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for Order {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HEAD_RESIDENT",
            "HIGHEST",
            "LOWEST",
            "RESIDENT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Order;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "HEAD_RESIDENT" => Ok(Order::HeadResident),
                    "HIGHEST" => Ok(Order::Highest),
                    "LOWEST" => Ok(Order::Lowest),
                    "RESIDENT" => Ok(Order::Resident),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PermissionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.grant_permissions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PermissionInfo", len)?;
        struct_ser.serialize_field("basicInfo", &self.basic_info)?;
        if !self.grant_permissions.is_empty() {
            let v = self.grant_permissions.iter().cloned().map(|v| {
                permission_info::Permission::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("grantPermissions", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PermissionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_info",
            "basicInfo",
            "grant_permissions",
            "grantPermissions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicInfo,
            GrantPermissions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "grantPermissions" | "grant_permissions" => Ok(GeneratedField::GrantPermissions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PermissionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PermissionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PermissionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_info__ = None;
                let mut grant_permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicInfo => {
                            if basic_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            basic_info__ = map_.next_value()?;
                        }
                        GeneratedField::GrantPermissions => {
                            if grant_permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("grantPermissions"));
                            }
                            grant_permissions__ = Some(map_.next_value::<Vec<permission_info::Permission>>()?.into_iter().map(|x| x as i32).collect());
                        }
                    }
                }
                Ok(PermissionInfo {
                    basic_info: basic_info__.ok_or_else(|| serde::de::Error::missing_field("basicInfo"))?,
                    grant_permissions: grant_permissions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.PermissionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for permission_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PermissionInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for permission_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = permission_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PermissionInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<permission_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(permission_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.PermissionInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for permission_info::Permission {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DeviceStatus => "DEVICE_STATUS",
            Self::UserStatus => "USER_STATUS",
            Self::BodySensor => "BODY_SENSOR",
            Self::MotionSensor => "MOTION_SENSOR",
            Self::Notify => "NOTIFY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for permission_info::Permission {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DEVICE_STATUS",
            "USER_STATUS",
            "BODY_SENSOR",
            "MOTION_SENSOR",
            "NOTIFY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = permission_info::Permission;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DEVICE_STATUS" => Ok(permission_info::Permission::DeviceStatus),
                    "USER_STATUS" => Ok(permission_info::Permission::UserStatus),
                    "BODY_SENSOR" => Ok(permission_info::Permission::BodySensor),
                    "MOTION_SENSOR" => Ok(permission_info::Permission::MotionSensor),
                    "NOTIFY" => Ok(permission_info::Permission::Notify),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneAlarm {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.alert_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneAlarm", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        if let Some(v) = self.alert_time.as_ref() {
            struct_ser.serialize_field("alertTime", v)?;
        }
        struct_ser.serialize_field("label", &self.label)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneAlarm {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "alert_time",
            "alertTime",
            "label",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            AlertTime,
            Label,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "alertTime" | "alert_time" => Ok(GeneratedField::AlertTime),
                            "label" => Ok(GeneratedField::Label),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneAlarm;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneAlarm")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneAlarm, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut alert_time__ = None;
                let mut label__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AlertTime => {
                            if alert_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertTime"));
                            }
                            alert_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Label => {
                            if label__.is_some() {
                                return Err(serde::de::Error::duplicate_field("label"));
                            }
                            label__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PhoneAlarm {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    alert_time: alert_time__,
                    label: label__.ok_or_else(|| serde::de::Error::missing_field("label"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneAlarm", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for phone_alarm::OpCode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Alert => "ALERT",
            Self::Dismiss => "DISMISS",
            Self::Snooze => "SNOOZE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for phone_alarm::OpCode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALERT",
            "DISMISS",
            "SNOOZE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = phone_alarm::OpCode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALERT" => Ok(phone_alarm::OpCode::Alert),
                    "DISMISS" => Ok(phone_alarm::OpCode::Dismiss),
                    "SNOOZE" => Ok(phone_alarm::OpCode::Snooze),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for phone_alarm::Operation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneAlarm.Operation", len)?;
        let v = phone_alarm::OpCode::try_from(self.op_code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.op_code)))?;
        struct_ser.serialize_field("opCode", &v)?;
        struct_ser.serialize_field("phoneAlarm", &self.phone_alarm)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for phone_alarm::Operation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "op_code",
            "opCode",
            "phone_alarm",
            "phoneAlarm",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpCode,
            PhoneAlarm,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "opCode" | "op_code" => Ok(GeneratedField::OpCode),
                            "phoneAlarm" | "phone_alarm" => Ok(GeneratedField::PhoneAlarm),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = phone_alarm::Operation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneAlarm.Operation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<phone_alarm::Operation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op_code__ = None;
                let mut phone_alarm__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpCode => {
                            if op_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("opCode"));
                            }
                            op_code__ = Some(map_.next_value::<phone_alarm::OpCode>()? as i32);
                        }
                        GeneratedField::PhoneAlarm => {
                            if phone_alarm__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneAlarm"));
                            }
                            phone_alarm__ = map_.next_value()?;
                        }
                    }
                }
                Ok(phone_alarm::Operation {
                    op_code: op_code__.ok_or_else(|| serde::de::Error::missing_field("opCode"))?,
                    phone_alarm: phone_alarm__.ok_or_else(|| serde::de::Error::missing_field("phoneAlarm"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneAlarm.Operation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneAppStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneAppStatus", len)?;
        struct_ser.serialize_field("basicInfo", &self.basic_info)?;
        let v = phone_app_status::Status::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneAppStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_info",
            "basicInfo",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicInfo,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneAppStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneAppStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneAppStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_info__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicInfo => {
                            if basic_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            basic_info__ = map_.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<phone_app_status::Status>()? as i32);
                        }
                    }
                }
                Ok(PhoneAppStatus {
                    basic_info: basic_info__.ok_or_else(|| serde::de::Error::missing_field("basicInfo"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneAppStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for phone_app_status::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Connected => "CONNECTED",
            Self::Disconnected => "DISCONNECTED",
            Self::Uninstalled => "UNINSTALLED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for phone_app_status::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CONNECTED",
            "DISCONNECTED",
            "UNINSTALLED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = phone_app_status::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CONNECTED" => Ok(phone_app_status::Status::Connected),
                    "DISCONNECTED" => Ok(phone_app_status::Status::Disconnected),
                    "UNINSTALLED" => Ok(phone_app_status::Status::Uninstalled),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneControlData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.user_role.is_some() {
            len += 1;
        }
        if self.remote_control.is_some() {
            len += 1;
        }
        if self.vibrate_level.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneControlData", len)?;
        if let Some(v) = self.user_role.as_ref() {
            struct_ser.serialize_field("userRole", v)?;
        }
        if let Some(v) = self.remote_control.as_ref() {
            struct_ser.serialize_field("remoteControl", v)?;
        }
        if let Some(v) = self.vibrate_level.as_ref() {
            struct_ser.serialize_field("vibrateLevel", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneControlData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user_role",
            "userRole",
            "remote_control",
            "remoteControl",
            "vibrate_level",
            "vibrateLevel",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UserRole,
            RemoteControl,
            VibrateLevel,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "userRole" | "user_role" => Ok(GeneratedField::UserRole),
                            "remoteControl" | "remote_control" => Ok(GeneratedField::RemoteControl),
                            "vibrateLevel" | "vibrate_level" => Ok(GeneratedField::VibrateLevel),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneControlData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneControlData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneControlData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user_role__ = None;
                let mut remote_control__ = None;
                let mut vibrate_level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UserRole => {
                            if user_role__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userRole"));
                            }
                            user_role__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RemoteControl => {
                            if remote_control__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remoteControl"));
                            }
                            remote_control__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VibrateLevel => {
                            if vibrate_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibrateLevel"));
                            }
                            vibrate_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PhoneControlData {
                    user_role: user_role__,
                    remote_control: remote_control__,
                    vibrate_level: vibrate_level__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneControlData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhonePermission {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.PhonePermission", len)?;
        struct_ser.serialize_field("permissions", &self.permissions)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhonePermission {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "permissions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Permissions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "permissions" => Ok(GeneratedField::Permissions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhonePermission;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhonePermission")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhonePermission, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut permissions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Permissions => {
                            if permissions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("permissions"));
                            }
                            permissions__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PhonePermission {
                    permissions: permissions__.ok_or_else(|| serde::de::Error::missing_field("permissions"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhonePermission", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.mute_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneSetting", len)?;
        if let Some(v) = self.mute_mode.as_ref() {
            struct_ser.serialize_field("muteMode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mute_mode",
            "muteMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MuteMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "muteMode" | "mute_mode" => Ok(GeneratedField::MuteMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mute_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MuteMode => {
                            if mute_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("muteMode"));
                            }
                            mute_mode__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PhoneSetting {
                    mute_mode: mute_mode__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for phone_setting::MuteMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneSetting.MuteMode", len)?;
        struct_ser.serialize_field("mute", &self.mute)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for phone_setting::MuteMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mute",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mute,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mute" => Ok(GeneratedField::Mute),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = phone_setting::MuteMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneSetting.MuteMode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<phone_setting::MuteMode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mute__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mute => {
                            if mute__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mute"));
                            }
                            mute__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(phone_setting::MuteMode {
                    mute: mute__.ok_or_else(|| serde::de::Error::missing_field("mute"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneSetting.MuteMode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for phone_setting::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneSetting.Request", len)?;
        struct_ser.serialize_field("items", &self.items)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for phone_setting::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = phone_setting::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneSetting.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<phone_setting::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(phone_setting::Request {
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneSetting.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneSportData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneSportData", len)?;
        struct_ser.serialize_field("distance", &self.distance)?;
        struct_ser.serialize_field("pace", &self.pace)?;
        let v = GpsAccuracy::try_from(self.gps_accuracy)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.gps_accuracy)))?;
        struct_ser.serialize_field("gpsAccuracy", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneSportData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "distance",
            "pace",
            "gps_accuracy",
            "gpsAccuracy",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Distance,
            Pace,
            GpsAccuracy,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "distance" => Ok(GeneratedField::Distance),
                            "pace" => Ok(GeneratedField::Pace),
                            "gpsAccuracy" | "gps_accuracy" => Ok(GeneratedField::GpsAccuracy),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneSportData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneSportData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneSportData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut distance__ = None;
                let mut pace__ = None;
                let mut gps_accuracy__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Pace => {
                            if pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pace"));
                            }
                            pace__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::GpsAccuracy => {
                            if gps_accuracy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gpsAccuracy"));
                            }
                            gps_accuracy__ = Some(map_.next_value::<GpsAccuracy>()? as i32);
                        }
                    }
                }
                Ok(PhoneSportData {
                    distance: distance__.ok_or_else(|| serde::de::Error::missing_field("distance"))?,
                    pace: pace__.ok_or_else(|| serde::de::Error::missing_field("pace"))?,
                    gps_accuracy: gps_accuracy__.ok_or_else(|| serde::de::Error::missing_field("gpsAccuracy"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneSportData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneSportDataV2a {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.distance.is_some() {
            len += 1;
        }
        if self.current_pace.is_some() {
            len += 1;
        }
        if self.average_pace.is_some() {
            len += 1;
        }
        if self.steps.is_some() {
            len += 1;
        }
        if self.stride.is_some() {
            len += 1;
        }
        if self.stride_frequency.is_some() {
            len += 1;
        }
        if self.rise.is_some() {
            len += 1;
        }
        if self.decline.is_some() {
            len += 1;
        }
        if self.reminder_kilometre_duration.is_some() {
            len += 1;
        }
        if self.reminder_kilometre_pace.is_some() {
            len += 1;
        }
        if self.reminder_pace.is_some() {
            len += 1;
        }
        if self.reminder_heart_rate.is_some() {
            len += 1;
        }
        if self.target_type.is_some() {
            len += 1;
        }
        if self.target_value.is_some() {
            len += 1;
        }
        if self.current_value.is_some() {
            len += 1;
        }
        if self.heart_rate_section.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneSportDataV2A", len)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        struct_ser.serialize_field("heartRate", &self.heart_rate)?;
        struct_ser.serialize_field("calories", &self.calories)?;
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        if let Some(v) = self.current_pace.as_ref() {
            struct_ser.serialize_field("currentPace", v)?;
        }
        if let Some(v) = self.average_pace.as_ref() {
            struct_ser.serialize_field("averagePace", v)?;
        }
        if let Some(v) = self.steps.as_ref() {
            struct_ser.serialize_field("steps", v)?;
        }
        if let Some(v) = self.stride.as_ref() {
            struct_ser.serialize_field("stride", v)?;
        }
        if let Some(v) = self.stride_frequency.as_ref() {
            struct_ser.serialize_field("strideFrequency", v)?;
        }
        if let Some(v) = self.rise.as_ref() {
            struct_ser.serialize_field("rise", v)?;
        }
        if let Some(v) = self.decline.as_ref() {
            struct_ser.serialize_field("decline", v)?;
        }
        if let Some(v) = self.reminder_kilometre_duration.as_ref() {
            struct_ser.serialize_field("reminderKilometreDuration", v)?;
        }
        if let Some(v) = self.reminder_kilometre_pace.as_ref() {
            struct_ser.serialize_field("reminderKilometrePace", v)?;
        }
        if let Some(v) = self.reminder_pace.as_ref() {
            struct_ser.serialize_field("reminderPace", v)?;
        }
        if let Some(v) = self.reminder_heart_rate.as_ref() {
            struct_ser.serialize_field("reminderHeartRate", v)?;
        }
        if let Some(v) = self.target_type.as_ref() {
            let v = SportTargetType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("targetType", &v)?;
        }
        if let Some(v) = self.target_value.as_ref() {
            struct_ser.serialize_field("targetValue", v)?;
        }
        if let Some(v) = self.current_value.as_ref() {
            struct_ser.serialize_field("currentValue", v)?;
        }
        if let Some(v) = self.heart_rate_section.as_ref() {
            let v = HeartRateSection::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("heartRateSection", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneSportDataV2a {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "duration",
            "heart_rate",
            "heartRate",
            "calories",
            "distance",
            "current_pace",
            "currentPace",
            "average_pace",
            "averagePace",
            "steps",
            "stride",
            "stride_frequency",
            "strideFrequency",
            "rise",
            "decline",
            "reminder_kilometre_duration",
            "reminderKilometreDuration",
            "reminder_kilometre_pace",
            "reminderKilometrePace",
            "reminder_pace",
            "reminderPace",
            "reminder_heart_rate",
            "reminderHeartRate",
            "target_type",
            "targetType",
            "target_value",
            "targetValue",
            "current_value",
            "currentValue",
            "heart_rate_section",
            "heartRateSection",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Duration,
            HeartRate,
            Calories,
            Distance,
            CurrentPace,
            AveragePace,
            Steps,
            Stride,
            StrideFrequency,
            Rise,
            Decline,
            ReminderKilometreDuration,
            ReminderKilometrePace,
            ReminderPace,
            ReminderHeartRate,
            TargetType,
            TargetValue,
            CurrentValue,
            HeartRateSection,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "duration" => Ok(GeneratedField::Duration),
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "calories" => Ok(GeneratedField::Calories),
                            "distance" => Ok(GeneratedField::Distance),
                            "currentPace" | "current_pace" => Ok(GeneratedField::CurrentPace),
                            "averagePace" | "average_pace" => Ok(GeneratedField::AveragePace),
                            "steps" => Ok(GeneratedField::Steps),
                            "stride" => Ok(GeneratedField::Stride),
                            "strideFrequency" | "stride_frequency" => Ok(GeneratedField::StrideFrequency),
                            "rise" => Ok(GeneratedField::Rise),
                            "decline" => Ok(GeneratedField::Decline),
                            "reminderKilometreDuration" | "reminder_kilometre_duration" => Ok(GeneratedField::ReminderKilometreDuration),
                            "reminderKilometrePace" | "reminder_kilometre_pace" => Ok(GeneratedField::ReminderKilometrePace),
                            "reminderPace" | "reminder_pace" => Ok(GeneratedField::ReminderPace),
                            "reminderHeartRate" | "reminder_heart_rate" => Ok(GeneratedField::ReminderHeartRate),
                            "targetType" | "target_type" => Ok(GeneratedField::TargetType),
                            "targetValue" | "target_value" => Ok(GeneratedField::TargetValue),
                            "currentValue" | "current_value" => Ok(GeneratedField::CurrentValue),
                            "heartRateSection" | "heart_rate_section" => Ok(GeneratedField::HeartRateSection),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneSportDataV2a;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneSportDataV2A")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneSportDataV2a, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut duration__ = None;
                let mut heart_rate__ = None;
                let mut calories__ = None;
                let mut distance__ = None;
                let mut current_pace__ = None;
                let mut average_pace__ = None;
                let mut steps__ = None;
                let mut stride__ = None;
                let mut stride_frequency__ = None;
                let mut rise__ = None;
                let mut decline__ = None;
                let mut reminder_kilometre_duration__ = None;
                let mut reminder_kilometre_pace__ = None;
                let mut reminder_pace__ = None;
                let mut reminder_heart_rate__ = None;
                let mut target_type__ = None;
                let mut target_value__ = None;
                let mut current_value__ = None;
                let mut heart_rate_section__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentPace => {
                            if current_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPace"));
                            }
                            current_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AveragePace => {
                            if average_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("averagePace"));
                            }
                            average_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Steps => {
                            if steps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("steps"));
                            }
                            steps__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Stride => {
                            if stride__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stride"));
                            }
                            stride__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StrideFrequency => {
                            if stride_frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strideFrequency"));
                            }
                            stride_frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Rise => {
                            if rise__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rise"));
                            }
                            rise__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Decline => {
                            if decline__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decline"));
                            }
                            decline__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReminderKilometreDuration => {
                            if reminder_kilometre_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderKilometreDuration"));
                            }
                            reminder_kilometre_duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReminderKilometrePace => {
                            if reminder_kilometre_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderKilometrePace"));
                            }
                            reminder_kilometre_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReminderPace => {
                            if reminder_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderPace"));
                            }
                            reminder_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReminderHeartRate => {
                            if reminder_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderHeartRate"));
                            }
                            reminder_heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetType => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetType"));
                            }
                            target_type__ = map_.next_value::<::std::option::Option<SportTargetType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::TargetValue => {
                            if target_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetValue"));
                            }
                            target_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentValue => {
                            if current_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentValue"));
                            }
                            current_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HeartRateSection => {
                            if heart_rate_section__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRateSection"));
                            }
                            heart_rate_section__ = map_.next_value::<::std::option::Option<HeartRateSection>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(PhoneSportDataV2a {
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    heart_rate: heart_rate__.ok_or_else(|| serde::de::Error::missing_field("heartRate"))?,
                    calories: calories__.ok_or_else(|| serde::de::Error::missing_field("calories"))?,
                    distance: distance__,
                    current_pace: current_pace__,
                    average_pace: average_pace__,
                    steps: steps__,
                    stride: stride__,
                    stride_frequency: stride_frequency__,
                    rise: rise__,
                    decline: decline__,
                    reminder_kilometre_duration: reminder_kilometre_duration__,
                    reminder_kilometre_pace: reminder_kilometre_pace__,
                    reminder_pace: reminder_pace__,
                    reminder_heart_rate: reminder_heart_rate__,
                    target_type: target_type__,
                    target_value: target_value__,
                    current_value: current_value__,
                    heart_rate_section: heart_rate_section__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneSportDataV2A", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneSportDataV2d {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.altitude.is_some() {
            len += 1;
        }
        if self.speed.is_some() {
            len += 1;
        }
        if self.bearing.is_some() {
            len += 1;
        }
        if self.horizontal_accuracy.is_some() {
            len += 1;
        }
        if self.vertical_accuracy.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneSportDataV2D", len)?;
        let v = GpsAccuracy::try_from(self.gps_accuracy)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.gps_accuracy)))?;
        struct_ser.serialize_field("gpsAccuracy", &v)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("longitude", &self.longitude)?;
        struct_ser.serialize_field("latitude", &self.latitude)?;
        if let Some(v) = self.altitude.as_ref() {
            struct_ser.serialize_field("altitude", v)?;
        }
        if let Some(v) = self.speed.as_ref() {
            struct_ser.serialize_field("speed", v)?;
        }
        if let Some(v) = self.bearing.as_ref() {
            struct_ser.serialize_field("bearing", v)?;
        }
        if let Some(v) = self.horizontal_accuracy.as_ref() {
            struct_ser.serialize_field("horizontalAccuracy", v)?;
        }
        if let Some(v) = self.vertical_accuracy.as_ref() {
            struct_ser.serialize_field("verticalAccuracy", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneSportDataV2d {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "gps_accuracy",
            "gpsAccuracy",
            "timestamp",
            "longitude",
            "latitude",
            "altitude",
            "speed",
            "bearing",
            "horizontal_accuracy",
            "horizontalAccuracy",
            "vertical_accuracy",
            "verticalAccuracy",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GpsAccuracy,
            Timestamp,
            Longitude,
            Latitude,
            Altitude,
            Speed,
            Bearing,
            HorizontalAccuracy,
            VerticalAccuracy,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "gpsAccuracy" | "gps_accuracy" => Ok(GeneratedField::GpsAccuracy),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "longitude" => Ok(GeneratedField::Longitude),
                            "latitude" => Ok(GeneratedField::Latitude),
                            "altitude" => Ok(GeneratedField::Altitude),
                            "speed" => Ok(GeneratedField::Speed),
                            "bearing" => Ok(GeneratedField::Bearing),
                            "horizontalAccuracy" | "horizontal_accuracy" => Ok(GeneratedField::HorizontalAccuracy),
                            "verticalAccuracy" | "vertical_accuracy" => Ok(GeneratedField::VerticalAccuracy),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneSportDataV2d;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneSportDataV2D")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneSportDataV2d, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut gps_accuracy__ = None;
                let mut timestamp__ = None;
                let mut longitude__ = None;
                let mut latitude__ = None;
                let mut altitude__ = None;
                let mut speed__ = None;
                let mut bearing__ = None;
                let mut horizontal_accuracy__ = None;
                let mut vertical_accuracy__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::GpsAccuracy => {
                            if gps_accuracy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gpsAccuracy"));
                            }
                            gps_accuracy__ = Some(map_.next_value::<GpsAccuracy>()? as i32);
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Longitude => {
                            if longitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("longitude"));
                            }
                            longitude__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Latitude => {
                            if latitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("latitude"));
                            }
                            latitude__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Altitude => {
                            if altitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("altitude"));
                            }
                            altitude__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Speed => {
                            if speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speed"));
                            }
                            speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Bearing => {
                            if bearing__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bearing"));
                            }
                            bearing__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HorizontalAccuracy => {
                            if horizontal_accuracy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("horizontalAccuracy"));
                            }
                            horizontal_accuracy__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VerticalAccuracy => {
                            if vertical_accuracy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verticalAccuracy"));
                            }
                            vertical_accuracy__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PhoneSportDataV2d {
                    gps_accuracy: gps_accuracy__.ok_or_else(|| serde::de::Error::missing_field("gpsAccuracy"))?,
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    longitude: longitude__.ok_or_else(|| serde::de::Error::missing_field("longitude"))?,
                    latitude: latitude__.ok_or_else(|| serde::de::Error::missing_field("latitude"))?,
                    altitude: altitude__,
                    speed: speed__,
                    bearing: bearing__,
                    horizontal_accuracy: horizontal_accuracy__,
                    vertical_accuracy: vertical_accuracy__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneSportDataV2D", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneStatus", len)?;
        struct_ser.serialize_field("screen", &self.screen)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "screen",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Screen,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "screen" => Ok(GeneratedField::Screen),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut screen__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Screen => {
                            if screen__.is_some() {
                                return Err(serde::de::Error::duplicate_field("screen"));
                            }
                            screen__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PhoneStatus {
                    screen: screen__.ok_or_else(|| serde::de::Error::missing_field("screen"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneTrace {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneTrace", len)?;
        struct_ser.serialize_field("dirAngle", &self.dir_angle)?;
        struct_ser.serialize_field("dirChangeCount", &self.dir_change_count)?;
        struct_ser.serialize_field("dirChangeStd", &self.dir_change_std)?;
        struct_ser.serialize_field("dirChangeAvg", &self.dir_change_avg)?;
        struct_ser.serialize_field("ambientLightAvg", &self.ambient_light_avg)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneTrace {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dir_angle",
            "dirAngle",
            "dir_change_count",
            "dirChangeCount",
            "dir_change_std",
            "dirChangeStd",
            "dir_change_avg",
            "dirChangeAvg",
            "ambient_light_avg",
            "ambientLightAvg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DirAngle,
            DirChangeCount,
            DirChangeStd,
            DirChangeAvg,
            AmbientLightAvg,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dirAngle" | "dir_angle" => Ok(GeneratedField::DirAngle),
                            "dirChangeCount" | "dir_change_count" => Ok(GeneratedField::DirChangeCount),
                            "dirChangeStd" | "dir_change_std" => Ok(GeneratedField::DirChangeStd),
                            "dirChangeAvg" | "dir_change_avg" => Ok(GeneratedField::DirChangeAvg),
                            "ambientLightAvg" | "ambient_light_avg" => Ok(GeneratedField::AmbientLightAvg),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneTrace;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneTrace")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneTrace, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dir_angle__ = None;
                let mut dir_change_count__ = None;
                let mut dir_change_std__ = None;
                let mut dir_change_avg__ = None;
                let mut ambient_light_avg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DirAngle => {
                            if dir_angle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dirAngle"));
                            }
                            dir_angle__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DirChangeCount => {
                            if dir_change_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dirChangeCount"));
                            }
                            dir_change_count__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DirChangeStd => {
                            if dir_change_std__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dirChangeStd"));
                            }
                            dir_change_std__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DirChangeAvg => {
                            if dir_change_avg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dirChangeAvg"));
                            }
                            dir_change_avg__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AmbientLightAvg => {
                            if ambient_light_avg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ambientLightAvg"));
                            }
                            ambient_light_avg__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PhoneTrace {
                    dir_angle: dir_angle__.ok_or_else(|| serde::de::Error::missing_field("dirAngle"))?,
                    dir_change_count: dir_change_count__.ok_or_else(|| serde::de::Error::missing_field("dirChangeCount"))?,
                    dir_change_std: dir_change_std__.ok_or_else(|| serde::de::Error::missing_field("dirChangeStd"))?,
                    dir_change_avg: dir_change_avg__.ok_or_else(|| serde::de::Error::missing_field("dirChangeAvg"))?,
                    ambient_light_avg: ambient_light_avg__.ok_or_else(|| serde::de::Error::missing_field("ambientLightAvg"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneTrace", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhoneUsage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.PhoneUsage", len)?;
        struct_ser.serialize_field("hold", &self.hold)?;
        struct_ser.serialize_field("screen", &self.screen)?;
        struct_ser.serialize_field("foregroundAppType", &self.foreground_app_type)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhoneUsage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hold",
            "screen",
            "foreground_app_type",
            "foregroundAppType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Hold,
            Screen,
            ForegroundAppType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hold" => Ok(GeneratedField::Hold),
                            "screen" => Ok(GeneratedField::Screen),
                            "foregroundAppType" | "foreground_app_type" => Ok(GeneratedField::ForegroundAppType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhoneUsage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PhoneUsage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhoneUsage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hold__ = None;
                let mut screen__ = None;
                let mut foreground_app_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Hold => {
                            if hold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hold"));
                            }
                            hold__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Screen => {
                            if screen__.is_some() {
                                return Err(serde::de::Error::duplicate_field("screen"));
                            }
                            screen__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ForegroundAppType => {
                            if foreground_app_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("foregroundAppType"));
                            }
                            foreground_app_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(PhoneUsage {
                    hold: hold__.ok_or_else(|| serde::de::Error::missing_field("hold"))?,
                    screen: screen__.ok_or_else(|| serde::de::Error::missing_field("screen"))?,
                    foreground_app_type: foreground_app_type__.ok_or_else(|| serde::de::Error::missing_field("foregroundAppType"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PhoneUsage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayInfoItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.duration_in_ms.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PlayInfoItem", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        if let Some(v) = self.duration_in_ms.as_ref() {
            struct_ser.serialize_field("durationInMs", v)?;
        }
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayInfoItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "duration_in_ms",
            "durationInMs",
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            DurationInMs,
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "durationInMs" | "duration_in_ms" => Ok(GeneratedField::DurationInMs),
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayInfoItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PlayInfoItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayInfoItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut duration_in_ms__ = None;
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::DurationInMs => {
                            if duration_in_ms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("durationInMs"));
                            }
                            duration_in_ms__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PlayInfoItem {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    duration_in_ms: duration_in_ms__,
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PlayInfoItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for play_info_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PlayInfoItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for play_info_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = play_info_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PlayInfoItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<play_info_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(play_info_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.PlayInfoItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayInfoType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::PitUnknown => "PIT_UNKNOWN",
            Self::Joke => "JOKE",
            Self::Poem => "POEM",
            Self::Music => "MUSIC",
            Self::Station => "STATION",
            Self::VoiceNews => "VOICE_NEWS",
            Self::Sound => "SOUND",
            Self::Translation => "TRANSLATION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for PlayInfoType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PIT_UNKNOWN",
            "JOKE",
            "POEM",
            "MUSIC",
            "STATION",
            "VOICE_NEWS",
            "SOUND",
            "TRANSLATION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayInfoType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PIT_UNKNOWN" => Ok(PlayInfoType::PitUnknown),
                    "JOKE" => Ok(PlayInfoType::Joke),
                    "POEM" => Ok(PlayInfoType::Poem),
                    "MUSIC" => Ok(PlayInfoType::Music),
                    "STATION" => Ok(PlayInfoType::Station),
                    "VOICE_NEWS" => Ok(PlayInfoType::VoiceNews),
                    "SOUND" => Ok(PlayInfoType::Sound),
                    "TRANSLATION" => Ok(PlayInfoType::Translation),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerControl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.volume.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PlayerControl", len)?;
        let v = player_control::Command::try_from(self.command)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.command)))?;
        struct_ser.serialize_field("command", &v)?;
        if let Some(v) = self.volume.as_ref() {
            struct_ser.serialize_field("volume", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerControl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "command",
            "volume",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Command,
            Volume,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "command" => Ok(GeneratedField::Command),
                            "volume" => Ok(GeneratedField::Volume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerControl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PlayerControl")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerControl, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut command__ = None;
                let mut volume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            command__ = Some(map_.next_value::<player_control::Command>()? as i32);
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayerControl {
                    command: command__.ok_or_else(|| serde::de::Error::missing_field("command"))?,
                    volume: volume__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PlayerControl", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for player_control::Command {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Play => "PLAY",
            Self::Pause => "PAUSE",
            Self::Stop => "STOP",
            Self::Prev => "PREV",
            Self::Next => "NEXT",
            Self::AdjustVolume => "ADJUST_VOLUME",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for player_control::Command {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PLAY",
            "PAUSE",
            "STOP",
            "PREV",
            "NEXT",
            "ADJUST_VOLUME",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = player_control::Command;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PLAY" => Ok(player_control::Command::Play),
                    "PAUSE" => Ok(player_control::Command::Pause),
                    "STOP" => Ok(player_control::Command::Stop),
                    "PREV" => Ok(player_control::Command::Prev),
                    "NEXT" => Ok(player_control::Command::Next),
                    "ADJUST_VOLUME" => Ok(player_control::Command::AdjustVolume),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.volume.is_some() {
            len += 1;
        }
        if self.current_position.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PlayerInfo", len)?;
        let v = player_info::State::try_from(self.state)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.state)))?;
        struct_ser.serialize_field("state", &v)?;
        if let Some(v) = self.volume.as_ref() {
            struct_ser.serialize_field("volume", v)?;
        }
        struct_ser.serialize_field("playerName", &self.player_name)?;
        struct_ser.serialize_field("songTitle", &self.song_title)?;
        struct_ser.serialize_field("songArtist", &self.song_artist)?;
        if let Some(v) = self.current_position.as_ref() {
            struct_ser.serialize_field("currentPosition", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "state",
            "volume",
            "player_name",
            "playerName",
            "song_title",
            "songTitle",
            "song_artist",
            "songArtist",
            "current_position",
            "currentPosition",
            "duration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            Volume,
            PlayerName,
            SongTitle,
            SongArtist,
            CurrentPosition,
            Duration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            "volume" => Ok(GeneratedField::Volume),
                            "playerName" | "player_name" => Ok(GeneratedField::PlayerName),
                            "songTitle" | "song_title" => Ok(GeneratedField::SongTitle),
                            "songArtist" | "song_artist" => Ok(GeneratedField::SongArtist),
                            "currentPosition" | "current_position" => Ok(GeneratedField::CurrentPosition),
                            "duration" => Ok(GeneratedField::Duration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PlayerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut volume__ = None;
                let mut player_name__ = None;
                let mut song_title__ = None;
                let mut song_artist__ = None;
                let mut current_position__ = None;
                let mut duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value::<player_info::State>()? as i32);
                        }
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PlayerName => {
                            if player_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("playerName"));
                            }
                            player_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SongTitle => {
                            if song_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songTitle"));
                            }
                            song_title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SongArtist => {
                            if song_artist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songArtist"));
                            }
                            song_artist__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CurrentPosition => {
                            if current_position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPosition"));
                            }
                            current_position__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayerInfo {
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    volume: volume__,
                    player_name: player_name__.ok_or_else(|| serde::de::Error::missing_field("playerName"))?,
                    song_title: song_title__.ok_or_else(|| serde::de::Error::missing_field("songTitle"))?,
                    song_artist: song_artist__.ok_or_else(|| serde::de::Error::missing_field("songArtist"))?,
                    current_position: current_position__,
                    duration: duration__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PlayerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for player_info::State {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "NONE",
            Self::Playing => "PLAYING",
            Self::Pause => "PAUSE",
            Self::Stop => "STOP",
            Self::NoPermission => "NO_PERMISSION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for player_info::State {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NONE",
            "PLAYING",
            "PAUSE",
            "STOP",
            "NO_PERMISSION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = player_info::State;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NONE" => Ok(player_info::State::None),
                    "PLAYING" => Ok(player_info::State::Playing),
                    "PAUSE" => Ok(player_info::State::Pause),
                    "STOP" => Ok(player_info::State::Stop),
                    "NO_PERMISSION" => Ok(player_info::State::NoPermission),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PowerMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Performance => "PERFORMANCE",
            Self::PowerSave => "POWER_SAVE",
            Self::SuperPowerSave => "SUPER_POWER_SAVE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for PowerMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PERFORMANCE",
            "POWER_SAVE",
            "SUPER_POWER_SAVE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PowerMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PERFORMANCE" => Ok(PowerMode::Performance),
                    "POWER_SAVE" => Ok(PowerMode::PowerSave),
                    "SUPER_POWER_SAVE" => Ok(PowerMode::SuperPowerSave),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareAppIcon {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.PrepareAppIcon", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareAppIcon {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareAppIcon;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareAppIcon")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareAppIcon, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(PrepareAppIcon {
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareAppIcon", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_app_icon::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.support_compress_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareAppIcon.Request", len)?;
        struct_ser.serialize_field("packageName", &self.package_name)?;
        if let Some(v) = self.support_compress_mode.as_ref() {
            struct_ser.serialize_field("supportCompressMode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prepare_app_icon::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_name",
            "packageName",
            "support_compress_mode",
            "supportCompressMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageName,
            SupportCompressMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageName" | "package_name" => Ok(GeneratedField::PackageName),
                            "supportCompressMode" | "support_compress_mode" => Ok(GeneratedField::SupportCompressMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_app_icon::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareAppIcon.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prepare_app_icon::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_name__ = None;
                let mut support_compress_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageName => {
                            if package_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageName"));
                            }
                            package_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportCompressMode => {
                            if support_compress_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportCompressMode"));
                            }
                            support_compress_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(prepare_app_icon::Request {
                    package_name: package_name__.ok_or_else(|| serde::de::Error::missing_field("packageName"))?,
                    support_compress_mode: support_compress_mode__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareAppIcon.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_app_icon::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.support_image_format.is_some() {
            len += 1;
        }
        if self.expected_max_size.is_some() {
            len += 1;
        }
        if self.select_compress_mode.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareAppIcon.Response", len)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.support_image_format.as_ref() {
            let v = ImageFormat::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("supportImageFormat", &v)?;
        }
        if let Some(v) = self.expected_max_size.as_ref() {
            struct_ser.serialize_field("expectedMaxSize", v)?;
        }
        if let Some(v) = self.select_compress_mode.as_ref() {
            struct_ser.serialize_field("selectCompressMode", v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prepare_app_icon::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prepare_status",
            "prepareStatus",
            "support_image_format",
            "supportImageFormat",
            "expected_max_size",
            "expectedMaxSize",
            "select_compress_mode",
            "selectCompressMode",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrepareStatus,
            SupportImageFormat,
            ExpectedMaxSize,
            SelectCompressMode,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "supportImageFormat" | "support_image_format" => Ok(GeneratedField::SupportImageFormat),
                            "expectedMaxSize" | "expected_max_size" => Ok(GeneratedField::ExpectedMaxSize),
                            "selectCompressMode" | "select_compress_mode" => Ok(GeneratedField::SelectCompressMode),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_app_icon::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareAppIcon.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prepare_app_icon::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prepare_status__ = None;
                let mut support_image_format__ = None;
                let mut expected_max_size__ = None;
                let mut select_compress_mode__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::SupportImageFormat => {
                            if support_image_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportImageFormat"));
                            }
                            support_image_format__ = map_.next_value::<::std::option::Option<ImageFormat>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ExpectedMaxSize => {
                            if expected_max_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedMaxSize"));
                            }
                            expected_max_size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SelectCompressMode => {
                            if select_compress_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectCompressMode"));
                            }
                            select_compress_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(prepare_app_icon::Response {
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    support_image_format: support_image_format__,
                    expected_max_size: expected_max_size__,
                    select_compress_mode: select_compress_mode__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareAppIcon.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.version_code.is_some() {
            len += 1;
        }
        if self.support_compress_mode.is_some() {
            len += 1;
        }
        if self.verification.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareInfo", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("size", &self.size)?;
        if let Some(v) = self.version_code.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("versionCode", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.support_compress_mode.as_ref() {
            struct_ser.serialize_field("supportCompressMode", v)?;
        }
        if let Some(v) = self.verification.as_ref() {
            struct_ser.serialize_field("verification", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "size",
            "version_code",
            "versionCode",
            "support_compress_mode",
            "supportCompressMode",
            "verification",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Size,
            VersionCode,
            SupportCompressMode,
            Verification,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "size" => Ok(GeneratedField::Size),
                            "versionCode" | "version_code" => Ok(GeneratedField::VersionCode),
                            "supportCompressMode" | "support_compress_mode" => Ok(GeneratedField::SupportCompressMode),
                            "verification" => Ok(GeneratedField::Verification),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut size__ = None;
                let mut version_code__ = None;
                let mut support_compress_mode__ = None;
                let mut verification__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::VersionCode => {
                            if version_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionCode"));
                            }
                            version_code__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SupportCompressMode => {
                            if support_compress_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportCompressMode"));
                            }
                            support_compress_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Verification => {
                            if verification__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verification"));
                            }
                            verification__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PrepareInfo {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    size: size__.ok_or_else(|| serde::de::Error::missing_field("size"))?,
                    version_code: version_code__,
                    support_compress_mode: support_compress_mode__,
                    verification: verification__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_info::Verification {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.trial_duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareInfo.Verification", len)?;
        struct_ser.serialize_field("info", &self.info)?;
        struct_ser.serialize_field("sign", &self.sign)?;
        if let Some(v) = self.trial_duration.as_ref() {
            struct_ser.serialize_field("trialDuration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prepare_info::Verification {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "info",
            "sign",
            "trial_duration",
            "trialDuration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Info,
            Sign,
            TrialDuration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "info" => Ok(GeneratedField::Info),
                            "sign" => Ok(GeneratedField::Sign),
                            "trialDuration" | "trial_duration" => Ok(GeneratedField::TrialDuration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_info::Verification;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareInfo.Verification")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prepare_info::Verification, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut info__ = None;
                let mut sign__ = None;
                let mut trial_duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Info => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("info"));
                            }
                            info__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sign => {
                            if sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sign"));
                            }
                            sign__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TrialDuration => {
                            if trial_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("trialDuration"));
                            }
                            trial_duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(prepare_info::Verification {
                    info: info__.ok_or_else(|| serde::de::Error::missing_field("info"))?,
                    sign: sign__.ok_or_else(|| serde::de::Error::missing_field("sign"))?,
                    trial_duration: trial_duration__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareInfo.Verification", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareOta {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.PrepareOta", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareOta {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareOta;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareOta")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareOta, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(PrepareOta {
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareOta", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_ota::Progress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.percent.is_some() {
            len += 1;
        }
        if self.min_battery.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareOta.Progress", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        if let Some(v) = self.percent.as_ref() {
            struct_ser.serialize_field("percent", v)?;
        }
        if let Some(v) = self.min_battery.as_ref() {
            struct_ser.serialize_field("minBattery", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prepare_ota::Progress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "percent",
            "min_battery",
            "minBattery",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            Percent,
            MinBattery,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "percent" => Ok(GeneratedField::Percent),
                            "minBattery" | "min_battery" => Ok(GeneratedField::MinBattery),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_ota::Progress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareOta.Progress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prepare_ota::Progress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut percent__ = None;
                let mut min_battery__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Percent => {
                            if percent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("percent"));
                            }
                            percent__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinBattery => {
                            if min_battery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minBattery"));
                            }
                            min_battery__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(prepare_ota::Progress {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    percent: percent__,
                    min_battery: min_battery__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareOta.Progress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_ota::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 6;
        if self.file_size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareOta.Request", len)?;
        struct_ser.serialize_field("force", &self.force)?;
        let v = prepare_ota::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("firmwareVersion", &self.firmware_version)?;
        struct_ser.serialize_field("fileMd5", &self.file_md5)?;
        struct_ser.serialize_field("changeLog", &self.change_log)?;
        struct_ser.serialize_field("fileUrl", &self.file_url)?;
        if let Some(v) = self.file_size.as_ref() {
            struct_ser.serialize_field("fileSize", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prepare_ota::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "force",
            "type",
            "firmware_version",
            "firmwareVersion",
            "file_md5",
            "fileMd5",
            "change_log",
            "changeLog",
            "file_url",
            "fileUrl",
            "file_size",
            "fileSize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Force,
            Type,
            FirmwareVersion,
            FileMd5,
            ChangeLog,
            FileUrl,
            FileSize,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "force" => Ok(GeneratedField::Force),
                            "type" => Ok(GeneratedField::Type),
                            "firmwareVersion" | "firmware_version" => Ok(GeneratedField::FirmwareVersion),
                            "fileMd5" | "file_md5" => Ok(GeneratedField::FileMd5),
                            "changeLog" | "change_log" => Ok(GeneratedField::ChangeLog),
                            "fileUrl" | "file_url" => Ok(GeneratedField::FileUrl),
                            "fileSize" | "file_size" => Ok(GeneratedField::FileSize),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_ota::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareOta.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prepare_ota::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut force__ = None;
                let mut r#type__ = None;
                let mut firmware_version__ = None;
                let mut file_md5__ = None;
                let mut change_log__ = None;
                let mut file_url__ = None;
                let mut file_size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Force => {
                            if force__.is_some() {
                                return Err(serde::de::Error::duplicate_field("force"));
                            }
                            force__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<prepare_ota::Type>()? as i32);
                        }
                        GeneratedField::FirmwareVersion => {
                            if firmware_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firmwareVersion"));
                            }
                            firmware_version__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FileMd5 => {
                            if file_md5__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fileMd5"));
                            }
                            file_md5__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ChangeLog => {
                            if change_log__.is_some() {
                                return Err(serde::de::Error::duplicate_field("changeLog"));
                            }
                            change_log__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FileUrl => {
                            if file_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fileUrl"));
                            }
                            file_url__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FileSize => {
                            if file_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fileSize"));
                            }
                            file_size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(prepare_ota::Request {
                    force: force__.ok_or_else(|| serde::de::Error::missing_field("force"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    firmware_version: firmware_version__.ok_or_else(|| serde::de::Error::missing_field("firmwareVersion"))?,
                    file_md5: file_md5__.ok_or_else(|| serde::de::Error::missing_field("fileMd5"))?,
                    change_log: change_log__.ok_or_else(|| serde::de::Error::missing_field("changeLog"))?,
                    file_url: file_url__.ok_or_else(|| serde::de::Error::missing_field("fileUrl"))?,
                    file_size: file_size__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareOta.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_ota::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        if self.min_battery.is_some() {
            len += 1;
        }
        if self.progress.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareOta.Response", len)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        if let Some(v) = self.min_battery.as_ref() {
            struct_ser.serialize_field("minBattery", v)?;
        }
        if let Some(v) = self.progress.as_ref() {
            struct_ser.serialize_field("progress", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prepare_ota::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prepare_status",
            "prepareStatus",
            "expected_slice_length",
            "expectedSliceLength",
            "min_battery",
            "minBattery",
            "progress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrepareStatus,
            ExpectedSliceLength,
            MinBattery,
            Progress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            "minBattery" | "min_battery" => Ok(GeneratedField::MinBattery),
                            "progress" => Ok(GeneratedField::Progress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_ota::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareOta.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prepare_ota::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prepare_status__ = None;
                let mut expected_slice_length__ = None;
                let mut min_battery__ = None;
                let mut progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinBattery => {
                            if min_battery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minBattery"));
                            }
                            min_battery__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("progress"));
                            }
                            progress__ = map_.next_value()?;
                        }
                    }
                }
                Ok(prepare_ota::Response {
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    expected_slice_length: expected_slice_length__,
                    min_battery: min_battery__,
                    progress: progress__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareOta.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prepare_ota::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::All => "ALL",
            Self::Rom => "ROM",
            Self::Res => "RES",
            Self::Silent => "SILENT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for prepare_ota::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALL",
            "ROM",
            "RES",
            "SILENT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prepare_ota::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALL" => Ok(prepare_ota::Type::All),
                    "ROM" => Ok(prepare_ota::Type::Rom),
                    "RES" => Ok(prepare_ota::Type::Res),
                    "SILENT" => Ok(prepare_ota::Type::Silent),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.select_compress_mode.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareReply", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.select_compress_mode.as_ref() {
            struct_ser.serialize_field("selectCompressMode", v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "prepare_status",
            "prepareStatus",
            "select_compress_mode",
            "selectCompressMode",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            PrepareStatus,
            SelectCompressMode,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "selectCompressMode" | "select_compress_mode" => Ok(GeneratedField::SelectCompressMode),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut prepare_status__ = None;
                let mut select_compress_mode__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::SelectCompressMode => {
                            if select_compress_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectCompressMode"));
                            }
                            select_compress_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PrepareReply {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    select_compress_mode: select_compress_mode__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.support_compress_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareRequest", len)?;
        struct_ser.serialize_field("dataType", &self.data_type)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("dataId", pbjson::private::base64::encode(&self.data_id).as_str())?;
        struct_ser.serialize_field("dataLength", &self.data_length)?;
        if let Some(v) = self.support_compress_mode.as_ref() {
            struct_ser.serialize_field("supportCompressMode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "data_type",
            "dataType",
            "data_id",
            "dataId",
            "data_length",
            "dataLength",
            "support_compress_mode",
            "supportCompressMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DataType,
            DataId,
            DataLength,
            SupportCompressMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dataType" | "data_type" => Ok(GeneratedField::DataType),
                            "dataId" | "data_id" => Ok(GeneratedField::DataId),
                            "dataLength" | "data_length" => Ok(GeneratedField::DataLength),
                            "supportCompressMode" | "support_compress_mode" => Ok(GeneratedField::SupportCompressMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut data_type__ = None;
                let mut data_id__ = None;
                let mut data_length__ = None;
                let mut support_compress_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DataType => {
                            if data_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataType"));
                            }
                            data_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DataId => {
                            if data_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataId"));
                            }
                            data_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DataLength => {
                            if data_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataLength"));
                            }
                            data_length__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SupportCompressMode => {
                            if support_compress_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportCompressMode"));
                            }
                            support_compress_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PrepareRequest {
                    data_type: data_type__.ok_or_else(|| serde::de::Error::missing_field("dataType"))?,
                    data_id: data_id__.ok_or_else(|| serde::de::Error::missing_field("dataId"))?,
                    data_length: data_length__.ok_or_else(|| serde::de::Error::missing_field("dataLength"))?,
                    support_compress_mode: support_compress_mode__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.select_compress_mode.is_some() {
            len += 1;
        }
        if self.remained_data_length.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PrepareResponse", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("dataId", pbjson::private::base64::encode(&self.data_id).as_str())?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.select_compress_mode.as_ref() {
            struct_ser.serialize_field("selectCompressMode", v)?;
        }
        if let Some(v) = self.remained_data_length.as_ref() {
            struct_ser.serialize_field("remainedDataLength", v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrepareResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "data_id",
            "dataId",
            "prepare_status",
            "prepareStatus",
            "select_compress_mode",
            "selectCompressMode",
            "remained_data_length",
            "remainedDataLength",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DataId,
            PrepareStatus,
            SelectCompressMode,
            RemainedDataLength,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dataId" | "data_id" => Ok(GeneratedField::DataId),
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "selectCompressMode" | "select_compress_mode" => Ok(GeneratedField::SelectCompressMode),
                            "remainedDataLength" | "remained_data_length" => Ok(GeneratedField::RemainedDataLength),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PrepareResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrepareResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut data_id__ = None;
                let mut prepare_status__ = None;
                let mut select_compress_mode__ = None;
                let mut remained_data_length__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DataId => {
                            if data_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataId"));
                            }
                            data_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::SelectCompressMode => {
                            if select_compress_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectCompressMode"));
                            }
                            select_compress_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RemainedDataLength => {
                            if remained_data_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remainedDataLength"));
                            }
                            remained_data_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PrepareResponse {
                    data_id: data_id__.ok_or_else(|| serde::de::Error::missing_field("dataId"))?,
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    select_compress_mode: select_compress_mode__,
                    remained_data_length: remained_data_length__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PrepareResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrepareStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ready => "READY",
            Self::Busy => "BUSY",
            Self::Duplicated => "DUPLICATED",
            Self::LowStorage => "LOW_STORAGE",
            Self::LowBattery => "LOW_BATTERY",
            Self::Downgrade => "DOWNGRADE",
            Self::OpNotSupport => "OP_NOT_SUPPORT",
            Self::ExceedQuantityLimit => "EXCEED_QUANTITY_LIMIT",
            Self::NetworkError => "NETWORK_ERROR",
            Self::Failed => "FAILED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for PrepareStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "READY",
            "BUSY",
            "DUPLICATED",
            "LOW_STORAGE",
            "LOW_BATTERY",
            "DOWNGRADE",
            "OP_NOT_SUPPORT",
            "EXCEED_QUANTITY_LIMIT",
            "NETWORK_ERROR",
            "FAILED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrepareStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "READY" => Ok(PrepareStatus::Ready),
                    "BUSY" => Ok(PrepareStatus::Busy),
                    "DUPLICATED" => Ok(PrepareStatus::Duplicated),
                    "LOW_STORAGE" => Ok(PrepareStatus::LowStorage),
                    "LOW_BATTERY" => Ok(PrepareStatus::LowBattery),
                    "DOWNGRADE" => Ok(PrepareStatus::Downgrade),
                    "OP_NOT_SUPPORT" => Ok(PrepareStatus::OpNotSupport),
                    "EXCEED_QUANTITY_LIMIT" => Ok(PrepareStatus::ExceedQuantityLimit),
                    "NETWORK_ERROR" => Ok(PrepareStatus::NetworkError),
                    "FAILED" => Ok(PrepareStatus::Failed),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PressureCalibrate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.PressureCalibrate", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PressureCalibrate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PressureCalibrate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PressureCalibrate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PressureCalibrate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(PressureCalibrate {
                })
            }
        }
        deserializer.deserialize_struct("protocol.PressureCalibrate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for pressure_calibrate::CalibrationResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.current_pressure.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PressureCalibrate.CalibrationResult", len)?;
        let v = pressure_calibrate::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.current_pressure.as_ref() {
            struct_ser.serialize_field("currentPressure", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for pressure_calibrate::CalibrationResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "current_pressure",
            "currentPressure",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            CurrentPressure,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "currentPressure" | "current_pressure" => Ok(GeneratedField::CurrentPressure),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = pressure_calibrate::CalibrationResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PressureCalibrate.CalibrationResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<pressure_calibrate::CalibrationResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut current_pressure__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<pressure_calibrate::Code>()? as i32);
                        }
                        GeneratedField::CurrentPressure => {
                            if current_pressure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPressure"));
                            }
                            current_pressure__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(pressure_calibrate::CalibrationResult {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    current_pressure: current_pressure__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PressureCalibrate.CalibrationResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for pressure_calibrate::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ok => "OK",
            Self::NotWearing => "NOT_WEARING",
            Self::InSport => "IN_SPORT",
            Self::NotInCalibrating => "NOT_IN_CALIBRATING",
            Self::Unknown => "UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for pressure_calibrate::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OK",
            "NOT_WEARING",
            "IN_SPORT",
            "NOT_IN_CALIBRATING",
            "UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = pressure_calibrate::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OK" => Ok(pressure_calibrate::Code::Ok),
                    "NOT_WEARING" => Ok(pressure_calibrate::Code::NotWearing),
                    "IN_SPORT" => Ok(pressure_calibrate::Code::InSport),
                    "NOT_IN_CALIBRATING" => Ok(pressure_calibrate::Code::NotInCalibrating),
                    "UNKNOWN" => Ok(pressure_calibrate::Code::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for pressure_calibrate::EvaluationResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.PressureCalibrate.EvaluationResult", len)?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for pressure_calibrate::EvaluationResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = pressure_calibrate::EvaluationResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PressureCalibrate.EvaluationResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<pressure_calibrate::EvaluationResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(pressure_calibrate::EvaluationResult {
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PressureCalibrate.EvaluationResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for pressure_calibrate::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.need_collect_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PressureCalibrate.Response", len)?;
        let v = pressure_calibrate::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.need_collect_time.as_ref() {
            struct_ser.serialize_field("needCollectTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for pressure_calibrate::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "need_collect_time",
            "needCollectTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            NeedCollectTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "needCollectTime" | "need_collect_time" => Ok(GeneratedField::NeedCollectTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = pressure_calibrate::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PressureCalibrate.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<pressure_calibrate::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut need_collect_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<pressure_calibrate::Code>()? as i32);
                        }
                        GeneratedField::NeedCollectTime => {
                            if need_collect_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needCollectTime"));
                            }
                            need_collect_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(pressure_calibrate::Response {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    need_collect_time: need_collect_time__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PressureCalibrate.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PressureMonitor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.warning_non_sleep.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PressureMonitor", len)?;
        struct_ser.serialize_field("on", &self.on)?;
        if let Some(v) = self.warning_non_sleep.as_ref() {
            struct_ser.serialize_field("warningNonSleep", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PressureMonitor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "on",
            "warning_non_sleep",
            "warningNonSleep",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            On,
            WarningNonSleep,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "on" => Ok(GeneratedField::On),
                            "warningNonSleep" | "warning_non_sleep" => Ok(GeneratedField::WarningNonSleep),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PressureMonitor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PressureMonitor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PressureMonitor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut on__ = None;
                let mut warning_non_sleep__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::On => {
                            if on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("on"));
                            }
                            on__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WarningNonSleep => {
                            if warning_non_sleep__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warningNonSleep"));
                            }
                            warning_non_sleep__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PressureMonitor {
                    on: on__.ok_or_else(|| serde::de::Error::missing_field("on"))?,
                    warning_non_sleep: warning_non_sleep__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PressureMonitor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PreviewImageRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.PreviewImageRequest", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PreviewImageRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PreviewImageRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PreviewImageRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PreviewImageRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PreviewImageRequest {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PreviewImageRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PreviewImageResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.expected_image_format.is_some() {
            len += 1;
        }
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.PreviewImageResponse", len)?;
        let v = PrepareStatus::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        if let Some(v) = self.expected_image_format.as_ref() {
            let v = ImageFormat::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("expectedImageFormat", &v)?;
        }
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PreviewImageResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
            "expected_image_format",
            "expectedImageFormat",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
            ExpectedImageFormat,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            "expectedImageFormat" | "expected_image_format" => Ok(GeneratedField::ExpectedImageFormat),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PreviewImageResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.PreviewImageResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PreviewImageResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                let mut expected_image_format__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::ExpectedImageFormat => {
                            if expected_image_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedImageFormat"));
                            }
                            expected_image_format__ = map_.next_value::<::std::option::Option<ImageFormat>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PreviewImageResponse {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    expected_image_format: expected_image_format__,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.PreviewImageResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProbeSector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.ProbeSector", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProbeSector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProbeSector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProbeSector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(ProbeSector {
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for probe_sector::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.ProbeSector.Data", len)?;
        struct_ser.serialize_field("median", &self.median)?;
        struct_ser.serialize_field("deviation", &self.deviation)?;
        struct_ser.serialize_field("nt", &self.nt)?;
        struct_ser.serialize_field("nte", &self.nte)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("parity", pbjson::private::base64::encode(&self.parity).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for probe_sector::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "median",
            "deviation",
            "nt",
            "nte",
            "parity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Median,
            Deviation,
            Nt,
            Nte,
            Parity,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "median" => Ok(GeneratedField::Median),
                            "deviation" => Ok(GeneratedField::Deviation),
                            "nt" => Ok(GeneratedField::Nt),
                            "nte" => Ok(GeneratedField::Nte),
                            "parity" => Ok(GeneratedField::Parity),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = probe_sector::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<probe_sector::Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut median__ = None;
                let mut deviation__ = None;
                let mut nt__ = None;
                let mut nte__ = None;
                let mut parity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Median => {
                            if median__.is_some() {
                                return Err(serde::de::Error::duplicate_field("median"));
                            }
                            median__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Deviation => {
                            if deviation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviation"));
                            }
                            deviation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nt => {
                            if nt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nt"));
                            }
                            nt__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nte => {
                            if nte__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nte"));
                            }
                            nte__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Parity => {
                            if parity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parity"));
                            }
                            parity__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(probe_sector::Data {
                    median: median__.ok_or_else(|| serde::de::Error::missing_field("median"))?,
                    deviation: deviation__.ok_or_else(|| serde::de::Error::missing_field("deviation"))?,
                    nt: nt__.ok_or_else(|| serde::de::Error::missing_field("nt"))?,
                    nte: nte__.ok_or_else(|| serde::de::Error::missing_field("nte"))?,
                    parity: parity__.ok_or_else(|| serde::de::Error::missing_field("parity"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for probe_sector::KeyInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.key_a_list.is_some() {
            len += 1;
        }
        if self.key_b_list.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProbeSector.KeyInfo", len)?;
        struct_ser.serialize_field("foundKeyA", &self.found_key_a)?;
        struct_ser.serialize_field("foundKeyB", &self.found_key_b)?;
        if let Some(v) = self.key_a_list.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("keyAList", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.key_b_list.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("keyBList", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for probe_sector::KeyInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "found_key_a",
            "foundKeyA",
            "found_key_b",
            "foundKeyB",
            "key_a_list",
            "keyAList",
            "key_b_list",
            "keyBList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FoundKeyA,
            FoundKeyB,
            KeyAList,
            KeyBList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "foundKeyA" | "found_key_a" => Ok(GeneratedField::FoundKeyA),
                            "foundKeyB" | "found_key_b" => Ok(GeneratedField::FoundKeyB),
                            "keyAList" | "key_a_list" => Ok(GeneratedField::KeyAList),
                            "keyBList" | "key_b_list" => Ok(GeneratedField::KeyBList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = probe_sector::KeyInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector.KeyInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<probe_sector::KeyInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut found_key_a__ = None;
                let mut found_key_b__ = None;
                let mut key_a_list__ = None;
                let mut key_b_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FoundKeyA => {
                            if found_key_a__.is_some() {
                                return Err(serde::de::Error::duplicate_field("foundKeyA"));
                            }
                            found_key_a__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FoundKeyB => {
                            if found_key_b__.is_some() {
                                return Err(serde::de::Error::duplicate_field("foundKeyB"));
                            }
                            found_key_b__ = Some(map_.next_value()?);
                        }
                        GeneratedField::KeyAList => {
                            if key_a_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyAList"));
                            }
                            key_a_list__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::KeyBList => {
                            if key_b_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyBList"));
                            }
                            key_b_list__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(probe_sector::KeyInfo {
                    found_key_a: found_key_a__.ok_or_else(|| serde::de::Error::missing_field("foundKeyA"))?,
                    found_key_b: found_key_b__.ok_or_else(|| serde::de::Error::missing_field("foundKeyB"))?,
                    key_a_list: key_a_list__,
                    key_b_list: key_b_list__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector.KeyInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for probe_sector::Nonce {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.distances.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProbeSector.Nonce", len)?;
        struct_ser.serialize_field("median", &self.median)?;
        struct_ser.serialize_field("deviation", &self.deviation)?;
        if !self.distances.is_empty() {
            struct_ser.serialize_field("distances", &self.distances)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for probe_sector::Nonce {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "median",
            "deviation",
            "distances",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Median,
            Deviation,
            Distances,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "median" => Ok(GeneratedField::Median),
                            "deviation" => Ok(GeneratedField::Deviation),
                            "distances" => Ok(GeneratedField::Distances),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = probe_sector::Nonce;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector.Nonce")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<probe_sector::Nonce, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut median__ = None;
                let mut deviation__ = None;
                let mut distances__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Median => {
                            if median__.is_some() {
                                return Err(serde::de::Error::duplicate_field("median"));
                            }
                            median__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Deviation => {
                            if deviation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviation"));
                            }
                            deviation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Distances => {
                            if distances__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distances"));
                            }
                            distances__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(probe_sector::Nonce {
                    median: median__.ok_or_else(|| serde::de::Error::missing_field("median"))?,
                    deviation: deviation__.ok_or_else(|| serde::de::Error::missing_field("deviation"))?,
                    distances: distances__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector.Nonce", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for probe_sector::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.ProbeSector.Request", len)?;
        struct_ser.serialize_field("index", &self.index)?;
        struct_ser.serialize_field("mode", &self.mode)?;
        struct_ser.serialize_field("tag", &self.tag)?;
        struct_ser.serialize_field("nonce", &self.nonce)?;
        struct_ser.serialize_field("dumpKeyA", &self.dump_key_a)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for probe_sector::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "index",
            "mode",
            "tag",
            "nonce",
            "dump_key_a",
            "dumpKeyA",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Index,
            Mode,
            Tag,
            Nonce,
            DumpKeyA,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "index" => Ok(GeneratedField::Index),
                            "mode" => Ok(GeneratedField::Mode),
                            "tag" => Ok(GeneratedField::Tag),
                            "nonce" => Ok(GeneratedField::Nonce),
                            "dumpKeyA" | "dump_key_a" => Ok(GeneratedField::DumpKeyA),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = probe_sector::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<probe_sector::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index__ = None;
                let mut mode__ = None;
                let mut tag__ = None;
                let mut nonce__ = None;
                let mut dump_key_a__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("index"));
                            }
                            index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Tag => {
                            if tag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tag"));
                            }
                            tag__ = map_.next_value()?;
                        }
                        GeneratedField::Nonce => {
                            if nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonce"));
                            }
                            nonce__ = map_.next_value()?;
                        }
                        GeneratedField::DumpKeyA => {
                            if dump_key_a__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dumpKeyA"));
                            }
                            dump_key_a__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(probe_sector::Request {
                    index: index__.ok_or_else(|| serde::de::Error::missing_field("index"))?,
                    mode: mode__.ok_or_else(|| serde::de::Error::missing_field("mode"))?,
                    tag: tag__.ok_or_else(|| serde::de::Error::missing_field("tag"))?,
                    nonce: nonce__.ok_or_else(|| serde::de::Error::missing_field("nonce"))?,
                    dump_key_a: dump_key_a__.ok_or_else(|| serde::de::Error::missing_field("dumpKeyA"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for probe_sector::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.nonce.is_some() {
            len += 1;
        }
        if self.data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProbeSector.Response", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        if let Some(v) = self.nonce.as_ref() {
            struct_ser.serialize_field("nonce", v)?;
        }
        if let Some(v) = self.data.as_ref() {
            struct_ser.serialize_field("data", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for probe_sector::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "nonce",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            Nonce,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "nonce" => Ok(GeneratedField::Nonce),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = probe_sector::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<probe_sector::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut nonce__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Nonce => {
                            if nonce__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonce"));
                            }
                            nonce__ = map_.next_value()?;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(probe_sector::Response {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    nonce: nonce__,
                    data: data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for probe_sector::Tag {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.ProbeSector.Tag", len)?;
        struct_ser.serialize_field("authUid", &self.auth_uid)?;
        struct_ser.serialize_field("index", &self.index)?;
        struct_ser.serialize_field("keyInfo", &self.key_info)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for probe_sector::Tag {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "auth_uid",
            "authUid",
            "index",
            "key_info",
            "keyInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AuthUid,
            Index,
            KeyInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "authUid" | "auth_uid" => Ok(GeneratedField::AuthUid),
                            "index" => Ok(GeneratedField::Index),
                            "keyInfo" | "key_info" => Ok(GeneratedField::KeyInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = probe_sector::Tag;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProbeSector.Tag")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<probe_sector::Tag, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut auth_uid__ = None;
                let mut index__ = None;
                let mut key_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AuthUid => {
                            if auth_uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authUid"));
                            }
                            auth_uid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("index"));
                            }
                            index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::KeyInfo => {
                            if key_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyInfo"));
                            }
                            key_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(probe_sector::Tag {
                    auth_uid: auth_uid__.ok_or_else(|| serde::de::Error::missing_field("authUid"))?,
                    index: index__.ok_or_else(|| serde::de::Error::missing_field("index"))?,
                    key_info: key_info__.ok_or_else(|| serde::de::Error::missing_field("keyInfo"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProbeSector.Tag", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Profile {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.Profile", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("iccid", pbjson::private::base64::encode(&self.iccid).as_str())?;
        struct_ser.serialize_field("imei", &self.imei)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Profile {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "iccid",
            "imei",
            "name",
            "enable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Iccid,
            Imei,
            Name,
            Enable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "iccid" => Ok(GeneratedField::Iccid),
                            "imei" => Ok(GeneratedField::Imei),
                            "name" => Ok(GeneratedField::Name),
                            "enable" => Ok(GeneratedField::Enable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Profile;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Profile")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Profile, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut iccid__ = None;
                let mut imei__ = None;
                let mut name__ = None;
                let mut enable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Iccid => {
                            if iccid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iccid"));
                            }
                            iccid__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Imei => {
                            if imei__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imei"));
                            }
                            imei__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Profile {
                    iccid: iccid__.ok_or_else(|| serde::de::Error::missing_field("iccid"))?,
                    imei: imei__.ok_or_else(|| serde::de::Error::missing_field("imei"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Profile", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for profile::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Profile.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for profile::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = profile::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Profile.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<profile::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(profile::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Profile.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfileDownload {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ProfileDownload", len)?;
        struct_ser.serialize_field("activationCode", &self.activation_code)?;
        struct_ser.serialize_field("confirmationCode", &self.confirmation_code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfileDownload {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "activation_code",
            "activationCode",
            "confirmation_code",
            "confirmationCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActivationCode,
            ConfirmationCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "activationCode" | "activation_code" => Ok(GeneratedField::ActivationCode),
                            "confirmationCode" | "confirmation_code" => Ok(GeneratedField::ConfirmationCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfileDownload;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProfileDownload")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfileDownload, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut activation_code__ = None;
                let mut confirmation_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActivationCode => {
                            if activation_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activationCode"));
                            }
                            activation_code__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ConfirmationCode => {
                            if confirmation_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("confirmationCode"));
                            }
                            confirmation_code__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ProfileDownload {
                    activation_code: activation_code__.ok_or_else(|| serde::de::Error::missing_field("activationCode"))?,
                    confirmation_code: confirmation_code__.ok_or_else(|| serde::de::Error::missing_field("confirmationCode"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProfileDownload", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfileOperator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ProfileOperator", len)?;
        let v = profile_operator::Cmd::try_from(self.cmd)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.cmd)))?;
        struct_ser.serialize_field("cmd", &v)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("iccid", pbjson::private::base64::encode(&self.iccid).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfileOperator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cmd",
            "iccid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cmd,
            Iccid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cmd" => Ok(GeneratedField::Cmd),
                            "iccid" => Ok(GeneratedField::Iccid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfileOperator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProfileOperator")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfileOperator, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cmd__ = None;
                let mut iccid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = Some(map_.next_value::<profile_operator::Cmd>()? as i32);
                        }
                        GeneratedField::Iccid => {
                            if iccid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iccid"));
                            }
                            iccid__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ProfileOperator {
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                    iccid: iccid__.ok_or_else(|| serde::de::Error::missing_field("iccid"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProfileOperator", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for profile_operator::Cmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Enable => "ENABLE",
            Self::Disable => "DISABLE",
            Self::Delete => "DELETE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for profile_operator::Cmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ENABLE",
            "DISABLE",
            "DELETE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = profile_operator::Cmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ENABLE" => Ok(profile_operator::Cmd::Enable),
                    "DISABLE" => Ok(profile_operator::Cmd::Disable),
                    "DELETE" => Ok(profile_operator::Cmd::Delete),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ProfilePrepare {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.ProfilePrepare", len)?;
        let v = TelecomOperator::try_from(self.telecom_operator)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.telecom_operator)))?;
        struct_ser.serialize_field("telecomOperator", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfilePrepare {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "telecom_operator",
            "telecomOperator",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TelecomOperator,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "telecomOperator" | "telecom_operator" => Ok(GeneratedField::TelecomOperator),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfilePrepare;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProfilePrepare")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfilePrepare, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut telecom_operator__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TelecomOperator => {
                            if telecom_operator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("telecomOperator"));
                            }
                            telecom_operator__ = Some(map_.next_value::<TelecomOperator>()? as i32);
                        }
                    }
                }
                Ok(ProfilePrepare {
                    telecom_operator: telecom_operator__.ok_or_else(|| serde::de::Error::missing_field("telecomOperator"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProfilePrepare", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectionData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 5;
        if self.steps.is_some() {
            len += 1;
        }
        if self.distance.is_some() {
            len += 1;
        }
        if self.current_pace.is_some() {
            len += 1;
        }
        if self.speed.is_some() {
            len += 1;
        }
        if self.jump_count.is_some() {
            len += 1;
        }
        if self.stumble_count.is_some() {
            len += 1;
        }
        if self.group_info.is_some() {
            len += 1;
        }
        if self.abnormal_heart_rate.is_some() {
            len += 1;
        }
        if self.heart_rate_zone.is_some() {
            len += 1;
        }
        if self.device_list.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionData", len)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        struct_ser.serialize_field("startTime", &self.start_time)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        struct_ser.serialize_field("heartRate", &self.heart_rate)?;
        struct_ser.serialize_field("calories", &self.calories)?;
        if let Some(v) = self.steps.as_ref() {
            struct_ser.serialize_field("steps", v)?;
        }
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        if let Some(v) = self.current_pace.as_ref() {
            struct_ser.serialize_field("currentPace", v)?;
        }
        if let Some(v) = self.speed.as_ref() {
            struct_ser.serialize_field("speed", v)?;
        }
        if let Some(v) = self.jump_count.as_ref() {
            struct_ser.serialize_field("jumpCount", v)?;
        }
        if let Some(v) = self.stumble_count.as_ref() {
            struct_ser.serialize_field("stumbleCount", v)?;
        }
        if let Some(v) = self.group_info.as_ref() {
            struct_ser.serialize_field("groupInfo", v)?;
        }
        if let Some(v) = self.abnormal_heart_rate.as_ref() {
            struct_ser.serialize_field("abnormalHeartRate", v)?;
        }
        if let Some(v) = self.heart_rate_zone.as_ref() {
            let v = HeartRateSection::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("heartRateZone", &v)?;
        }
        if let Some(v) = self.device_list.as_ref() {
            struct_ser.serialize_field("deviceList", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_type",
            "sportType",
            "start_time",
            "startTime",
            "duration",
            "heart_rate",
            "heartRate",
            "calories",
            "steps",
            "distance",
            "current_pace",
            "currentPace",
            "speed",
            "jump_count",
            "jumpCount",
            "stumble_count",
            "stumbleCount",
            "group_info",
            "groupInfo",
            "abnormal_heart_rate",
            "abnormalHeartRate",
            "heart_rate_zone",
            "heartRateZone",
            "device_list",
            "deviceList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportType,
            StartTime,
            Duration,
            HeartRate,
            Calories,
            Steps,
            Distance,
            CurrentPace,
            Speed,
            JumpCount,
            StumbleCount,
            GroupInfo,
            AbnormalHeartRate,
            HeartRateZone,
            DeviceList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "startTime" | "start_time" => Ok(GeneratedField::StartTime),
                            "duration" => Ok(GeneratedField::Duration),
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "calories" => Ok(GeneratedField::Calories),
                            "steps" => Ok(GeneratedField::Steps),
                            "distance" => Ok(GeneratedField::Distance),
                            "currentPace" | "current_pace" => Ok(GeneratedField::CurrentPace),
                            "speed" => Ok(GeneratedField::Speed),
                            "jumpCount" | "jump_count" => Ok(GeneratedField::JumpCount),
                            "stumbleCount" | "stumble_count" => Ok(GeneratedField::StumbleCount),
                            "groupInfo" | "group_info" => Ok(GeneratedField::GroupInfo),
                            "abnormalHeartRate" | "abnormal_heart_rate" => Ok(GeneratedField::AbnormalHeartRate),
                            "heartRateZone" | "heart_rate_zone" => Ok(GeneratedField::HeartRateZone),
                            "deviceList" | "device_list" => Ok(GeneratedField::DeviceList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectionData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectionData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_type__ = None;
                let mut start_time__ = None;
                let mut duration__ = None;
                let mut heart_rate__ = None;
                let mut calories__ = None;
                let mut steps__ = None;
                let mut distance__ = None;
                let mut current_pace__ = None;
                let mut speed__ = None;
                let mut jump_count__ = None;
                let mut stumble_count__ = None;
                let mut group_info__ = None;
                let mut abnormal_heart_rate__ = None;
                let mut heart_rate_zone__ = None;
                let mut device_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Steps => {
                            if steps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("steps"));
                            }
                            steps__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentPace => {
                            if current_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPace"));
                            }
                            current_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Speed => {
                            if speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speed"));
                            }
                            speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::JumpCount => {
                            if jump_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jumpCount"));
                            }
                            jump_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StumbleCount => {
                            if stumble_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stumbleCount"));
                            }
                            stumble_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GroupInfo => {
                            if group_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupInfo"));
                            }
                            group_info__ = map_.next_value()?;
                        }
                        GeneratedField::AbnormalHeartRate => {
                            if abnormal_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("abnormalHeartRate"));
                            }
                            abnormal_heart_rate__ = map_.next_value()?;
                        }
                        GeneratedField::HeartRateZone => {
                            if heart_rate_zone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRateZone"));
                            }
                            heart_rate_zone__ = map_.next_value::<::std::option::Option<HeartRateSection>>()?.map(|x| x as i32);
                        }
                        GeneratedField::DeviceList => {
                            if device_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceList"));
                            }
                            device_list__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ProjectionData {
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    start_time: start_time__.ok_or_else(|| serde::de::Error::missing_field("startTime"))?,
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    heart_rate: heart_rate__.ok_or_else(|| serde::de::Error::missing_field("heartRate"))?,
                    calories: calories__.ok_or_else(|| serde::de::Error::missing_field("calories"))?,
                    steps: steps__,
                    distance: distance__,
                    current_pace: current_pace__,
                    speed: speed__,
                    jump_count: jump_count__,
                    stumble_count: stumble_count__,
                    group_info: group_info__,
                    abnormal_heart_rate: abnormal_heart_rate__,
                    heart_rate_zone: heart_rate_zone__,
                    device_list: device_list__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for projection_data::Device {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionData.Device", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("pid", &self.pid)?;
        struct_ser.serialize_field("connectStatus", &self.connect_status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for projection_data::Device {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "pid",
            "connect_status",
            "connectStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Pid,
            ConnectStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "pid" => Ok(GeneratedField::Pid),
                            "connectStatus" | "connect_status" => Ok(GeneratedField::ConnectStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = projection_data::Device;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionData.Device")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<projection_data::Device, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut pid__ = None;
                let mut connect_status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Pid => {
                            if pid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pid"));
                            }
                            pid__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ConnectStatus => {
                            if connect_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("connectStatus"));
                            }
                            connect_status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(projection_data::Device {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    pid: pid__.ok_or_else(|| serde::de::Error::missing_field("pid"))?,
                    connect_status: connect_status__.ok_or_else(|| serde::de::Error::missing_field("connectStatus"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionData.Device", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for projection_data::device::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionData.Device.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for projection_data::device::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = projection_data::device::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionData.Device.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<projection_data::device::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(projection_data::device::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionData.Device.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for projection_data::GroupInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.group_index.is_some() {
            len += 1;
        }
        if self.calories.is_some() {
            len += 1;
        }
        if self.recommend_heart_rate.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionData.GroupInfo", len)?;
        struct_ser.serialize_field("segmentType", &self.segment_type)?;
        struct_ser.serialize_field("segmentTimestamp", &self.segment_timestamp)?;
        struct_ser.serialize_field("segmentDuration", &self.segment_duration)?;
        if let Some(v) = self.group_index.as_ref() {
            struct_ser.serialize_field("groupIndex", v)?;
        }
        if let Some(v) = self.calories.as_ref() {
            struct_ser.serialize_field("calories", v)?;
        }
        if let Some(v) = self.recommend_heart_rate.as_ref() {
            struct_ser.serialize_field("recommendHeartRate", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("count", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for projection_data::GroupInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "segment_type",
            "segmentType",
            "segment_timestamp",
            "segmentTimestamp",
            "segment_duration",
            "segmentDuration",
            "group_index",
            "groupIndex",
            "calories",
            "recommend_heart_rate",
            "recommendHeartRate",
            "count",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SegmentType,
            SegmentTimestamp,
            SegmentDuration,
            GroupIndex,
            Calories,
            RecommendHeartRate,
            Count,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "segmentType" | "segment_type" => Ok(GeneratedField::SegmentType),
                            "segmentTimestamp" | "segment_timestamp" => Ok(GeneratedField::SegmentTimestamp),
                            "segmentDuration" | "segment_duration" => Ok(GeneratedField::SegmentDuration),
                            "groupIndex" | "group_index" => Ok(GeneratedField::GroupIndex),
                            "calories" => Ok(GeneratedField::Calories),
                            "recommendHeartRate" | "recommend_heart_rate" => Ok(GeneratedField::RecommendHeartRate),
                            "count" => Ok(GeneratedField::Count),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = projection_data::GroupInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionData.GroupInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<projection_data::GroupInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut segment_type__ = None;
                let mut segment_timestamp__ = None;
                let mut segment_duration__ = None;
                let mut group_index__ = None;
                let mut calories__ = None;
                let mut recommend_heart_rate__ = None;
                let mut count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SegmentType => {
                            if segment_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("segmentType"));
                            }
                            segment_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SegmentTimestamp => {
                            if segment_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("segmentTimestamp"));
                            }
                            segment_timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SegmentDuration => {
                            if segment_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("segmentDuration"));
                            }
                            segment_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::GroupIndex => {
                            if group_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groupIndex"));
                            }
                            group_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RecommendHeartRate => {
                            if recommend_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("recommendHeartRate"));
                            }
                            recommend_heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(projection_data::GroupInfo {
                    segment_type: segment_type__.ok_or_else(|| serde::de::Error::missing_field("segmentType"))?,
                    segment_timestamp: segment_timestamp__.ok_or_else(|| serde::de::Error::missing_field("segmentTimestamp"))?,
                    segment_duration: segment_duration__.ok_or_else(|| serde::de::Error::missing_field("segmentDuration"))?,
                    group_index: group_index__,
                    calories: calories__,
                    recommend_heart_rate: recommend_heart_rate__,
                    count: count__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionData.GroupInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectionDevice {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionDevice", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("state", &self.state)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionDevice {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "state",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            State,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "state" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectionDevice;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionDevice")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectionDevice, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ProjectionDevice {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionDevice", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for projection_device::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionDevice.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for projection_device::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = projection_device::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionDevice.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<projection_device::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(projection_device::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionDevice.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectionMember {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionMember", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        struct_ser.serialize_field("userId", &self.user_id)?;
        struct_ser.serialize_field("userName", &self.user_name)?;
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionMember {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "user_id",
            "userId",
            "user_name",
            "userName",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            UserId,
            UserName,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "userId" | "user_id" => Ok(GeneratedField::UserId),
                            "userName" | "user_name" => Ok(GeneratedField::UserName),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectionMember;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionMember")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectionMember, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut user_id__ = None;
                let mut user_name__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UserId => {
                            if user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userId"));
                            }
                            user_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UserName => {
                            if user_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userName"));
                            }
                            user_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ProjectionMember {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    user_id: user_id__.ok_or_else(|| serde::de::Error::missing_field("userId"))?,
                    user_name: user_name__.ok_or_else(|| serde::de::Error::missing_field("userName"))?,
                    status: status__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionMember", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for projection_member::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionMember.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for projection_member::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = projection_member::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionMember.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<projection_member::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(projection_member::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionMember.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectionReport {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 13;
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionReport", len)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("timezone", &self.timezone)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        struct_ser.serialize_field("toalCalories", &self.toal_calories)?;
        struct_ser.serialize_field("calories", &self.calories)?;
        struct_ser.serialize_field("avgHeartRate", &self.avg_heart_rate)?;
        struct_ser.serialize_field("maxHeartRate", &self.max_heart_rate)?;
        struct_ser.serialize_field("minHeartRate", &self.min_heart_rate)?;
        struct_ser.serialize_field("hrmWarmUpDuration", &self.hrm_warm_up_duration)?;
        struct_ser.serialize_field("hrmFatBurningDuration", &self.hrm_fat_burning_duration)?;
        struct_ser.serialize_field("hrmAerobicDuration", &self.hrm_aerobic_duration)?;
        struct_ser.serialize_field("hrmAnaerobicDuration", &self.hrm_anaerobic_duration)?;
        struct_ser.serialize_field("hrmExtremeDuration", &self.hrm_extreme_duration)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionReport {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "timezone",
            "duration",
            "toal_calories",
            "toalCalories",
            "calories",
            "avg_heart_rate",
            "avgHeartRate",
            "max_heart_rate",
            "maxHeartRate",
            "min_heart_rate",
            "minHeartRate",
            "hrm_warm_up_duration",
            "hrmWarmUpDuration",
            "hrm_fat_burning_duration",
            "hrmFatBurningDuration",
            "hrm_aerobic_duration",
            "hrmAerobicDuration",
            "hrm_anaerobic_duration",
            "hrmAnaerobicDuration",
            "hrm_extreme_duration",
            "hrmExtremeDuration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Timezone,
            Duration,
            ToalCalories,
            Calories,
            AvgHeartRate,
            MaxHeartRate,
            MinHeartRate,
            HrmWarmUpDuration,
            HrmFatBurningDuration,
            HrmAerobicDuration,
            HrmAnaerobicDuration,
            HrmExtremeDuration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "timezone" => Ok(GeneratedField::Timezone),
                            "duration" => Ok(GeneratedField::Duration),
                            "toalCalories" | "toal_calories" => Ok(GeneratedField::ToalCalories),
                            "calories" => Ok(GeneratedField::Calories),
                            "avgHeartRate" | "avg_heart_rate" => Ok(GeneratedField::AvgHeartRate),
                            "maxHeartRate" | "max_heart_rate" => Ok(GeneratedField::MaxHeartRate),
                            "minHeartRate" | "min_heart_rate" => Ok(GeneratedField::MinHeartRate),
                            "hrmWarmUpDuration" | "hrm_warm_up_duration" => Ok(GeneratedField::HrmWarmUpDuration),
                            "hrmFatBurningDuration" | "hrm_fat_burning_duration" => Ok(GeneratedField::HrmFatBurningDuration),
                            "hrmAerobicDuration" | "hrm_aerobic_duration" => Ok(GeneratedField::HrmAerobicDuration),
                            "hrmAnaerobicDuration" | "hrm_anaerobic_duration" => Ok(GeneratedField::HrmAnaerobicDuration),
                            "hrmExtremeDuration" | "hrm_extreme_duration" => Ok(GeneratedField::HrmExtremeDuration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectionReport;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionReport")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectionReport, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut timezone__ = None;
                let mut duration__ = None;
                let mut toal_calories__ = None;
                let mut calories__ = None;
                let mut avg_heart_rate__ = None;
                let mut max_heart_rate__ = None;
                let mut min_heart_rate__ = None;
                let mut hrm_warm_up_duration__ = None;
                let mut hrm_fat_burning_duration__ = None;
                let mut hrm_aerobic_duration__ = None;
                let mut hrm_anaerobic_duration__ = None;
                let mut hrm_extreme_duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Timezone => {
                            if timezone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timezone"));
                            }
                            timezone__ = map_.next_value()?;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ToalCalories => {
                            if toal_calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("toalCalories"));
                            }
                            toal_calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AvgHeartRate => {
                            if avg_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgHeartRate"));
                            }
                            avg_heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MaxHeartRate => {
                            if max_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxHeartRate"));
                            }
                            max_heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MinHeartRate => {
                            if min_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minHeartRate"));
                            }
                            min_heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HrmWarmUpDuration => {
                            if hrm_warm_up_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hrmWarmUpDuration"));
                            }
                            hrm_warm_up_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HrmFatBurningDuration => {
                            if hrm_fat_burning_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hrmFatBurningDuration"));
                            }
                            hrm_fat_burning_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HrmAerobicDuration => {
                            if hrm_aerobic_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hrmAerobicDuration"));
                            }
                            hrm_aerobic_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HrmAnaerobicDuration => {
                            if hrm_anaerobic_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hrmAnaerobicDuration"));
                            }
                            hrm_anaerobic_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HrmExtremeDuration => {
                            if hrm_extreme_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hrmExtremeDuration"));
                            }
                            hrm_extreme_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ProjectionReport {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    timezone: timezone__.ok_or_else(|| serde::de::Error::missing_field("timezone"))?,
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    toal_calories: toal_calories__.ok_or_else(|| serde::de::Error::missing_field("toalCalories"))?,
                    calories: calories__.ok_or_else(|| serde::de::Error::missing_field("calories"))?,
                    avg_heart_rate: avg_heart_rate__.ok_or_else(|| serde::de::Error::missing_field("avgHeartRate"))?,
                    max_heart_rate: max_heart_rate__.ok_or_else(|| serde::de::Error::missing_field("maxHeartRate"))?,
                    min_heart_rate: min_heart_rate__.ok_or_else(|| serde::de::Error::missing_field("minHeartRate"))?,
                    hrm_warm_up_duration: hrm_warm_up_duration__.ok_or_else(|| serde::de::Error::missing_field("hrmWarmUpDuration"))?,
                    hrm_fat_burning_duration: hrm_fat_burning_duration__.ok_or_else(|| serde::de::Error::missing_field("hrmFatBurningDuration"))?,
                    hrm_aerobic_duration: hrm_aerobic_duration__.ok_or_else(|| serde::de::Error::missing_field("hrmAerobicDuration"))?,
                    hrm_anaerobic_duration: hrm_anaerobic_duration__.ok_or_else(|| serde::de::Error::missing_field("hrmAnaerobicDuration"))?,
                    hrm_extreme_duration: hrm_extreme_duration__.ok_or_else(|| serde::de::Error::missing_field("hrmExtremeDuration"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionReport", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectionRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionRequest", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        struct_ser.serialize_field("cmd", &self.cmd)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "cmd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            Cmd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "cmd" => Ok(GeneratedField::Cmd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectionRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectionRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut cmd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ProjectionRequest {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProjectionResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ProjectionResponse", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProjectionResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProjectionResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ProjectionResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProjectionResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(ProjectionResponse {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ProjectionResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Prop {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Prop", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Prop {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Prop;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Prop")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Prop, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Prop {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Prop", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prop::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.props.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Prop.Request", len)?;
        struct_ser.serialize_field("did", &self.did)?;
        if !self.props.is_empty() {
            struct_ser.serialize_field("props", &self.props)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prop::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "did",
            "props",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Did,
            Props,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "did" => Ok(GeneratedField::Did),
                            "props" => Ok(GeneratedField::Props),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prop::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Prop.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prop::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut did__ = None;
                let mut props__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Did => {
                            if did__.is_some() {
                                return Err(serde::de::Error::duplicate_field("did"));
                            }
                            did__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Props => {
                            if props__.is_some() {
                                return Err(serde::de::Error::duplicate_field("props"));
                            }
                            props__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(prop::Request {
                    did: did__.ok_or_else(|| serde::de::Error::missing_field("did"))?,
                    props: props__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Prop.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for prop::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.props_value.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Prop.Response", len)?;
        struct_ser.serialize_field("did", &self.did)?;
        if !self.props_value.is_empty() {
            struct_ser.serialize_field("propsValue", &self.props_value)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for prop::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "did",
            "props_value",
            "propsValue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Did,
            PropsValue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "did" => Ok(GeneratedField::Did),
                            "propsValue" | "props_value" => Ok(GeneratedField::PropsValue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = prop::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Prop.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<prop::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut did__ = None;
                let mut props_value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Did => {
                            if did__.is_some() {
                                return Err(serde::de::Error::duplicate_field("did"));
                            }
                            did__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PropsValue => {
                            if props_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("propsValue"));
                            }
                            props_value__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(prop::Response {
                    did: did__.ok_or_else(|| serde::de::Error::missing_field("did"))?,
                    props_value: props_value__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Prop.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RangeValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.RangeValue", len)?;
        struct_ser.serialize_field("from", &self.from)?;
        struct_ser.serialize_field("to", &self.to)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RangeValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "from",
            "to",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            From,
            To,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "from" => Ok(GeneratedField::From),
                            "to" => Ok(GeneratedField::To),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RangeValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RangeValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RangeValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut from__ = None;
                let mut to__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::From => {
                            if from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("from"));
                            }
                            from__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::To => {
                            if to__.is_some() {
                                return Err(serde::de::Error::duplicate_field("to"));
                            }
                            to__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RangeValue {
                    from: from__.ok_or_else(|| serde::de::Error::missing_field("from"))?,
                    to: to__.ok_or_else(|| serde::de::Error::missing_field("to"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RangeValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RecordRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.RecordRequest", len)?;
        let v = RecordType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("action", &self.action)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RecordRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "action",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Action,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "action" => Ok(GeneratedField::Action),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RecordRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RecordRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RecordRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut action__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<RecordType>()? as i32);
                        }
                        GeneratedField::Action => {
                            if action__.is_some() {
                                return Err(serde::de::Error::duplicate_field("action"));
                            }
                            action__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(RecordRequest {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    action: action__.ok_or_else(|| serde::de::Error::missing_field("action"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RecordRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RecordResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.media_file_id.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.RecordResponse", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        if let Some(v) = self.media_file_id.as_ref() {
            struct_ser.serialize_field("mediaFileId", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RecordResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "media_file_id",
            "mediaFileId",
            "duration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            MediaFileId,
            Duration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "mediaFileId" | "media_file_id" => Ok(GeneratedField::MediaFileId),
                            "duration" => Ok(GeneratedField::Duration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RecordResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RecordResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RecordResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut media_file_id__ = None;
                let mut duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MediaFileId => {
                            if media_file_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaFileId"));
                            }
                            media_file_id__ = map_.next_value()?;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RecordResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    media_file_id: media_file_id__,
                    duration: duration__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RecordResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RecordStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.size.is_some() {
            len += 1;
        }
        if self.extra_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.RecordStatus", len)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("size", v)?;
        }
        if let Some(v) = self.extra_data.as_ref() {
            struct_ser.serialize_field("extraData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RecordStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "duration",
            "size",
            "extra_data",
            "extraData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Duration,
            Size,
            ExtraData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "duration" => Ok(GeneratedField::Duration),
                            "size" => Ok(GeneratedField::Size),
                            "extraData" | "extra_data" => Ok(GeneratedField::ExtraData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RecordStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RecordStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RecordStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut duration__ = None;
                let mut size__ = None;
                let mut extra_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = map_.next_value()?;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = map_.next_value()?;
                        }
                        GeneratedField::ExtraData => {
                            if extra_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraData"));
                            }
                            extra_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(RecordStatus {
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    size: size__,
                    extra_data: extra_data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RecordStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for record_status::ExtraData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.RecordStatus.ExtraData", len)?;
        struct_ser.serialize_field("mediaFile", &self.media_file)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for record_status::ExtraData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "media_file",
            "mediaFile",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MediaFile,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mediaFile" | "media_file" => Ok(GeneratedField::MediaFile),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = record_status::ExtraData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RecordStatus.ExtraData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<record_status::ExtraData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut media_file__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MediaFile => {
                            if media_file__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaFile"));
                            }
                            media_file__ = map_.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(record_status::ExtraData {
                    media_file: media_file__.ok_or_else(|| serde::de::Error::missing_field("mediaFile"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RecordStatus.ExtraData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RecordType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::RecordNormal => "RECORD_NORMAL",
            Self::RecordRealtime => "RECORD_REALTIME",
            Self::RecordMusic => "RECORD_MUSIC",
            Self::RecordTranslation => "RECORD_TRANSLATION",
            Self::RecordTranslationFace => "RECORD_TRANSLATION_FACE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for RecordType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RECORD_NORMAL",
            "RECORD_REALTIME",
            "RECORD_MUSIC",
            "RECORD_TRANSLATION",
            "RECORD_TRANSLATION_FACE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RecordType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "RECORD_NORMAL" => Ok(RecordType::RecordNormal),
                    "RECORD_REALTIME" => Ok(RecordType::RecordRealtime),
                    "RECORD_MUSIC" => Ok(RecordType::RecordMusic),
                    "RECORD_TRANSLATION" => Ok(RecordType::RecordTranslation),
                    "RECORD_TRANSLATION_FACE" => Ok(RecordType::RecordTranslationFace),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RemainingSportData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.sport_course_type.is_some() {
            len += 1;
        }
        if self.cloud_course_id.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.distance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.RemainingSportData", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("ids", pbjson::private::base64::encode(&self.ids).as_str())?;
        if let Some(v) = self.sport_course_type.as_ref() {
            struct_ser.serialize_field("sportCourseType", v)?;
        }
        if let Some(v) = self.cloud_course_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("cloudCourseId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", v)?;
        }
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RemainingSportData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ids",
            "sport_course_type",
            "sportCourseType",
            "cloud_course_id",
            "cloudCourseId",
            "duration",
            "distance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ids,
            SportCourseType,
            CloudCourseId,
            Duration,
            Distance,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ids" => Ok(GeneratedField::Ids),
                            "sportCourseType" | "sport_course_type" => Ok(GeneratedField::SportCourseType),
                            "cloudCourseId" | "cloud_course_id" => Ok(GeneratedField::CloudCourseId),
                            "duration" => Ok(GeneratedField::Duration),
                            "distance" => Ok(GeneratedField::Distance),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RemainingSportData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RemainingSportData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RemainingSportData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ids__ = None;
                let mut sport_course_type__ = None;
                let mut cloud_course_id__ = None;
                let mut duration__ = None;
                let mut distance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ids => {
                            if ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SportCourseType => {
                            if sport_course_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportCourseType"));
                            }
                            sport_course_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CloudCourseId => {
                            if cloud_course_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cloudCourseId"));
                            }
                            cloud_course_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RemainingSportData {
                    ids: ids__.ok_or_else(|| serde::de::Error::missing_field("ids"))?,
                    sport_course_type: sport_course_type__,
                    cloud_course_id: cloud_course_id__,
                    duration: duration__,
                    distance: distance__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RemainingSportData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for remaining_sport_data::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.RemainingSportData.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for remaining_sport_data::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = remaining_sport_data::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RemainingSportData.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<remaining_sport_data::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(remaining_sport_data::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.RemainingSportData.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReminderIdList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReminderIdList", len)?;
        if !self.id.is_empty() {
            struct_ser.serialize_field("id", &self.id)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReminderIdList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReminderIdList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReminderIdList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReminderIdList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(ReminderIdList {
                    id: id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReminderIdList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReminderInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ReminderInfo", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("data", &self.data)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReminderInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReminderInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReminderInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReminderInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ReminderInfo {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    data: data__.ok_or_else(|| serde::de::Error::missing_field("data"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReminderInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for reminder_info::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.week_days.is_some() {
            len += 1;
        }
        if self.truncated.is_some() {
            len += 1;
        }
        if self.source.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.update_time.is_some() {
            len += 1;
        }
        if !self.sub_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReminderInfo.Data", len)?;
        struct_ser.serialize_field("date", &self.date)?;
        struct_ser.serialize_field("time", &self.time)?;
        let v = ClockMode::try_from(self.clock_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.clock_mode)))?;
        struct_ser.serialize_field("clockMode", &v)?;
        if let Some(v) = self.week_days.as_ref() {
            struct_ser.serialize_field("weekDays", v)?;
        }
        struct_ser.serialize_field("label", &self.label)?;
        if let Some(v) = self.truncated.as_ref() {
            struct_ser.serialize_field("truncated", v)?;
        }
        if let Some(v) = self.source.as_ref() {
            struct_ser.serialize_field("source", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.update_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("updateTime", ToString::to_string(&v).as_str())?;
        }
        if !self.sub_list.is_empty() {
            struct_ser.serialize_field("subList", &self.sub_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for reminder_info::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "date",
            "time",
            "clock_mode",
            "clockMode",
            "week_days",
            "weekDays",
            "label",
            "truncated",
            "source",
            "status",
            "update_time",
            "updateTime",
            "sub_list",
            "subList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Date,
            Time,
            ClockMode,
            WeekDays,
            Label,
            Truncated,
            Source,
            Status,
            UpdateTime,
            SubList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "date" => Ok(GeneratedField::Date),
                            "time" => Ok(GeneratedField::Time),
                            "clockMode" | "clock_mode" => Ok(GeneratedField::ClockMode),
                            "weekDays" | "week_days" => Ok(GeneratedField::WeekDays),
                            "label" => Ok(GeneratedField::Label),
                            "truncated" => Ok(GeneratedField::Truncated),
                            "source" => Ok(GeneratedField::Source),
                            "status" => Ok(GeneratedField::Status),
                            "updateTime" | "update_time" => Ok(GeneratedField::UpdateTime),
                            "subList" | "sub_list" => Ok(GeneratedField::SubList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reminder_info::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReminderInfo.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<reminder_info::Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut date__ = None;
                let mut time__ = None;
                let mut clock_mode__ = None;
                let mut week_days__ = None;
                let mut label__ = None;
                let mut truncated__ = None;
                let mut source__ = None;
                let mut status__ = None;
                let mut update_time__ = None;
                let mut sub_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Date => {
                            if date__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            date__ = map_.next_value()?;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            time__ = map_.next_value()?;
                        }
                        GeneratedField::ClockMode => {
                            if clock_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockMode"));
                            }
                            clock_mode__ = Some(map_.next_value::<ClockMode>()? as i32);
                        }
                        GeneratedField::WeekDays => {
                            if week_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekDays"));
                            }
                            week_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Label => {
                            if label__.is_some() {
                                return Err(serde::de::Error::duplicate_field("label"));
                            }
                            label__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Truncated => {
                            if truncated__.is_some() {
                                return Err(serde::de::Error::duplicate_field("truncated"));
                            }
                            truncated__ = map_.next_value()?;
                        }
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UpdateTime => {
                            if update_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updateTime"));
                            }
                            update_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SubList => {
                            if sub_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subList"));
                            }
                            sub_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(reminder_info::Data {
                    date: date__.ok_or_else(|| serde::de::Error::missing_field("date"))?,
                    time: time__.ok_or_else(|| serde::de::Error::missing_field("time"))?,
                    clock_mode: clock_mode__.ok_or_else(|| serde::de::Error::missing_field("clockMode"))?,
                    week_days: week_days__,
                    label: label__.ok_or_else(|| serde::de::Error::missing_field("label"))?,
                    truncated: truncated__,
                    source: source__,
                    status: status__,
                    update_time: update_time__,
                    sub_list: sub_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReminderInfo.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for reminder_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.support_max_reminders.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReminderInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.support_max_reminders.as_ref() {
            struct_ser.serialize_field("supportMaxReminders", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for reminder_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "support_max_reminders",
            "supportMaxReminders",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            SupportMaxReminders,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "supportMaxReminders" | "support_max_reminders" => Ok(GeneratedField::SupportMaxReminders),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reminder_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReminderInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<reminder_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut support_max_reminders__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportMaxReminders => {
                            if support_max_reminders__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMaxReminders"));
                            }
                            support_max_reminders__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(reminder_info::List {
                    list: list__.unwrap_or_default(),
                    support_max_reminders: support_max_reminders__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReminderInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for reminder_info::Mark {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.source.is_some() {
            len += 1;
        }
        if !self.sub_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReminderInfo.Mark", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        if let Some(v) = self.source.as_ref() {
            struct_ser.serialize_field("source", v)?;
        }
        struct_ser.serialize_field("status", &self.status)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("updateTime", ToString::to_string(&self.update_time).as_str())?;
        if !self.sub_list.is_empty() {
            struct_ser.serialize_field("subList", &self.sub_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for reminder_info::Mark {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "source",
            "status",
            "update_time",
            "updateTime",
            "sub_list",
            "subList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Source,
            Status,
            UpdateTime,
            SubList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "source" => Ok(GeneratedField::Source),
                            "status" => Ok(GeneratedField::Status),
                            "updateTime" | "update_time" => Ok(GeneratedField::UpdateTime),
                            "subList" | "sub_list" => Ok(GeneratedField::SubList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reminder_info::Mark;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReminderInfo.Mark")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<reminder_info::Mark, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut source__ = None;
                let mut status__ = None;
                let mut update_time__ = None;
                let mut sub_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::UpdateTime => {
                            if update_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updateTime"));
                            }
                            update_time__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SubList => {
                            if sub_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subList"));
                            }
                            sub_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(reminder_info::Mark {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    source: source__,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    update_time: update_time__.ok_or_else(|| serde::de::Error::missing_field("updateTime"))?,
                    sub_list: sub_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReminderInfo.Mark", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for reminder_info::SubTodo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.truncated.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReminderInfo.SubTodo", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.serialize_field("content", &self.content)?;
        if let Some(v) = self.truncated.as_ref() {
            struct_ser.serialize_field("truncated", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for reminder_info::SubTodo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "status",
            "content",
            "truncated",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Status,
            Content,
            Truncated,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "status" => Ok(GeneratedField::Status),
                            "content" => Ok(GeneratedField::Content),
                            "truncated" => Ok(GeneratedField::Truncated),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reminder_info::SubTodo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReminderInfo.SubTodo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<reminder_info::SubTodo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut status__ = None;
                let mut content__ = None;
                let mut truncated__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Truncated => {
                            if truncated__.is_some() {
                                return Err(serde::de::Error::duplicate_field("truncated"));
                            }
                            truncated__ = map_.next_value()?;
                        }
                    }
                }
                Ok(reminder_info::SubTodo {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    content: content__.ok_or_else(|| serde::de::Error::missing_field("content"))?,
                    truncated: truncated__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReminderInfo.SubTodo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplyMsg {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.contents.is_empty() {
            len += 1;
        }
        if self.support_max_numbers.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReplyMsg", len)?;
        let v = reply_msg::Target::try_from(self.target)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.target)))?;
        struct_ser.serialize_field("target", &v)?;
        if !self.contents.is_empty() {
            struct_ser.serialize_field("contents", &self.contents)?;
        }
        if let Some(v) = self.support_max_numbers.as_ref() {
            struct_ser.serialize_field("supportMaxNumbers", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplyMsg {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "target",
            "contents",
            "support_max_numbers",
            "supportMaxNumbers",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Target,
            Contents,
            SupportMaxNumbers,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "target" => Ok(GeneratedField::Target),
                            "contents" => Ok(GeneratedField::Contents),
                            "supportMaxNumbers" | "support_max_numbers" => Ok(GeneratedField::SupportMaxNumbers),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplyMsg;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReplyMsg")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReplyMsg, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target__ = None;
                let mut contents__ = None;
                let mut support_max_numbers__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("target"));
                            }
                            target__ = Some(map_.next_value::<reply_msg::Target>()? as i32);
                        }
                        GeneratedField::Contents => {
                            if contents__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contents"));
                            }
                            contents__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportMaxNumbers => {
                            if support_max_numbers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMaxNumbers"));
                            }
                            support_max_numbers__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ReplyMsg {
                    target: target__.ok_or_else(|| serde::de::Error::missing_field("target"))?,
                    contents: contents__.unwrap_or_default(),
                    support_max_numbers: support_max_numbers__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReplyMsg", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for reply_msg::Removal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReplyMsg.Removal", len)?;
        let v = reply_msg::Target::try_from(self.target)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.target)))?;
        struct_ser.serialize_field("target", &v)?;
        if !self.id.is_empty() {
            struct_ser.serialize_field("id", &self.id)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for reply_msg::Removal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "target",
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Target,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "target" => Ok(GeneratedField::Target),
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reply_msg::Removal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReplyMsg.Removal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<reply_msg::Removal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("target"));
                            }
                            target__ = Some(map_.next_value::<reply_msg::Target>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(reply_msg::Removal {
                    target: target__.ok_or_else(|| serde::de::Error::missing_field("target"))?,
                    id: id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReplyMsg.Removal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for reply_msg::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Success => "SUCCESS",
            Self::ExceedLimit => "EXCEED_LIMIT",
            Self::InvalidId => "INVALID_ID",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for reply_msg::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUCCESS",
            "EXCEED_LIMIT",
            "INVALID_ID",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reply_msg::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUCCESS" => Ok(reply_msg::Result::Success),
                    "EXCEED_LIMIT" => Ok(reply_msg::Result::ExceedLimit),
                    "INVALID_ID" => Ok(reply_msg::Result::InvalidId),
                    "FAIL" => Ok(reply_msg::Result::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for reply_msg::Target {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Sms => "SMS",
            Self::Wechat => "WECHAT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for reply_msg::Target {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SMS",
            "WECHAT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = reply_msg::Target;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SMS" => Ok(reply_msg::Target::Sms),
                    "WECHAT" => Ok(reply_msg::Target::Wechat),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ReplyRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReplyRequest", len)?;
        let v = reply_msg::Target::try_from(self.target)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.target)))?;
        struct_ser.serialize_field("target", &v)?;
        struct_ser.serialize_field("contents", &self.contents)?;
        struct_ser.serialize_field("needResult", &self.need_result)?;
        if let Some(v) = self.data.as_ref() {
            match v {
                reply_request::Data::PhoneNumber(v) => {
                    struct_ser.serialize_field("phoneNumber", v)?;
                }
                reply_request::Data::NotifyId(v) => {
                    struct_ser.serialize_field("notifyId", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReplyRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "target",
            "contents",
            "need_result",
            "needResult",
            "phone_number",
            "phoneNumber",
            "notify_id",
            "notifyId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Target,
            Contents,
            NeedResult,
            PhoneNumber,
            NotifyId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "target" => Ok(GeneratedField::Target),
                            "contents" => Ok(GeneratedField::Contents),
                            "needResult" | "need_result" => Ok(GeneratedField::NeedResult),
                            "phoneNumber" | "phone_number" => Ok(GeneratedField::PhoneNumber),
                            "notifyId" | "notify_id" => Ok(GeneratedField::NotifyId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplyRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReplyRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReplyRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target__ = None;
                let mut contents__ = None;
                let mut need_result__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("target"));
                            }
                            target__ = Some(map_.next_value::<reply_msg::Target>()? as i32);
                        }
                        GeneratedField::Contents => {
                            if contents__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contents"));
                            }
                            contents__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NeedResult => {
                            if need_result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needResult"));
                            }
                            need_result__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PhoneNumber => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneNumber"));
                            }
                            data__ = map_.next_value::<::std::option::Option<_>>()?.map(reply_request::Data::PhoneNumber);
                        }
                        GeneratedField::NotifyId => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("notifyId"));
                            }
                            data__ = map_.next_value::<::std::option::Option<_>>()?.map(reply_request::Data::NotifyId)
;
                        }
                    }
                }
                Ok(ReplyRequest {
                    target: target__.ok_or_else(|| serde::de::Error::missing_field("target"))?,
                    contents: contents__.ok_or_else(|| serde::de::Error::missing_field("contents"))?,
                    need_result: need_result__.ok_or_else(|| serde::de::Error::missing_field("needResult"))?,
                    data: data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReplyRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReplyResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ReplySuccess => "REPLY_SUCCESS",
            Self::TargetNotSupport => "TARGET_NOT_SUPPORT",
            Self::NotifyNotFound => "NOTIFY_NOT_FOUND",
            Self::NoReplyPermission => "NO_REPLY_PERMISSION",
            Self::ReplyFail => "REPLY_FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ReplyResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "REPLY_SUCCESS",
            "TARGET_NOT_SUPPORT",
            "NOTIFY_NOT_FOUND",
            "NO_REPLY_PERMISSION",
            "REPLY_FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReplyResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "REPLY_SUCCESS" => Ok(ReplyResult::ReplySuccess),
                    "TARGET_NOT_SUPPORT" => Ok(ReplyResult::TargetNotSupport),
                    "NOTIFY_NOT_FOUND" => Ok(ReplyResult::NotifyNotFound),
                    "NO_REPLY_PERMISSION" => Ok(ReplyResult::NoReplyPermission),
                    "REPLY_FAIL" => Ok(ReplyResult::ReplyFail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ReportData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ReportData", len)?;
        let v = report_data::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReportData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReportData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReportData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReportData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<report_data::Type>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ReportData {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    id: id__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReportData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for report_data::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ReportData.Result", len)?;
        let v = report_data::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        let v = report_data::Status::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for report_data::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = report_data::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ReportData.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<report_data::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<report_data::Type>()? as i32);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<report_data::Status>()? as i32);
                        }
                    }
                }
                Ok(report_data::Result {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ReportData.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for report_data::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Success => "SUCCESS",
            Self::NoData => "NO_DATA",
            Self::UrlDirect => "URL_DIRECT",
            Self::Busy => "BUSY",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for report_data::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUCCESS",
            "NO_DATA",
            "URL_DIRECT",
            "BUSY",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = report_data::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUCCESS" => Ok(report_data::Status::Success),
                    "NO_DATA" => Ok(report_data::Status::NoData),
                    "URL_DIRECT" => Ok(report_data::Status::UrlDirect),
                    "BUSY" => Ok(report_data::Status::Busy),
                    "FAIL" => Ok(report_data::Status::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for report_data::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DeviceLog => "DEVICE_LOG",
            Self::Statistics => "STATISTICS",
            Self::DumpLog => "DUMP_LOG",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for report_data::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DEVICE_LOG",
            "STATISTICS",
            "DUMP_LOG",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = report_data::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DEVICE_LOG" => Ok(report_data::Type::DeviceLog),
                    "STATISTICS" => Ok(report_data::Type::Statistics),
                    "DUMP_LOG" => Ok(report_data::Type::DumpLog),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RequestInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.RequestInfo", len)?;
        struct_ser.serialize_field("onlyAudio", &self.only_audio)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RequestInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "only_audio",
            "onlyAudio",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OnlyAudio,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "onlyAudio" | "only_audio" => Ok(GeneratedField::OnlyAudio),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RequestInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RequestInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RequestInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut only_audio__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OnlyAudio => {
                            if only_audio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onlyAudio"));
                            }
                            only_audio__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RequestInfo {
                    only_audio: only_audio__.ok_or_else(|| serde::de::Error::missing_field("onlyAudio"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RequestInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Research {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.Research", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Research {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Research;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Research, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(Research {
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::App {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.App", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::App {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "type",
            "enable",
            "timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Type,
            Enable,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "type" => Ok(GeneratedField::Type),
                            "enable" => Ok(GeneratedField::Enable),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::App;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.App")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::App, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut r#type__ = None;
                let mut enable__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(research::App {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.App", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::app::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Research.App.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::app::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::app::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.App.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::app::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(research::app::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.App.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::BpgCalibrationRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.BPGCalibrationRequest", len)?;
        struct_ser.serialize_field("researchId", &self.research_id)?;
        struct_ser.serialize_field("needCalibTimes", &self.need_calib_times)?;
        struct_ser.serialize_field("currentCalibTimes", &self.current_calib_times)?;
        struct_ser.serialize_field("systolicBp", &self.systolic_bp)?;
        struct_ser.serialize_field("diastolicBp", &self.diastolic_bp)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::BpgCalibrationRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "research_id",
            "researchId",
            "need_calib_times",
            "needCalibTimes",
            "current_calib_times",
            "currentCalibTimes",
            "systolic_bp",
            "systolicBp",
            "diastolic_bp",
            "diastolicBp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResearchId,
            NeedCalibTimes,
            CurrentCalibTimes,
            SystolicBp,
            DiastolicBp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "researchId" | "research_id" => Ok(GeneratedField::ResearchId),
                            "needCalibTimes" | "need_calib_times" => Ok(GeneratedField::NeedCalibTimes),
                            "currentCalibTimes" | "current_calib_times" => Ok(GeneratedField::CurrentCalibTimes),
                            "systolicBp" | "systolic_bp" => Ok(GeneratedField::SystolicBp),
                            "diastolicBp" | "diastolic_bp" => Ok(GeneratedField::DiastolicBp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::BpgCalibrationRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.BPGCalibrationRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::BpgCalibrationRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut research_id__ = None;
                let mut need_calib_times__ = None;
                let mut current_calib_times__ = None;
                let mut systolic_bp__ = None;
                let mut diastolic_bp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResearchId => {
                            if research_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchId"));
                            }
                            research_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::NeedCalibTimes => {
                            if need_calib_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needCalibTimes"));
                            }
                            need_calib_times__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CurrentCalibTimes => {
                            if current_calib_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentCalibTimes"));
                            }
                            current_calib_times__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SystolicBp => {
                            if systolic_bp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systolicBp"));
                            }
                            systolic_bp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DiastolicBp => {
                            if diastolic_bp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("diastolicBp"));
                            }
                            diastolic_bp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(research::BpgCalibrationRequest {
                    research_id: research_id__.ok_or_else(|| serde::de::Error::missing_field("researchId"))?,
                    need_calib_times: need_calib_times__.ok_or_else(|| serde::de::Error::missing_field("needCalibTimes"))?,
                    current_calib_times: current_calib_times__.ok_or_else(|| serde::de::Error::missing_field("currentCalibTimes"))?,
                    systolic_bp: systolic_bp__.ok_or_else(|| serde::de::Error::missing_field("systolicBp"))?,
                    diastolic_bp: diastolic_bp__.ok_or_else(|| serde::de::Error::missing_field("diastolicBp"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.BPGCalibrationRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::BpgCalibrationStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.BPGCalibrationStatus", len)?;
        struct_ser.serialize_field("calibSuccessTimes", &self.calib_success_times)?;
        struct_ser.serialize_field("calibSuccessTs", &self.calib_success_ts)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::BpgCalibrationStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "calib_success_times",
            "calibSuccessTimes",
            "calib_success_ts",
            "calibSuccessTs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CalibSuccessTimes,
            CalibSuccessTs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "calibSuccessTimes" | "calib_success_times" => Ok(GeneratedField::CalibSuccessTimes),
                            "calibSuccessTs" | "calib_success_ts" => Ok(GeneratedField::CalibSuccessTs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::BpgCalibrationStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.BPGCalibrationStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::BpgCalibrationStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut calib_success_times__ = None;
                let mut calib_success_ts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CalibSuccessTimes => {
                            if calib_success_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calibSuccessTimes"));
                            }
                            calib_success_times__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CalibSuccessTs => {
                            if calib_success_ts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calibSuccessTs"));
                            }
                            calib_success_ts__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(research::BpgCalibrationStatus {
                    calib_success_times: calib_success_times__.ok_or_else(|| serde::de::Error::missing_field("calibSuccessTimes"))?,
                    calib_success_ts: calib_success_ts__.ok_or_else(|| serde::de::Error::missing_field("calibSuccessTs"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.BPGCalibrationStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::BpSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.BpSetting", len)?;
        struct_ser.serialize_field("researchId", &self.research_id)?;
        struct_ser.serialize_field("caliMorning", &self.cali_morning)?;
        struct_ser.serialize_field("caliAfternoon", &self.cali_afternoon)?;
        struct_ser.serialize_field("reminderFrequence", &self.reminder_frequence)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::BpSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "research_id",
            "researchId",
            "cali_morning",
            "caliMorning",
            "cali_afternoon",
            "caliAfternoon",
            "reminder_frequence",
            "reminderFrequence",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResearchId,
            CaliMorning,
            CaliAfternoon,
            ReminderFrequence,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "researchId" | "research_id" => Ok(GeneratedField::ResearchId),
                            "caliMorning" | "cali_morning" => Ok(GeneratedField::CaliMorning),
                            "caliAfternoon" | "cali_afternoon" => Ok(GeneratedField::CaliAfternoon),
                            "reminderFrequence" | "reminder_frequence" => Ok(GeneratedField::ReminderFrequence),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::BpSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.BpSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::BpSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut research_id__ = None;
                let mut cali_morning__ = None;
                let mut cali_afternoon__ = None;
                let mut reminder_frequence__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResearchId => {
                            if research_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchId"));
                            }
                            research_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CaliMorning => {
                            if cali_morning__.is_some() {
                                return Err(serde::de::Error::duplicate_field("caliMorning"));
                            }
                            cali_morning__ = map_.next_value()?;
                        }
                        GeneratedField::CaliAfternoon => {
                            if cali_afternoon__.is_some() {
                                return Err(serde::de::Error::duplicate_field("caliAfternoon"));
                            }
                            cali_afternoon__ = map_.next_value()?;
                        }
                        GeneratedField::ReminderFrequence => {
                            if reminder_frequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderFrequence"));
                            }
                            reminder_frequence__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(research::BpSetting {
                    research_id: research_id__.ok_or_else(|| serde::de::Error::missing_field("researchId"))?,
                    cali_morning: cali_morning__.ok_or_else(|| serde::de::Error::missing_field("caliMorning"))?,
                    cali_afternoon: cali_afternoon__.ok_or_else(|| serde::de::Error::missing_field("caliAfternoon"))?,
                    reminder_frequence: reminder_frequence__.ok_or_else(|| serde::de::Error::missing_field("reminderFrequence"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.BpSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::CalibrationRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.CalibrationRequest", len)?;
        struct_ser.serialize_field("researchId", &self.research_id)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::CalibrationRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "research_id",
            "researchId",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResearchId,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "researchId" | "research_id" => Ok(GeneratedField::ResearchId),
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::CalibrationRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.CalibrationRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::CalibrationRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut research_id__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResearchId => {
                            if research_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchId"));
                            }
                            research_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(research::CalibrationRequest {
                    research_id: research_id__.ok_or_else(|| serde::de::Error::missing_field("researchId"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.CalibrationRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::CalibrationResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.CalibrationResponse", len)?;
        struct_ser.serialize_field("researchId", &self.research_id)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::CalibrationResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "research_id",
            "researchId",
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResearchId,
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "researchId" | "research_id" => Ok(GeneratedField::ResearchId),
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::CalibrationResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.CalibrationResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::CalibrationResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut research_id__ = None;
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResearchId => {
                            if research_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("researchId"));
                            }
                            research_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(research::CalibrationResponse {
                    research_id: research_id__.ok_or_else(|| serde::de::Error::missing_field("researchId"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.CalibrationResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::Device {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Research.Device", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::Device {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "enable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Enable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "enable" => Ok(GeneratedField::Enable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::Device;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.Device")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::Device, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut enable__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(research::Device {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.Device", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for research::device::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Research.Device.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for research::device::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = research::device::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Research.Device.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<research::device::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(research::device::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Research.Device.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResetMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoErase => "NO_ERASE",
            Self::EraseAll => "ERASE_ALL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ResetMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_ERASE",
            "ERASE_ALL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResetMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_ERASE" => Ok(ResetMode::NoErase),
                    "ERASE_ALL" => Ok(ResetMode::EraseAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ResultType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::StartListening => "START_LISTENING",
            Self::EndListening => "END_LISTENING",
            Self::RecognizeResult => "RECOGNIZE_RESULT",
            Self::StopCapture => "STOP_CAPTURE",
            Self::DialogFinish => "DIALOG_FINISH",
            Self::SystemTruncationnotification => "SYSTEM_TRUNCATIONNOTIFICATION",
            Self::ErrorNetwork => "ERROR_NETWORK",
            Self::ErrorAuth => "ERROR_AUTH",
            Self::ErrorTooManyDevices => "ERROR_TOO_MANY_DEVICES",
            Self::ErrorContentTooLong => "ERROR_CONTENT_TOO_LONG",
            Self::AivsErrorAsrTimeout => "AIVS_ERROR_ASR_TIMEOUT",
            Self::AivsErrorTtsTimeout => "AIVS_ERROR_TTS_TIMEOUT",
            Self::ErrorConnectTimeout => "ERROR_CONNECT_TIMEOUT",
            Self::ErrorAudioEmpty => "ERROR_AUDIO_EMPTY",
            Self::ErrorSubscriptionExpired => "ERROR_SUBSCRIPTION_EXPIRED",
            Self::ErrorTodayFreeCountLimit => "ERROR_TODAY_FREE_COUNT_LIMIT",
            Self::ErrorAllFreeCountLimit => "ERROR_ALL_FREE_COUNT_LIMIT",
            Self::ErrorSensativeContent => "ERROR_SENSATIVE_CONTENT",
            Self::ErrorUnsupportLanguage => "ERROR_UNSUPPORT_LANGUAGE",
            Self::ErrorUnknown => "ERROR_UNKNOWN",
            Self::TemplateToast => "TEMPLATE_TOAST",
            Self::TemplateGeneral => "TEMPLATE_GENERAL",
            Self::TemplateGeneral2 => "TEMPLATE_GENERAL2",
            Self::TemplateWeather => "TEMPLATE_WEATHER",
            Self::TemplatePlayinfo => "TEMPLATE_PLAYINFO",
            Self::TemplateLists => "TEMPLATE_LISTS",
            Self::TemplateSwitchpanel => "TEMPLATE_SWITCHPANEL",
            Self::AlertsSetalert => "ALERTS_SETALERT",
            Self::SpeechsynthesizerSpeak => "SPEECHSYNTHESIZER_SPEAK",
            Self::SpeechrecognizerExpectspeech => "SPEECHRECOGNIZER_EXPECTSPEECH",
            Self::LauncherLaunchapp => "LAUNCHER_LAUNCHAPP",
            Self::TemplateSwitchpanellist => "TEMPLATE_SWITCHPANELLIST",
            Self::BrightnesscontrollerAdjustbrightness => "BRIGHTNESSCONTROLLER_ADJUSTBRIGHTNESS",
            Self::SystemSetproperty => "SYSTEM_SETPROPERTY",
            Self::ApplicationOperate => "APPLICATION_OPERATE",
            Self::AlertsDeliveralertintention => "ALERTS_DELIVERALERTINTENTION",
            Self::AlertsStopalert => "ALERTS_STOPALERT",
            Self::Playbackcontroller => "PLAYBACKCONTROLLER",
            Self::PlaybackcontrollerStop => "PLAYBACKCONTROLLER_STOP",
            Self::PlaybackcontrollerPlay => "PLAYBACKCONTROLLER_PLAY",
            Self::PlaybackcontrollerPause => "PLAYBACKCONTROLLER_PAUSE",
            Self::PlaybackcontrollerNext => "PLAYBACKCONTROLLER_NEXT",
            Self::PlaybackcontrollerPrev => "PLAYBACKCONTROLLER_PREV",
            Self::PlaybackcontrollerContinueplaying => "PLAYBACKCONTROLLER_CONTINUEPLAYING",
            Self::SpeakerSetmute => "SPEAKER_SETMUTE",
            Self::SpeakerSetvolume => "SPEAKER_SETVOLUME",
            Self::SpeakerAjustvolume => "SPEAKER_AJUSTVOLUME",
            Self::TemplateDevicelist => "TEMPLATE_DEVICELIST",
            Self::ExecuteDeviceskill => "EXECUTE_DEVICESKILL",
            Self::ShowContacts => "SHOW_CONTACTS",
            Self::MakeCall => "MAKE_CALL",
            Self::WearableControllerSwitch => "WEARABLE_CONTROLLER_SWITCH",
            Self::WearableControllerExecute => "WEARABLE_CONTROLLER_EXECUTE",
            Self::WearableControllerAction => "WEARABLE_CONTROLLER_ACTION",
            Self::LlmLoadingCard => "LLM_LOADING_CARD",
            Self::LlmDeclarationContent => "LLM_DECLARATION_CONTENT",
            Self::LlmIllegalContent => "LLM_ILLEGAL_CONTENT",
            Self::LlmToastStream => "LLM_TOAST_STREAM",
            Self::LlmFinishStream => "LLM_FINISH_STREAM",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ResultType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "START_LISTENING",
            "END_LISTENING",
            "RECOGNIZE_RESULT",
            "STOP_CAPTURE",
            "DIALOG_FINISH",
            "SYSTEM_TRUNCATIONNOTIFICATION",
            "ERROR_NETWORK",
            "ERROR_AUTH",
            "ERROR_TOO_MANY_DEVICES",
            "ERROR_CONTENT_TOO_LONG",
            "AIVS_ERROR_ASR_TIMEOUT",
            "AIVS_ERROR_TTS_TIMEOUT",
            "ERROR_CONNECT_TIMEOUT",
            "ERROR_AUDIO_EMPTY",
            "ERROR_SUBSCRIPTION_EXPIRED",
            "ERROR_TODAY_FREE_COUNT_LIMIT",
            "ERROR_ALL_FREE_COUNT_LIMIT",
            "ERROR_SENSATIVE_CONTENT",
            "ERROR_UNSUPPORT_LANGUAGE",
            "ERROR_UNKNOWN",
            "TEMPLATE_TOAST",
            "TEMPLATE_GENERAL",
            "TEMPLATE_GENERAL2",
            "TEMPLATE_WEATHER",
            "TEMPLATE_PLAYINFO",
            "TEMPLATE_LISTS",
            "TEMPLATE_SWITCHPANEL",
            "ALERTS_SETALERT",
            "SPEECHSYNTHESIZER_SPEAK",
            "SPEECHRECOGNIZER_EXPECTSPEECH",
            "LAUNCHER_LAUNCHAPP",
            "TEMPLATE_SWITCHPANELLIST",
            "BRIGHTNESSCONTROLLER_ADJUSTBRIGHTNESS",
            "SYSTEM_SETPROPERTY",
            "APPLICATION_OPERATE",
            "ALERTS_DELIVERALERTINTENTION",
            "ALERTS_STOPALERT",
            "PLAYBACKCONTROLLER",
            "PLAYBACKCONTROLLER_STOP",
            "PLAYBACKCONTROLLER_PLAY",
            "PLAYBACKCONTROLLER_PAUSE",
            "PLAYBACKCONTROLLER_NEXT",
            "PLAYBACKCONTROLLER_PREV",
            "PLAYBACKCONTROLLER_CONTINUEPLAYING",
            "SPEAKER_SETMUTE",
            "SPEAKER_SETVOLUME",
            "SPEAKER_AJUSTVOLUME",
            "TEMPLATE_DEVICELIST",
            "EXECUTE_DEVICESKILL",
            "SHOW_CONTACTS",
            "MAKE_CALL",
            "WEARABLE_CONTROLLER_SWITCH",
            "WEARABLE_CONTROLLER_EXECUTE",
            "WEARABLE_CONTROLLER_ACTION",
            "LLM_LOADING_CARD",
            "LLM_DECLARATION_CONTENT",
            "LLM_ILLEGAL_CONTENT",
            "LLM_TOAST_STREAM",
            "LLM_FINISH_STREAM",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResultType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "START_LISTENING" => Ok(ResultType::StartListening),
                    "END_LISTENING" => Ok(ResultType::EndListening),
                    "RECOGNIZE_RESULT" => Ok(ResultType::RecognizeResult),
                    "STOP_CAPTURE" => Ok(ResultType::StopCapture),
                    "DIALOG_FINISH" => Ok(ResultType::DialogFinish),
                    "SYSTEM_TRUNCATIONNOTIFICATION" => Ok(ResultType::SystemTruncationnotification),
                    "ERROR_NETWORK" => Ok(ResultType::ErrorNetwork),
                    "ERROR_AUTH" => Ok(ResultType::ErrorAuth),
                    "ERROR_TOO_MANY_DEVICES" => Ok(ResultType::ErrorTooManyDevices),
                    "ERROR_CONTENT_TOO_LONG" => Ok(ResultType::ErrorContentTooLong),
                    "AIVS_ERROR_ASR_TIMEOUT" => Ok(ResultType::AivsErrorAsrTimeout),
                    "AIVS_ERROR_TTS_TIMEOUT" => Ok(ResultType::AivsErrorTtsTimeout),
                    "ERROR_CONNECT_TIMEOUT" => Ok(ResultType::ErrorConnectTimeout),
                    "ERROR_AUDIO_EMPTY" => Ok(ResultType::ErrorAudioEmpty),
                    "ERROR_SUBSCRIPTION_EXPIRED" => Ok(ResultType::ErrorSubscriptionExpired),
                    "ERROR_TODAY_FREE_COUNT_LIMIT" => Ok(ResultType::ErrorTodayFreeCountLimit),
                    "ERROR_ALL_FREE_COUNT_LIMIT" => Ok(ResultType::ErrorAllFreeCountLimit),
                    "ERROR_SENSATIVE_CONTENT" => Ok(ResultType::ErrorSensativeContent),
                    "ERROR_UNSUPPORT_LANGUAGE" => Ok(ResultType::ErrorUnsupportLanguage),
                    "ERROR_UNKNOWN" => Ok(ResultType::ErrorUnknown),
                    "TEMPLATE_TOAST" => Ok(ResultType::TemplateToast),
                    "TEMPLATE_GENERAL" => Ok(ResultType::TemplateGeneral),
                    "TEMPLATE_GENERAL2" => Ok(ResultType::TemplateGeneral2),
                    "TEMPLATE_WEATHER" => Ok(ResultType::TemplateWeather),
                    "TEMPLATE_PLAYINFO" => Ok(ResultType::TemplatePlayinfo),
                    "TEMPLATE_LISTS" => Ok(ResultType::TemplateLists),
                    "TEMPLATE_SWITCHPANEL" => Ok(ResultType::TemplateSwitchpanel),
                    "ALERTS_SETALERT" => Ok(ResultType::AlertsSetalert),
                    "SPEECHSYNTHESIZER_SPEAK" => Ok(ResultType::SpeechsynthesizerSpeak),
                    "SPEECHRECOGNIZER_EXPECTSPEECH" => Ok(ResultType::SpeechrecognizerExpectspeech),
                    "LAUNCHER_LAUNCHAPP" => Ok(ResultType::LauncherLaunchapp),
                    "TEMPLATE_SWITCHPANELLIST" => Ok(ResultType::TemplateSwitchpanellist),
                    "BRIGHTNESSCONTROLLER_ADJUSTBRIGHTNESS" => Ok(ResultType::BrightnesscontrollerAdjustbrightness),
                    "SYSTEM_SETPROPERTY" => Ok(ResultType::SystemSetproperty),
                    "APPLICATION_OPERATE" => Ok(ResultType::ApplicationOperate),
                    "ALERTS_DELIVERALERTINTENTION" => Ok(ResultType::AlertsDeliveralertintention),
                    "ALERTS_STOPALERT" => Ok(ResultType::AlertsStopalert),
                    "PLAYBACKCONTROLLER" => Ok(ResultType::Playbackcontroller),
                    "PLAYBACKCONTROLLER_STOP" => Ok(ResultType::PlaybackcontrollerStop),
                    "PLAYBACKCONTROLLER_PLAY" => Ok(ResultType::PlaybackcontrollerPlay),
                    "PLAYBACKCONTROLLER_PAUSE" => Ok(ResultType::PlaybackcontrollerPause),
                    "PLAYBACKCONTROLLER_NEXT" => Ok(ResultType::PlaybackcontrollerNext),
                    "PLAYBACKCONTROLLER_PREV" => Ok(ResultType::PlaybackcontrollerPrev),
                    "PLAYBACKCONTROLLER_CONTINUEPLAYING" => Ok(ResultType::PlaybackcontrollerContinueplaying),
                    "SPEAKER_SETMUTE" => Ok(ResultType::SpeakerSetmute),
                    "SPEAKER_SETVOLUME" => Ok(ResultType::SpeakerSetvolume),
                    "SPEAKER_AJUSTVOLUME" => Ok(ResultType::SpeakerAjustvolume),
                    "TEMPLATE_DEVICELIST" => Ok(ResultType::TemplateDevicelist),
                    "EXECUTE_DEVICESKILL" => Ok(ResultType::ExecuteDeviceskill),
                    "SHOW_CONTACTS" => Ok(ResultType::ShowContacts),
                    "MAKE_CALL" => Ok(ResultType::MakeCall),
                    "WEARABLE_CONTROLLER_SWITCH" => Ok(ResultType::WearableControllerSwitch),
                    "WEARABLE_CONTROLLER_EXECUTE" => Ok(ResultType::WearableControllerExecute),
                    "WEARABLE_CONTROLLER_ACTION" => Ok(ResultType::WearableControllerAction),
                    "LLM_LOADING_CARD" => Ok(ResultType::LlmLoadingCard),
                    "LLM_DECLARATION_CONTENT" => Ok(ResultType::LlmDeclarationContent),
                    "LLM_ILLEGAL_CONTENT" => Ok(ResultType::LlmIllegalContent),
                    "LLM_TOAST_STREAM" => Ok(ResultType::LlmToastStream),
                    "LLM_FINISH_STREAM" => Ok(ResultType::LlmFinishStream),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for RichText {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.RichText", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.serialize_field("color", &self.color)?;
        struct_ser.serialize_field("bgColor", &self.bg_color)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RichText {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
            "color",
            "bg_color",
            "bgColor",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
            Color,
            BgColor,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            "color" => Ok(GeneratedField::Color),
                            "bgColor" | "bg_color" => Ok(GeneratedField::BgColor),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RichText;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RichText")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RichText, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                let mut color__ = None;
                let mut bg_color__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Color => {
                            if color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("color"));
                            }
                            color__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BgColor => {
                            if bg_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bgColor"));
                            }
                            bg_color__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(RichText {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                    color: color__.ok_or_else(|| serde::de::Error::missing_field("color"))?,
                    bg_color: bg_color__.ok_or_else(|| serde::de::Error::missing_field("bgColor"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.RichText", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for rich_text::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.RichText.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for rich_text::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = rich_text::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.RichText.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<rich_text::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(rich_text::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.RichText.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Sector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.key_a.is_some() {
            len += 1;
        }
        if self.key_b.is_some() {
            len += 1;
        }
        if self.content.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Sector", len)?;
        struct_ser.serialize_field("index", &self.index)?;
        struct_ser.serialize_field("enctypted", &self.enctypted)?;
        if let Some(v) = self.key_a.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("keyA", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.key_b.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("keyB", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.content.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("content", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Sector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "index",
            "enctypted",
            "key_a",
            "keyA",
            "key_b",
            "keyB",
            "content",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Index,
            Enctypted,
            KeyA,
            KeyB,
            Content,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "index" => Ok(GeneratedField::Index),
                            "enctypted" => Ok(GeneratedField::Enctypted),
                            "keyA" | "key_a" => Ok(GeneratedField::KeyA),
                            "keyB" | "key_b" => Ok(GeneratedField::KeyB),
                            "content" => Ok(GeneratedField::Content),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Sector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Sector")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Sector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index__ = None;
                let mut enctypted__ = None;
                let mut key_a__ = None;
                let mut key_b__ = None;
                let mut content__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("index"));
                            }
                            index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Enctypted => {
                            if enctypted__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enctypted"));
                            }
                            enctypted__ = Some(map_.next_value()?);
                        }
                        GeneratedField::KeyA => {
                            if key_a__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyA"));
                            }
                            key_a__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::KeyB => {
                            if key_b__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyB"));
                            }
                            key_b__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("content"));
                            }
                            content__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Sector {
                    index: index__.ok_or_else(|| serde::de::Error::missing_field("index"))?,
                    enctypted: enctypted__.ok_or_else(|| serde::de::Error::missing_field("enctypted"))?,
                    key_a: key_a__,
                    key_b: key_b__,
                    content: content__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Sector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SectorKey {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.keys.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SectorKey", len)?;
        struct_ser.serialize_field("index", &self.index)?;
        if !self.keys.is_empty() {
            struct_ser.serialize_field("keys", &self.keys.iter().map(pbjson::private::base64::encode).collect::<Vec<_>>())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SectorKey {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "index",
            "keys",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Index,
            Keys,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "index" => Ok(GeneratedField::Index),
                            "keys" => Ok(GeneratedField::Keys),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SectorKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SectorKey")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SectorKey, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index__ = None;
                let mut keys__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("index"));
                            }
                            index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Keys => {
                            if keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keys"));
                            }
                            keys__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::BytesDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(SectorKey {
                    index: index__.ok_or_else(|| serde::de::Error::missing_field("index"))?,
                    keys: keys__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SectorKey", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sector_key::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SectorKey.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sector_key::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sector_key::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SectorKey.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sector_key::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(sector_key::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SectorKey.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SedentaryReminder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.launch_break_start_time.is_some() {
            len += 1;
        }
        if self.launch_break_end_time.is_some() {
            len += 1;
        }
        if self.stretch_guide.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SedentaryReminder", len)?;
        struct_ser.serialize_field("on", &self.on)?;
        struct_ser.serialize_field("startTime", &self.start_time)?;
        struct_ser.serialize_field("endTime", &self.end_time)?;
        struct_ser.serialize_field("noDisturbInLaunchBreak", &self.no_disturb_in_launch_break)?;
        if let Some(v) = self.launch_break_start_time.as_ref() {
            struct_ser.serialize_field("launchBreakStartTime", v)?;
        }
        if let Some(v) = self.launch_break_end_time.as_ref() {
            struct_ser.serialize_field("launchBreakEndTime", v)?;
        }
        if let Some(v) = self.stretch_guide.as_ref() {
            let v = OptionalSwitcher::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("stretchGuide", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SedentaryReminder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "on",
            "start_time",
            "startTime",
            "end_time",
            "endTime",
            "no_disturb_in_launch_break",
            "noDisturbInLaunchBreak",
            "launch_break_start_time",
            "launchBreakStartTime",
            "launch_break_end_time",
            "launchBreakEndTime",
            "stretch_guide",
            "stretchGuide",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            On,
            StartTime,
            EndTime,
            NoDisturbInLaunchBreak,
            LaunchBreakStartTime,
            LaunchBreakEndTime,
            StretchGuide,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "on" => Ok(GeneratedField::On),
                            "startTime" | "start_time" => Ok(GeneratedField::StartTime),
                            "endTime" | "end_time" => Ok(GeneratedField::EndTime),
                            "noDisturbInLaunchBreak" | "no_disturb_in_launch_break" => Ok(GeneratedField::NoDisturbInLaunchBreak),
                            "launchBreakStartTime" | "launch_break_start_time" => Ok(GeneratedField::LaunchBreakStartTime),
                            "launchBreakEndTime" | "launch_break_end_time" => Ok(GeneratedField::LaunchBreakEndTime),
                            "stretchGuide" | "stretch_guide" => Ok(GeneratedField::StretchGuide),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SedentaryReminder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SedentaryReminder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SedentaryReminder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut on__ = None;
                let mut start_time__ = None;
                let mut end_time__ = None;
                let mut no_disturb_in_launch_break__ = None;
                let mut launch_break_start_time__ = None;
                let mut launch_break_end_time__ = None;
                let mut stretch_guide__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::On => {
                            if on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("on"));
                            }
                            on__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = map_.next_value()?;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endTime"));
                            }
                            end_time__ = map_.next_value()?;
                        }
                        GeneratedField::NoDisturbInLaunchBreak => {
                            if no_disturb_in_launch_break__.is_some() {
                                return Err(serde::de::Error::duplicate_field("noDisturbInLaunchBreak"));
                            }
                            no_disturb_in_launch_break__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LaunchBreakStartTime => {
                            if launch_break_start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("launchBreakStartTime"));
                            }
                            launch_break_start_time__ = map_.next_value()?;
                        }
                        GeneratedField::LaunchBreakEndTime => {
                            if launch_break_end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("launchBreakEndTime"));
                            }
                            launch_break_end_time__ = map_.next_value()?;
                        }
                        GeneratedField::StretchGuide => {
                            if stretch_guide__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stretchGuide"));
                            }
                            stretch_guide__ = map_.next_value::<::std::option::Option<OptionalSwitcher>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(SedentaryReminder {
                    on: on__.ok_or_else(|| serde::de::Error::missing_field("on"))?,
                    start_time: start_time__.ok_or_else(|| serde::de::Error::missing_field("startTime"))?,
                    end_time: end_time__.ok_or_else(|| serde::de::Error::missing_field("endTime"))?,
                    no_disturb_in_launch_break: no_disturb_in_launch_break__.ok_or_else(|| serde::de::Error::missing_field("noDisturbInLaunchBreak"))?,
                    launch_break_start_time: launch_break_start_time__,
                    launch_break_end_time: launch_break_end_time__,
                    stretch_guide: stretch_guide__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SedentaryReminder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SelfChecking {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.SelfChecking", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SelfChecking {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SelfChecking;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SelfChecking, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(SelfChecking {
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Cmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Enter => "ENTER",
            Self::Start => "START",
            Self::Exit => "EXIT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Cmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ENTER",
            "START",
            "EXIT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Cmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ENTER" => Ok(self_checking::Cmd::Enter),
                    "START" => Ok(self_checking::Cmd::Start),
                    "EXIT" => Ok(self_checking::Cmd::Exit),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Func {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Bluetooth => "BLUETOOTH",
            Self::Gnss => "GNSS",
            Self::Nfc => "NFC",
            Self::Wifi => "WIFI",
            Self::Esim => "ESIM",
            Self::Acc => "ACC",
            Self::Gyro => "GYRO",
            Self::Mag => "MAG",
            Self::Baro => "BARO",
            Self::Light => "LIGHT",
            Self::Ppg => "PPG",
            Self::Cap => "CAP",
            Self::Temp => "TEMP",
            Self::Charge => "CHARGE",
            Self::Battery => "BATTERY",
            Self::Dp => "DP",
            Self::Tp => "TP",
            Self::Key => "KEY",
            Self::Rotary => "ROTARY",
            Self::Motor => "MOTOR",
            Self::Storage => "STORAGE",
            Self::Audio => "AUDIO",
            Self::Dou => "DOU",
            Self::Mic => "MIC",
            Self::Pa => "PA",
            Self::Camera => "CAMERA",
            Self::Imu => "IMU",
            Self::IndicatorLight => "INDICATOR_LIGHT",
            Self::PrivacyLight => "PRIVACY_LIGHT",
            Self::Range => "RANGE",
            Self::HeartRate => "HEART_RATE",
            Self::BloodOxygen => "BLOOD_OXYGEN",
            Self::Ecg => "ECG",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Func {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BLUETOOTH",
            "GNSS",
            "NFC",
            "WIFI",
            "ESIM",
            "ACC",
            "GYRO",
            "MAG",
            "BARO",
            "LIGHT",
            "PPG",
            "CAP",
            "TEMP",
            "CHARGE",
            "BATTERY",
            "DP",
            "TP",
            "KEY",
            "ROTARY",
            "MOTOR",
            "STORAGE",
            "AUDIO",
            "DOU",
            "MIC",
            "PA",
            "CAMERA",
            "IMU",
            "INDICATOR_LIGHT",
            "PRIVACY_LIGHT",
            "RANGE",
            "HEART_RATE",
            "BLOOD_OXYGEN",
            "ECG",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Func;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BLUETOOTH" => Ok(self_checking::Func::Bluetooth),
                    "GNSS" => Ok(self_checking::Func::Gnss),
                    "NFC" => Ok(self_checking::Func::Nfc),
                    "WIFI" => Ok(self_checking::Func::Wifi),
                    "ESIM" => Ok(self_checking::Func::Esim),
                    "ACC" => Ok(self_checking::Func::Acc),
                    "GYRO" => Ok(self_checking::Func::Gyro),
                    "MAG" => Ok(self_checking::Func::Mag),
                    "BARO" => Ok(self_checking::Func::Baro),
                    "LIGHT" => Ok(self_checking::Func::Light),
                    "PPG" => Ok(self_checking::Func::Ppg),
                    "CAP" => Ok(self_checking::Func::Cap),
                    "TEMP" => Ok(self_checking::Func::Temp),
                    "CHARGE" => Ok(self_checking::Func::Charge),
                    "BATTERY" => Ok(self_checking::Func::Battery),
                    "DP" => Ok(self_checking::Func::Dp),
                    "TP" => Ok(self_checking::Func::Tp),
                    "KEY" => Ok(self_checking::Func::Key),
                    "ROTARY" => Ok(self_checking::Func::Rotary),
                    "MOTOR" => Ok(self_checking::Func::Motor),
                    "STORAGE" => Ok(self_checking::Func::Storage),
                    "AUDIO" => Ok(self_checking::Func::Audio),
                    "DOU" => Ok(self_checking::Func::Dou),
                    "MIC" => Ok(self_checking::Func::Mic),
                    "PA" => Ok(self_checking::Func::Pa),
                    "CAMERA" => Ok(self_checking::Func::Camera),
                    "IMU" => Ok(self_checking::Func::Imu),
                    "INDICATOR_LIGHT" => Ok(self_checking::Func::IndicatorLight),
                    "PRIVACY_LIGHT" => Ok(self_checking::Func::PrivacyLight),
                    "RANGE" => Ok(self_checking::Func::Range),
                    "HEART_RATE" => Ok(self_checking::Func::HeartRate),
                    "BLOOD_OXYGEN" => Ok(self_checking::Func::BloodOxygen),
                    "ECG" => Ok(self_checking::Func::Ecg),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SelfChecking.Item", len)?;
        let v = self_checking::Func::try_from(self.func)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.func)))?;
        struct_ser.serialize_field("func", &v)?;
        struct_ser.serialize_field("pass", &self.pass)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "func",
            "pass",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Func,
            Pass,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "func" => Ok(GeneratedField::Func),
                            "pass" => Ok(GeneratedField::Pass),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<self_checking::Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut func__ = None;
                let mut pass__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Func => {
                            if func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func"));
                            }
                            func__ = Some(map_.next_value::<self_checking::Func>()? as i32);
                        }
                        GeneratedField::Pass => {
                            if pass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pass"));
                            }
                            pass__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(self_checking::Item {
                    func: func__.ok_or_else(|| serde::de::Error::missing_field("func"))?,
                    pass: pass__.ok_or_else(|| serde::de::Error::missing_field("pass"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SelfChecking.Request", len)?;
        let v = self_checking::Cmd::try_from(self.cmd)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.cmd)))?;
        struct_ser.serialize_field("cmd", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cmd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cmd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cmd" => Ok(GeneratedField::Cmd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<self_checking::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cmd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = Some(map_.next_value::<self_checking::Cmd>()? as i32);
                        }
                    }
                }
                Ok(self_checking::Request {
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SelfChecking.Response", len)?;
        let v = self_checking::Cmd::try_from(self.cmd)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.cmd)))?;
        struct_ser.serialize_field("cmd", &v)?;
        let v = self_checking::Status::try_from(self.status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.status)))?;
        struct_ser.serialize_field("status", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cmd",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cmd,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cmd" => Ok(GeneratedField::Cmd),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<self_checking::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cmd__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = Some(map_.next_value::<self_checking::Cmd>()? as i32);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value::<self_checking::Status>()? as i32);
                        }
                    }
                }
                Ok(self_checking::Response {
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        if self.partial.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SelfChecking.Result", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        if let Some(v) = self.partial.as_ref() {
            struct_ser.serialize_field("partial", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "partial",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            Partial,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "partial" => Ok(GeneratedField::Partial),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<self_checking::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut partial__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Partial => {
                            if partial__.is_some() {
                                return Err(serde::de::Error::duplicate_field("partial"));
                            }
                            partial__ = map_.next_value()?;
                        }
                    }
                }
                Ok(self_checking::Result {
                    items: items__.unwrap_or_default(),
                    partial: partial__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::Status {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ok => "OK",
            Self::WillReboot => "WILL_REBOOT",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::Status {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OK",
            "WILL_REBOOT",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::Status;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OK" => Ok(self_checking::Status::Ok),
                    "WILL_REBOOT" => Ok(self_checking::Status::WillReboot),
                    "FAIL" => Ok(self_checking::Status::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::StepRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SelfChecking.StepRequest", len)?;
        let v = self_checking::Func::try_from(self.func)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.func)))?;
        struct_ser.serialize_field("func", &v)?;
        struct_ser.serialize_field("step", &self.step)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::StepRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "func",
            "step",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Func,
            Step,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "func" => Ok(GeneratedField::Func),
                            "step" => Ok(GeneratedField::Step),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::StepRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking.StepRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<self_checking::StepRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut func__ = None;
                let mut step__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Func => {
                            if func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func"));
                            }
                            func__ = Some(map_.next_value::<self_checking::Func>()? as i32);
                        }
                        GeneratedField::Step => {
                            if step__.is_some() {
                                return Err(serde::de::Error::duplicate_field("step"));
                            }
                            step__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(self_checking::StepRequest {
                    func: func__.ok_or_else(|| serde::de::Error::missing_field("func"))?,
                    step: step__.ok_or_else(|| serde::de::Error::missing_field("step"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking.StepRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for self_checking::StepResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.SelfChecking.StepResult", len)?;
        let v = self_checking::Func::try_from(self.func)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.func)))?;
        struct_ser.serialize_field("func", &v)?;
        struct_ser.serialize_field("step", &self.step)?;
        struct_ser.serialize_field("result", &self.result)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for self_checking::StepResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "func",
            "step",
            "result",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Func,
            Step,
            Result,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "func" => Ok(GeneratedField::Func),
                            "step" => Ok(GeneratedField::Step),
                            "result" => Ok(GeneratedField::Result),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = self_checking::StepResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SelfChecking.StepResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<self_checking::StepResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut func__ = None;
                let mut step__ = None;
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Func => {
                            if func__.is_some() {
                                return Err(serde::de::Error::duplicate_field("func"));
                            }
                            func__ = Some(map_.next_value::<self_checking::Func>()? as i32);
                        }
                        GeneratedField::Step => {
                            if step__.is_some() {
                                return Err(serde::de::Error::duplicate_field("step"));
                            }
                            step__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(self_checking::StepResult {
                    func: func__.ok_or_else(|| serde::de::Error::missing_field("func"))?,
                    step: step__.ok_or_else(|| serde::de::Error::missing_field("step"))?,
                    result: result__.ok_or_else(|| serde::de::Error::missing_field("result"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SelfChecking.StepResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SensorCaptureRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.timestamp.is_some() {
            len += 1;
        }
        if self.meta_info.is_some() {
            len += 1;
        }
        if self.sensor_list.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SensorCaptureRequest", len)?;
        let v = sensor_capture_request::State::try_from(self.state)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.state)))?;
        struct_ser.serialize_field("state", &v)?;
        let v = sensor_capture_request::Mode::try_from(self.mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.mode)))?;
        struct_ser.serialize_field("mode", &v)?;
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", v)?;
        }
        if let Some(v) = self.meta_info.as_ref() {
            struct_ser.serialize_field("metaInfo", v)?;
        }
        if let Some(v) = self.sensor_list.as_ref() {
            struct_ser.serialize_field("sensorList", v)?;
        }
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("settingInfo", pbjson::private::base64::encode(&self.setting_info).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SensorCaptureRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "state",
            "mode",
            "timestamp",
            "meta_info",
            "metaInfo",
            "sensor_list",
            "sensorList",
            "setting_info",
            "settingInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            Mode,
            Timestamp,
            MetaInfo,
            SensorList,
            SettingInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            "mode" => Ok(GeneratedField::Mode),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "metaInfo" | "meta_info" => Ok(GeneratedField::MetaInfo),
                            "sensorList" | "sensor_list" => Ok(GeneratedField::SensorList),
                            "settingInfo" | "setting_info" => Ok(GeneratedField::SettingInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SensorCaptureRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorCaptureRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SensorCaptureRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut mode__ = None;
                let mut timestamp__ = None;
                let mut meta_info__ = None;
                let mut sensor_list__ = None;
                let mut setting_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value::<sensor_capture_request::State>()? as i32);
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mode"));
                            }
                            mode__ = Some(map_.next_value::<sensor_capture_request::Mode>()? as i32);
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MetaInfo => {
                            if meta_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metaInfo"));
                            }
                            meta_info__ = map_.next_value()?;
                        }
                        GeneratedField::SensorList => {
                            if sensor_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensorList"));
                            }
                            sensor_list__ = map_.next_value()?;
                        }
                        GeneratedField::SettingInfo => {
                            if setting_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settingInfo"));
                            }
                            setting_info__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SensorCaptureRequest {
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    mode: mode__.ok_or_else(|| serde::de::Error::missing_field("mode"))?,
                    timestamp: timestamp__,
                    meta_info: meta_info__,
                    sensor_list: sensor_list__,
                    setting_info: setting_info__.ok_or_else(|| serde::de::Error::missing_field("settingInfo"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorCaptureRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sensor_capture_request::MetaInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 7;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorCaptureRequest.MetaInfo", len)?;
        struct_ser.serialize_field("userId", &self.user_id)?;
        let v = Sex::try_from(self.sex)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sex)))?;
        struct_ser.serialize_field("sex", &v)?;
        struct_ser.serialize_field("userAge", &self.user_age)?;
        struct_ser.serialize_field("height", &self.height)?;
        struct_ser.serialize_field("weight", &self.weight)?;
        struct_ser.serialize_field("mainScene", &self.main_scene)?;
        struct_ser.serialize_field("subScene", &self.sub_scene)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sensor_capture_request::MetaInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "user_id",
            "userId",
            "sex",
            "user_age",
            "userAge",
            "height",
            "weight",
            "main_scene",
            "mainScene",
            "sub_scene",
            "subScene",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UserId,
            Sex,
            UserAge,
            Height,
            Weight,
            MainScene,
            SubScene,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "userId" | "user_id" => Ok(GeneratedField::UserId),
                            "sex" => Ok(GeneratedField::Sex),
                            "userAge" | "user_age" => Ok(GeneratedField::UserAge),
                            "height" => Ok(GeneratedField::Height),
                            "weight" => Ok(GeneratedField::Weight),
                            "mainScene" | "main_scene" => Ok(GeneratedField::MainScene),
                            "subScene" | "sub_scene" => Ok(GeneratedField::SubScene),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sensor_capture_request::MetaInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorCaptureRequest.MetaInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sensor_capture_request::MetaInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut user_id__ = None;
                let mut sex__ = None;
                let mut user_age__ = None;
                let mut height__ = None;
                let mut weight__ = None;
                let mut main_scene__ = None;
                let mut sub_scene__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UserId => {
                            if user_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userId"));
                            }
                            user_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Sex => {
                            if sex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sex"));
                            }
                            sex__ = Some(map_.next_value::<Sex>()? as i32);
                        }
                        GeneratedField::UserAge => {
                            if user_age__.is_some() {
                                return Err(serde::de::Error::duplicate_field("userAge"));
                            }
                            user_age__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Height => {
                            if height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("height"));
                            }
                            height__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Weight => {
                            if weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weight"));
                            }
                            weight__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MainScene => {
                            if main_scene__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainScene"));
                            }
                            main_scene__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubScene => {
                            if sub_scene__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subScene"));
                            }
                            sub_scene__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(sensor_capture_request::MetaInfo {
                    user_id: user_id__.ok_or_else(|| serde::de::Error::missing_field("userId"))?,
                    sex: sex__.ok_or_else(|| serde::de::Error::missing_field("sex"))?,
                    user_age: user_age__.ok_or_else(|| serde::de::Error::missing_field("userAge"))?,
                    height: height__.ok_or_else(|| serde::de::Error::missing_field("height"))?,
                    weight: weight__.ok_or_else(|| serde::de::Error::missing_field("weight"))?,
                    main_scene: main_scene__.ok_or_else(|| serde::de::Error::missing_field("mainScene"))?,
                    sub_scene: sub_scene__.ok_or_else(|| serde::de::Error::missing_field("subScene"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorCaptureRequest.MetaInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sensor_capture_request::Mode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::OnlineCapture => "ONLINE_CAPTURE",
            Self::OfflineCapture => "OFFLINE_CAPTURE",
            Self::RealtimeCapture => "REALTIME_CAPTURE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for sensor_capture_request::Mode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ONLINE_CAPTURE",
            "OFFLINE_CAPTURE",
            "REALTIME_CAPTURE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sensor_capture_request::Mode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ONLINE_CAPTURE" => Ok(sensor_capture_request::Mode::OnlineCapture),
                    "OFFLINE_CAPTURE" => Ok(sensor_capture_request::Mode::OfflineCapture),
                    "REALTIME_CAPTURE" => Ok(sensor_capture_request::Mode::RealtimeCapture),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for sensor_capture_request::Sensor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorCaptureRequest.Sensor", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("frequence", &self.frequence)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sensor_capture_request::Sensor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "frequence",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Frequence,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "frequence" => Ok(GeneratedField::Frequence),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sensor_capture_request::Sensor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorCaptureRequest.Sensor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sensor_capture_request::Sensor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut frequence__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Frequence => {
                            if frequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frequence"));
                            }
                            frequence__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(sensor_capture_request::Sensor {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    frequence: frequence__.ok_or_else(|| serde::de::Error::missing_field("frequence"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorCaptureRequest.Sensor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sensor_capture_request::sensor::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SensorCaptureRequest.Sensor.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sensor_capture_request::sensor::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sensor_capture_request::sensor::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorCaptureRequest.Sensor.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sensor_capture_request::sensor::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(sensor_capture_request::sensor::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorCaptureRequest.Sensor.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sensor_capture_request::State {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::StartCapture => "START_CAPTURE",
            Self::StopCapture => "STOP_CAPTURE",
            Self::SyncCapture => "SYNC_CAPTURE",
            Self::SetCapture => "SET_CAPTURE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for sensor_capture_request::State {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "START_CAPTURE",
            "STOP_CAPTURE",
            "SYNC_CAPTURE",
            "SET_CAPTURE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sensor_capture_request::State;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "START_CAPTURE" => Ok(sensor_capture_request::State::StartCapture),
                    "STOP_CAPTURE" => Ok(sensor_capture_request::State::StopCapture),
                    "SYNC_CAPTURE" => Ok(sensor_capture_request::State::SyncCapture),
                    "SET_CAPTURE" => Ok(sensor_capture_request::State::SetCapture),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SensorCaptureResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorCaptureResponse", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("settingInfo", pbjson::private::base64::encode(&self.setting_info).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SensorCaptureResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "setting_info",
            "settingInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            SettingInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "settingInfo" | "setting_info" => Ok(GeneratedField::SettingInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SensorCaptureResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorCaptureResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SensorCaptureResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut setting_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SettingInfo => {
                            if setting_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("settingInfo"));
                            }
                            setting_info__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SensorCaptureResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    setting_info: setting_info__.ok_or_else(|| serde::de::Error::missing_field("settingInfo"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorCaptureResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SensorConfirmRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorConfirmRequest", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("dataId", pbjson::private::base64::encode(&self.data_id).as_str())?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SensorConfirmRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "data_id",
            "dataId",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DataId,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dataId" | "data_id" => Ok(GeneratedField::DataId),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SensorConfirmRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorConfirmRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SensorConfirmRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut data_id__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DataId => {
                            if data_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataId"));
                            }
                            data_id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SensorConfirmRequest {
                    data_id: data_id__.ok_or_else(|| serde::de::Error::missing_field("dataId"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorConfirmRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SensorConfirmResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorConfirmResponse", len)?;
        struct_ser.serialize_field("result", &self.result)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SensorConfirmResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "result",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Result,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "result" => Ok(GeneratedField::Result),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SensorConfirmResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorConfirmResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SensorConfirmResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SensorConfirmResponse {
                    result: result__.ok_or_else(|| serde::de::Error::missing_field("result"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorConfirmResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SensorReplayRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorReplayRequest", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        struct_ser.serialize_field("instance", &self.instance)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("md5", pbjson::private::base64::encode(&self.md5).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SensorReplayRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "instance",
            "md5",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Instance,
            Md5,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "instance" => Ok(GeneratedField::Instance),
                            "md5" => Ok(GeneratedField::Md5),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SensorReplayRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorReplayRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SensorReplayRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut instance__ = None;
                let mut md5__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Instance => {
                            if instance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("instance"));
                            }
                            instance__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Md5 => {
                            if md5__.is_some() {
                                return Err(serde::de::Error::duplicate_field("md5"));
                            }
                            md5__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SensorReplayRequest {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    instance: instance__.ok_or_else(|| serde::de::Error::missing_field("instance"))?,
                    md5: md5__.ok_or_else(|| serde::de::Error::missing_field("md5"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorReplayRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SensorReplayResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SensorReplayResponse", len)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SensorReplayResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SensorReplayResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SensorReplayResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SensorReplayResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SensorReplayResponse {
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SensorReplayResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Sex {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Neutral => "NEUTRAL",
            Self::Male => "MALE",
            Self::Female => "FEMALE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for Sex {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NEUTRAL",
            "MALE",
            "FEMALE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Sex;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NEUTRAL" => Ok(Sex::Neutral),
                    "MALE" => Ok(Sex::Male),
                    "FEMALE" => Ok(Sex::Female),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ShareDevice {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ShareDevice", len)?;
        let v = DeviceType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        if let Some(v) = self.info.as_ref() {
            match v {
                share_device::Info::AudioInfo(v) => {
                    struct_ser.serialize_field("audioInfo", v)?;
                }
                share_device::Info::TvInfo(v) => {
                    struct_ser.serialize_field("tvInfo", v)?;
                }
                share_device::Info::HeadsetInfo(v) => {
                    struct_ser.serialize_field("headsetInfo", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShareDevice {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "id",
            "name",
            "audio_info",
            "audioInfo",
            "tv_info",
            "tvInfo",
            "headset_info",
            "headsetInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
            Name,
            AudioInfo,
            TvInfo,
            HeadsetInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "audioInfo" | "audio_info" => Ok(GeneratedField::AudioInfo),
                            "tvInfo" | "tv_info" => Ok(GeneratedField::TvInfo),
                            "headsetInfo" | "headset_info" => Ok(GeneratedField::HeadsetInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShareDevice;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ShareDevice")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShareDevice, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                let mut name__ = None;
                let mut info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<DeviceType>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AudioInfo => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("audioInfo"));
                            }
                            info__ = map_.next_value::<::std::option::Option<_>>()?.map(share_device::Info::AudioInfo)
;
                        }
                        GeneratedField::TvInfo => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("tvInfo"));
                            }
                            info__ = map_.next_value::<::std::option::Option<_>>()?.map(share_device::Info::TvInfo)
;
                        }
                        GeneratedField::HeadsetInfo => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("headsetInfo"));
                            }
                            info__ = map_.next_value::<::std::option::Option<_>>()?.map(share_device::Info::HeadsetInfo)
;
                        }
                    }
                }
                Ok(ShareDevice {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    info: info__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ShareDevice", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for share_device::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ShareDevice.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for share_device::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = share_device::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ShareDevice.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<share_device::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(share_device::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ShareDevice.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Shortcut {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.sub_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Shortcut", len)?;
        let v = shortcut::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        if let Some(v) = self.sub_type.as_ref() {
            struct_ser.serialize_field("subType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Shortcut {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "sub_type",
            "subType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            SubType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "subType" | "sub_type" => Ok(GeneratedField::SubType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Shortcut;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Shortcut")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Shortcut, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut sub_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<shortcut::Type>()? as i32);
                        }
                        GeneratedField::SubType => {
                            if sub_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subType"));
                            }
                            sub_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Shortcut {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    sub_type: sub_type__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Shortcut", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for shortcut::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Shortcut.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for shortcut::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = shortcut::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Shortcut.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<shortcut::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(shortcut::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Shortcut.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for shortcut::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "NONE",
            Self::Voice => "VOICE",
            Self::Function => "FUNCTION",
            Self::Sport => "SPORT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for shortcut::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NONE",
            "VOICE",
            "FUNCTION",
            "SPORT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = shortcut::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NONE" => Ok(shortcut::Type::None),
                    "VOICE" => Ok(shortcut::Type::Voice),
                    "FUNCTION" => Ok(shortcut::Type::Function),
                    "SPORT" => Ok(shortcut::Type::Sport),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ShowContacts {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ShowContacts", len)?;
        let v = show_contacts::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShowContacts {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShowContacts;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ShowContacts")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShowContacts, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<show_contacts::Code>()? as i32);
                        }
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ShowContacts {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.ShowContacts", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for show_contacts::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ok => "OK",
            Self::NoPermission => "NO_PERMISSION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for show_contacts::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OK",
            "NO_PERMISSION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = show_contacts::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OK" => Ok(show_contacts::Code::Ok),
                    "NO_PERMISSION" => Ok(show_contacts::Code::NoPermission),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for show_contacts::ContactData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.ShowContacts.ContactData", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("number", &self.number)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for show_contacts::ContactData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "number",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Number,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "number" => Ok(GeneratedField::Number),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = show_contacts::ContactData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ShowContacts.ContactData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<show_contacts::ContactData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut number__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Number => {
                            if number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("number"));
                            }
                            number__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(show_contacts::ContactData {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    number: number__.ok_or_else(|| serde::de::Error::missing_field("number"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ShowContacts.ContactData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SleepDisorder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.times.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SleepDisorder", len)?;
        struct_ser.serialize_field("reminder", &self.reminder)?;
        if !self.times.is_empty() {
            struct_ser.serialize_field("times", &self.times)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SleepDisorder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reminder",
            "times",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Reminder,
            Times,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reminder" => Ok(GeneratedField::Reminder),
                            "times" => Ok(GeneratedField::Times),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SleepDisorder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SleepDisorder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SleepDisorder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reminder__ = None;
                let mut times__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Reminder => {
                            if reminder__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminder"));
                            }
                            reminder__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Times => {
                            if times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("times"));
                            }
                            times__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SleepDisorder {
                    reminder: reminder__.ok_or_else(|| serde::de::Error::missing_field("reminder"))?,
                    times: times__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SleepDisorder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SleepRegularity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SleepRegularity", len)?;
        struct_ser.serialize_field("on", &self.on)?;
        struct_ser.serialize_field("measurePeriod", &self.measure_period)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SleepRegularity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "on",
            "measure_period",
            "measurePeriod",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            On,
            MeasurePeriod,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "on" => Ok(GeneratedField::On),
                            "measurePeriod" | "measure_period" => Ok(GeneratedField::MeasurePeriod),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SleepRegularity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SleepRegularity")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SleepRegularity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut on__ = None;
                let mut measure_period__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::On => {
                            if on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("on"));
                            }
                            on__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MeasurePeriod => {
                            if measure_period__.is_some() {
                                return Err(serde::de::Error::duplicate_field("measurePeriod"));
                            }
                            measure_period__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SleepRegularity {
                    on: on__.ok_or_else(|| serde::de::Error::missing_field("on"))?,
                    measure_period: measure_period__.ok_or_else(|| serde::de::Error::missing_field("measurePeriod"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SleepRegularity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SleepResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.section_list.is_empty() {
            len += 1;
        }
        if self.animal.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SleepResult", len)?;
        if !self.section_list.is_empty() {
            struct_ser.serialize_field("sectionList", &self.section_list)?;
        }
        if let Some(v) = self.animal.as_ref() {
            struct_ser.serialize_field("animal", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SleepResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "section_list",
            "sectionList",
            "animal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SectionList,
            Animal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sectionList" | "section_list" => Ok(GeneratedField::SectionList),
                            "animal" => Ok(GeneratedField::Animal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SleepResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SleepResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SleepResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut section_list__ = None;
                let mut animal__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SectionList => {
                            if section_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sectionList"));
                            }
                            section_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Animal => {
                            if animal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("animal"));
                            }
                            animal__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SleepResult {
                    section_list: section_list__.unwrap_or_default(),
                    animal: animal__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SleepResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sleep_result::Animal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.current_progress.is_some() {
            len += 1;
        }
        if self.total_progress.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SleepResult.Animal", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        if let Some(v) = self.current_progress.as_ref() {
            struct_ser.serialize_field("currentProgress", v)?;
        }
        if let Some(v) = self.total_progress.as_ref() {
            struct_ser.serialize_field("totalProgress", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sleep_result::Animal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "current_progress",
            "currentProgress",
            "total_progress",
            "totalProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            CurrentProgress,
            TotalProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "currentProgress" | "current_progress" => Ok(GeneratedField::CurrentProgress),
                            "totalProgress" | "total_progress" => Ok(GeneratedField::TotalProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sleep_result::Animal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SleepResult.Animal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sleep_result::Animal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut current_progress__ = None;
                let mut total_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CurrentProgress => {
                            if current_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentProgress"));
                            }
                            current_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalProgress => {
                            if total_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalProgress"));
                            }
                            total_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(sleep_result::Animal {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    current_progress: current_progress__,
                    total_progress: total_progress__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SleepResult.Animal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sleep_result::ExtraData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 5;
        let mut struct_ser = serializer.serialize_struct("protocol.SleepResult.ExtraData", len)?;
        struct_ser.serialize_field("bedtime", &self.bedtime)?;
        struct_ser.serialize_field("sleepTime", &self.sleep_time)?;
        struct_ser.serialize_field("sleepQuality", &self.sleep_quality)?;
        struct_ser.serialize_field("sleepEfficiency", &self.sleep_efficiency)?;
        struct_ser.serialize_field("breathing", &self.breathing)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sleep_result::ExtraData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bedtime",
            "sleep_time",
            "sleepTime",
            "sleep_quality",
            "sleepQuality",
            "sleep_efficiency",
            "sleepEfficiency",
            "breathing",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bedtime,
            SleepTime,
            SleepQuality,
            SleepEfficiency,
            Breathing,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bedtime" => Ok(GeneratedField::Bedtime),
                            "sleepTime" | "sleep_time" => Ok(GeneratedField::SleepTime),
                            "sleepQuality" | "sleep_quality" => Ok(GeneratedField::SleepQuality),
                            "sleepEfficiency" | "sleep_efficiency" => Ok(GeneratedField::SleepEfficiency),
                            "breathing" => Ok(GeneratedField::Breathing),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sleep_result::ExtraData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SleepResult.ExtraData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sleep_result::ExtraData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bedtime__ = None;
                let mut sleep_time__ = None;
                let mut sleep_quality__ = None;
                let mut sleep_efficiency__ = None;
                let mut breathing__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bedtime => {
                            if bedtime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bedtime"));
                            }
                            bedtime__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SleepTime => {
                            if sleep_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepTime"));
                            }
                            sleep_time__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SleepQuality => {
                            if sleep_quality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepQuality"));
                            }
                            sleep_quality__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SleepEfficiency => {
                            if sleep_efficiency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepEfficiency"));
                            }
                            sleep_efficiency__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Breathing => {
                            if breathing__.is_some() {
                                return Err(serde::de::Error::duplicate_field("breathing"));
                            }
                            breathing__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(sleep_result::ExtraData {
                    bedtime: bedtime__.ok_or_else(|| serde::de::Error::missing_field("bedtime"))?,
                    sleep_time: sleep_time__.ok_or_else(|| serde::de::Error::missing_field("sleepTime"))?,
                    sleep_quality: sleep_quality__.ok_or_else(|| serde::de::Error::missing_field("sleepQuality"))?,
                    sleep_efficiency: sleep_efficiency__.ok_or_else(|| serde::de::Error::missing_field("sleepEfficiency"))?,
                    breathing: breathing__.ok_or_else(|| serde::de::Error::missing_field("breathing"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SleepResult.ExtraData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sleep_result::Section {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 6;
        if self.extra_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SleepResult.Section", len)?;
        struct_ser.serialize_field("timezone", &self.timezone)?;
        struct_ser.serialize_field("validSleepTime", &self.valid_sleep_time)?;
        struct_ser.serialize_field("sleepTimestamp", &self.sleep_timestamp)?;
        struct_ser.serialize_field("wakeupTimestamp", &self.wakeup_timestamp)?;
        struct_ser.serialize_field("averageHeartRate", &self.average_heart_rate)?;
        struct_ser.serialize_field("averageBloodOxygen", &self.average_blood_oxygen)?;
        if let Some(v) = self.extra_data.as_ref() {
            struct_ser.serialize_field("extraData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sleep_result::Section {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timezone",
            "valid_sleep_time",
            "validSleepTime",
            "sleep_timestamp",
            "sleepTimestamp",
            "wakeup_timestamp",
            "wakeupTimestamp",
            "average_heart_rate",
            "averageHeartRate",
            "average_blood_oxygen",
            "averageBloodOxygen",
            "extra_data",
            "extraData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timezone,
            ValidSleepTime,
            SleepTimestamp,
            WakeupTimestamp,
            AverageHeartRate,
            AverageBloodOxygen,
            ExtraData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timezone" => Ok(GeneratedField::Timezone),
                            "validSleepTime" | "valid_sleep_time" => Ok(GeneratedField::ValidSleepTime),
                            "sleepTimestamp" | "sleep_timestamp" => Ok(GeneratedField::SleepTimestamp),
                            "wakeupTimestamp" | "wakeup_timestamp" => Ok(GeneratedField::WakeupTimestamp),
                            "averageHeartRate" | "average_heart_rate" => Ok(GeneratedField::AverageHeartRate),
                            "averageBloodOxygen" | "average_blood_oxygen" => Ok(GeneratedField::AverageBloodOxygen),
                            "extraData" | "extra_data" => Ok(GeneratedField::ExtraData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sleep_result::Section;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SleepResult.Section")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sleep_result::Section, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timezone__ = None;
                let mut valid_sleep_time__ = None;
                let mut sleep_timestamp__ = None;
                let mut wakeup_timestamp__ = None;
                let mut average_heart_rate__ = None;
                let mut average_blood_oxygen__ = None;
                let mut extra_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timezone => {
                            if timezone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timezone"));
                            }
                            timezone__ = map_.next_value()?;
                        }
                        GeneratedField::ValidSleepTime => {
                            if valid_sleep_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validSleepTime"));
                            }
                            valid_sleep_time__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SleepTimestamp => {
                            if sleep_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sleepTimestamp"));
                            }
                            sleep_timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::WakeupTimestamp => {
                            if wakeup_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wakeupTimestamp"));
                            }
                            wakeup_timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AverageHeartRate => {
                            if average_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("averageHeartRate"));
                            }
                            average_heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AverageBloodOxygen => {
                            if average_blood_oxygen__.is_some() {
                                return Err(serde::de::Error::duplicate_field("averageBloodOxygen"));
                            }
                            average_blood_oxygen__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::ExtraData => {
                            if extra_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraData"));
                            }
                            extra_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(sleep_result::Section {
                    timezone: timezone__.ok_or_else(|| serde::de::Error::missing_field("timezone"))?,
                    valid_sleep_time: valid_sleep_time__.ok_or_else(|| serde::de::Error::missing_field("validSleepTime"))?,
                    sleep_timestamp: sleep_timestamp__.ok_or_else(|| serde::de::Error::missing_field("sleepTimestamp"))?,
                    wakeup_timestamp: wakeup_timestamp__.ok_or_else(|| serde::de::Error::missing_field("wakeupTimestamp"))?,
                    average_heart_rate: average_heart_rate__.ok_or_else(|| serde::de::Error::missing_field("averageHeartRate"))?,
                    average_blood_oxygen: average_blood_oxygen__.ok_or_else(|| serde::de::Error::missing_field("averageBloodOxygen"))?,
                    extra_data: extra_data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SleepResult.Section", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SmallHabit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if !self.time.is_empty() {
            len += 1;
        }
        if self.week_days.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SmallHabit", len)?;
        let v = small_habit::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        if !self.time.is_empty() {
            struct_ser.serialize_field("time", &self.time)?;
        }
        let v = ClockMode::try_from(self.clock_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.clock_mode)))?;
        struct_ser.serialize_field("clockMode", &v)?;
        if let Some(v) = self.week_days.as_ref() {
            struct_ser.serialize_field("weekDays", v)?;
        }
        struct_ser.serialize_field("enable", &self.enable)?;
        struct_ser.serialize_field("label", &self.label)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SmallHabit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "time",
            "clock_mode",
            "clockMode",
            "week_days",
            "weekDays",
            "enable",
            "label",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Time,
            ClockMode,
            WeekDays,
            Enable,
            Label,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "time" => Ok(GeneratedField::Time),
                            "clockMode" | "clock_mode" => Ok(GeneratedField::ClockMode),
                            "weekDays" | "week_days" => Ok(GeneratedField::WeekDays),
                            "enable" => Ok(GeneratedField::Enable),
                            "label" => Ok(GeneratedField::Label),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SmallHabit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SmallHabit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SmallHabit, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut time__ = None;
                let mut clock_mode__ = None;
                let mut week_days__ = None;
                let mut enable__ = None;
                let mut label__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<small_habit::Type>()? as i32);
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            time__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ClockMode => {
                            if clock_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clockMode"));
                            }
                            clock_mode__ = Some(map_.next_value::<ClockMode>()? as i32);
                        }
                        GeneratedField::WeekDays => {
                            if week_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekDays"));
                            }
                            week_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Label => {
                            if label__.is_some() {
                                return Err(serde::de::Error::duplicate_field("label"));
                            }
                            label__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SmallHabit {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    time: time__.unwrap_or_default(),
                    clock_mode: clock_mode__.ok_or_else(|| serde::de::Error::missing_field("clockMode"))?,
                    week_days: week_days__,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                    label: label__.ok_or_else(|| serde::de::Error::missing_field("label"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SmallHabit", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for small_habit::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SmallHabit.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for small_habit::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = small_habit::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SmallHabit.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<small_habit::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(small_habit::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SmallHabit.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for small_habit::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GoToBedEarly => "GO_TO_BED_EARLY",
            Self::DoMoreExercise => "DO_MORE_EXERCISE",
            Self::DrinkWater => "DRINK_WATER",
            Self::Reading => "READING",
            Self::EatBreakfast => "EAT_BREAKFAST",
            Self::CallParents => "CALL_PARENTS",
            Self::EatFruit => "EAT_FRUIT",
            Self::ActiveNeck => "ACTIVE_NECK",
            Self::LearnToCharge => "LEARN_TO_CHARGE",
            Self::PracticeASkill => "PRACTICE_A_SKILL",
            Self::ContactFriend => "CONTACT_FRIEND",
            Self::SittingUpright => "SITTING_UPRIGHT",
            Self::EatVegetable => "EAT_VEGETABLE",
            Self::CivilizedLanguage => "CIVILIZED_LANGUAGE",
            Self::Meditation => "MEDITATION",
            Self::BookKeeping => "BOOK_KEEPING",
            Self::ReciteWords => "RECITE_WORDS",
            Self::WalkAfterMeal => "WALK_AFTER_MEAL",
            Self::GoOutWithKey => "GO_OUT_WITH_KEY",
            Self::DailySummary => "DAILY_SUMMARY",
            Self::GargleAfterMeal => "GARGLE_AFTER_MEAL",
            Self::SmileMore => "SMILE_MORE",
            Self::TakeMedicine => "TAKE_MEDICINE",
            Self::NotHumpback => "NOT_HUMPBACK",
            Self::Calligraphy => "CALLIGRAPHY",
            Self::LunchBreak => "LUNCH_BREAK",
            Self::DoEyeExercises => "DO_EYE_EXERCISES",
            Self::DoYoga => "DO_YOGA",
            Self::ApplyFacialMask => "APPLY_FACIAL_MASK",
            Self::QuitSugar => "QUIT_SUGAR",
            Self::ShovelCatLitter => "SHOVEL_CAT_LITTER",
            Self::OnlineLesson => "ONLINE_LESSON",
            Self::WateringFlowers => "WATERING_FLOWERS",
            Self::TakeAPictureOneDay => "TAKE_A_PICTURE_ONE_DAY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for small_habit::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GO_TO_BED_EARLY",
            "DO_MORE_EXERCISE",
            "DRINK_WATER",
            "READING",
            "EAT_BREAKFAST",
            "CALL_PARENTS",
            "EAT_FRUIT",
            "ACTIVE_NECK",
            "LEARN_TO_CHARGE",
            "PRACTICE_A_SKILL",
            "CONTACT_FRIEND",
            "SITTING_UPRIGHT",
            "EAT_VEGETABLE",
            "CIVILIZED_LANGUAGE",
            "MEDITATION",
            "BOOK_KEEPING",
            "RECITE_WORDS",
            "WALK_AFTER_MEAL",
            "GO_OUT_WITH_KEY",
            "DAILY_SUMMARY",
            "GARGLE_AFTER_MEAL",
            "SMILE_MORE",
            "TAKE_MEDICINE",
            "NOT_HUMPBACK",
            "CALLIGRAPHY",
            "LUNCH_BREAK",
            "DO_EYE_EXERCISES",
            "DO_YOGA",
            "APPLY_FACIAL_MASK",
            "QUIT_SUGAR",
            "SHOVEL_CAT_LITTER",
            "ONLINE_LESSON",
            "WATERING_FLOWERS",
            "TAKE_A_PICTURE_ONE_DAY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = small_habit::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GO_TO_BED_EARLY" => Ok(small_habit::Type::GoToBedEarly),
                    "DO_MORE_EXERCISE" => Ok(small_habit::Type::DoMoreExercise),
                    "DRINK_WATER" => Ok(small_habit::Type::DrinkWater),
                    "READING" => Ok(small_habit::Type::Reading),
                    "EAT_BREAKFAST" => Ok(small_habit::Type::EatBreakfast),
                    "CALL_PARENTS" => Ok(small_habit::Type::CallParents),
                    "EAT_FRUIT" => Ok(small_habit::Type::EatFruit),
                    "ACTIVE_NECK" => Ok(small_habit::Type::ActiveNeck),
                    "LEARN_TO_CHARGE" => Ok(small_habit::Type::LearnToCharge),
                    "PRACTICE_A_SKILL" => Ok(small_habit::Type::PracticeASkill),
                    "CONTACT_FRIEND" => Ok(small_habit::Type::ContactFriend),
                    "SITTING_UPRIGHT" => Ok(small_habit::Type::SittingUpright),
                    "EAT_VEGETABLE" => Ok(small_habit::Type::EatVegetable),
                    "CIVILIZED_LANGUAGE" => Ok(small_habit::Type::CivilizedLanguage),
                    "MEDITATION" => Ok(small_habit::Type::Meditation),
                    "BOOK_KEEPING" => Ok(small_habit::Type::BookKeeping),
                    "RECITE_WORDS" => Ok(small_habit::Type::ReciteWords),
                    "WALK_AFTER_MEAL" => Ok(small_habit::Type::WalkAfterMeal),
                    "GO_OUT_WITH_KEY" => Ok(small_habit::Type::GoOutWithKey),
                    "DAILY_SUMMARY" => Ok(small_habit::Type::DailySummary),
                    "GARGLE_AFTER_MEAL" => Ok(small_habit::Type::GargleAfterMeal),
                    "SMILE_MORE" => Ok(small_habit::Type::SmileMore),
                    "TAKE_MEDICINE" => Ok(small_habit::Type::TakeMedicine),
                    "NOT_HUMPBACK" => Ok(small_habit::Type::NotHumpback),
                    "CALLIGRAPHY" => Ok(small_habit::Type::Calligraphy),
                    "LUNCH_BREAK" => Ok(small_habit::Type::LunchBreak),
                    "DO_EYE_EXERCISES" => Ok(small_habit::Type::DoEyeExercises),
                    "DO_YOGA" => Ok(small_habit::Type::DoYoga),
                    "APPLY_FACIAL_MASK" => Ok(small_habit::Type::ApplyFacialMask),
                    "QUIT_SUGAR" => Ok(small_habit::Type::QuitSugar),
                    "SHOVEL_CAT_LITTER" => Ok(small_habit::Type::ShovelCatLitter),
                    "ONLINE_LESSON" => Ok(small_habit::Type::OnlineLesson),
                    "WATERING_FLOWERS" => Ok(small_habit::Type::WateringFlowers),
                    "TAKE_A_PICTURE_ONE_DAY" => Ok(small_habit::Type::TakeAPictureOneDay),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for small_habit::TypeList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.r#type.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SmallHabit.TypeList", len)?;
        if !self.r#type.is_empty() {
            let v = self.r#type.iter().cloned().map(|v| {
                small_habit::Type::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("type", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for small_habit::TypeList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = small_habit::TypeList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SmallHabit.TypeList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<small_habit::TypeList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<Vec<small_habit::Type>>()?.into_iter().map(|x| x as i32).collect());
                        }
                    }
                }
                Ok(small_habit::TypeList {
                    r#type: r#type__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SmallHabit.TypeList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Song {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 5;
        if self.duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Song", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("id", pbjson::private::base64::encode(&self.id).as_str())?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("size", &self.size)?;
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", v)?;
        }
        struct_ser.serialize_field("album", &self.album)?;
        struct_ser.serialize_field("artist", &self.artist)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Song {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "size",
            "duration",
            "album",
            "artist",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            Size,
            Duration,
            Album,
            Artist,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "size" => Ok(GeneratedField::Size),
                            "duration" => Ok(GeneratedField::Duration),
                            "album" => Ok(GeneratedField::Album),
                            "artist" => Ok(GeneratedField::Artist),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Song;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Song, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut size__ = None;
                let mut duration__ = None;
                let mut album__ = None;
                let mut artist__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Album => {
                            if album__.is_some() {
                                return Err(serde::de::Error::duplicate_field("album"));
                            }
                            album__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Artist => {
                            if artist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("artist"));
                            }
                            artist__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Song {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    size: size__.ok_or_else(|| serde::de::Error::missing_field("size"))?,
                    duration: duration__,
                    album: album__.ok_or_else(|| serde::de::Error::missing_field("album"))?,
                    artist: artist__.ok_or_else(|| serde::de::Error::missing_field("artist"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::AddRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Song.AddRequest", len)?;
        struct_ser.serialize_field("song", &self.song)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::AddRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "song",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Song,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "song" => Ok(GeneratedField::Song),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::AddRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.AddRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::AddRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut song__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Song => {
                            if song__.is_some() {
                                return Err(serde::de::Error::duplicate_field("song"));
                            }
                            song__ = map_.next_value()?;
                        }
                    }
                }
                Ok(song::AddRequest {
                    song: song__.ok_or_else(|| serde::de::Error::missing_field("song"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.AddRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::AddResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.expected_slice_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Song.AddResponse", len)?;
        let v = PrepareStatus::try_from(self.prepare_status)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.prepare_status)))?;
        struct_ser.serialize_field("prepareStatus", &v)?;
        if let Some(v) = self.expected_slice_length.as_ref() {
            struct_ser.serialize_field("expectedSliceLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::AddResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "prepare_status",
            "prepareStatus",
            "expected_slice_length",
            "expectedSliceLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PrepareStatus,
            ExpectedSliceLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "expectedSliceLength" | "expected_slice_length" => Ok(GeneratedField::ExpectedSliceLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::AddResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.AddResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::AddResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut prepare_status__ = None;
                let mut expected_slice_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PrepareStatus => {
                            if prepare_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            prepare_status__ = Some(map_.next_value::<PrepareStatus>()? as i32);
                        }
                        GeneratedField::ExpectedSliceLength => {
                            if expected_slice_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expectedSliceLength"));
                            }
                            expected_slice_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(song::AddResponse {
                    prepare_status: prepare_status__.ok_or_else(|| serde::de::Error::missing_field("prepareStatus"))?,
                    expected_slice_length: expected_slice_length__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.AddResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::GetRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Song.GetRequest", len)?;
        struct_ser.serialize_field("index", &self.index)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::GetRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "index",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Index,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "index" => Ok(GeneratedField::Index),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::GetRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.GetRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::GetRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("index"));
                            }
                            index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(song::GetRequest {
                    index: index__.ok_or_else(|| serde::de::Error::missing_field("index"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.GetRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::GetResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Song.GetResponse", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.serialize_field("nextIndex", &self.next_index)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::GetResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "next_index",
            "nextIndex",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            NextIndex,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "nextIndex" | "next_index" => Ok(GeneratedField::NextIndex),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::GetResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.GetResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::GetResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut next_index__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextIndex => {
                            if next_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextIndex"));
                            }
                            next_index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(song::GetResponse {
                    list: list__.unwrap_or_default(),
                    next_index: next_index__.ok_or_else(|| serde::de::Error::missing_field("nextIndex"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.GetResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::RemoveRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Song.RemoveRequest", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("id", pbjson::private::base64::encode(&self.id).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::RemoveRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::RemoveRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.RemoveRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::RemoveRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(song::RemoveRequest {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.RemoveRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::RemoveResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.Song.RemoveResponse", len)?;
        struct_ser.serialize_field("success", &self.success)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::RemoveResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "success",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "success" => Ok(GeneratedField::Success),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::RemoveResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.RemoveResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::RemoveResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(song::RemoveResponse {
                    success: success__.ok_or_else(|| serde::de::Error::missing_field("success"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.RemoveResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::ReportResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Song.ReportResult", len)?;
        let v = song::report_result::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        if let Some(v) = self.id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("id", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for song::ReportResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::ReportResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Song.ReportResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<song::ReportResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<song::report_result::Code>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(song::ReportResult {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    id: id__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Song.ReportResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for song::report_result::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Success => "SUCCESS",
            Self::IdNotMatch => "ID_NOT_MATCH",
            Self::Fail => "FAIL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for song::report_result::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUCCESS",
            "ID_NOT_MATCH",
            "FAIL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = song::report_result::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUCCESS" => Ok(song::report_result::Code::Success),
                    "ID_NOT_MATCH" => Ok(song::report_result::Code::IdNotMatch),
                    "FAIL" => Ok(song::report_result::Code::Fail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SongSummary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SongSummary", len)?;
        struct_ser.serialize_field("supportMediaFormat", &self.support_media_format)?;
        struct_ser.serialize_field("songCount", &self.song_count)?;
        struct_ser.serialize_field("songlistLimit", &self.songlist_limit)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SongSummary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "support_media_format",
            "supportMediaFormat",
            "song_count",
            "songCount",
            "songlist_limit",
            "songlistLimit",
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SupportMediaFormat,
            SongCount,
            SonglistLimit,
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "supportMediaFormat" | "support_media_format" => Ok(GeneratedField::SupportMediaFormat),
                            "songCount" | "song_count" => Ok(GeneratedField::SongCount),
                            "songlistLimit" | "songlist_limit" => Ok(GeneratedField::SonglistLimit),
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SongSummary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SongSummary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SongSummary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut support_media_format__ = None;
                let mut song_count__ = None;
                let mut songlist_limit__ = None;
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SupportMediaFormat => {
                            if support_media_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMediaFormat"));
                            }
                            support_media_format__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SongCount => {
                            if song_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songCount"));
                            }
                            song_count__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SonglistLimit => {
                            if songlist_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songlistLimit"));
                            }
                            songlist_limit__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SongSummary {
                    support_media_format: support_media_format__.ok_or_else(|| serde::de::Error::missing_field("supportMediaFormat"))?,
                    song_count: song_count__.ok_or_else(|| serde::de::Error::missing_field("songCount"))?,
                    songlist_limit: songlist_limit__.ok_or_else(|| serde::de::Error::missing_field("songlistLimit"))?,
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SongSummary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Songlist {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.Songlist", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("songCount", &self.song_count)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Songlist {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "song_count",
            "songCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            SongCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "songCount" | "song_count" => Ok(GeneratedField::SongCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Songlist;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Songlist")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Songlist, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut song_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SongCount => {
                            if song_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songCount"));
                            }
                            song_count__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Songlist {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    song_count: song_count__.ok_or_else(|| serde::de::Error::missing_field("songCount"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Songlist", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for songlist::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.Songlist.Request", len)?;
        let v = songlist::request::Cmd::try_from(self.cmd)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.cmd)))?;
        struct_ser.serialize_field("cmd", &v)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("songIds", pbjson::private::base64::encode(&self.song_ids).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for songlist::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cmd",
            "id",
            "name",
            "song_ids",
            "songIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cmd,
            Id,
            Name,
            SongIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cmd" => Ok(GeneratedField::Cmd),
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "songIds" | "song_ids" => Ok(GeneratedField::SongIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = songlist::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Songlist.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<songlist::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cmd__ = None;
                let mut id__ = None;
                let mut name__ = None;
                let mut song_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = Some(map_.next_value::<songlist::request::Cmd>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SongIds => {
                            if song_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songIds"));
                            }
                            song_ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(songlist::Request {
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    song_ids: song_ids__.ok_or_else(|| serde::de::Error::missing_field("songIds"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Songlist.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for songlist::request::Cmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Add => "ADD",
            Self::Remove => "REMOVE",
            Self::Rename => "RENAME",
            Self::QuerySong => "QUERY_SONG",
            Self::AddSong => "ADD_SONG",
            Self::RemoveSong => "REMOVE_SONG",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for songlist::request::Cmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ADD",
            "REMOVE",
            "RENAME",
            "QUERY_SONG",
            "ADD_SONG",
            "REMOVE_SONG",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = songlist::request::Cmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ADD" => Ok(songlist::request::Cmd::Add),
                    "REMOVE" => Ok(songlist::request::Cmd::Remove),
                    "RENAME" => Ok(songlist::request::Cmd::Rename),
                    "QUERY_SONG" => Ok(songlist::request::Cmd::QuerySong),
                    "ADD_SONG" => Ok(songlist::request::Cmd::AddSong),
                    "REMOVE_SONG" => Ok(songlist::request::Cmd::RemoveSong),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for songlist::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Songlist.Response", len)?;
        let v = songlist::response::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("songIds", pbjson::private::base64::encode(&self.song_ids).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for songlist::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "song_ids",
            "songIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            SongIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "songIds" | "song_ids" => Ok(GeneratedField::SongIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = songlist::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Songlist.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<songlist::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut song_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<songlist::response::Code>()? as i32);
                        }
                        GeneratedField::SongIds => {
                            if song_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("songIds"));
                            }
                            song_ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(songlist::Response {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    song_ids: song_ids__.ok_or_else(|| serde::de::Error::missing_field("songIds"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Songlist.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for songlist::response::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoError => "NO_ERROR",
            Self::CmdNotSupport => "CMD_NOT_SUPPORT",
            Self::ExceedLimit => "EXCEED_LIMIT",
            Self::IdExist => "ID_EXIST",
            Self::IdNotFound => "ID_NOT_FOUND",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for songlist::response::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_ERROR",
            "CMD_NOT_SUPPORT",
            "EXCEED_LIMIT",
            "ID_EXIST",
            "ID_NOT_FOUND",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = songlist::response::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_ERROR" => Ok(songlist::response::Code::NoError),
                    "CMD_NOT_SUPPORT" => Ok(songlist::response::Code::CmdNotSupport),
                    "EXCEED_LIMIT" => Ok(songlist::response::Code::ExceedLimit),
                    "ID_EXIST" => Ok(songlist::response::Code::IdExist),
                    "ID_NOT_FOUND" => Ok(songlist::response::Code::IdNotFound),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SpeakerAjustVolume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.SpeakerAjustVolume", len)?;
        struct_ser.serialize_field("volumeDelta", &self.volume_delta)?;
        let v = SpeakerVolumeType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        let v = SpeakerUnitDef::try_from(self.unit)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.unit)))?;
        struct_ser.serialize_field("unit", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SpeakerAjustVolume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volume_delta",
            "volumeDelta",
            "type",
            "unit",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VolumeDelta,
            Type,
            Unit,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volumeDelta" | "volume_delta" => Ok(GeneratedField::VolumeDelta),
                            "type" => Ok(GeneratedField::Type),
                            "unit" => Ok(GeneratedField::Unit),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeakerAjustVolume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeakerAjustVolume")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpeakerAjustVolume, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume_delta__ = None;
                let mut r#type__ = None;
                let mut unit__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VolumeDelta => {
                            if volume_delta__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeDelta"));
                            }
                            volume_delta__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<SpeakerVolumeType>()? as i32);
                        }
                        GeneratedField::Unit => {
                            if unit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unit"));
                            }
                            unit__ = Some(map_.next_value::<SpeakerUnitDef>()? as i32);
                        }
                    }
                }
                Ok(SpeakerAjustVolume {
                    volume_delta: volume_delta__.ok_or_else(|| serde::de::Error::missing_field("volumeDelta"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    unit: unit__.ok_or_else(|| serde::de::Error::missing_field("unit"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeakerAjustVolume", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SpeakerSetMute {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SpeakerSetMute", len)?;
        struct_ser.serialize_field("mute", &self.mute)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SpeakerSetMute {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mute",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mute,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mute" => Ok(GeneratedField::Mute),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeakerSetMute;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeakerSetMute")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpeakerSetMute, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mute__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mute => {
                            if mute__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mute"));
                            }
                            mute__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpeakerSetMute {
                    mute: mute__.ok_or_else(|| serde::de::Error::missing_field("mute"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeakerSetMute", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SpeakerSetVolume {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.once.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SpeakerSetVolume", len)?;
        struct_ser.serialize_field("volume", &self.volume)?;
        let v = SpeakerVolumeType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        let v = SpeakerUnitDef::try_from(self.unit)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.unit)))?;
        struct_ser.serialize_field("unit", &v)?;
        if let Some(v) = self.once.as_ref() {
            struct_ser.serialize_field("once", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SpeakerSetVolume {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "volume",
            "type",
            "unit",
            "once",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Volume,
            Type,
            Unit,
            Once,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "volume" => Ok(GeneratedField::Volume),
                            "type" => Ok(GeneratedField::Type),
                            "unit" => Ok(GeneratedField::Unit),
                            "once" => Ok(GeneratedField::Once),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeakerSetVolume;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeakerSetVolume")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpeakerSetVolume, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut volume__ = None;
                let mut r#type__ = None;
                let mut unit__ = None;
                let mut once__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Volume => {
                            if volume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volume"));
                            }
                            volume__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<SpeakerVolumeType>()? as i32);
                        }
                        GeneratedField::Unit => {
                            if unit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unit"));
                            }
                            unit__ = Some(map_.next_value::<SpeakerUnitDef>()? as i32);
                        }
                        GeneratedField::Once => {
                            if once__.is_some() {
                                return Err(serde::de::Error::duplicate_field("once"));
                            }
                            once__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SpeakerSetVolume {
                    volume: volume__.ok_or_else(|| serde::de::Error::missing_field("volume"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    unit: unit__.ok_or_else(|| serde::de::Error::missing_field("unit"))?,
                    once: once__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeakerSetVolume", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SpeakerUnitDef {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SpeakerUnitUnknown => "Speaker_UNIT_UNKNOWN",
            Self::SpeakerUnitPercent => "Speaker_UNIT_PERCENT",
            Self::SpeakerUnitAbsolute => "Speaker_UNIT_ABSOLUTE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SpeakerUnitDef {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Speaker_UNIT_UNKNOWN",
            "Speaker_UNIT_PERCENT",
            "Speaker_UNIT_ABSOLUTE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeakerUnitDef;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Speaker_UNIT_UNKNOWN" => Ok(SpeakerUnitDef::SpeakerUnitUnknown),
                    "Speaker_UNIT_PERCENT" => Ok(SpeakerUnitDef::SpeakerUnitPercent),
                    "Speaker_UNIT_ABSOLUTE" => Ok(SpeakerUnitDef::SpeakerUnitAbsolute),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SpeakerVolumeType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SpeakerVolumeUnknown => "Speaker_VOLUME_UNKNOWN",
            Self::SpeakerVolumeMedia => "Speaker_VOLUME_MEDIA",
            Self::SpeakerVolumeRing => "Speaker_VOLUME_RING",
            Self::SpeakerVolumeNotification => "Speaker_VOLUME_NOTIFICATION",
            Self::SpeakerVolumeVoiceAssistant => "Speaker_VOLUME_VOICE_ASSISTANT",
            Self::SpeakerVolumeAlarm => "Speaker_VOLUME_ALARM",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SpeakerVolumeType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Speaker_VOLUME_UNKNOWN",
            "Speaker_VOLUME_MEDIA",
            "Speaker_VOLUME_RING",
            "Speaker_VOLUME_NOTIFICATION",
            "Speaker_VOLUME_VOICE_ASSISTANT",
            "Speaker_VOLUME_ALARM",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeakerVolumeType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Speaker_VOLUME_UNKNOWN" => Ok(SpeakerVolumeType::SpeakerVolumeUnknown),
                    "Speaker_VOLUME_MEDIA" => Ok(SpeakerVolumeType::SpeakerVolumeMedia),
                    "Speaker_VOLUME_RING" => Ok(SpeakerVolumeType::SpeakerVolumeRing),
                    "Speaker_VOLUME_NOTIFICATION" => Ok(SpeakerVolumeType::SpeakerVolumeNotification),
                    "Speaker_VOLUME_VOICE_ASSISTANT" => Ok(SpeakerVolumeType::SpeakerVolumeVoiceAssistant),
                    "Speaker_VOLUME_ALARM" => Ok(SpeakerVolumeType::SpeakerVolumeAlarm),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SpeechRecognizeResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SpeechRecognizeResult", len)?;
        struct_ser.serialize_field("isFinal", &self.is_final)?;
        struct_ser.serialize_field("results", &self.results)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SpeechRecognizeResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_final",
            "isFinal",
            "results",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsFinal,
            Results,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isFinal" | "is_final" => Ok(GeneratedField::IsFinal),
                            "results" => Ok(GeneratedField::Results),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeechRecognizeResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeechRecognizeResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpeechRecognizeResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_final__ = None;
                let mut results__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsFinal => {
                            if is_final__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isFinal"));
                            }
                            is_final__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Results => {
                            if results__.is_some() {
                                return Err(serde::de::Error::duplicate_field("results"));
                            }
                            results__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SpeechRecognizeResult {
                    is_final: is_final__.ok_or_else(|| serde::de::Error::missing_field("isFinal"))?,
                    results: results__.ok_or_else(|| serde::de::Error::missing_field("results"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeechRecognizeResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SpeechRecognizeResultItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SpeechRecognizeResultItem", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SpeechRecognizeResultItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeechRecognizeResultItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeechRecognizeResultItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpeechRecognizeResultItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpeechRecognizeResultItem {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeechRecognizeResultItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for speech_recognize_result_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SpeechRecognizeResultItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for speech_recognize_result_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = speech_recognize_result_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeechRecognizeResultItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<speech_recognize_result_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(speech_recognize_result_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeechRecognizeResultItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SpeechSynthesizerSpeak {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SpeechSynthesizerSpeak", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SpeechSynthesizerSpeak {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SpeechSynthesizerSpeak;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SpeechSynthesizerSpeak")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SpeechSynthesizerSpeak, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SpeechSynthesizerSpeak {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SpeechSynthesizerSpeak", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportCourse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.cloud_course_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportCourse", len)?;
        struct_ser.serialize_field("sportCourseType", &self.sport_course_type)?;
        if let Some(v) = self.cloud_course_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("cloudCourseId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.serialize_field("courseName", &self.course_name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportCourse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_course_type",
            "sportCourseType",
            "cloud_course_id",
            "cloudCourseId",
            "course_name",
            "courseName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportCourseType,
            CloudCourseId,
            CourseName,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportCourseType" | "sport_course_type" => Ok(GeneratedField::SportCourseType),
                            "cloudCourseId" | "cloud_course_id" => Ok(GeneratedField::CloudCourseId),
                            "courseName" | "course_name" => Ok(GeneratedField::CourseName),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportCourse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportCourse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportCourse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_course_type__ = None;
                let mut cloud_course_id__ = None;
                let mut course_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportCourseType => {
                            if sport_course_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportCourseType"));
                            }
                            sport_course_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::CloudCourseId => {
                            if cloud_course_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cloudCourseId"));
                            }
                            cloud_course_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CourseName => {
                            if course_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("courseName"));
                            }
                            course_name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SportCourse {
                    sport_course_type: sport_course_type__.ok_or_else(|| serde::de::Error::missing_field("sportCourseType"))?,
                    cloud_course_id: cloud_course_id__,
                    course_name: course_name__.ok_or_else(|| serde::de::Error::missing_field("courseName"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportCourse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportExtraData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.avg_pace.is_some() {
            len += 1;
        }
        if self.max_pace.is_some() {
            len += 1;
        }
        if self.avg_speed.is_some() {
            len += 1;
        }
        if self.max_speed.is_some() {
            len += 1;
        }
        if self.avg_frequency.is_some() {
            len += 1;
        }
        if self.max_frequency.is_some() {
            len += 1;
        }
        if self.avg_stride.is_some() {
            len += 1;
        }
        if self.degree.is_some() {
            len += 1;
        }
        if self.main_run_style.is_some() {
            len += 1;
        }
        if self.forefoot_ratio.is_some() {
            len += 1;
        }
        if self.heel_ratio.is_some() {
            len += 1;
        }
        if self.avg_impact.is_some() {
            len += 1;
        }
        if self.max_impact.is_some() {
            len += 1;
        }
        if self.avg_on_ground.is_some() {
            len += 1;
        }
        if self.min_on_ground.is_some() {
            len += 1;
        }
        if self.avg_off_ground.is_some() {
            len += 1;
        }
        if self.max_off_ground.is_some() {
            len += 1;
        }
        if self.avg_on_off_ratio.is_some() {
            len += 1;
        }
        if self.min_on_off_ratio.is_some() {
            len += 1;
        }
        if self.max_on_ground.is_some() {
            len += 1;
        }
        if self.avg_vertical_stride_ratio.is_some() {
            len += 1;
        }
        if self.min_vertical_stride_ratio.is_some() {
            len += 1;
        }
        if self.max_vertical_stride_ratio.is_some() {
            len += 1;
        }
        if self.avg_vertical_amplitude.is_some() {
            len += 1;
        }
        if self.min_vertical_amplitude.is_some() {
            len += 1;
        }
        if self.max_vertical_amplitude.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportExtraData", len)?;
        if let Some(v) = self.avg_pace.as_ref() {
            struct_ser.serialize_field("avgPace", v)?;
        }
        if let Some(v) = self.max_pace.as_ref() {
            struct_ser.serialize_field("maxPace", v)?;
        }
        if let Some(v) = self.avg_speed.as_ref() {
            struct_ser.serialize_field("avgSpeed", v)?;
        }
        if let Some(v) = self.max_speed.as_ref() {
            struct_ser.serialize_field("maxSpeed", v)?;
        }
        if let Some(v) = self.avg_frequency.as_ref() {
            struct_ser.serialize_field("avgFrequency", v)?;
        }
        if let Some(v) = self.max_frequency.as_ref() {
            struct_ser.serialize_field("maxFrequency", v)?;
        }
        if let Some(v) = self.avg_stride.as_ref() {
            struct_ser.serialize_field("avgStride", v)?;
        }
        if let Some(v) = self.degree.as_ref() {
            struct_ser.serialize_field("degree", v)?;
        }
        if let Some(v) = self.main_run_style.as_ref() {
            struct_ser.serialize_field("mainRunStyle", v)?;
        }
        if let Some(v) = self.forefoot_ratio.as_ref() {
            struct_ser.serialize_field("forefootRatio", v)?;
        }
        if let Some(v) = self.heel_ratio.as_ref() {
            struct_ser.serialize_field("heelRatio", v)?;
        }
        if let Some(v) = self.avg_impact.as_ref() {
            struct_ser.serialize_field("avgImpact", v)?;
        }
        if let Some(v) = self.max_impact.as_ref() {
            struct_ser.serialize_field("maxImpact", v)?;
        }
        if let Some(v) = self.avg_on_ground.as_ref() {
            struct_ser.serialize_field("avgOnGround", v)?;
        }
        if let Some(v) = self.min_on_ground.as_ref() {
            struct_ser.serialize_field("minOnGround", v)?;
        }
        if let Some(v) = self.avg_off_ground.as_ref() {
            struct_ser.serialize_field("avgOffGround", v)?;
        }
        if let Some(v) = self.max_off_ground.as_ref() {
            struct_ser.serialize_field("maxOffGround", v)?;
        }
        if let Some(v) = self.avg_on_off_ratio.as_ref() {
            struct_ser.serialize_field("avgOnOffRatio", v)?;
        }
        if let Some(v) = self.min_on_off_ratio.as_ref() {
            struct_ser.serialize_field("minOnOffRatio", v)?;
        }
        if let Some(v) = self.max_on_ground.as_ref() {
            struct_ser.serialize_field("maxOnGround", v)?;
        }
        if let Some(v) = self.avg_vertical_stride_ratio.as_ref() {
            struct_ser.serialize_field("avgVerticalStrideRatio", v)?;
        }
        if let Some(v) = self.min_vertical_stride_ratio.as_ref() {
            struct_ser.serialize_field("minVerticalStrideRatio", v)?;
        }
        if let Some(v) = self.max_vertical_stride_ratio.as_ref() {
            struct_ser.serialize_field("maxVerticalStrideRatio", v)?;
        }
        if let Some(v) = self.avg_vertical_amplitude.as_ref() {
            struct_ser.serialize_field("avgVerticalAmplitude", v)?;
        }
        if let Some(v) = self.min_vertical_amplitude.as_ref() {
            struct_ser.serialize_field("minVerticalAmplitude", v)?;
        }
        if let Some(v) = self.max_vertical_amplitude.as_ref() {
            struct_ser.serialize_field("maxVerticalAmplitude", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportExtraData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "avg_pace",
            "avgPace",
            "max_pace",
            "maxPace",
            "avg_speed",
            "avgSpeed",
            "max_speed",
            "maxSpeed",
            "avg_frequency",
            "avgFrequency",
            "max_frequency",
            "maxFrequency",
            "avg_stride",
            "avgStride",
            "degree",
            "main_run_style",
            "mainRunStyle",
            "forefoot_ratio",
            "forefootRatio",
            "heel_ratio",
            "heelRatio",
            "avg_impact",
            "avgImpact",
            "max_impact",
            "maxImpact",
            "avg_on_ground",
            "avgOnGround",
            "min_on_ground",
            "minOnGround",
            "avg_off_ground",
            "avgOffGround",
            "max_off_ground",
            "maxOffGround",
            "avg_on_off_ratio",
            "avgOnOffRatio",
            "min_on_off_ratio",
            "minOnOffRatio",
            "max_on_ground",
            "maxOnGround",
            "avg_vertical_stride_ratio",
            "avgVerticalStrideRatio",
            "min_vertical_stride_ratio",
            "minVerticalStrideRatio",
            "max_vertical_stride_ratio",
            "maxVerticalStrideRatio",
            "avg_vertical_amplitude",
            "avgVerticalAmplitude",
            "min_vertical_amplitude",
            "minVerticalAmplitude",
            "max_vertical_amplitude",
            "maxVerticalAmplitude",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AvgPace,
            MaxPace,
            AvgSpeed,
            MaxSpeed,
            AvgFrequency,
            MaxFrequency,
            AvgStride,
            Degree,
            MainRunStyle,
            ForefootRatio,
            HeelRatio,
            AvgImpact,
            MaxImpact,
            AvgOnGround,
            MinOnGround,
            AvgOffGround,
            MaxOffGround,
            AvgOnOffRatio,
            MinOnOffRatio,
            MaxOnGround,
            AvgVerticalStrideRatio,
            MinVerticalStrideRatio,
            MaxVerticalStrideRatio,
            AvgVerticalAmplitude,
            MinVerticalAmplitude,
            MaxVerticalAmplitude,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "avgPace" | "avg_pace" => Ok(GeneratedField::AvgPace),
                            "maxPace" | "max_pace" => Ok(GeneratedField::MaxPace),
                            "avgSpeed" | "avg_speed" => Ok(GeneratedField::AvgSpeed),
                            "maxSpeed" | "max_speed" => Ok(GeneratedField::MaxSpeed),
                            "avgFrequency" | "avg_frequency" => Ok(GeneratedField::AvgFrequency),
                            "maxFrequency" | "max_frequency" => Ok(GeneratedField::MaxFrequency),
                            "avgStride" | "avg_stride" => Ok(GeneratedField::AvgStride),
                            "degree" => Ok(GeneratedField::Degree),
                            "mainRunStyle" | "main_run_style" => Ok(GeneratedField::MainRunStyle),
                            "forefootRatio" | "forefoot_ratio" => Ok(GeneratedField::ForefootRatio),
                            "heelRatio" | "heel_ratio" => Ok(GeneratedField::HeelRatio),
                            "avgImpact" | "avg_impact" => Ok(GeneratedField::AvgImpact),
                            "maxImpact" | "max_impact" => Ok(GeneratedField::MaxImpact),
                            "avgOnGround" | "avg_on_ground" => Ok(GeneratedField::AvgOnGround),
                            "minOnGround" | "min_on_ground" => Ok(GeneratedField::MinOnGround),
                            "avgOffGround" | "avg_off_ground" => Ok(GeneratedField::AvgOffGround),
                            "maxOffGround" | "max_off_ground" => Ok(GeneratedField::MaxOffGround),
                            "avgOnOffRatio" | "avg_on_off_ratio" => Ok(GeneratedField::AvgOnOffRatio),
                            "minOnOffRatio" | "min_on_off_ratio" => Ok(GeneratedField::MinOnOffRatio),
                            "maxOnGround" | "max_on_ground" => Ok(GeneratedField::MaxOnGround),
                            "avgVerticalStrideRatio" | "avg_vertical_stride_ratio" => Ok(GeneratedField::AvgVerticalStrideRatio),
                            "minVerticalStrideRatio" | "min_vertical_stride_ratio" => Ok(GeneratedField::MinVerticalStrideRatio),
                            "maxVerticalStrideRatio" | "max_vertical_stride_ratio" => Ok(GeneratedField::MaxVerticalStrideRatio),
                            "avgVerticalAmplitude" | "avg_vertical_amplitude" => Ok(GeneratedField::AvgVerticalAmplitude),
                            "minVerticalAmplitude" | "min_vertical_amplitude" => Ok(GeneratedField::MinVerticalAmplitude),
                            "maxVerticalAmplitude" | "max_vertical_amplitude" => Ok(GeneratedField::MaxVerticalAmplitude),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportExtraData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportExtraData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportExtraData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut avg_pace__ = None;
                let mut max_pace__ = None;
                let mut avg_speed__ = None;
                let mut max_speed__ = None;
                let mut avg_frequency__ = None;
                let mut max_frequency__ = None;
                let mut avg_stride__ = None;
                let mut degree__ = None;
                let mut main_run_style__ = None;
                let mut forefoot_ratio__ = None;
                let mut heel_ratio__ = None;
                let mut avg_impact__ = None;
                let mut max_impact__ = None;
                let mut avg_on_ground__ = None;
                let mut min_on_ground__ = None;
                let mut avg_off_ground__ = None;
                let mut max_off_ground__ = None;
                let mut avg_on_off_ratio__ = None;
                let mut min_on_off_ratio__ = None;
                let mut max_on_ground__ = None;
                let mut avg_vertical_stride_ratio__ = None;
                let mut min_vertical_stride_ratio__ = None;
                let mut max_vertical_stride_ratio__ = None;
                let mut avg_vertical_amplitude__ = None;
                let mut min_vertical_amplitude__ = None;
                let mut max_vertical_amplitude__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AvgPace => {
                            if avg_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgPace"));
                            }
                            avg_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxPace => {
                            if max_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxPace"));
                            }
                            max_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgSpeed => {
                            if avg_speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgSpeed"));
                            }
                            avg_speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxSpeed => {
                            if max_speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxSpeed"));
                            }
                            max_speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgFrequency => {
                            if avg_frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgFrequency"));
                            }
                            avg_frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxFrequency => {
                            if max_frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxFrequency"));
                            }
                            max_frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgStride => {
                            if avg_stride__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgStride"));
                            }
                            avg_stride__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Degree => {
                            if degree__.is_some() {
                                return Err(serde::de::Error::duplicate_field("degree"));
                            }
                            degree__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MainRunStyle => {
                            if main_run_style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainRunStyle"));
                            }
                            main_run_style__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ForefootRatio => {
                            if forefoot_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("forefootRatio"));
                            }
                            forefoot_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HeelRatio => {
                            if heel_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heelRatio"));
                            }
                            heel_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgImpact => {
                            if avg_impact__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgImpact"));
                            }
                            avg_impact__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxImpact => {
                            if max_impact__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxImpact"));
                            }
                            max_impact__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgOnGround => {
                            if avg_on_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgOnGround"));
                            }
                            avg_on_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinOnGround => {
                            if min_on_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minOnGround"));
                            }
                            min_on_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgOffGround => {
                            if avg_off_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgOffGround"));
                            }
                            avg_off_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxOffGround => {
                            if max_off_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxOffGround"));
                            }
                            max_off_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgOnOffRatio => {
                            if avg_on_off_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgOnOffRatio"));
                            }
                            avg_on_off_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinOnOffRatio => {
                            if min_on_off_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minOnOffRatio"));
                            }
                            min_on_off_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxOnGround => {
                            if max_on_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxOnGround"));
                            }
                            max_on_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgVerticalStrideRatio => {
                            if avg_vertical_stride_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgVerticalStrideRatio"));
                            }
                            avg_vertical_stride_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinVerticalStrideRatio => {
                            if min_vertical_stride_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minVerticalStrideRatio"));
                            }
                            min_vertical_stride_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxVerticalStrideRatio => {
                            if max_vertical_stride_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxVerticalStrideRatio"));
                            }
                            max_vertical_stride_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvgVerticalAmplitude => {
                            if avg_vertical_amplitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("avgVerticalAmplitude"));
                            }
                            avg_vertical_amplitude__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinVerticalAmplitude => {
                            if min_vertical_amplitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minVerticalAmplitude"));
                            }
                            min_vertical_amplitude__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxVerticalAmplitude => {
                            if max_vertical_amplitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxVerticalAmplitude"));
                            }
                            max_vertical_amplitude__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SportExtraData {
                    avg_pace: avg_pace__,
                    max_pace: max_pace__,
                    avg_speed: avg_speed__,
                    max_speed: max_speed__,
                    avg_frequency: avg_frequency__,
                    max_frequency: max_frequency__,
                    avg_stride: avg_stride__,
                    degree: degree__,
                    main_run_style: main_run_style__,
                    forefoot_ratio: forefoot_ratio__,
                    heel_ratio: heel_ratio__,
                    avg_impact: avg_impact__,
                    max_impact: max_impact__,
                    avg_on_ground: avg_on_ground__,
                    min_on_ground: min_on_ground__,
                    avg_off_ground: avg_off_ground__,
                    max_off_ground: max_off_ground__,
                    avg_on_off_ratio: avg_on_off_ratio__,
                    min_on_off_ratio: min_on_off_ratio__,
                    max_on_ground: max_on_ground__,
                    avg_vertical_stride_ratio: avg_vertical_stride_ratio__,
                    min_vertical_stride_ratio: min_vertical_stride_ratio__,
                    max_vertical_stride_ratio: max_vertical_stride_ratio__,
                    avg_vertical_amplitude: avg_vertical_amplitude__,
                    min_vertical_amplitude: min_vertical_amplitude__,
                    max_vertical_amplitude: max_vertical_amplitude__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportExtraData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SportOption", len)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        struct_ser.serialize_field("show", &self.show)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_type",
            "sportType",
            "show",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportType,
            Show,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "show" => Ok(GeneratedField::Show),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportOption")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportOption, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_type__ = None;
                let mut show__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::Show => {
                            if show__.is_some() {
                                return Err(serde::de::Error::duplicate_field("show"));
                            }
                            show__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SportOption {
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    show: show__.ok_or_else(|| serde::de::Error::missing_field("show"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportOption", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sport_option::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.shortcut_sport_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportOption.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.shortcut_sport_type.as_ref() {
            let v = SportType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("shortcutSportType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for sport_option::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "shortcut_sport_type",
            "shortcutSportType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            ShortcutSportType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "shortcutSportType" | "shortcut_sport_type" => Ok(GeneratedField::ShortcutSportType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sport_option::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportOption.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<sport_option::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut shortcut_sport_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ShortcutSportType => {
                            if shortcut_sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shortcutSportType"));
                            }
                            shortcut_sport_type__ = map_.next_value::<::std::option::Option<SportType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(sport_option::List {
                    list: list__.unwrap_or_default(),
                    shortcut_sport_type: shortcut_sport_type__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportOption.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportPreRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.main_sport_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportPreRequest", len)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        if let Some(v) = self.main_sport_type.as_ref() {
            let v = SportType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("mainSportType", &v)?;
        }
        struct_ser.serialize_field("supportVersions", &self.support_versions)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportPreRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_type",
            "sportType",
            "main_sport_type",
            "mainSportType",
            "support_versions",
            "supportVersions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportType,
            MainSportType,
            SupportVersions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "mainSportType" | "main_sport_type" => Ok(GeneratedField::MainSportType),
                            "supportVersions" | "support_versions" => Ok(GeneratedField::SupportVersions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportPreRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportPreRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportPreRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_type__ = None;
                let mut main_sport_type__ = None;
                let mut support_versions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::MainSportType => {
                            if main_sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainSportType"));
                            }
                            main_sport_type__ = map_.next_value::<::std::option::Option<SportType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SupportVersions => {
                            if support_versions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportVersions"));
                            }
                            support_versions__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SportPreRequest {
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    main_sport_type: main_sport_type__,
                    support_versions: support_versions__.ok_or_else(|| serde::de::Error::missing_field("supportVersions"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportPreRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportPreResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.gps_accuracy.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportPreResponse", len)?;
        let v = sport_response::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        struct_ser.serialize_field("selectVersion", &self.select_version)?;
        if let Some(v) = self.gps_accuracy.as_ref() {
            let v = GpsAccuracy::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("gpsAccuracy", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportPreResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "select_version",
            "selectVersion",
            "gps_accuracy",
            "gpsAccuracy",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            SelectVersion,
            GpsAccuracy,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "selectVersion" | "select_version" => Ok(GeneratedField::SelectVersion),
                            "gpsAccuracy" | "gps_accuracy" => Ok(GeneratedField::GpsAccuracy),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportPreResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportPreResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportPreResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut select_version__ = None;
                let mut gps_accuracy__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<sport_response::Code>()? as i32);
                        }
                        GeneratedField::SelectVersion => {
                            if select_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectVersion"));
                            }
                            select_version__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::GpsAccuracy => {
                            if gps_accuracy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gpsAccuracy"));
                            }
                            gps_accuracy__ = map_.next_value::<::std::option::Option<GpsAccuracy>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(SportPreResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    select_version: select_version__.ok_or_else(|| serde::de::Error::missing_field("selectVersion"))?,
                    gps_accuracy: gps_accuracy__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportPreResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 5;
        if self.main_sport_type.is_some() {
            len += 1;
        }
        if self.support_versions.is_some() {
            len += 1;
        }
        if !self.sport_target_list.is_empty() {
            len += 1;
        }
        if self.sport_course.is_some() {
            len += 1;
        }
        if self.wear_mode.is_some() {
            len += 1;
        }
        if self.extra_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportRequest", len)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("timezone", &self.timezone)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        if let Some(v) = self.main_sport_type.as_ref() {
            let v = SportType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("mainSportType", &v)?;
        }
        let v = SportState::try_from(self.state)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.state)))?;
        struct_ser.serialize_field("state", &v)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("ids", pbjson::private::base64::encode(&self.ids).as_str())?;
        if let Some(v) = self.support_versions.as_ref() {
            struct_ser.serialize_field("supportVersions", v)?;
        }
        if !self.sport_target_list.is_empty() {
            struct_ser.serialize_field("sportTargetList", &self.sport_target_list)?;
        }
        if let Some(v) = self.sport_course.as_ref() {
            struct_ser.serialize_field("sportCourse", v)?;
        }
        if let Some(v) = self.wear_mode.as_ref() {
            let v = WearMode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("wearMode", &v)?;
        }
        if let Some(v) = self.extra_data.as_ref() {
            struct_ser.serialize_field("extraData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "timezone",
            "sport_type",
            "sportType",
            "main_sport_type",
            "mainSportType",
            "state",
            "ids",
            "support_versions",
            "supportVersions",
            "sport_target_list",
            "sportTargetList",
            "sport_course",
            "sportCourse",
            "wear_mode",
            "wearMode",
            "extra_data",
            "extraData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Timezone,
            SportType,
            MainSportType,
            State,
            Ids,
            SupportVersions,
            SportTargetList,
            SportCourse,
            WearMode,
            ExtraData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "timezone" => Ok(GeneratedField::Timezone),
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "mainSportType" | "main_sport_type" => Ok(GeneratedField::MainSportType),
                            "state" => Ok(GeneratedField::State),
                            "ids" => Ok(GeneratedField::Ids),
                            "supportVersions" | "support_versions" => Ok(GeneratedField::SupportVersions),
                            "sportTargetList" | "sport_target_list" => Ok(GeneratedField::SportTargetList),
                            "sportCourse" | "sport_course" => Ok(GeneratedField::SportCourse),
                            "wearMode" | "wear_mode" => Ok(GeneratedField::WearMode),
                            "extraData" | "extra_data" => Ok(GeneratedField::ExtraData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut timezone__ = None;
                let mut sport_type__ = None;
                let mut main_sport_type__ = None;
                let mut state__ = None;
                let mut ids__ = None;
                let mut support_versions__ = None;
                let mut sport_target_list__ = None;
                let mut sport_course__ = None;
                let mut wear_mode__ = None;
                let mut extra_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Timezone => {
                            if timezone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timezone"));
                            }
                            timezone__ = map_.next_value()?;
                        }
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::MainSportType => {
                            if main_sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainSportType"));
                            }
                            main_sport_type__ = map_.next_value::<::std::option::Option<SportType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = Some(map_.next_value::<SportState>()? as i32);
                        }
                        GeneratedField::Ids => {
                            if ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SupportVersions => {
                            if support_versions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportVersions"));
                            }
                            support_versions__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SportTargetList => {
                            if sport_target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportTargetList"));
                            }
                            sport_target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SportCourse => {
                            if sport_course__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportCourse"));
                            }
                            sport_course__ = map_.next_value()?;
                        }
                        GeneratedField::WearMode => {
                            if wear_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearMode"));
                            }
                            wear_mode__ = map_.next_value::<::std::option::Option<WearMode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ExtraData => {
                            if extra_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraData"));
                            }
                            extra_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SportRequest {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    timezone: timezone__.ok_or_else(|| serde::de::Error::missing_field("timezone"))?,
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    main_sport_type: main_sport_type__,
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    ids: ids__.ok_or_else(|| serde::de::Error::missing_field("ids"))?,
                    support_versions: support_versions__,
                    sport_target_list: sport_target_list__.unwrap_or_default(),
                    sport_course: sport_course__,
                    wear_mode: wear_mode__,
                    extra_data: extra_data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.sport_status.is_some() {
            len += 1;
        }
        if self.gps_accuracy.is_some() {
            len += 1;
        }
        if self.select_version.is_some() {
            len += 1;
        }
        if self.current_wear_mode.is_some() {
            len += 1;
        }
        if self.extra_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportResponse", len)?;
        let v = sport_response::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("ids", pbjson::private::base64::encode(&self.ids).as_str())?;
        if let Some(v) = self.sport_status.as_ref() {
            struct_ser.serialize_field("sportStatus", v)?;
        }
        if let Some(v) = self.gps_accuracy.as_ref() {
            let v = GpsAccuracy::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("gpsAccuracy", &v)?;
        }
        if let Some(v) = self.select_version.as_ref() {
            struct_ser.serialize_field("selectVersion", v)?;
        }
        if let Some(v) = self.current_wear_mode.as_ref() {
            let v = WearMode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("currentWearMode", &v)?;
        }
        if let Some(v) = self.extra_data.as_ref() {
            struct_ser.serialize_field("extraData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "ids",
            "sport_status",
            "sportStatus",
            "gps_accuracy",
            "gpsAccuracy",
            "select_version",
            "selectVersion",
            "current_wear_mode",
            "currentWearMode",
            "extra_data",
            "extraData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            Ids,
            SportStatus,
            GpsAccuracy,
            SelectVersion,
            CurrentWearMode,
            ExtraData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "ids" => Ok(GeneratedField::Ids),
                            "sportStatus" | "sport_status" => Ok(GeneratedField::SportStatus),
                            "gpsAccuracy" | "gps_accuracy" => Ok(GeneratedField::GpsAccuracy),
                            "selectVersion" | "select_version" => Ok(GeneratedField::SelectVersion),
                            "currentWearMode" | "current_wear_mode" => Ok(GeneratedField::CurrentWearMode),
                            "extraData" | "extra_data" => Ok(GeneratedField::ExtraData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut ids__ = None;
                let mut sport_status__ = None;
                let mut gps_accuracy__ = None;
                let mut select_version__ = None;
                let mut current_wear_mode__ = None;
                let mut extra_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<sport_response::Code>()? as i32);
                        }
                        GeneratedField::Ids => {
                            if ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            ids__ = 
                                Some(map_.next_value::<::pbjson::private::BytesDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SportStatus => {
                            if sport_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportStatus"));
                            }
                            sport_status__ = map_.next_value()?;
                        }
                        GeneratedField::GpsAccuracy => {
                            if gps_accuracy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gpsAccuracy"));
                            }
                            gps_accuracy__ = map_.next_value::<::std::option::Option<GpsAccuracy>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SelectVersion => {
                            if select_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectVersion"));
                            }
                            select_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentWearMode => {
                            if current_wear_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentWearMode"));
                            }
                            current_wear_mode__ = map_.next_value::<::std::option::Option<WearMode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ExtraData => {
                            if extra_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraData"));
                            }
                            extra_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SportResponse {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    ids: ids__.ok_or_else(|| serde::de::Error::missing_field("ids"))?,
                    sport_status: sport_status__,
                    gps_accuracy: gps_accuracy__,
                    select_version: select_version__,
                    current_wear_mode: current_wear_mode__,
                    extra_data: extra_data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for sport_response::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ok => "OK",
            Self::Busy => "BUSY",
            Self::TypeNotMatch => "TYPE_NOT_MATCH",
            Self::NoPermission => "NO_PERMISSION",
            Self::SportNotSupport => "SPORT_NOT_SUPPORT",
            Self::LackOfAccuracy => "LACK_OF_ACCURACY",
            Self::Charging => "CHARGING",
            Self::LowBattery => "LOW_BATTERY",
            Self::VersionNotSupport => "VERSION_NOT_SUPPORT",
            Self::ModeNotMatch => "MODE_NOT_MATCH",
            Self::Unknown => "UNKNOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for sport_response::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OK",
            "BUSY",
            "TYPE_NOT_MATCH",
            "NO_PERMISSION",
            "SPORT_NOT_SUPPORT",
            "LACK_OF_ACCURACY",
            "CHARGING",
            "LOW_BATTERY",
            "VERSION_NOT_SUPPORT",
            "MODE_NOT_MATCH",
            "UNKNOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = sport_response::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OK" => Ok(sport_response::Code::Ok),
                    "BUSY" => Ok(sport_response::Code::Busy),
                    "TYPE_NOT_MATCH" => Ok(sport_response::Code::TypeNotMatch),
                    "NO_PERMISSION" => Ok(sport_response::Code::NoPermission),
                    "SPORT_NOT_SUPPORT" => Ok(sport_response::Code::SportNotSupport),
                    "LACK_OF_ACCURACY" => Ok(sport_response::Code::LackOfAccuracy),
                    "CHARGING" => Ok(sport_response::Code::Charging),
                    "LOW_BATTERY" => Ok(sport_response::Code::LowBattery),
                    "VERSION_NOT_SUPPORT" => Ok(sport_response::Code::VersionNotSupport),
                    "MODE_NOT_MATCH" => Ok(sport_response::Code::ModeNotMatch),
                    "UNKNOWN" => Ok(sport_response::Code::Unknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SportState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SportStart => "SPORT_START",
            Self::SportPause => "SPORT_PAUSE",
            Self::SportResume => "SPORT_RESUME",
            Self::SportStop => "SPORT_STOP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SportState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SPORT_START",
            "SPORT_PAUSE",
            "SPORT_RESUME",
            "SPORT_STOP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SPORT_START" => Ok(SportState::SportStart),
                    "SPORT_PAUSE" => Ok(SportState::SportPause),
                    "SPORT_RESUME" => Ok(SportState::SportResume),
                    "SPORT_STOP" => Ok(SportState::SportStop),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SportStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.main_sport_type.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        if self.timezone.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.paused.is_some() {
            len += 1;
        }
        if self.standalone.is_some() {
            len += 1;
        }
        if self.select_version.is_some() {
            len += 1;
        }
        if self.app_launched.is_some() {
            len += 1;
        }
        if !self.sport_target_list.is_empty() {
            len += 1;
        }
        if self.sport_course.is_some() {
            len += 1;
        }
        if self.wear_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SportStatus", len)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        if let Some(v) = self.main_sport_type.as_ref() {
            let v = SportType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("mainSportType", &v)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", v)?;
        }
        if let Some(v) = self.timezone.as_ref() {
            struct_ser.serialize_field("timezone", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", v)?;
        }
        if let Some(v) = self.paused.as_ref() {
            struct_ser.serialize_field("paused", v)?;
        }
        if let Some(v) = self.standalone.as_ref() {
            struct_ser.serialize_field("standalone", v)?;
        }
        if let Some(v) = self.select_version.as_ref() {
            struct_ser.serialize_field("selectVersion", v)?;
        }
        if let Some(v) = self.app_launched.as_ref() {
            struct_ser.serialize_field("appLaunched", v)?;
        }
        if !self.sport_target_list.is_empty() {
            struct_ser.serialize_field("sportTargetList", &self.sport_target_list)?;
        }
        if let Some(v) = self.sport_course.as_ref() {
            struct_ser.serialize_field("sportCourse", v)?;
        }
        if let Some(v) = self.wear_mode.as_ref() {
            let v = WearMode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("wearMode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_type",
            "sportType",
            "main_sport_type",
            "mainSportType",
            "timestamp",
            "timezone",
            "duration",
            "paused",
            "standalone",
            "select_version",
            "selectVersion",
            "app_launched",
            "appLaunched",
            "sport_target_list",
            "sportTargetList",
            "sport_course",
            "sportCourse",
            "wear_mode",
            "wearMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportType,
            MainSportType,
            Timestamp,
            Timezone,
            Duration,
            Paused,
            Standalone,
            SelectVersion,
            AppLaunched,
            SportTargetList,
            SportCourse,
            WearMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "mainSportType" | "main_sport_type" => Ok(GeneratedField::MainSportType),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "timezone" => Ok(GeneratedField::Timezone),
                            "duration" => Ok(GeneratedField::Duration),
                            "paused" => Ok(GeneratedField::Paused),
                            "standalone" => Ok(GeneratedField::Standalone),
                            "selectVersion" | "select_version" => Ok(GeneratedField::SelectVersion),
                            "appLaunched" | "app_launched" => Ok(GeneratedField::AppLaunched),
                            "sportTargetList" | "sport_target_list" => Ok(GeneratedField::SportTargetList),
                            "sportCourse" | "sport_course" => Ok(GeneratedField::SportCourse),
                            "wearMode" | "wear_mode" => Ok(GeneratedField::WearMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_type__ = None;
                let mut main_sport_type__ = None;
                let mut timestamp__ = None;
                let mut timezone__ = None;
                let mut duration__ = None;
                let mut paused__ = None;
                let mut standalone__ = None;
                let mut select_version__ = None;
                let mut app_launched__ = None;
                let mut sport_target_list__ = None;
                let mut sport_course__ = None;
                let mut wear_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                        GeneratedField::MainSportType => {
                            if main_sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainSportType"));
                            }
                            main_sport_type__ = map_.next_value::<::std::option::Option<SportType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Timezone => {
                            if timezone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timezone"));
                            }
                            timezone__ = map_.next_value()?;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Paused => {
                            if paused__.is_some() {
                                return Err(serde::de::Error::duplicate_field("paused"));
                            }
                            paused__ = map_.next_value()?;
                        }
                        GeneratedField::Standalone => {
                            if standalone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("standalone"));
                            }
                            standalone__ = map_.next_value()?;
                        }
                        GeneratedField::SelectVersion => {
                            if select_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("selectVersion"));
                            }
                            select_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AppLaunched => {
                            if app_launched__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appLaunched"));
                            }
                            app_launched__ = map_.next_value()?;
                        }
                        GeneratedField::SportTargetList => {
                            if sport_target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportTargetList"));
                            }
                            sport_target_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SportCourse => {
                            if sport_course__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportCourse"));
                            }
                            sport_course__ = map_.next_value()?;
                        }
                        GeneratedField::WearMode => {
                            if wear_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearMode"));
                            }
                            wear_mode__ = map_.next_value::<::std::option::Option<WearMode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(SportStatus {
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                    main_sport_type: main_sport_type__,
                    timestamp: timestamp__,
                    timezone: timezone__,
                    duration: duration__,
                    paused: paused__,
                    standalone: standalone__,
                    select_version: select_version__,
                    app_launched: app_launched__,
                    sport_target_list: sport_target_list__.unwrap_or_default(),
                    sport_course: sport_course__,
                    wear_mode: wear_mode__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SportTarget", len)?;
        let v = SportTargetType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SportTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SportTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SportTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<SportTargetType>()? as i32);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SportTarget {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SportTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SportTargetType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::TargetDuration => "TARGET_DURATION",
            Self::TargetCalorie => "TARGET_CALORIE",
            Self::TargetDistance => "TARGET_DISTANCE",
            Self::TargetPace => "TARGET_PACE",
            Self::TargetStepFrequency => "TARGET_STEP_FREQUENCY",
            Self::TargetCount => "TARGET_COUNT",
            Self::TargetHeartrate => "TARGET_HEARTRATE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SportTargetType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TARGET_DURATION",
            "TARGET_CALORIE",
            "TARGET_DISTANCE",
            "TARGET_PACE",
            "TARGET_STEP_FREQUENCY",
            "TARGET_COUNT",
            "TARGET_HEARTRATE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportTargetType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TARGET_DURATION" => Ok(SportTargetType::TargetDuration),
                    "TARGET_CALORIE" => Ok(SportTargetType::TargetCalorie),
                    "TARGET_DISTANCE" => Ok(SportTargetType::TargetDistance),
                    "TARGET_PACE" => Ok(SportTargetType::TargetPace),
                    "TARGET_STEP_FREQUENCY" => Ok(SportTargetType::TargetStepFrequency),
                    "TARGET_COUNT" => Ok(SportTargetType::TargetCount),
                    "TARGET_HEARTRATE" => Ok(SportTargetType::TargetHeartrate),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SportType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "NONE",
            Self::RunOutdoor => "RUN_OUTDOOR",
            Self::WalkOutdoor => "WALK_OUTDOOR",
            Self::RunIndoor => "RUN_INDOOR",
            Self::Climbing => "CLIMBING",
            Self::CrossCountry => "CROSS_COUNTRY",
            Self::RideOutdoor => "RIDE_OUTDOOR",
            Self::RideIndoor => "RIDE_INDOOR",
            Self::FreeTraining => "FREE_TRAINING",
            Self::SwimIndoor => "SWIM_INDOOR",
            Self::SwimOutdoor => "SWIM_OUTDOOR",
            Self::EllipticalMachine => "ELLIPTICAL_MACHINE",
            Self::Yoga => "YOGA",
            Self::RowingMachine => "ROWING_MACHINE",
            Self::RopeSkipping => "ROPE_SKIPPING",
            Self::HikingOutdoor => "HIKING_OUTDOOR",
            Self::HighIntervalTraining => "HIGH_INTERVAL_TRAINING",
            Self::Triathlon => "TRIATHLON",
            Self::GeneralBall => "GENERAL_BALL",
            Self::BasketballS => "BASKETBALL_S",
            Self::GolfS => "GOLF_S",
            Self::Skiing => "SKIING",
            Self::OutdoorWalkCategory => "OUTDOOR_WALK_CATEGORY",
            Self::OutdoorNonWalkCategory => "OUTDOOR_NON_WALK_CATEGORY",
            Self::RockClimbingS => "ROCK_CLIMBING_S",
            Self::Diving => "DIVING",
            Self::Sailboat => "SAILBOAT",
            Self::PaddleBoard => "PADDLE_BOARD",
            Self::WaterPolo => "WATER_POLO",
            Self::AquaticSport => "AQUATIC_SPORT",
            Self::Surfing => "SURFING",
            Self::Canoeing => "CANOEING",
            Self::KayakRafting => "KAYAK_RAFTING",
            Self::Rowing => "ROWING",
            Self::Motorboat => "MOTORBOAT",
            Self::WebSwimming => "WEB_SWIMMING",
            Self::Driving => "DRIVING",
            Self::FancySwimming => "FANCY_SWIMMING",
            Self::Snorkeling => "SNORKELING",
            Self::KiteSurfing => "KITE_SURFING",
            Self::IndoorSurfing => "INDOOR_SURFING",
            Self::DragonBoat => "DRAGON_BOAT",
            Self::FreeDiving => "FREE_DIVING",
            Self::ScubaDiving => "SCUBA_DIVING",
            Self::InstrumentDiving => "INSTRUMENT_DIVING",
            Self::RockClimbing => "ROCK_CLIMBING",
            Self::Skate => "SKATE",
            Self::RollerSkating => "ROLLER_SKATING",
            Self::Parkour => "PARKOUR",
            Self::Atv => "ATV",
            Self::Paraglider => "PARAGLIDER",
            Self::BicycleMoto => "BICYCLE_MOTO",
            Self::HeelAndToe => "HEEL_AND_TOE",
            Self::ClimbingMachine => "CLIMBING_MACHINE",
            Self::ClimbStairs => "CLIMB_STAIRS",
            Self::Stepper => "STEPPER",
            Self::CoreTraining => "CORE_TRAINING",
            Self::FlexibilityTraining => "FLEXIBILITY_TRAINING",
            Self::Pilates => "PILATES",
            Self::Gymnastics => "GYMNASTICS",
            Self::Stretch => "STRETCH",
            Self::StrengthTraining => "STRENGTH_TRAINING",
            Self::CrossFit => "CROSS_FIT",
            Self::Aerobics => "AEROBICS",
            Self::PhysicalTraining => "PHYSICAL_TRAINING",
            Self::WallBall => "WALL_BALL",
            Self::DumbbellTraining => "DUMBBELL_TRAINING",
            Self::BarbellTraining => "BARBELL_TRAINING",
            Self::Weightlifting => "WEIGHTLIFTING",
            Self::Deadlift => "DEADLIFT",
            Self::BobbyJump => "BOBBY_JUMP",
            Self::SitUps => "SIT_UPS",
            Self::FunctionalTraining => "FUNCTIONAL_TRAINING",
            Self::UpperLimbTraining => "UPPER_LIMB_TRAINING",
            Self::LowerLimbTraining => "LOWER_LIMB_TRAINING",
            Self::WaistTraining => "WAIST_TRAINING",
            Self::BackTraining => "BACK_TRAINING",
            Self::Spinning => "SPINNING",
            Self::WalkingMachine => "WALKING_MACHINE",
            Self::StepTraining => "STEP_TRAINING",
            Self::SingleBar => "SINGLE_BAR",
            Self::ParallelBars => "PARALLEL_BARS",
            Self::GroupCallisthenics => "GROUP_CALLISTHENICS",
            Self::Strike => "STRIKE",
            Self::BattleRope => "BATTLE_ROPE",
            Self::MixedAerobic => "MIXED_AEROBIC",
            Self::WalkIndoor => "WALK_INDOOR",
            Self::Gym => "GYM",
            Self::SquareDance => "SQUARE_DANCE",
            Self::BellyDance => "BELLY_DANCE",
            Self::Ballet => "BALLET",
            Self::StreetDance => "STREET_DANCE",
            Self::Zumba => "ZUMBA",
            Self::NationalDance => "NATIONAL_DANCE",
            Self::Jazz => "JAZZ",
            Self::LatinDance => "LATIN_DANCE",
            Self::HipHopDance => "HIP_HOP_DANCE",
            Self::PoleDance => "POLE_DANCE",
            Self::Breakdancing => "BREAKDANCING",
            Self::SocialDancing => "SOCIAL_DANCING",
            Self::ModernDancing => "MODERN_DANCING",
            Self::Dance => "DANCE",
            Self::Boxing => "BOXING",
            Self::Wrestling => "WRESTLING",
            Self::MartialArts => "MARTIAL_ARTS",
            Self::Taichi => "TAICHI",
            Self::MuayThai => "MUAY_THAI",
            Self::Judo => "JUDO",
            Self::Taekwondo => "TAEKWONDO",
            Self::Karate => "KARATE",
            Self::FreeSparring => "FREE_SPARRING",
            Self::Swordsmanship => "SWORDSMANSHIP",
            Self::Fencing => "FENCING",
            Self::Jujitsu => "JUJITSU",
            Self::Football => "FOOTBALL",
            Self::Basketball => "BASKETBALL",
            Self::Volleyball => "VOLLEYBALL",
            Self::Baseball => "BASEBALL",
            Self::Softball => "SOFTBALL",
            Self::Rugby => "RUGBY",
            Self::Hockey => "HOCKEY",
            Self::Pingpong => "PINGPONG",
            Self::Badminton => "BADMINTON",
            Self::Tennis => "TENNIS",
            Self::Cricket => "CRICKET",
            Self::Handball => "HANDBALL",
            Self::Bowling => "BOWLING",
            Self::Squash => "SQUASH",
            Self::Billiards => "BILLIARDS",
            Self::Shuttlecock => "SHUTTLECOCK",
            Self::BeachFootball => "BEACH_FOOTBALL",
            Self::BeachVolleyball => "BEACH_VOLLEYBALL",
            Self::SepakTakraw => "SEPAK_TAKRAW",
            Self::Golf => "GOLF",
            Self::Foosball => "FOOSBALL",
            Self::IndoorFootball => "INDOOR_FOOTBALL",
            Self::SandbagsBall => "SANDBAGS_BALL",
            Self::Bocci => "BOCCI",
            Self::HihiBall => "HIHI_BALL",
            Self::Gateball => "GATEBALL",
            Self::Dodgeball => "DODGEBALL",
            Self::ShuffleBall => "SHUFFLE_BALL",
            Self::OutdoorSkating => "OUTDOOR_SKATING",
            Self::Curling => "CURLING",
            Self::SnowSports => "SNOW_SPORTS",
            Self::Snowmobile => "SNOWMOBILE",
            Self::Puck => "PUCK",
            Self::SnowCar => "SNOW_CAR",
            Self::Sled => "SLED",
            Self::IndoorSkating => "INDOOR__SKATING",
            Self::Snowboarding => "SNOWBOARDING",
            Self::DoubleBoardSkiing => "DOUBLE_BOARD_SKIING",
            Self::CrossCountrySkiing => "CROSS_COUNTRY_SKIING",
            Self::Archery => "ARCHERY",
            Self::Darts => "DARTS",
            Self::HorseRiding => "HORSE_RIDING",
            Self::TugOfWar => "TUG_OF_WAR",
            Self::HulaHoop => "HULA_HOOP",
            Self::FlyKite => "FLY_KITE",
            Self::Fishing => "FISHING",
            Self::Frisbee => "FRISBEE",
            Self::ShuttlecockKicking => "SHUTTLECOCK_KICKING",
            Self::Swing => "SWING",
            Self::MotionSensingGame => "MOTION_SENSING_GAME",
            Self::ElectronicSports => "ELECTRONIC_SPORTS",
            Self::NintendoJustdance => "NINTENDO_JUSTDANCE",
            Self::Chess => "CHESS",
            Self::Draughts => "DRAUGHTS",
            Self::Weiqi => "WEIQI",
            Self::Bridge => "BRIDGE",
            Self::BoardGames => "BOARD_GAMES",
            Self::IndoorRockClimbing => "INDOOR_ROCK_CLIMBING",
            Self::OutdoorRockClimbing => "OUTDOOR_ROCK_CLIMBING",
            Self::Equesttrian => "EQUESTTRIAN",
            Self::TrackAndField => "TRACK_AND_FIELD",
            Self::RacingCar => "RACING_CAR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SportType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NONE",
            "RUN_OUTDOOR",
            "WALK_OUTDOOR",
            "RUN_INDOOR",
            "CLIMBING",
            "CROSS_COUNTRY",
            "RIDE_OUTDOOR",
            "RIDE_INDOOR",
            "FREE_TRAINING",
            "SWIM_INDOOR",
            "SWIM_OUTDOOR",
            "ELLIPTICAL_MACHINE",
            "YOGA",
            "ROWING_MACHINE",
            "ROPE_SKIPPING",
            "HIKING_OUTDOOR",
            "HIGH_INTERVAL_TRAINING",
            "TRIATHLON",
            "GENERAL_BALL",
            "BASKETBALL_S",
            "GOLF_S",
            "SKIING",
            "OUTDOOR_WALK_CATEGORY",
            "OUTDOOR_NON_WALK_CATEGORY",
            "ROCK_CLIMBING_S",
            "DIVING",
            "SAILBOAT",
            "PADDLE_BOARD",
            "WATER_POLO",
            "AQUATIC_SPORT",
            "SURFING",
            "CANOEING",
            "KAYAK_RAFTING",
            "ROWING",
            "MOTORBOAT",
            "WEB_SWIMMING",
            "DRIVING",
            "FANCY_SWIMMING",
            "SNORKELING",
            "KITE_SURFING",
            "INDOOR_SURFING",
            "DRAGON_BOAT",
            "FREE_DIVING",
            "SCUBA_DIVING",
            "INSTRUMENT_DIVING",
            "ROCK_CLIMBING",
            "SKATE",
            "ROLLER_SKATING",
            "PARKOUR",
            "ATV",
            "PARAGLIDER",
            "BICYCLE_MOTO",
            "HEEL_AND_TOE",
            "CLIMBING_MACHINE",
            "CLIMB_STAIRS",
            "STEPPER",
            "CORE_TRAINING",
            "FLEXIBILITY_TRAINING",
            "PILATES",
            "GYMNASTICS",
            "STRETCH",
            "STRENGTH_TRAINING",
            "CROSS_FIT",
            "AEROBICS",
            "PHYSICAL_TRAINING",
            "WALL_BALL",
            "DUMBBELL_TRAINING",
            "BARBELL_TRAINING",
            "WEIGHTLIFTING",
            "DEADLIFT",
            "BOBBY_JUMP",
            "SIT_UPS",
            "FUNCTIONAL_TRAINING",
            "UPPER_LIMB_TRAINING",
            "LOWER_LIMB_TRAINING",
            "WAIST_TRAINING",
            "BACK_TRAINING",
            "SPINNING",
            "WALKING_MACHINE",
            "STEP_TRAINING",
            "SINGLE_BAR",
            "PARALLEL_BARS",
            "GROUP_CALLISTHENICS",
            "STRIKE",
            "BATTLE_ROPE",
            "MIXED_AEROBIC",
            "WALK_INDOOR",
            "GYM",
            "SQUARE_DANCE",
            "BELLY_DANCE",
            "BALLET",
            "STREET_DANCE",
            "ZUMBA",
            "NATIONAL_DANCE",
            "JAZZ",
            "LATIN_DANCE",
            "HIP_HOP_DANCE",
            "POLE_DANCE",
            "BREAKDANCING",
            "SOCIAL_DANCING",
            "MODERN_DANCING",
            "DANCE",
            "BOXING",
            "WRESTLING",
            "MARTIAL_ARTS",
            "TAICHI",
            "MUAY_THAI",
            "JUDO",
            "TAEKWONDO",
            "KARATE",
            "FREE_SPARRING",
            "SWORDSMANSHIP",
            "FENCING",
            "JUJITSU",
            "FOOTBALL",
            "BASKETBALL",
            "VOLLEYBALL",
            "BASEBALL",
            "SOFTBALL",
            "RUGBY",
            "HOCKEY",
            "PINGPONG",
            "BADMINTON",
            "TENNIS",
            "CRICKET",
            "HANDBALL",
            "BOWLING",
            "SQUASH",
            "BILLIARDS",
            "SHUTTLECOCK",
            "BEACH_FOOTBALL",
            "BEACH_VOLLEYBALL",
            "SEPAK_TAKRAW",
            "GOLF",
            "FOOSBALL",
            "INDOOR_FOOTBALL",
            "SANDBAGS_BALL",
            "BOCCI",
            "HIHI_BALL",
            "GATEBALL",
            "DODGEBALL",
            "SHUFFLE_BALL",
            "OUTDOOR_SKATING",
            "CURLING",
            "SNOW_SPORTS",
            "SNOWMOBILE",
            "PUCK",
            "SNOW_CAR",
            "SLED",
            "INDOOR__SKATING",
            "SNOWBOARDING",
            "DOUBLE_BOARD_SKIING",
            "CROSS_COUNTRY_SKIING",
            "ARCHERY",
            "DARTS",
            "HORSE_RIDING",
            "TUG_OF_WAR",
            "HULA_HOOP",
            "FLY_KITE",
            "FISHING",
            "FRISBEE",
            "SHUTTLECOCK_KICKING",
            "SWING",
            "MOTION_SENSING_GAME",
            "ELECTRONIC_SPORTS",
            "NINTENDO_JUSTDANCE",
            "CHESS",
            "DRAUGHTS",
            "WEIQI",
            "BRIDGE",
            "BOARD_GAMES",
            "INDOOR_ROCK_CLIMBING",
            "OUTDOOR_ROCK_CLIMBING",
            "EQUESTTRIAN",
            "TRACK_AND_FIELD",
            "RACING_CAR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SportType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NONE" => Ok(SportType::None),
                    "RUN_OUTDOOR" => Ok(SportType::RunOutdoor),
                    "WALK_OUTDOOR" => Ok(SportType::WalkOutdoor),
                    "RUN_INDOOR" => Ok(SportType::RunIndoor),
                    "CLIMBING" => Ok(SportType::Climbing),
                    "CROSS_COUNTRY" => Ok(SportType::CrossCountry),
                    "RIDE_OUTDOOR" => Ok(SportType::RideOutdoor),
                    "RIDE_INDOOR" => Ok(SportType::RideIndoor),
                    "FREE_TRAINING" => Ok(SportType::FreeTraining),
                    "SWIM_INDOOR" => Ok(SportType::SwimIndoor),
                    "SWIM_OUTDOOR" => Ok(SportType::SwimOutdoor),
                    "ELLIPTICAL_MACHINE" => Ok(SportType::EllipticalMachine),
                    "YOGA" => Ok(SportType::Yoga),
                    "ROWING_MACHINE" => Ok(SportType::RowingMachine),
                    "ROPE_SKIPPING" => Ok(SportType::RopeSkipping),
                    "HIKING_OUTDOOR" => Ok(SportType::HikingOutdoor),
                    "HIGH_INTERVAL_TRAINING" => Ok(SportType::HighIntervalTraining),
                    "TRIATHLON" => Ok(SportType::Triathlon),
                    "GENERAL_BALL" => Ok(SportType::GeneralBall),
                    "BASKETBALL_S" => Ok(SportType::BasketballS),
                    "GOLF_S" => Ok(SportType::GolfS),
                    "SKIING" => Ok(SportType::Skiing),
                    "OUTDOOR_WALK_CATEGORY" => Ok(SportType::OutdoorWalkCategory),
                    "OUTDOOR_NON_WALK_CATEGORY" => Ok(SportType::OutdoorNonWalkCategory),
                    "ROCK_CLIMBING_S" => Ok(SportType::RockClimbingS),
                    "DIVING" => Ok(SportType::Diving),
                    "SAILBOAT" => Ok(SportType::Sailboat),
                    "PADDLE_BOARD" => Ok(SportType::PaddleBoard),
                    "WATER_POLO" => Ok(SportType::WaterPolo),
                    "AQUATIC_SPORT" => Ok(SportType::AquaticSport),
                    "SURFING" => Ok(SportType::Surfing),
                    "CANOEING" => Ok(SportType::Canoeing),
                    "KAYAK_RAFTING" => Ok(SportType::KayakRafting),
                    "ROWING" => Ok(SportType::Rowing),
                    "MOTORBOAT" => Ok(SportType::Motorboat),
                    "WEB_SWIMMING" => Ok(SportType::WebSwimming),
                    "DRIVING" => Ok(SportType::Driving),
                    "FANCY_SWIMMING" => Ok(SportType::FancySwimming),
                    "SNORKELING" => Ok(SportType::Snorkeling),
                    "KITE_SURFING" => Ok(SportType::KiteSurfing),
                    "INDOOR_SURFING" => Ok(SportType::IndoorSurfing),
                    "DRAGON_BOAT" => Ok(SportType::DragonBoat),
                    "FREE_DIVING" => Ok(SportType::FreeDiving),
                    "SCUBA_DIVING" => Ok(SportType::ScubaDiving),
                    "INSTRUMENT_DIVING" => Ok(SportType::InstrumentDiving),
                    "ROCK_CLIMBING" => Ok(SportType::RockClimbing),
                    "SKATE" => Ok(SportType::Skate),
                    "ROLLER_SKATING" => Ok(SportType::RollerSkating),
                    "PARKOUR" => Ok(SportType::Parkour),
                    "ATV" => Ok(SportType::Atv),
                    "PARAGLIDER" => Ok(SportType::Paraglider),
                    "BICYCLE_MOTO" => Ok(SportType::BicycleMoto),
                    "HEEL_AND_TOE" => Ok(SportType::HeelAndToe),
                    "CLIMBING_MACHINE" => Ok(SportType::ClimbingMachine),
                    "CLIMB_STAIRS" => Ok(SportType::ClimbStairs),
                    "STEPPER" => Ok(SportType::Stepper),
                    "CORE_TRAINING" => Ok(SportType::CoreTraining),
                    "FLEXIBILITY_TRAINING" => Ok(SportType::FlexibilityTraining),
                    "PILATES" => Ok(SportType::Pilates),
                    "GYMNASTICS" => Ok(SportType::Gymnastics),
                    "STRETCH" => Ok(SportType::Stretch),
                    "STRENGTH_TRAINING" => Ok(SportType::StrengthTraining),
                    "CROSS_FIT" => Ok(SportType::CrossFit),
                    "AEROBICS" => Ok(SportType::Aerobics),
                    "PHYSICAL_TRAINING" => Ok(SportType::PhysicalTraining),
                    "WALL_BALL" => Ok(SportType::WallBall),
                    "DUMBBELL_TRAINING" => Ok(SportType::DumbbellTraining),
                    "BARBELL_TRAINING" => Ok(SportType::BarbellTraining),
                    "WEIGHTLIFTING" => Ok(SportType::Weightlifting),
                    "DEADLIFT" => Ok(SportType::Deadlift),
                    "BOBBY_JUMP" => Ok(SportType::BobbyJump),
                    "SIT_UPS" => Ok(SportType::SitUps),
                    "FUNCTIONAL_TRAINING" => Ok(SportType::FunctionalTraining),
                    "UPPER_LIMB_TRAINING" => Ok(SportType::UpperLimbTraining),
                    "LOWER_LIMB_TRAINING" => Ok(SportType::LowerLimbTraining),
                    "WAIST_TRAINING" => Ok(SportType::WaistTraining),
                    "BACK_TRAINING" => Ok(SportType::BackTraining),
                    "SPINNING" => Ok(SportType::Spinning),
                    "WALKING_MACHINE" => Ok(SportType::WalkingMachine),
                    "STEP_TRAINING" => Ok(SportType::StepTraining),
                    "SINGLE_BAR" => Ok(SportType::SingleBar),
                    "PARALLEL_BARS" => Ok(SportType::ParallelBars),
                    "GROUP_CALLISTHENICS" => Ok(SportType::GroupCallisthenics),
                    "STRIKE" => Ok(SportType::Strike),
                    "BATTLE_ROPE" => Ok(SportType::BattleRope),
                    "MIXED_AEROBIC" => Ok(SportType::MixedAerobic),
                    "WALK_INDOOR" => Ok(SportType::WalkIndoor),
                    "GYM" => Ok(SportType::Gym),
                    "SQUARE_DANCE" => Ok(SportType::SquareDance),
                    "BELLY_DANCE" => Ok(SportType::BellyDance),
                    "BALLET" => Ok(SportType::Ballet),
                    "STREET_DANCE" => Ok(SportType::StreetDance),
                    "ZUMBA" => Ok(SportType::Zumba),
                    "NATIONAL_DANCE" => Ok(SportType::NationalDance),
                    "JAZZ" => Ok(SportType::Jazz),
                    "LATIN_DANCE" => Ok(SportType::LatinDance),
                    "HIP_HOP_DANCE" => Ok(SportType::HipHopDance),
                    "POLE_DANCE" => Ok(SportType::PoleDance),
                    "BREAKDANCING" => Ok(SportType::Breakdancing),
                    "SOCIAL_DANCING" => Ok(SportType::SocialDancing),
                    "MODERN_DANCING" => Ok(SportType::ModernDancing),
                    "DANCE" => Ok(SportType::Dance),
                    "BOXING" => Ok(SportType::Boxing),
                    "WRESTLING" => Ok(SportType::Wrestling),
                    "MARTIAL_ARTS" => Ok(SportType::MartialArts),
                    "TAICHI" => Ok(SportType::Taichi),
                    "MUAY_THAI" => Ok(SportType::MuayThai),
                    "JUDO" => Ok(SportType::Judo),
                    "TAEKWONDO" => Ok(SportType::Taekwondo),
                    "KARATE" => Ok(SportType::Karate),
                    "FREE_SPARRING" => Ok(SportType::FreeSparring),
                    "SWORDSMANSHIP" => Ok(SportType::Swordsmanship),
                    "FENCING" => Ok(SportType::Fencing),
                    "JUJITSU" => Ok(SportType::Jujitsu),
                    "FOOTBALL" => Ok(SportType::Football),
                    "BASKETBALL" => Ok(SportType::Basketball),
                    "VOLLEYBALL" => Ok(SportType::Volleyball),
                    "BASEBALL" => Ok(SportType::Baseball),
                    "SOFTBALL" => Ok(SportType::Softball),
                    "RUGBY" => Ok(SportType::Rugby),
                    "HOCKEY" => Ok(SportType::Hockey),
                    "PINGPONG" => Ok(SportType::Pingpong),
                    "BADMINTON" => Ok(SportType::Badminton),
                    "TENNIS" => Ok(SportType::Tennis),
                    "CRICKET" => Ok(SportType::Cricket),
                    "HANDBALL" => Ok(SportType::Handball),
                    "BOWLING" => Ok(SportType::Bowling),
                    "SQUASH" => Ok(SportType::Squash),
                    "BILLIARDS" => Ok(SportType::Billiards),
                    "SHUTTLECOCK" => Ok(SportType::Shuttlecock),
                    "BEACH_FOOTBALL" => Ok(SportType::BeachFootball),
                    "BEACH_VOLLEYBALL" => Ok(SportType::BeachVolleyball),
                    "SEPAK_TAKRAW" => Ok(SportType::SepakTakraw),
                    "GOLF" => Ok(SportType::Golf),
                    "FOOSBALL" => Ok(SportType::Foosball),
                    "INDOOR_FOOTBALL" => Ok(SportType::IndoorFootball),
                    "SANDBAGS_BALL" => Ok(SportType::SandbagsBall),
                    "BOCCI" => Ok(SportType::Bocci),
                    "HIHI_BALL" => Ok(SportType::HihiBall),
                    "GATEBALL" => Ok(SportType::Gateball),
                    "DODGEBALL" => Ok(SportType::Dodgeball),
                    "SHUFFLE_BALL" => Ok(SportType::ShuffleBall),
                    "OUTDOOR_SKATING" => Ok(SportType::OutdoorSkating),
                    "CURLING" => Ok(SportType::Curling),
                    "SNOW_SPORTS" => Ok(SportType::SnowSports),
                    "SNOWMOBILE" => Ok(SportType::Snowmobile),
                    "PUCK" => Ok(SportType::Puck),
                    "SNOW_CAR" => Ok(SportType::SnowCar),
                    "SLED" => Ok(SportType::Sled),
                    "INDOOR__SKATING" => Ok(SportType::IndoorSkating),
                    "SNOWBOARDING" => Ok(SportType::Snowboarding),
                    "DOUBLE_BOARD_SKIING" => Ok(SportType::DoubleBoardSkiing),
                    "CROSS_COUNTRY_SKIING" => Ok(SportType::CrossCountrySkiing),
                    "ARCHERY" => Ok(SportType::Archery),
                    "DARTS" => Ok(SportType::Darts),
                    "HORSE_RIDING" => Ok(SportType::HorseRiding),
                    "TUG_OF_WAR" => Ok(SportType::TugOfWar),
                    "HULA_HOOP" => Ok(SportType::HulaHoop),
                    "FLY_KITE" => Ok(SportType::FlyKite),
                    "FISHING" => Ok(SportType::Fishing),
                    "FRISBEE" => Ok(SportType::Frisbee),
                    "SHUTTLECOCK_KICKING" => Ok(SportType::ShuttlecockKicking),
                    "SWING" => Ok(SportType::Swing),
                    "MOTION_SENSING_GAME" => Ok(SportType::MotionSensingGame),
                    "ELECTRONIC_SPORTS" => Ok(SportType::ElectronicSports),
                    "NINTENDO_JUSTDANCE" => Ok(SportType::NintendoJustdance),
                    "CHESS" => Ok(SportType::Chess),
                    "DRAUGHTS" => Ok(SportType::Draughts),
                    "WEIQI" => Ok(SportType::Weiqi),
                    "BRIDGE" => Ok(SportType::Bridge),
                    "BOARD_GAMES" => Ok(SportType::BoardGames),
                    "INDOOR_ROCK_CLIMBING" => Ok(SportType::IndoorRockClimbing),
                    "OUTDOOR_ROCK_CLIMBING" => Ok(SportType::OutdoorRockClimbing),
                    "EQUESTTRIAN" => Ok(SportType::Equesttrian),
                    "TRACK_AND_FIELD" => Ok(SportType::TrackAndField),
                    "RACING_CAR" => Ok(SportType::RacingCar),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Stock {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Stock", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                stock::Payload::StockInfo(v) => {
                    struct_ser.serialize_field("stockInfo", v)?;
                }
                stock::Payload::StockInfoList(v) => {
                    struct_ser.serialize_field("stockInfoList", v)?;
                }
                stock::Payload::Symbol(v) => {
                    struct_ser.serialize_field("symbol", v)?;
                }
                stock::Payload::StockSymbolList(v) => {
                    struct_ser.serialize_field("stockSymbolList", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Stock {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "stock_info",
            "stockInfo",
            "stock_info_list",
            "stockInfoList",
            "symbol",
            "stock_symbol_list",
            "stockSymbolList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StockInfo,
            StockInfoList,
            Symbol,
            StockSymbolList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "stockInfo" | "stock_info" => Ok(GeneratedField::StockInfo),
                            "stockInfoList" | "stock_info_list" => Ok(GeneratedField::StockInfoList),
                            "symbol" => Ok(GeneratedField::Symbol),
                            "stockSymbolList" | "stock_symbol_list" => Ok(GeneratedField::StockSymbolList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Stock;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Stock")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Stock, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StockInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stockInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(stock::Payload::StockInfo)
;
                        }
                        GeneratedField::StockInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stockInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(stock::Payload::StockInfoList)
;
                        }
                        GeneratedField::Symbol => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("symbol"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(stock::Payload::Symbol);
                        }
                        GeneratedField::StockSymbolList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stockSymbolList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(stock::Payload::StockSymbolList)
;
                        }
                    }
                }
                Ok(Stock {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Stock", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for stock::StockId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SyncStockInfo => "SYNC_STOCK_INFO",
            Self::SyncStockInfoList => "SYNC_STOCK_INFO_LIST",
            Self::DeleteStock => "DELETE_STOCK",
            Self::SetStockList => "SET_STOCK_LIST",
            Self::GetStockList => "GET_STOCK_LIST",
            Self::WearRequest => "WEAR_REQUEST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for stock::StockId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SYNC_STOCK_INFO",
            "SYNC_STOCK_INFO_LIST",
            "DELETE_STOCK",
            "SET_STOCK_LIST",
            "GET_STOCK_LIST",
            "WEAR_REQUEST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = stock::StockId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SYNC_STOCK_INFO" => Ok(stock::StockId::SyncStockInfo),
                    "SYNC_STOCK_INFO_LIST" => Ok(stock::StockId::SyncStockInfoList),
                    "DELETE_STOCK" => Ok(stock::StockId::DeleteStock),
                    "SET_STOCK_LIST" => Ok(stock::StockId::SetStockList),
                    "GET_STOCK_LIST" => Ok(stock::StockId::GetStockList),
                    "WEAR_REQUEST" => Ok(stock::StockId::WearRequest),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for StockInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 8;
        let mut struct_ser = serializer.serialize_struct("protocol.StockInfo", len)?;
        struct_ser.serialize_field("symbol", &self.symbol)?;
        struct_ser.serialize_field("market", &self.market)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("latestPrice", &self.latest_price)?;
        struct_ser.serialize_field("preClose", &self.pre_close)?;
        struct_ser.serialize_field("halted", &self.halted)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("delayMintue", &self.delay_mintue)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StockInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "symbol",
            "market",
            "name",
            "latest_price",
            "latestPrice",
            "pre_close",
            "preClose",
            "halted",
            "timestamp",
            "delay_mintue",
            "delayMintue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Symbol,
            Market,
            Name,
            LatestPrice,
            PreClose,
            Halted,
            Timestamp,
            DelayMintue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "symbol" => Ok(GeneratedField::Symbol),
                            "market" => Ok(GeneratedField::Market),
                            "name" => Ok(GeneratedField::Name),
                            "latestPrice" | "latest_price" => Ok(GeneratedField::LatestPrice),
                            "preClose" | "pre_close" => Ok(GeneratedField::PreClose),
                            "halted" => Ok(GeneratedField::Halted),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "delayMintue" | "delay_mintue" => Ok(GeneratedField::DelayMintue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StockInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.StockInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StockInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut symbol__ = None;
                let mut market__ = None;
                let mut name__ = None;
                let mut latest_price__ = None;
                let mut pre_close__ = None;
                let mut halted__ = None;
                let mut timestamp__ = None;
                let mut delay_mintue__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Symbol => {
                            if symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("symbol"));
                            }
                            symbol__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Market => {
                            if market__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            market__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LatestPrice => {
                            if latest_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("latestPrice"));
                            }
                            latest_price__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::PreClose => {
                            if pre_close__.is_some() {
                                return Err(serde::de::Error::duplicate_field("preClose"));
                            }
                            pre_close__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Halted => {
                            if halted__.is_some() {
                                return Err(serde::de::Error::duplicate_field("halted"));
                            }
                            halted__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DelayMintue => {
                            if delay_mintue__.is_some() {
                                return Err(serde::de::Error::duplicate_field("delayMintue"));
                            }
                            delay_mintue__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(StockInfo {
                    symbol: symbol__.ok_or_else(|| serde::de::Error::missing_field("symbol"))?,
                    market: market__.ok_or_else(|| serde::de::Error::missing_field("market"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    latest_price: latest_price__.ok_or_else(|| serde::de::Error::missing_field("latestPrice"))?,
                    pre_close: pre_close__.ok_or_else(|| serde::de::Error::missing_field("preClose"))?,
                    halted: halted__.ok_or_else(|| serde::de::Error::missing_field("halted"))?,
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    delay_mintue: delay_mintue__.ok_or_else(|| serde::de::Error::missing_field("delayMintue"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.StockInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for stock_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.StockInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for stock_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = stock_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.StockInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<stock_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(stock_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.StockInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StockSymbol {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.StockSymbol", len)?;
        struct_ser.serialize_field("symbol", &self.symbol)?;
        struct_ser.serialize_field("isWidget", &self.is_widget)?;
        struct_ser.serialize_field("order", &self.order)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StockSymbol {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "symbol",
            "is_widget",
            "isWidget",
            "order",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Symbol,
            IsWidget,
            Order,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "symbol" => Ok(GeneratedField::Symbol),
                            "isWidget" | "is_widget" => Ok(GeneratedField::IsWidget),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StockSymbol;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.StockSymbol")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StockSymbol, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut symbol__ = None;
                let mut is_widget__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Symbol => {
                            if symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("symbol"));
                            }
                            symbol__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsWidget => {
                            if is_widget__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isWidget"));
                            }
                            is_widget__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(StockSymbol {
                    symbol: symbol__.ok_or_else(|| serde::de::Error::missing_field("symbol"))?,
                    is_widget: is_widget__.ok_or_else(|| serde::de::Error::missing_field("isWidget"))?,
                    order: order__.ok_or_else(|| serde::de::Error::missing_field("order"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.StockSymbol", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for stock_symbol::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.StockSymbol.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for stock_symbol::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = stock_symbol::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.StockSymbol.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<stock_symbol::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(stock_symbol::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.StockSymbol.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StorageInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.StorageInfo", len)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("used", ToString::to_string(&self.used).as_str())?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("total", ToString::to_string(&self.total).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StorageInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "used",
            "total",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Used,
            Total,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "used" => Ok(GeneratedField::Used),
                            "total" => Ok(GeneratedField::Total),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StorageInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.StorageInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StorageInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut used__ = None;
                let mut total__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Used => {
                            if used__.is_some() {
                                return Err(serde::de::Error::duplicate_field("used"));
                            }
                            used__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Total => {
                            if total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("total"));
                            }
                            total__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(StorageInfo {
                    used: used__.ok_or_else(|| serde::de::Error::missing_field("used"))?,
                    total: total__.ok_or_else(|| serde::de::Error::missing_field("total"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.StorageInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SunRiseSet {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SunRiseSet", len)?;
        struct_ser.serialize_field("sunRise", &self.sun_rise)?;
        struct_ser.serialize_field("sunSet", &self.sun_set)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SunRiseSet {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sun_rise",
            "sunRise",
            "sun_set",
            "sunSet",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SunRise,
            SunSet,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sunRise" | "sun_rise" => Ok(GeneratedField::SunRise),
                            "sunSet" | "sun_set" => Ok(GeneratedField::SunSet),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SunRiseSet;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SunRiseSet")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SunRiseSet, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sun_rise__ = None;
                let mut sun_set__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SunRise => {
                            if sun_rise__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sunRise"));
                            }
                            sun_rise__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SunSet => {
                            if sun_set__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sunSet"));
                            }
                            sun_set__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SunRiseSet {
                    sun_rise: sun_rise__.ok_or_else(|| serde::de::Error::missing_field("sunRise"))?,
                    sun_set: sun_set__.ok_or_else(|| serde::de::Error::missing_field("sunSet"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SunRiseSet", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SuperCardData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.sectors.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SuperCardData", len)?;
        struct_ser.serialize_field("basicCardData", &self.basic_card_data)?;
        if !self.sectors.is_empty() {
            struct_ser.serialize_field("sectors", &self.sectors)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SuperCardData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_card_data",
            "basicCardData",
            "sectors",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicCardData,
            Sectors,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicCardData" | "basic_card_data" => Ok(GeneratedField::BasicCardData),
                            "sectors" => Ok(GeneratedField::Sectors),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SuperCardData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SuperCardData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SuperCardData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_card_data__ = None;
                let mut sectors__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicCardData => {
                            if basic_card_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicCardData"));
                            }
                            basic_card_data__ = map_.next_value()?;
                        }
                        GeneratedField::Sectors => {
                            if sectors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sectors"));
                            }
                            sectors__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SuperCardData {
                    basic_card_data: basic_card_data__.ok_or_else(|| serde::de::Error::missing_field("basicCardData"))?,
                    sectors: sectors__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SuperCardData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SwitchItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SwitchItem", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("status", &self.status)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SwitchItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "status",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Status,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "status" => Ok(GeneratedField::Status),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SwitchItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SwitchItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SwitchItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SwitchItem {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SwitchItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for switch_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SwitchItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for switch_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = switch_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SwitchItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<switch_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(switch_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.SwitchItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SwitchPanelType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "SwitchPanelType_UNKNOWN",
            Self::Default => "DEFAULT",
            Self::Countdown => "COUNTDOWN",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SwitchPanelType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SwitchPanelType_UNKNOWN",
            "DEFAULT",
            "COUNTDOWN",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SwitchPanelType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SwitchPanelType_UNKNOWN" => Ok(SwitchPanelType::Unknown),
                    "DEFAULT" => Ok(SwitchPanelType::Default),
                    "COUNTDOWN" => Ok(SwitchPanelType::Countdown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SyncParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SyncParam", len)?;
        struct_ser.serialize_field("reason", &self.reason)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reason",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Reason,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reason" => Ok(GeneratedField::Reason),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SyncParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reason__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(SyncParam {
                    reason: reason__.ok_or_else(|| serde::de::Error::missing_field("reason"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SyncParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for System {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.System", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                system::Payload::ResetMode(v) => {
                    let v = ResetMode::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("resetMode", &v)?;
                }
                system::Payload::DeviceStatus(v) => {
                    struct_ser.serialize_field("deviceStatus", v)?;
                }
                system::Payload::DeviceInfo(v) => {
                    struct_ser.serialize_field("deviceInfo", v)?;
                }
                system::Payload::SystemTime(v) => {
                    struct_ser.serialize_field("systemTime", v)?;
                }
                system::Payload::FindMode(v) => {
                    let v = FindMode::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("findMode", &v)?;
                }
                system::Payload::ForceUpgrade(v) => {
                    struct_ser.serialize_field("forceUpgrade", v)?;
                }
                system::Payload::WristScreen(v) => {
                    struct_ser.serialize_field("wristScreen", v)?;
                }
                system::Payload::Widget(v) => {
                    struct_ser.serialize_field("widget", v)?;
                }
                system::Payload::WidgetList(v) => {
                    struct_ser.serialize_field("widgetList", v)?;
                }
                system::Payload::AppList(v) => {
                    struct_ser.serialize_field("appList", v)?;
                }
                system::Payload::TimingSetting(v) => {
                    struct_ser.serialize_field("timingSetting", v)?;
                }
                system::Payload::Shortcut(v) => {
                    struct_ser.serialize_field("shortcut", v)?;
                }
                system::Payload::ShortcutList(v) => {
                    struct_ser.serialize_field("shortcutList", v)?;
                }
                system::Payload::SportOptionList(v) => {
                    struct_ser.serialize_field("sportOptionList", v)?;
                }
                system::Payload::HidStatus(v) => {
                    struct_ser.serialize_field("hidStatus", v)?;
                }
                system::Payload::PrepareOtaRequest(v) => {
                    struct_ser.serialize_field("prepareOtaRequest", v)?;
                }
                system::Payload::PrepareOtaResponse(v) => {
                    struct_ser.serialize_field("prepareOtaResponse", v)?;
                }
                system::Payload::AppLayout(v) => {
                    struct_ser.serialize_field("appLayout", v)?;
                }
                system::Payload::LockScreen(v) => {
                    struct_ser.serialize_field("lockScreen", v)?;
                }
                system::Payload::Language(v) => {
                    struct_ser.serialize_field("language", v)?;
                }
                system::Payload::AuthorizeUnlockList(v) => {
                    struct_ser.serialize_field("authorizeUnlockList", v)?;
                }
                system::Payload::AuthorizeUnlock(v) => {
                    struct_ser.serialize_field("authorizeUnlock", v)?;
                }
                system::Payload::NightMode(v) => {
                    struct_ser.serialize_field("nightMode", v)?;
                }
                system::Payload::SmallHabit(v) => {
                    struct_ser.serialize_field("smallHabit", v)?;
                }
                system::Payload::SmallHabitList(v) => {
                    struct_ser.serialize_field("smallHabitList", v)?;
                }
                system::Payload::SmallHabitType(v) => {
                    let v = small_habit::Type::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("smallHabitType", &v)?;
                }
                system::Payload::SmallHabitTypeList(v) => {
                    struct_ser.serialize_field("smallHabitTypeList", v)?;
                }
                system::Payload::WidgetGroupList(v) => {
                    struct_ser.serialize_field("widgetGroupList", v)?;
                }
                system::Payload::WidgetV2List(v) => {
                    struct_ser.serialize_field("widgetV2List", v)?;
                }
                system::Payload::WifiCapability(v) => {
                    struct_ser.serialize_field("wifiCapability", v)?;
                }
                system::Payload::WifiBasicInfo(v) => {
                    struct_ser.serialize_field("wifiBasicInfo", v)?;
                }
                system::Payload::WifiConfig(v) => {
                    struct_ser.serialize_field("wifiConfig", v)?;
                }
                system::Payload::WifiConfigList(v) => {
                    struct_ser.serialize_field("wifiConfigList", v)?;
                }
                system::Payload::SystemSettingRequest(v) => {
                    struct_ser.serialize_field("systemSettingRequest", v)?;
                }
                system::Payload::SystemSetting(v) => {
                    struct_ser.serialize_field("systemSetting", v)?;
                }
                system::Payload::PhoneSettingRequest(v) => {
                    struct_ser.serialize_field("phoneSettingRequest", v)?;
                }
                system::Payload::PhoneSetting(v) => {
                    struct_ser.serialize_field("phoneSetting", v)?;
                }
                system::Payload::VibratorSetting(v) => {
                    struct_ser.serialize_field("vibratorSetting", v)?;
                }
                system::Payload::VibratorItem(v) => {
                    struct_ser.serialize_field("VibratorItem", v)?;
                }
                system::Payload::Vibrator(v) => {
                    struct_ser.serialize_field("Vibrator", v)?;
                }
                system::Payload::VibratorEffect(v) => {
                    struct_ser.serialize_field("vibratorEffect", v)?;
                }
                system::Payload::VibratorRemoval(v) => {
                    struct_ser.serialize_field("vibratorRemoval", v)?;
                }
                system::Payload::VibratorError(v) => {
                    struct_ser.serialize_field("vibratorError", v)?;
                }
                system::Payload::StorageInfo(v) => {
                    struct_ser.serialize_field("storageInfo", v)?;
                }
                system::Payload::PhonePermission(v) => {
                    struct_ser.serialize_field("phonePermission", v)?;
                }
                system::Payload::LowLatency(v) => {
                    struct_ser.serialize_field("lowLatency", v)?;
                }
                system::Payload::PresentBasicStatus(v) => {
                    struct_ser.serialize_field("presentBasicStatus", v)?;
                }
                system::Payload::ReportBasicStatus(v) => {
                    struct_ser.serialize_field("reportBasicStatus", v)?;
                }
                system::Payload::ReportData(v) => {
                    struct_ser.serialize_field("reportData", v)?;
                }
                system::Payload::ReportDataResult(v) => {
                    struct_ser.serialize_field("reportDataResult", v)?;
                }
                system::Payload::NetworkProxyRequest(v) => {
                    struct_ser.serialize_field("networkProxyRequest", v)?;
                }
                system::Payload::WidgetV3(v) => {
                    struct_ser.serialize_field("widgetV3", v)?;
                }
                system::Payload::WidgetV3SupportedList(v) => {
                    struct_ser.serialize_field("widgetV3SupportedList", v)?;
                }
                system::Payload::OtaProgress(v) => {
                    struct_ser.serialize_field("otaProgress", v)?;
                }
                system::Payload::WifiApResult(v) => {
                    struct_ser.serialize_field("wifiApResult", v)?;
                }
                system::Payload::WifiAp(v) => {
                    struct_ser.serialize_field("wifiAp", v)?;
                }
                system::Payload::AlertStatus(v) => {
                    struct_ser.serialize_field("alertStatus", v)?;
                }
                system::Payload::NetworkStatus(v) => {
                    struct_ser.serialize_field("networkStatus", v)?;
                }
                system::Payload::WearStatus(v) => {
                    let v = basic_status::Wearing::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("wearStatus", &v)?;
                }
                system::Payload::UsageGuide(v) => {
                    struct_ser.serialize_field("usageGuide", v)?;
                }
                system::Payload::GuideFeedback(v) => {
                    struct_ser.serialize_field("guideFeedback", v)?;
                }
                system::Payload::BatteryStatus(v) => {
                    struct_ser.serialize_field("batteryStatus", v)?;
                }
                system::Payload::WifiConfigResult(v) => {
                    struct_ser.serialize_field("wifiConfigResult", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for System {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reset_mode",
            "resetMode",
            "device_status",
            "deviceStatus",
            "device_info",
            "deviceInfo",
            "system_time",
            "systemTime",
            "find_mode",
            "findMode",
            "force_upgrade",
            "forceUpgrade",
            "wrist_screen",
            "wristScreen",
            "widget",
            "widget_list",
            "widgetList",
            "app_list",
            "appList",
            "timing_setting",
            "timingSetting",
            "shortcut",
            "shortcut_list",
            "shortcutList",
            "sport_option_list",
            "sportOptionList",
            "hid_status",
            "hidStatus",
            "prepare_ota_request",
            "prepareOtaRequest",
            "prepare_ota_response",
            "prepareOtaResponse",
            "app_layout",
            "appLayout",
            "lock_screen",
            "lockScreen",
            "language",
            "authorize_unlock_list",
            "authorizeUnlockList",
            "authorize_unlock",
            "authorizeUnlock",
            "night_mode",
            "nightMode",
            "small_habit",
            "smallHabit",
            "small_habit_list",
            "smallHabitList",
            "small_habit_type",
            "smallHabitType",
            "small_habit_type_list",
            "smallHabitTypeList",
            "widget_group_list",
            "widgetGroupList",
            "widget_v2_list",
            "widgetV2List",
            "wifi_capability",
            "wifiCapability",
            "wifi_basic_info",
            "wifiBasicInfo",
            "wifi_config",
            "wifiConfig",
            "wifi_config_list",
            "wifiConfigList",
            "system_setting_request",
            "systemSettingRequest",
            "system_setting",
            "systemSetting",
            "phone_setting_request",
            "phoneSettingRequest",
            "phone_setting",
            "phoneSetting",
            "vibrator_setting",
            "vibratorSetting",
            "Vibrator_item",
            "VibratorItem",
            "Vibrator",
            "vibrator_effect",
            "vibratorEffect",
            "vibrator_removal",
            "vibratorRemoval",
            "vibrator_error",
            "vibratorError",
            "storage_info",
            "storageInfo",
            "phone_permission",
            "phonePermission",
            "low_latency",
            "lowLatency",
            "present_basic_status",
            "presentBasicStatus",
            "report_basic_status",
            "reportBasicStatus",
            "report_data",
            "reportData",
            "report_data_result",
            "reportDataResult",
            "network_proxy_request",
            "networkProxyRequest",
            "widget_v3",
            "widgetV3",
            "widget_v3_supported_list",
            "widgetV3SupportedList",
            "ota_progress",
            "otaProgress",
            "wifi_ap_result",
            "wifiApResult",
            "wifi_ap",
            "wifiAp",
            "alert_status",
            "alertStatus",
            "network_status",
            "networkStatus",
            "wear_status",
            "wearStatus",
            "usage_guide",
            "usageGuide",
            "guide_feedback",
            "guideFeedback",
            "battery_status",
            "batteryStatus",
            "wifi_config_result",
            "wifiConfigResult",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResetMode,
            DeviceStatus,
            DeviceInfo,
            SystemTime,
            FindMode,
            ForceUpgrade,
            WristScreen,
            Widget,
            WidgetList,
            AppList,
            TimingSetting,
            Shortcut,
            ShortcutList,
            SportOptionList,
            HidStatus,
            PrepareOtaRequest,
            PrepareOtaResponse,
            AppLayout,
            LockScreen,
            Language,
            AuthorizeUnlockList,
            AuthorizeUnlock,
            NightMode,
            SmallHabit,
            SmallHabitList,
            SmallHabitType,
            SmallHabitTypeList,
            WidgetGroupList,
            WidgetV2List,
            WifiCapability,
            WifiBasicInfo,
            WifiConfig,
            WifiConfigList,
            SystemSettingRequest,
            SystemSetting,
            PhoneSettingRequest,
            PhoneSetting,
            VibratorSetting,
            VibratorItem,
            Vibrator,
            VibratorEffect,
            VibratorRemoval,
            VibratorError,
            StorageInfo,
            PhonePermission,
            LowLatency,
            PresentBasicStatus,
            ReportBasicStatus,
            ReportData,
            ReportDataResult,
            NetworkProxyRequest,
            WidgetV3,
            WidgetV3SupportedList,
            OtaProgress,
            WifiApResult,
            WifiAp,
            AlertStatus,
            NetworkStatus,
            WearStatus,
            UsageGuide,
            GuideFeedback,
            BatteryStatus,
            WifiConfigResult,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "resetMode" | "reset_mode" => Ok(GeneratedField::ResetMode),
                            "deviceStatus" | "device_status" => Ok(GeneratedField::DeviceStatus),
                            "deviceInfo" | "device_info" => Ok(GeneratedField::DeviceInfo),
                            "systemTime" | "system_time" => Ok(GeneratedField::SystemTime),
                            "findMode" | "find_mode" => Ok(GeneratedField::FindMode),
                            "forceUpgrade" | "force_upgrade" => Ok(GeneratedField::ForceUpgrade),
                            "wristScreen" | "wrist_screen" => Ok(GeneratedField::WristScreen),
                            "widget" => Ok(GeneratedField::Widget),
                            "widgetList" | "widget_list" => Ok(GeneratedField::WidgetList),
                            "appList" | "app_list" => Ok(GeneratedField::AppList),
                            "timingSetting" | "timing_setting" => Ok(GeneratedField::TimingSetting),
                            "shortcut" => Ok(GeneratedField::Shortcut),
                            "shortcutList" | "shortcut_list" => Ok(GeneratedField::ShortcutList),
                            "sportOptionList" | "sport_option_list" => Ok(GeneratedField::SportOptionList),
                            "hidStatus" | "hid_status" => Ok(GeneratedField::HidStatus),
                            "prepareOtaRequest" | "prepare_ota_request" => Ok(GeneratedField::PrepareOtaRequest),
                            "prepareOtaResponse" | "prepare_ota_response" => Ok(GeneratedField::PrepareOtaResponse),
                            "appLayout" | "app_layout" => Ok(GeneratedField::AppLayout),
                            "lockScreen" | "lock_screen" => Ok(GeneratedField::LockScreen),
                            "language" => Ok(GeneratedField::Language),
                            "authorizeUnlockList" | "authorize_unlock_list" => Ok(GeneratedField::AuthorizeUnlockList),
                            "authorizeUnlock" | "authorize_unlock" => Ok(GeneratedField::AuthorizeUnlock),
                            "nightMode" | "night_mode" => Ok(GeneratedField::NightMode),
                            "smallHabit" | "small_habit" => Ok(GeneratedField::SmallHabit),
                            "smallHabitList" | "small_habit_list" => Ok(GeneratedField::SmallHabitList),
                            "smallHabitType" | "small_habit_type" => Ok(GeneratedField::SmallHabitType),
                            "smallHabitTypeList" | "small_habit_type_list" => Ok(GeneratedField::SmallHabitTypeList),
                            "widgetGroupList" | "widget_group_list" => Ok(GeneratedField::WidgetGroupList),
                            "widgetV2List" | "widget_v2_list" => Ok(GeneratedField::WidgetV2List),
                            "wifiCapability" | "wifi_capability" => Ok(GeneratedField::WifiCapability),
                            "wifiBasicInfo" | "wifi_basic_info" => Ok(GeneratedField::WifiBasicInfo),
                            "wifiConfig" | "wifi_config" => Ok(GeneratedField::WifiConfig),
                            "wifiConfigList" | "wifi_config_list" => Ok(GeneratedField::WifiConfigList),
                            "systemSettingRequest" | "system_setting_request" => Ok(GeneratedField::SystemSettingRequest),
                            "systemSetting" | "system_setting" => Ok(GeneratedField::SystemSetting),
                            "phoneSettingRequest" | "phone_setting_request" => Ok(GeneratedField::PhoneSettingRequest),
                            "phoneSetting" | "phone_setting" => Ok(GeneratedField::PhoneSetting),
                            "vibratorSetting" | "vibrator_setting" => Ok(GeneratedField::VibratorSetting),
                            "VibratorItem" | "Vibrator_item" => Ok(GeneratedField::VibratorItem),
                            "Vibrator" => Ok(GeneratedField::Vibrator),
                            "vibratorEffect" | "vibrator_effect" => Ok(GeneratedField::VibratorEffect),
                            "vibratorRemoval" | "vibrator_removal" => Ok(GeneratedField::VibratorRemoval),
                            "vibratorError" | "vibrator_error" => Ok(GeneratedField::VibratorError),
                            "storageInfo" | "storage_info" => Ok(GeneratedField::StorageInfo),
                            "phonePermission" | "phone_permission" => Ok(GeneratedField::PhonePermission),
                            "lowLatency" | "low_latency" => Ok(GeneratedField::LowLatency),
                            "presentBasicStatus" | "present_basic_status" => Ok(GeneratedField::PresentBasicStatus),
                            "reportBasicStatus" | "report_basic_status" => Ok(GeneratedField::ReportBasicStatus),
                            "reportData" | "report_data" => Ok(GeneratedField::ReportData),
                            "reportDataResult" | "report_data_result" => Ok(GeneratedField::ReportDataResult),
                            "networkProxyRequest" | "network_proxy_request" => Ok(GeneratedField::NetworkProxyRequest),
                            "widgetV3" | "widget_v3" => Ok(GeneratedField::WidgetV3),
                            "widgetV3SupportedList" | "widget_v3_supported_list" => Ok(GeneratedField::WidgetV3SupportedList),
                            "otaProgress" | "ota_progress" => Ok(GeneratedField::OtaProgress),
                            "wifiApResult" | "wifi_ap_result" => Ok(GeneratedField::WifiApResult),
                            "wifiAp" | "wifi_ap" => Ok(GeneratedField::WifiAp),
                            "alertStatus" | "alert_status" => Ok(GeneratedField::AlertStatus),
                            "networkStatus" | "network_status" => Ok(GeneratedField::NetworkStatus),
                            "wearStatus" | "wear_status" => Ok(GeneratedField::WearStatus),
                            "usageGuide" | "usage_guide" => Ok(GeneratedField::UsageGuide),
                            "guideFeedback" | "guide_feedback" => Ok(GeneratedField::GuideFeedback),
                            "batteryStatus" | "battery_status" => Ok(GeneratedField::BatteryStatus),
                            "wifiConfigResult" | "wifi_config_result" => Ok(GeneratedField::WifiConfigResult),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = System;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.System")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<System, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResetMode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("resetMode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<ResetMode>>()?.map(|x| system::Payload::ResetMode(x as i32));
                        }
                        GeneratedField::DeviceStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::DeviceStatus)
;
                        }
                        GeneratedField::DeviceInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::DeviceInfo)
;
                        }
                        GeneratedField::SystemTime => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemTime"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SystemTime)
;
                        }
                        GeneratedField::FindMode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("findMode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<FindMode>>()?.map(|x| system::Payload::FindMode(x as i32));
                        }
                        GeneratedField::ForceUpgrade => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("forceUpgrade"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::ForceUpgrade)
;
                        }
                        GeneratedField::WristScreen => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wristScreen"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WristScreen)
;
                        }
                        GeneratedField::Widget => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widget"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::Widget)
;
                        }
                        GeneratedField::WidgetList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgetList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WidgetList)
;
                        }
                        GeneratedField::AppList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::AppList)
;
                        }
                        GeneratedField::TimingSetting => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timingSetting"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::TimingSetting)
;
                        }
                        GeneratedField::Shortcut => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shortcut"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::Shortcut)
;
                        }
                        GeneratedField::ShortcutList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shortcutList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::ShortcutList)
;
                        }
                        GeneratedField::SportOptionList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportOptionList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SportOptionList)
;
                        }
                        GeneratedField::HidStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hidStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::HidStatus)
;
                        }
                        GeneratedField::PrepareOtaRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareOtaRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::PrepareOtaRequest)
;
                        }
                        GeneratedField::PrepareOtaResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareOtaResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::PrepareOtaResponse)
;
                        }
                        GeneratedField::AppLayout => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appLayout"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::AppLayout)
;
                        }
                        GeneratedField::LockScreen => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lockScreen"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::LockScreen)
;
                        }
                        GeneratedField::Language => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("language"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::Language)
;
                        }
                        GeneratedField::AuthorizeUnlockList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authorizeUnlockList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::AuthorizeUnlockList)
;
                        }
                        GeneratedField::AuthorizeUnlock => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authorizeUnlock"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::AuthorizeUnlock)
;
                        }
                        GeneratedField::NightMode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nightMode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::NightMode)
;
                        }
                        GeneratedField::SmallHabit => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("smallHabit"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SmallHabit)
;
                        }
                        GeneratedField::SmallHabitList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("smallHabitList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SmallHabitList)
;
                        }
                        GeneratedField::SmallHabitType => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("smallHabitType"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<small_habit::Type>>()?.map(|x| system::Payload::SmallHabitType(x as i32));
                        }
                        GeneratedField::SmallHabitTypeList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("smallHabitTypeList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SmallHabitTypeList)
;
                        }
                        GeneratedField::WidgetGroupList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgetGroupList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WidgetGroupList)
;
                        }
                        GeneratedField::WidgetV2List => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgetV2List"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WidgetV2List)
;
                        }
                        GeneratedField::WifiCapability => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiCapability"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiCapability)
;
                        }
                        GeneratedField::WifiBasicInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiBasicInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiBasicInfo)
;
                        }
                        GeneratedField::WifiConfig => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiConfig"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiConfig)
;
                        }
                        GeneratedField::WifiConfigList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiConfigList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiConfigList)
;
                        }
                        GeneratedField::SystemSettingRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemSettingRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SystemSettingRequest)
;
                        }
                        GeneratedField::SystemSetting => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemSetting"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::SystemSetting)
;
                        }
                        GeneratedField::PhoneSettingRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneSettingRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::PhoneSettingRequest)
;
                        }
                        GeneratedField::PhoneSetting => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneSetting"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::PhoneSetting)
;
                        }
                        GeneratedField::VibratorSetting => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibratorSetting"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::VibratorSetting)
;
                        }
                        GeneratedField::VibratorItem => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VibratorItem"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::VibratorItem)
;
                        }
                        GeneratedField::Vibrator => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Vibrator"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::Vibrator)
;
                        }
                        GeneratedField::VibratorEffect => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibratorEffect"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::VibratorEffect)
;
                        }
                        GeneratedField::VibratorRemoval => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibratorRemoval"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::VibratorRemoval)
;
                        }
                        GeneratedField::VibratorError => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibratorError"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::VibratorError)
;
                        }
                        GeneratedField::StorageInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::StorageInfo)
;
                        }
                        GeneratedField::PhonePermission => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phonePermission"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::PhonePermission)
;
                        }
                        GeneratedField::LowLatency => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowLatency"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::LowLatency)
;
                        }
                        GeneratedField::PresentBasicStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("presentBasicStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::PresentBasicStatus)
;
                        }
                        GeneratedField::ReportBasicStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reportBasicStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::ReportBasicStatus)
;
                        }
                        GeneratedField::ReportData => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reportData"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::ReportData)
;
                        }
                        GeneratedField::ReportDataResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reportDataResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::ReportDataResult)
;
                        }
                        GeneratedField::NetworkProxyRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("networkProxyRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::NetworkProxyRequest)
;
                        }
                        GeneratedField::WidgetV3 => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgetV3"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WidgetV3)
;
                        }
                        GeneratedField::WidgetV3SupportedList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgetV3SupportedList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WidgetV3SupportedList)
;
                        }
                        GeneratedField::OtaProgress => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("otaProgress"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::OtaProgress)
;
                        }
                        GeneratedField::WifiApResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiApResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiApResult)
;
                        }
                        GeneratedField::WifiAp => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiAp"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiAp)
;
                        }
                        GeneratedField::AlertStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::AlertStatus)
;
                        }
                        GeneratedField::NetworkStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("networkStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::NetworkStatus)
;
                        }
                        GeneratedField::WearStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<basic_status::Wearing>>()?.map(|x| system::Payload::WearStatus(x as i32));
                        }
                        GeneratedField::UsageGuide => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("usageGuide"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::UsageGuide)
;
                        }
                        GeneratedField::GuideFeedback => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("guideFeedback"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::GuideFeedback)
;
                        }
                        GeneratedField::BatteryStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("batteryStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::BatteryStatus)
;
                        }
                        GeneratedField::WifiConfigResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiConfigResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(system::Payload::WifiConfigResult)
;
                        }
                    }
                }
                Ok(System {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.System", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system::SystemId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Reset => "RESET",
            Self::ApplyNewBind => "APPLY_NEW_BIND",
            Self::NotifyNewBind => "NOTIFY_NEW_BIND",
            Self::NotifyAppDisconnected => "NOTIFY_APP_DISCONNECTED",
            Self::ApplyLowLatency => "APPLY_LOW_LATENCY",
            Self::GetDeviceStatus => "GET_DEVICE_STATUS",
            Self::GetDeviceInfo => "GET_DEVICE_INFO",
            Self::SetSystemTime => "SET_SYSTEM_TIME",
            Self::ForceUpgrade => "FORCE_UPGRADE",
            Self::PrepareOta => "PREPARE_OTA",
            Self::ReportOtaProgress => "REPORT_OTA_PROGRESS",
            Self::SetLanguage => "SET_LANGUAGE",
            Self::GetHidStatus => "GET_HID_STATUS",
            Self::SetHidStatus => "SET_HID_STATUS",
            Self::GetLockScreen => "GET_LOCK_SCREEN",
            Self::SetLockScreen => "SET_LOCK_SCREEN",
            Self::GetNightMode => "GET_NIGHT_MODE",
            Self::SetNightMode => "SET_NIGHT_MODE",
            Self::UnlockWatch => "UNLOCK_WATCH",
            Self::FindPhone => "FIND_PHONE",
            Self::FindWear => "FIND_WEAR",
            Self::GetAuthorizeUnlock => "GET_AUTHORIZE_UNLOCK",
            Self::SetAuthorizeUnlock => "SET_AUTHORIZE_UNLOCK",
            Self::GetQuietMode => "GET_QUIET_MODE",
            Self::SetQuietMode => "SET_QUIET_MODE",
            Self::GetWristScreen => "GET_WRIST_SCREEN",
            Self::SetWristScreen => "SET_WRIST_SCREEN",
            Self::SetWidget => "SET_WIDGET",
            Self::SetWidgetList => "SET_WIDGET_LIST",
            Self::GetWidgetList => "GET_WIDGET_LIST",
            Self::GetOrderedAppList => "GET_ORDERED_APP_LIST",
            Self::SetOrderedAppList => "SET_ORDERED_APP_LIST",
            Self::GetAppLayout => "GET_APP_LAYOUT",
            Self::SetAppLayout => "SET_APP_LAYOUT",
            Self::SetShortcut1 => "SET_SHORTCUT_1",
            Self::SetShortcut2 => "SET_SHORTCUT_2",
            Self::SetShortcut3 => "SET_SHORTCUT_3",
            Self::GetShortcut1 => "GET_SHORTCUT_1",
            Self::GetShortcut2 => "GET_SHORTCUT_2",
            Self::GetShortcut3 => "GET_SHORTCUT_3",
            Self::GetSupportShortcutList => "GET_SUPPORT_SHORTCUT_LIST",
            Self::GetSportOption => "GET_SPORT_OPTION",
            Self::SetSportOption => "SET_SPORT_OPTION",
            Self::AddOrUpdateSmallHabit => "ADD_OR_UPDATE_SMALL_HABIT",
            Self::SyncSmallHabit => "SYNC_SMALL_HABIT",
            Self::DeleteSmallHabit => "DELETE_SMALL_HABIT",
            Self::GetWidgetGroupList => "GET_WIDGET_GROUP_LIST",
            Self::SetWidgetGroupList => "SET_WIDGET_GROUP_LIST",
            Self::GetSupportWidgetList => "GET_SUPPORT_WIDGET_LIST",
            Self::GetWifiCapability => "GET_WIFI_CAPABILITY",
            Self::RequestWifiConfig => "REQUEST_WIFI_CONFIG",
            Self::AddWifiConfig => "ADD_WIFI_CONFIG",
            Self::NotifyWifiConfigResult => "NOTIFY_WIFI_CONFIG_RESULT",
            Self::SyncWifiConfigList => "SYNC_WIFI_CONFIG_LIST",
            Self::GetWifiConfigList => "GET_WIFI_CONFIG_LIST",
            Self::EnableWifiAp => "ENABLE_WIFI_AP",
            Self::DisableWifiAp => "DISABLE_WIFI_AP",
            Self::GetSystemSetting => "GET_SYSTEM_SETTING",
            Self::SetSystemSetting => "SET_SYSTEM_SETTING",
            Self::ReportSystemSetting => "REPORT_SYSTEM_SETTING",
            Self::RequestPhoneSetting => "REQUEST_PHONE_SETTING",
            Self::SyncPhoneSetting => "SYNC_PHONE_SETTING",
            Self::ModifyPhoneSetting => "MODIFY_PHONE_SETTING",
            Self::LackPhonePermission => "LACK_PHONE_PERMISSION",
            Self::GetAodSetting => "GET_AOD_SETTING",
            Self::SetAodSetting => "SET_AOD_SETTING",
            Self::GetVibratorSetting => "GET_VIBRATOR_SETTING",
            Self::SetVibratorItem => "SET_VIBRATOR_ITEM",
            Self::AddVibrator => "ADD_VIBRATOR",
            Self::TestVibrator => "TEST_VIBRATOR",
            Self::UpdateVibrator => "UPDATE_VIBRATOR",
            Self::RemoveVibrators => "REMOVE_VIBRATORS",
            Self::GetStorageInfo => "GET_STORAGE_INFO",
            Self::GetWearStatus => "GET_WEAR_STATUS",
            Self::GetBasicStatus => "GET_BASIC_STATUS",
            Self::ReportBasicStatus => "REPORT_BASIC_STATUS",
            Self::ReportBatteryStatus => "REPORT_BATTERY_STATUS",
            Self::GetAlertStatus => "GET_ALERT_STATUS",
            Self::ReportAlertStatus => "REPORT_ALERT_STATUS",
            Self::ReportData => "REPORT_DATA",
            Self::ReportDataResult => "REPORT_DATA_RESULT",
            Self::RequestNetworkProxy => "REQUEST_NETWORK_PROXY",
            Self::SyncNetworkStatus => "SYNC_NETWORK_STATUS",
            Self::GetWidgetV3 => "GET_WIDGET_V3",
            Self::SetWidgetV3 => "SET_WIDGET_V3",
            Self::GetSupportWidgetV3 => "GET_SUPPORT_WIDGET_V3",
            Self::StartUsageGuide => "START_USAGE_GUIDE",
            Self::ReportUsageGuideFeedback => "REPORT_USAGE_GUIDE_FEEDBACK",
            Self::FinishUsageGuide => "FINISH_USAGE_GUIDE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for system::SystemId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RESET",
            "APPLY_NEW_BIND",
            "NOTIFY_NEW_BIND",
            "NOTIFY_APP_DISCONNECTED",
            "APPLY_LOW_LATENCY",
            "GET_DEVICE_STATUS",
            "GET_DEVICE_INFO",
            "SET_SYSTEM_TIME",
            "FORCE_UPGRADE",
            "PREPARE_OTA",
            "REPORT_OTA_PROGRESS",
            "SET_LANGUAGE",
            "GET_HID_STATUS",
            "SET_HID_STATUS",
            "GET_LOCK_SCREEN",
            "SET_LOCK_SCREEN",
            "GET_NIGHT_MODE",
            "SET_NIGHT_MODE",
            "UNLOCK_WATCH",
            "FIND_PHONE",
            "FIND_WEAR",
            "GET_AUTHORIZE_UNLOCK",
            "SET_AUTHORIZE_UNLOCK",
            "GET_QUIET_MODE",
            "SET_QUIET_MODE",
            "GET_WRIST_SCREEN",
            "SET_WRIST_SCREEN",
            "SET_WIDGET",
            "SET_WIDGET_LIST",
            "GET_WIDGET_LIST",
            "GET_ORDERED_APP_LIST",
            "SET_ORDERED_APP_LIST",
            "GET_APP_LAYOUT",
            "SET_APP_LAYOUT",
            "SET_SHORTCUT_1",
            "SET_SHORTCUT_2",
            "SET_SHORTCUT_3",
            "GET_SHORTCUT_1",
            "GET_SHORTCUT_2",
            "GET_SHORTCUT_3",
            "GET_SUPPORT_SHORTCUT_LIST",
            "GET_SPORT_OPTION",
            "SET_SPORT_OPTION",
            "ADD_OR_UPDATE_SMALL_HABIT",
            "SYNC_SMALL_HABIT",
            "DELETE_SMALL_HABIT",
            "GET_WIDGET_GROUP_LIST",
            "SET_WIDGET_GROUP_LIST",
            "GET_SUPPORT_WIDGET_LIST",
            "GET_WIFI_CAPABILITY",
            "REQUEST_WIFI_CONFIG",
            "ADD_WIFI_CONFIG",
            "NOTIFY_WIFI_CONFIG_RESULT",
            "SYNC_WIFI_CONFIG_LIST",
            "GET_WIFI_CONFIG_LIST",
            "ENABLE_WIFI_AP",
            "DISABLE_WIFI_AP",
            "GET_SYSTEM_SETTING",
            "SET_SYSTEM_SETTING",
            "REPORT_SYSTEM_SETTING",
            "REQUEST_PHONE_SETTING",
            "SYNC_PHONE_SETTING",
            "MODIFY_PHONE_SETTING",
            "LACK_PHONE_PERMISSION",
            "GET_AOD_SETTING",
            "SET_AOD_SETTING",
            "GET_VIBRATOR_SETTING",
            "SET_VIBRATOR_ITEM",
            "ADD_VIBRATOR",
            "TEST_VIBRATOR",
            "UPDATE_VIBRATOR",
            "REMOVE_VIBRATORS",
            "GET_STORAGE_INFO",
            "GET_WEAR_STATUS",
            "GET_BASIC_STATUS",
            "REPORT_BASIC_STATUS",
            "REPORT_BATTERY_STATUS",
            "GET_ALERT_STATUS",
            "REPORT_ALERT_STATUS",
            "REPORT_DATA",
            "REPORT_DATA_RESULT",
            "REQUEST_NETWORK_PROXY",
            "SYNC_NETWORK_STATUS",
            "GET_WIDGET_V3",
            "SET_WIDGET_V3",
            "GET_SUPPORT_WIDGET_V3",
            "START_USAGE_GUIDE",
            "REPORT_USAGE_GUIDE_FEEDBACK",
            "FINISH_USAGE_GUIDE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system::SystemId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "RESET" => Ok(system::SystemId::Reset),
                    "APPLY_NEW_BIND" => Ok(system::SystemId::ApplyNewBind),
                    "NOTIFY_NEW_BIND" => Ok(system::SystemId::NotifyNewBind),
                    "NOTIFY_APP_DISCONNECTED" => Ok(system::SystemId::NotifyAppDisconnected),
                    "APPLY_LOW_LATENCY" => Ok(system::SystemId::ApplyLowLatency),
                    "GET_DEVICE_STATUS" => Ok(system::SystemId::GetDeviceStatus),
                    "GET_DEVICE_INFO" => Ok(system::SystemId::GetDeviceInfo),
                    "SET_SYSTEM_TIME" => Ok(system::SystemId::SetSystemTime),
                    "FORCE_UPGRADE" => Ok(system::SystemId::ForceUpgrade),
                    "PREPARE_OTA" => Ok(system::SystemId::PrepareOta),
                    "REPORT_OTA_PROGRESS" => Ok(system::SystemId::ReportOtaProgress),
                    "SET_LANGUAGE" => Ok(system::SystemId::SetLanguage),
                    "GET_HID_STATUS" => Ok(system::SystemId::GetHidStatus),
                    "SET_HID_STATUS" => Ok(system::SystemId::SetHidStatus),
                    "GET_LOCK_SCREEN" => Ok(system::SystemId::GetLockScreen),
                    "SET_LOCK_SCREEN" => Ok(system::SystemId::SetLockScreen),
                    "GET_NIGHT_MODE" => Ok(system::SystemId::GetNightMode),
                    "SET_NIGHT_MODE" => Ok(system::SystemId::SetNightMode),
                    "UNLOCK_WATCH" => Ok(system::SystemId::UnlockWatch),
                    "FIND_PHONE" => Ok(system::SystemId::FindPhone),
                    "FIND_WEAR" => Ok(system::SystemId::FindWear),
                    "GET_AUTHORIZE_UNLOCK" => Ok(system::SystemId::GetAuthorizeUnlock),
                    "SET_AUTHORIZE_UNLOCK" => Ok(system::SystemId::SetAuthorizeUnlock),
                    "GET_QUIET_MODE" => Ok(system::SystemId::GetQuietMode),
                    "SET_QUIET_MODE" => Ok(system::SystemId::SetQuietMode),
                    "GET_WRIST_SCREEN" => Ok(system::SystemId::GetWristScreen),
                    "SET_WRIST_SCREEN" => Ok(system::SystemId::SetWristScreen),
                    "SET_WIDGET" => Ok(system::SystemId::SetWidget),
                    "SET_WIDGET_LIST" => Ok(system::SystemId::SetWidgetList),
                    "GET_WIDGET_LIST" => Ok(system::SystemId::GetWidgetList),
                    "GET_ORDERED_APP_LIST" => Ok(system::SystemId::GetOrderedAppList),
                    "SET_ORDERED_APP_LIST" => Ok(system::SystemId::SetOrderedAppList),
                    "GET_APP_LAYOUT" => Ok(system::SystemId::GetAppLayout),
                    "SET_APP_LAYOUT" => Ok(system::SystemId::SetAppLayout),
                    "SET_SHORTCUT_1" => Ok(system::SystemId::SetShortcut1),
                    "SET_SHORTCUT_2" => Ok(system::SystemId::SetShortcut2),
                    "SET_SHORTCUT_3" => Ok(system::SystemId::SetShortcut3),
                    "GET_SHORTCUT_1" => Ok(system::SystemId::GetShortcut1),
                    "GET_SHORTCUT_2" => Ok(system::SystemId::GetShortcut2),
                    "GET_SHORTCUT_3" => Ok(system::SystemId::GetShortcut3),
                    "GET_SUPPORT_SHORTCUT_LIST" => Ok(system::SystemId::GetSupportShortcutList),
                    "GET_SPORT_OPTION" => Ok(system::SystemId::GetSportOption),
                    "SET_SPORT_OPTION" => Ok(system::SystemId::SetSportOption),
                    "ADD_OR_UPDATE_SMALL_HABIT" => Ok(system::SystemId::AddOrUpdateSmallHabit),
                    "SYNC_SMALL_HABIT" => Ok(system::SystemId::SyncSmallHabit),
                    "DELETE_SMALL_HABIT" => Ok(system::SystemId::DeleteSmallHabit),
                    "GET_WIDGET_GROUP_LIST" => Ok(system::SystemId::GetWidgetGroupList),
                    "SET_WIDGET_GROUP_LIST" => Ok(system::SystemId::SetWidgetGroupList),
                    "GET_SUPPORT_WIDGET_LIST" => Ok(system::SystemId::GetSupportWidgetList),
                    "GET_WIFI_CAPABILITY" => Ok(system::SystemId::GetWifiCapability),
                    "REQUEST_WIFI_CONFIG" => Ok(system::SystemId::RequestWifiConfig),
                    "ADD_WIFI_CONFIG" => Ok(system::SystemId::AddWifiConfig),
                    "NOTIFY_WIFI_CONFIG_RESULT" => Ok(system::SystemId::NotifyWifiConfigResult),
                    "SYNC_WIFI_CONFIG_LIST" => Ok(system::SystemId::SyncWifiConfigList),
                    "GET_WIFI_CONFIG_LIST" => Ok(system::SystemId::GetWifiConfigList),
                    "ENABLE_WIFI_AP" => Ok(system::SystemId::EnableWifiAp),
                    "DISABLE_WIFI_AP" => Ok(system::SystemId::DisableWifiAp),
                    "GET_SYSTEM_SETTING" => Ok(system::SystemId::GetSystemSetting),
                    "SET_SYSTEM_SETTING" => Ok(system::SystemId::SetSystemSetting),
                    "REPORT_SYSTEM_SETTING" => Ok(system::SystemId::ReportSystemSetting),
                    "REQUEST_PHONE_SETTING" => Ok(system::SystemId::RequestPhoneSetting),
                    "SYNC_PHONE_SETTING" => Ok(system::SystemId::SyncPhoneSetting),
                    "MODIFY_PHONE_SETTING" => Ok(system::SystemId::ModifyPhoneSetting),
                    "LACK_PHONE_PERMISSION" => Ok(system::SystemId::LackPhonePermission),
                    "GET_AOD_SETTING" => Ok(system::SystemId::GetAodSetting),
                    "SET_AOD_SETTING" => Ok(system::SystemId::SetAodSetting),
                    "GET_VIBRATOR_SETTING" => Ok(system::SystemId::GetVibratorSetting),
                    "SET_VIBRATOR_ITEM" => Ok(system::SystemId::SetVibratorItem),
                    "ADD_VIBRATOR" => Ok(system::SystemId::AddVibrator),
                    "TEST_VIBRATOR" => Ok(system::SystemId::TestVibrator),
                    "UPDATE_VIBRATOR" => Ok(system::SystemId::UpdateVibrator),
                    "REMOVE_VIBRATORS" => Ok(system::SystemId::RemoveVibrators),
                    "GET_STORAGE_INFO" => Ok(system::SystemId::GetStorageInfo),
                    "GET_WEAR_STATUS" => Ok(system::SystemId::GetWearStatus),
                    "GET_BASIC_STATUS" => Ok(system::SystemId::GetBasicStatus),
                    "REPORT_BASIC_STATUS" => Ok(system::SystemId::ReportBasicStatus),
                    "REPORT_BATTERY_STATUS" => Ok(system::SystemId::ReportBatteryStatus),
                    "GET_ALERT_STATUS" => Ok(system::SystemId::GetAlertStatus),
                    "REPORT_ALERT_STATUS" => Ok(system::SystemId::ReportAlertStatus),
                    "REPORT_DATA" => Ok(system::SystemId::ReportData),
                    "REPORT_DATA_RESULT" => Ok(system::SystemId::ReportDataResult),
                    "REQUEST_NETWORK_PROXY" => Ok(system::SystemId::RequestNetworkProxy),
                    "SYNC_NETWORK_STATUS" => Ok(system::SystemId::SyncNetworkStatus),
                    "GET_WIDGET_V3" => Ok(system::SystemId::GetWidgetV3),
                    "SET_WIDGET_V3" => Ok(system::SystemId::SetWidgetV3),
                    "GET_SUPPORT_WIDGET_V3" => Ok(system::SystemId::GetSupportWidgetV3),
                    "START_USAGE_GUIDE" => Ok(system::SystemId::StartUsageGuide),
                    "REPORT_USAGE_GUIDE_FEEDBACK" => Ok(system::SystemId::ReportUsageGuideFeedback),
                    "FINISH_USAGE_GUIDE" => Ok(system::SystemId::FinishUsageGuide),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SystemSetProperty {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetProperty", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("value", &self.value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SystemSetProperty {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemSetProperty;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetProperty")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SystemSetProperty, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SystemSetProperty {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    value: value__.ok_or_else(|| serde::de::Error::missing_field("value"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetProperty", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SystemSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.notificaton_setting.is_some() {
            len += 1;
        }
        if self.dnd_mode.is_some() {
            len += 1;
        }
        if self.wear_setting.is_some() {
            len += 1;
        }
        if self.disconnect_reminder.is_some() {
            len += 1;
        }
        if self.indicator_light.is_some() {
            len += 1;
        }
        if self.ai_assistant.is_some() {
            len += 1;
        }
        if self.media_setting.is_some() {
            len += 1;
        }
        if self.headset.is_some() {
            len += 1;
        }
        if self.ota_setting.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting", len)?;
        if let Some(v) = self.notificaton_setting.as_ref() {
            struct_ser.serialize_field("notificatonSetting", v)?;
        }
        if let Some(v) = self.dnd_mode.as_ref() {
            struct_ser.serialize_field("dndMode", v)?;
        }
        if let Some(v) = self.wear_setting.as_ref() {
            struct_ser.serialize_field("wearSetting", v)?;
        }
        if let Some(v) = self.disconnect_reminder.as_ref() {
            struct_ser.serialize_field("disconnectReminder", v)?;
        }
        if let Some(v) = self.indicator_light.as_ref() {
            struct_ser.serialize_field("indicatorLight", v)?;
        }
        if let Some(v) = self.ai_assistant.as_ref() {
            struct_ser.serialize_field("aiAssistant", v)?;
        }
        if let Some(v) = self.media_setting.as_ref() {
            struct_ser.serialize_field("mediaSetting", v)?;
        }
        if let Some(v) = self.headset.as_ref() {
            struct_ser.serialize_field("headset", v)?;
        }
        if let Some(v) = self.ota_setting.as_ref() {
            struct_ser.serialize_field("otaSetting", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SystemSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "notificaton_setting",
            "notificatonSetting",
            "dnd_mode",
            "dndMode",
            "wear_setting",
            "wearSetting",
            "disconnect_reminder",
            "disconnectReminder",
            "indicator_light",
            "indicatorLight",
            "ai_assistant",
            "aiAssistant",
            "media_setting",
            "mediaSetting",
            "headset",
            "ota_setting",
            "otaSetting",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NotificatonSetting,
            DndMode,
            WearSetting,
            DisconnectReminder,
            IndicatorLight,
            AiAssistant,
            MediaSetting,
            Headset,
            OtaSetting,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "notificatonSetting" | "notificaton_setting" => Ok(GeneratedField::NotificatonSetting),
                            "dndMode" | "dnd_mode" => Ok(GeneratedField::DndMode),
                            "wearSetting" | "wear_setting" => Ok(GeneratedField::WearSetting),
                            "disconnectReminder" | "disconnect_reminder" => Ok(GeneratedField::DisconnectReminder),
                            "indicatorLight" | "indicator_light" => Ok(GeneratedField::IndicatorLight),
                            "aiAssistant" | "ai_assistant" => Ok(GeneratedField::AiAssistant),
                            "mediaSetting" | "media_setting" => Ok(GeneratedField::MediaSetting),
                            "headset" => Ok(GeneratedField::Headset),
                            "otaSetting" | "ota_setting" => Ok(GeneratedField::OtaSetting),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SystemSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut notificaton_setting__ = None;
                let mut dnd_mode__ = None;
                let mut wear_setting__ = None;
                let mut disconnect_reminder__ = None;
                let mut indicator_light__ = None;
                let mut ai_assistant__ = None;
                let mut media_setting__ = None;
                let mut headset__ = None;
                let mut ota_setting__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NotificatonSetting => {
                            if notificaton_setting__.is_some() {
                                return Err(serde::de::Error::duplicate_field("notificatonSetting"));
                            }
                            notificaton_setting__ = map_.next_value()?;
                        }
                        GeneratedField::DndMode => {
                            if dnd_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dndMode"));
                            }
                            dnd_mode__ = map_.next_value()?;
                        }
                        GeneratedField::WearSetting => {
                            if wear_setting__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearSetting"));
                            }
                            wear_setting__ = map_.next_value()?;
                        }
                        GeneratedField::DisconnectReminder => {
                            if disconnect_reminder__.is_some() {
                                return Err(serde::de::Error::duplicate_field("disconnectReminder"));
                            }
                            disconnect_reminder__ = map_.next_value()?;
                        }
                        GeneratedField::IndicatorLight => {
                            if indicator_light__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indicatorLight"));
                            }
                            indicator_light__ = map_.next_value()?;
                        }
                        GeneratedField::AiAssistant => {
                            if ai_assistant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aiAssistant"));
                            }
                            ai_assistant__ = map_.next_value()?;
                        }
                        GeneratedField::MediaSetting => {
                            if media_setting__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mediaSetting"));
                            }
                            media_setting__ = map_.next_value()?;
                        }
                        GeneratedField::Headset => {
                            if headset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("headset"));
                            }
                            headset__ = map_.next_value()?;
                        }
                        GeneratedField::OtaSetting => {
                            if ota_setting__.is_some() {
                                return Err(serde::de::Error::duplicate_field("otaSetting"));
                            }
                            ota_setting__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SystemSetting {
                    notificaton_setting: notificaton_setting__,
                    dnd_mode: dnd_mode__,
                    wear_setting: wear_setting__,
                    disconnect_reminder: disconnect_reminder__,
                    indicator_light: indicator_light__,
                    ai_assistant: ai_assistant__,
                    media_setting: media_setting__,
                    headset: headset__,
                    ota_setting: ota_setting__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::AiAssistant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.camera_access.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.AIAssistant", len)?;
        struct_ser.serialize_field("voiceWakeup", &self.voice_wakeup)?;
        if let Some(v) = self.camera_access.as_ref() {
            struct_ser.serialize_field("cameraAccess", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::AiAssistant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "voice_wakeup",
            "voiceWakeup",
            "camera_access",
            "cameraAccess",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VoiceWakeup,
            CameraAccess,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "voiceWakeup" | "voice_wakeup" => Ok(GeneratedField::VoiceWakeup),
                            "cameraAccess" | "camera_access" => Ok(GeneratedField::CameraAccess),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::AiAssistant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.AIAssistant")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::AiAssistant, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut voice_wakeup__ = None;
                let mut camera_access__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VoiceWakeup => {
                            if voice_wakeup__.is_some() {
                                return Err(serde::de::Error::duplicate_field("voiceWakeup"));
                            }
                            voice_wakeup__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CameraAccess => {
                            if camera_access__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cameraAccess"));
                            }
                            camera_access__ = map_.next_value()?;
                        }
                    }
                }
                Ok(system_setting::AiAssistant {
                    voice_wakeup: voice_wakeup__.ok_or_else(|| serde::de::Error::missing_field("voiceWakeup"))?,
                    camera_access: camera_access__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.AIAssistant", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::DndMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.DNDMode", len)?;
        struct_ser.serialize_field("syncWithPhone", &self.sync_with_phone)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::DndMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sync_with_phone",
            "syncWithPhone",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SyncWithPhone,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "syncWithPhone" | "sync_with_phone" => Ok(GeneratedField::SyncWithPhone),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::DndMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.DNDMode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::DndMode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sync_with_phone__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SyncWithPhone => {
                            if sync_with_phone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("syncWithPhone"));
                            }
                            sync_with_phone__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(system_setting::DndMode {
                    sync_with_phone: sync_with_phone__.ok_or_else(|| serde::de::Error::missing_field("syncWithPhone"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.DNDMode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::DisconnectReminder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.DisconnectReminder", len)?;
        struct_ser.serialize_field("alert", &self.alert)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::DisconnectReminder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "alert",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Alert,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "alert" => Ok(GeneratedField::Alert),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::DisconnectReminder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.DisconnectReminder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::DisconnectReminder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut alert__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Alert => {
                            if alert__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alert"));
                            }
                            alert__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(system_setting::DisconnectReminder {
                    alert: alert__.ok_or_else(|| serde::de::Error::missing_field("alert"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.DisconnectReminder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::Headset {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.volume_adaptive.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.Headset", len)?;
        struct_ser.serialize_field("wearDetection", &self.wear_detection)?;
        if let Some(v) = self.volume_adaptive.as_ref() {
            struct_ser.serialize_field("volumeAdaptive", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::Headset {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "wear_detection",
            "wearDetection",
            "volume_adaptive",
            "volumeAdaptive",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WearDetection,
            VolumeAdaptive,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "wearDetection" | "wear_detection" => Ok(GeneratedField::WearDetection),
                            "volumeAdaptive" | "volume_adaptive" => Ok(GeneratedField::VolumeAdaptive),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::Headset;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.Headset")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::Headset, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut wear_detection__ = None;
                let mut volume_adaptive__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WearDetection => {
                            if wear_detection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearDetection"));
                            }
                            wear_detection__ = Some(map_.next_value()?);
                        }
                        GeneratedField::VolumeAdaptive => {
                            if volume_adaptive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("volumeAdaptive"));
                            }
                            volume_adaptive__ = map_.next_value()?;
                        }
                    }
                }
                Ok(system_setting::Headset {
                    wear_detection: wear_detection__.ok_or_else(|| serde::de::Error::missing_field("wearDetection"))?,
                    volume_adaptive: volume_adaptive__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.Headset", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::IndicatorLight {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.IndicatorLight", len)?;
        struct_ser.serialize_field("brightness", &self.brightness)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::IndicatorLight {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "brightness",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Brightness,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "brightness" => Ok(GeneratedField::Brightness),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::IndicatorLight;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.IndicatorLight")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::IndicatorLight, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut brightness__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Brightness => {
                            if brightness__.is_some() {
                                return Err(serde::de::Error::duplicate_field("brightness"));
                            }
                            brightness__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(system_setting::IndicatorLight {
                    brightness: brightness__.ok_or_else(|| serde::de::Error::missing_field("brightness"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.IndicatorLight", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::MediaSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.MediaSetting", len)?;
        struct_ser.serialize_field("shootingMode", &self.shooting_mode)?;
        struct_ser.serialize_field("videoDuration", &self.video_duration)?;
        struct_ser.serialize_field("autoSync", &self.auto_sync)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::MediaSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "shooting_mode",
            "shootingMode",
            "video_duration",
            "videoDuration",
            "auto_sync",
            "autoSync",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ShootingMode,
            VideoDuration,
            AutoSync,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "shootingMode" | "shooting_mode" => Ok(GeneratedField::ShootingMode),
                            "videoDuration" | "video_duration" => Ok(GeneratedField::VideoDuration),
                            "autoSync" | "auto_sync" => Ok(GeneratedField::AutoSync),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::MediaSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.MediaSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::MediaSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut shooting_mode__ = None;
                let mut video_duration__ = None;
                let mut auto_sync__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ShootingMode => {
                            if shooting_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("shootingMode"));
                            }
                            shooting_mode__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::VideoDuration => {
                            if video_duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("videoDuration"));
                            }
                            video_duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::AutoSync => {
                            if auto_sync__.is_some() {
                                return Err(serde::de::Error::duplicate_field("autoSync"));
                            }
                            auto_sync__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(system_setting::MediaSetting {
                    shooting_mode: shooting_mode__.ok_or_else(|| serde::de::Error::missing_field("shootingMode"))?,
                    video_duration: video_duration__.ok_or_else(|| serde::de::Error::missing_field("videoDuration"))?,
                    auto_sync: auto_sync__.ok_or_else(|| serde::de::Error::missing_field("autoSync"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.MediaSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::NotificationSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.only_wear.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.NotificationSetting", len)?;
        let v = OptionalSwitcher::try_from(self.auto_screen)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.auto_screen)))?;
        struct_ser.serialize_field("autoScreen", &v)?;
        let v = OptionalSwitcher::try_from(self.only_lockscreen)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.only_lockscreen)))?;
        struct_ser.serialize_field("onlyLockscreen", &v)?;
        if let Some(v) = self.only_wear.as_ref() {
            let v = OptionalSwitcher::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("onlyWear", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::NotificationSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "auto_screen",
            "autoScreen",
            "only_lockscreen",
            "onlyLockscreen",
            "only_wear",
            "onlyWear",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AutoScreen,
            OnlyLockscreen,
            OnlyWear,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "autoScreen" | "auto_screen" => Ok(GeneratedField::AutoScreen),
                            "onlyLockscreen" | "only_lockscreen" => Ok(GeneratedField::OnlyLockscreen),
                            "onlyWear" | "only_wear" => Ok(GeneratedField::OnlyWear),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::NotificationSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.NotificationSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::NotificationSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut auto_screen__ = None;
                let mut only_lockscreen__ = None;
                let mut only_wear__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AutoScreen => {
                            if auto_screen__.is_some() {
                                return Err(serde::de::Error::duplicate_field("autoScreen"));
                            }
                            auto_screen__ = Some(map_.next_value::<OptionalSwitcher>()? as i32);
                        }
                        GeneratedField::OnlyLockscreen => {
                            if only_lockscreen__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onlyLockscreen"));
                            }
                            only_lockscreen__ = Some(map_.next_value::<OptionalSwitcher>()? as i32);
                        }
                        GeneratedField::OnlyWear => {
                            if only_wear__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onlyWear"));
                            }
                            only_wear__ = map_.next_value::<::std::option::Option<OptionalSwitcher>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(system_setting::NotificationSetting {
                    auto_screen: auto_screen__.ok_or_else(|| serde::de::Error::missing_field("autoScreen"))?,
                    only_lockscreen: only_lockscreen__.ok_or_else(|| serde::de::Error::missing_field("onlyLockscreen"))?,
                    only_wear: only_wear__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.NotificationSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::OtaSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.OtaSetting", len)?;
        struct_ser.serialize_field("silent", &self.silent)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::OtaSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "silent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Silent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "silent" => Ok(GeneratedField::Silent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::OtaSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.OtaSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::OtaSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut silent__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Silent => {
                            if silent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("silent"));
                            }
                            silent__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(system_setting::OtaSetting {
                    silent: silent__.ok_or_else(|| serde::de::Error::missing_field("silent"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.OtaSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.Request", len)?;
        struct_ser.serialize_field("items", &self.items)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(system_setting::Request {
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::WearSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.hybrid_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.WearSetting", len)?;
        let v = WearMode::try_from(self.wear_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.wear_mode)))?;
        struct_ser.serialize_field("wearMode", &v)?;
        if let Some(v) = self.hybrid_mode.as_ref() {
            struct_ser.serialize_field("hybridMode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::WearSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "wear_mode",
            "wearMode",
            "hybrid_mode",
            "hybridMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WearMode,
            HybridMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "wearMode" | "wear_mode" => Ok(GeneratedField::WearMode),
                            "hybridMode" | "hybrid_mode" => Ok(GeneratedField::HybridMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::WearSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.WearSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::WearSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut wear_mode__ = None;
                let mut hybrid_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WearMode => {
                            if wear_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wearMode"));
                            }
                            wear_mode__ = Some(map_.next_value::<WearMode>()? as i32);
                        }
                        GeneratedField::HybridMode => {
                            if hybrid_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hybridMode"));
                            }
                            hybrid_mode__ = map_.next_value()?;
                        }
                    }
                }
                Ok(system_setting::WearSetting {
                    wear_mode: wear_mode__.ok_or_else(|| serde::de::Error::missing_field("wearMode"))?,
                    hybrid_mode: hybrid_mode__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.WearSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for system_setting::wear_setting::HybridMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.lack_feature.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemSetting.WearSetting.HybridMode", len)?;
        let v = PowerMode::try_from(self.power_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.power_mode)))?;
        struct_ser.serialize_field("powerMode", &v)?;
        if let Some(v) = self.lack_feature.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("lackFeature", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for system_setting::wear_setting::HybridMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "power_mode",
            "powerMode",
            "lack_feature",
            "lackFeature",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PowerMode,
            LackFeature,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "powerMode" | "power_mode" => Ok(GeneratedField::PowerMode),
                            "lackFeature" | "lack_feature" => Ok(GeneratedField::LackFeature),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = system_setting::wear_setting::HybridMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemSetting.WearSetting.HybridMode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<system_setting::wear_setting::HybridMode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut power_mode__ = None;
                let mut lack_feature__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PowerMode => {
                            if power_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("powerMode"));
                            }
                            power_mode__ = Some(map_.next_value::<PowerMode>()? as i32);
                        }
                        GeneratedField::LackFeature => {
                            if lack_feature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lackFeature"));
                            }
                            lack_feature__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(system_setting::wear_setting::HybridMode {
                    power_mode: power_mode__.ok_or_else(|| serde::de::Error::missing_field("powerMode"))?,
                    lack_feature: lack_feature__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemSetting.WearSetting.HybridMode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SystemTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.time_zone.is_some() {
            len += 1;
        }
        if self.is_12_hours.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.SystemTime", len)?;
        struct_ser.serialize_field("date", &self.date)?;
        struct_ser.serialize_field("time", &self.time)?;
        if let Some(v) = self.time_zone.as_ref() {
            struct_ser.serialize_field("timeZone", v)?;
        }
        if let Some(v) = self.is_12_hours.as_ref() {
            struct_ser.serialize_field("is12Hours", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SystemTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "date",
            "time",
            "time_zone",
            "timeZone",
            "is_12_hours",
            "is12Hours",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Date,
            Time,
            TimeZone,
            Is12Hours,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "date" => Ok(GeneratedField::Date),
                            "time" => Ok(GeneratedField::Time),
                            "timeZone" | "time_zone" => Ok(GeneratedField::TimeZone),
                            "is12Hours" | "is_12_hours" => Ok(GeneratedField::Is12Hours),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.SystemTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SystemTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut date__ = None;
                let mut time__ = None;
                let mut time_zone__ = None;
                let mut is_12_hours__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Date => {
                            if date__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            date__ = map_.next_value()?;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("time"));
                            }
                            time__ = map_.next_value()?;
                        }
                        GeneratedField::TimeZone => {
                            if time_zone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timeZone"));
                            }
                            time_zone__ = map_.next_value()?;
                        }
                        GeneratedField::Is12Hours => {
                            if is_12_hours__.is_some() {
                                return Err(serde::de::Error::duplicate_field("is12Hours"));
                            }
                            is_12_hours__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SystemTime {
                    date: date__.ok_or_else(|| serde::de::Error::missing_field("date"))?,
                    time: time__.ok_or_else(|| serde::de::Error::missing_field("time"))?,
                    time_zone: time_zone__,
                    is_12_hours: is_12_hours__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.SystemTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TvControl {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.TVControl", len)?;
        struct_ser.serialize_field("deviceId", &self.device_id)?;
        struct_ser.serialize_field("cmd", &self.cmd)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TvControl {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "device_id",
            "deviceId",
            "cmd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeviceId,
            Cmd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "deviceId" | "device_id" => Ok(GeneratedField::DeviceId),
                            "cmd" => Ok(GeneratedField::Cmd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TvControl;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TVControl")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TvControl, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut device_id__ = None;
                let mut cmd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeviceId => {
                            if device_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deviceId"));
                            }
                            device_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cmd"));
                            }
                            cmd__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(TvControl {
                    device_id: device_id__.ok_or_else(|| serde::de::Error::missing_field("deviceId"))?,
                    cmd: cmd__.ok_or_else(|| serde::de::Error::missing_field("cmd"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TVControl", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TvData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.TVData", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TvData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TvData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TVData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TvData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TvData {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TVData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TvInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.TVInfo", len)?;
        struct_ser.serialize_field("state", &self.state)?;
        if let Some(v) = self.data.as_ref() {
            struct_ser.serialize_field("data", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TvInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "state",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "state" => Ok(GeneratedField::State),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TvInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TVInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TvInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("state"));
                            }
                            state__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TvInfo {
                    state: state__.ok_or_else(|| serde::de::Error::missing_field("state"))?,
                    data: data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TVInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TelecomOperator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ChinaMobile => "CHINA_MOBILE",
            Self::ChinaUnicom => "CHINA_UNICOM",
            Self::ChinaTelecom => "CHINA_TELECOM",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for TelecomOperator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CHINA_MOBILE",
            "CHINA_UNICOM",
            "CHINA_TELECOM",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TelecomOperator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CHINA_MOBILE" => Ok(TelecomOperator::ChinaMobile),
                    "CHINA_UNICOM" => Ok(TelecomOperator::ChinaUnicom),
                    "CHINA_TELECOM" => Ok(TelecomOperator::ChinaTelecom),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TemperatureUnit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NoUnit => "NO_UNIT",
            Self::Centigrade => "CENTIGRADE",
            Self::Fahrenheit => "FAHRENHEIT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for TemperatureUnit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NO_UNIT",
            "CENTIGRADE",
            "FAHRENHEIT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemperatureUnit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NO_UNIT" => Ok(TemperatureUnit::NoUnit),
                    "CENTIGRADE" => Ok(TemperatureUnit::Centigrade),
                    "FAHRENHEIT" => Ok(TemperatureUnit::Fahrenheit),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateDeviceList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateDeviceList", len)?;
        struct_ser.serialize_field("items", &self.items)?;
        struct_ser.serialize_field("exceedMaxItems", &self.exceed_max_items)?;
        struct_ser.serialize_field("showIndex", &self.show_index)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateDeviceList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "exceed_max_items",
            "exceedMaxItems",
            "show_index",
            "showIndex",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            ExceedMaxItems,
            ShowIndex,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "exceedMaxItems" | "exceed_max_items" => Ok(GeneratedField::ExceedMaxItems),
                            "showIndex" | "show_index" => Ok(GeneratedField::ShowIndex),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateDeviceList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateDeviceList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateDeviceList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut exceed_max_items__ = None;
                let mut show_index__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                        GeneratedField::ExceedMaxItems => {
                            if exceed_max_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exceedMaxItems"));
                            }
                            exceed_max_items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ShowIndex => {
                            if show_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("showIndex"));
                            }
                            show_index__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TemplateDeviceList {
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                    exceed_max_items: exceed_max_items__.ok_or_else(|| serde::de::Error::missing_field("exceedMaxItems"))?,
                    show_index: show_index__.ok_or_else(|| serde::de::Error::missing_field("showIndex"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateDeviceList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateGeneral {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.results.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateGeneral", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("text", &self.text)?;
        if let Some(v) = self.results.as_ref() {
            struct_ser.serialize_field("results", v)?;
        }
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateGeneral {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "text",
            "results",
            "skill_description",
            "skillDescription",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            Text,
            Results,
            SkillDescription,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "text" => Ok(GeneratedField::Text),
                            "results" => Ok(GeneratedField::Results),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateGeneral;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateGeneral")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateGeneral, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut text__ = None;
                let mut results__ = None;
                let mut skill_description__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Results => {
                            if results__.is_some() {
                                return Err(serde::de::Error::duplicate_field("results"));
                            }
                            results__ = map_.next_value()?;
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TemplateGeneral {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                    results: results__,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateGeneral", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateGeneral2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateGeneral2", len)?;
        struct_ser.serialize_field("mainTitle", &self.main_title)?;
        struct_ser.serialize_field("subTitles", &self.sub_titles)?;
        struct_ser.serialize_field("texts", &self.texts)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateGeneral2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "main_title",
            "mainTitle",
            "sub_titles",
            "subTitles",
            "texts",
            "skill_description",
            "skillDescription",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MainTitle,
            SubTitles,
            Texts,
            SkillDescription,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mainTitle" | "main_title" => Ok(GeneratedField::MainTitle),
                            "subTitles" | "sub_titles" => Ok(GeneratedField::SubTitles),
                            "texts" => Ok(GeneratedField::Texts),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateGeneral2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateGeneral2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateGeneral2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut main_title__ = None;
                let mut sub_titles__ = None;
                let mut texts__ = None;
                let mut skill_description__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MainTitle => {
                            if main_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainTitle"));
                            }
                            main_title__ = map_.next_value()?;
                        }
                        GeneratedField::SubTitles => {
                            if sub_titles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subTitles"));
                            }
                            sub_titles__ = map_.next_value()?;
                        }
                        GeneratedField::Texts => {
                            if texts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("texts"));
                            }
                            texts__ = map_.next_value()?;
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TemplateGeneral2 {
                    main_title: main_title__.ok_or_else(|| serde::de::Error::missing_field("mainTitle"))?,
                    sub_titles: sub_titles__.ok_or_else(|| serde::de::Error::missing_field("subTitles"))?,
                    texts: texts__.ok_or_else(|| serde::de::Error::missing_field("texts"))?,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateGeneral2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateLists {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.title.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateLists", len)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.serialize_field("items", &self.items)?;
        if let Some(v) = self.title.as_ref() {
            struct_ser.serialize_field("title", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateLists {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "skill_description",
            "skillDescription",
            "items",
            "title",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillDescription,
            Items,
            Title,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            "items" => Ok(GeneratedField::Items),
                            "title" => Ok(GeneratedField::Title),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateLists;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateLists")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateLists, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_description__ = None;
                let mut items__ = None;
                let mut title__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TemplateLists {
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                    title: title__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateLists", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplatePlayInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.TemplatePlayInfo", len)?;
        struct_ser.serialize_field("items", &self.items)?;
        let v = PlayInfoType::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplatePlayInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "type",
            "skill_description",
            "skillDescription",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            Type,
            SkillDescription,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "type" => Ok(GeneratedField::Type),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplatePlayInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplatePlayInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplatePlayInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut r#type__ = None;
                let mut skill_description__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<PlayInfoType>()? as i32);
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TemplatePlayInfo {
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplatePlayInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateSwitchPanel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateSwitchPanel", len)?;
        struct_ser.serialize_field("title", &self.title)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.serialize_field("status", &self.status)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = SwitchPanelType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateSwitchPanel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "title",
            "skill_description",
            "skillDescription",
            "status",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Title,
            SkillDescription,
            Status,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "title" => Ok(GeneratedField::Title),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            "status" => Ok(GeneratedField::Status),
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateSwitchPanel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateSwitchPanel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateSwitchPanel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title__ = None;
                let mut skill_description__ = None;
                let mut status__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<SwitchPanelType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(TemplateSwitchPanel {
                    title: title__.ok_or_else(|| serde::de::Error::missing_field("title"))?,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                    status: status__.ok_or_else(|| serde::de::Error::missing_field("status"))?,
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateSwitchPanel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateSwitchPanelList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.items.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateSwitchPanelList", len)?;
        struct_ser.serialize_field("titles", &self.titles)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = SwitchPanelType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.items.as_ref() {
            struct_ser.serialize_field("items", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateSwitchPanelList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "titles",
            "skill_description",
            "skillDescription",
            "type",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Titles,
            SkillDescription,
            Type,
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "titles" => Ok(GeneratedField::Titles),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            "type" => Ok(GeneratedField::Type),
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateSwitchPanelList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateSwitchPanelList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateSwitchPanelList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut titles__ = None;
                let mut skill_description__ = None;
                let mut r#type__ = None;
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Titles => {
                            if titles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("titles"));
                            }
                            titles__ = map_.next_value()?;
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<SwitchPanelType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TemplateSwitchPanelList {
                    titles: titles__.ok_or_else(|| serde::de::Error::missing_field("titles"))?,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                    r#type: r#type__,
                    items: items__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateSwitchPanelList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateToast {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateToast", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateToast {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateToast;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateToast")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateToast, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TemplateToast {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateToast", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TemplateWeather {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.TemplateWeather", len)?;
        struct_ser.serialize_field("weather", &self.weather)?;
        struct_ser.serialize_field("skillDescription", &self.skill_description)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TemplateWeather {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "weather",
            "skill_description",
            "skillDescription",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Weather,
            SkillDescription,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "weather" => Ok(GeneratedField::Weather),
                            "skillDescription" | "skill_description" => Ok(GeneratedField::SkillDescription),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TemplateWeather;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TemplateWeather")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TemplateWeather, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut weather__ = None;
                let mut skill_description__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Weather => {
                            if weather__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weather"));
                            }
                            weather__ = map_.next_value()?;
                        }
                        GeneratedField::SkillDescription => {
                            if skill_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("skillDescription"));
                            }
                            skill_description__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TemplateWeather {
                    weather: weather__.ok_or_else(|| serde::de::Error::missing_field("weather"))?,
                    skill_description: skill_description__.ok_or_else(|| serde::de::Error::missing_field("skillDescription"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TemplateWeather", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ThirdpartyApp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.ThirdpartyApp", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                thirdparty_app::Payload::AppItemList(v) => {
                    struct_ser.serialize_field("appItemList", v)?;
                }
                thirdparty_app::Payload::InstallRequest(v) => {
                    struct_ser.serialize_field("installRequest", v)?;
                }
                thirdparty_app::Payload::InstallResponse(v) => {
                    struct_ser.serialize_field("installResponse", v)?;
                }
                thirdparty_app::Payload::InstallResult(v) => {
                    struct_ser.serialize_field("installResult", v)?;
                }
                thirdparty_app::Payload::BasicInfo(v) => {
                    struct_ser.serialize_field("basicInfo", v)?;
                }
                thirdparty_app::Payload::LaunchInfo(v) => {
                    struct_ser.serialize_field("launchInfo", v)?;
                }
                thirdparty_app::Payload::PermissionInfoList(v) => {
                    struct_ser.serialize_field("permissionInfoList", v)?;
                }
                thirdparty_app::Payload::AppStatus(v) => {
                    struct_ser.serialize_field("appStatus", v)?;
                }
                thirdparty_app::Payload::MessageContent(v) => {
                    struct_ser.serialize_field("messageContent", v)?;
                }
                thirdparty_app::Payload::WechatLicenseRequest(v) => {
                    struct_ser.serialize_field("wechatLicenseRequest", v)?;
                }
                thirdparty_app::Payload::WechatLicenseResponse(v) => {
                    struct_ser.serialize_field("wechatLicenseResponse", v)?;
                }
                thirdparty_app::Payload::MihomeRequest(v) => {
                    struct_ser.serialize_field("mihomeRequest", v)?;
                }
                thirdparty_app::Payload::MihomeList(v) => {
                    struct_ser.serialize_field("mihomeList", v)?;
                }
                thirdparty_app::Payload::SceneRequest(v) => {
                    struct_ser.serialize_field("sceneRequest", v)?;
                }
                thirdparty_app::Payload::SceneList(v) => {
                    struct_ser.serialize_field("sceneList", v)?;
                }
                thirdparty_app::Payload::SceneExcutor(v) => {
                    struct_ser.serialize_field("sceneExcutor", v)?;
                }
                thirdparty_app::Payload::SceneResult(v) => {
                    struct_ser.serialize_field("sceneResult", v)?;
                }
                thirdparty_app::Payload::CourseTable(v) => {
                    struct_ser.serialize_field("courseTable", v)?;
                }
                thirdparty_app::Payload::BloodGlucose(v) => {
                    struct_ser.serialize_field("bloodGlucose", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ThirdpartyApp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "app_item_list",
            "appItemList",
            "install_request",
            "installRequest",
            "install_response",
            "installResponse",
            "install_result",
            "installResult",
            "basic_info",
            "basicInfo",
            "launch_info",
            "launchInfo",
            "permission_info_list",
            "permissionInfoList",
            "app_status",
            "appStatus",
            "message_content",
            "messageContent",
            "wechat_license_request",
            "wechatLicenseRequest",
            "wechat_license_response",
            "wechatLicenseResponse",
            "mihome_request",
            "mihomeRequest",
            "mihome_list",
            "mihomeList",
            "scene_request",
            "sceneRequest",
            "scene_list",
            "sceneList",
            "scene_excutor",
            "sceneExcutor",
            "scene_result",
            "sceneResult",
            "course_table",
            "courseTable",
            "blood_glucose",
            "bloodGlucose",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AppItemList,
            InstallRequest,
            InstallResponse,
            InstallResult,
            BasicInfo,
            LaunchInfo,
            PermissionInfoList,
            AppStatus,
            MessageContent,
            WechatLicenseRequest,
            WechatLicenseResponse,
            MihomeRequest,
            MihomeList,
            SceneRequest,
            SceneList,
            SceneExcutor,
            SceneResult,
            CourseTable,
            BloodGlucose,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "appItemList" | "app_item_list" => Ok(GeneratedField::AppItemList),
                            "installRequest" | "install_request" => Ok(GeneratedField::InstallRequest),
                            "installResponse" | "install_response" => Ok(GeneratedField::InstallResponse),
                            "installResult" | "install_result" => Ok(GeneratedField::InstallResult),
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "launchInfo" | "launch_info" => Ok(GeneratedField::LaunchInfo),
                            "permissionInfoList" | "permission_info_list" => Ok(GeneratedField::PermissionInfoList),
                            "appStatus" | "app_status" => Ok(GeneratedField::AppStatus),
                            "messageContent" | "message_content" => Ok(GeneratedField::MessageContent),
                            "wechatLicenseRequest" | "wechat_license_request" => Ok(GeneratedField::WechatLicenseRequest),
                            "wechatLicenseResponse" | "wechat_license_response" => Ok(GeneratedField::WechatLicenseResponse),
                            "mihomeRequest" | "mihome_request" => Ok(GeneratedField::MihomeRequest),
                            "mihomeList" | "mihome_list" => Ok(GeneratedField::MihomeList),
                            "sceneRequest" | "scene_request" => Ok(GeneratedField::SceneRequest),
                            "sceneList" | "scene_list" => Ok(GeneratedField::SceneList),
                            "sceneExcutor" | "scene_excutor" => Ok(GeneratedField::SceneExcutor),
                            "sceneResult" | "scene_result" => Ok(GeneratedField::SceneResult),
                            "courseTable" | "course_table" => Ok(GeneratedField::CourseTable),
                            "bloodGlucose" | "blood_glucose" => Ok(GeneratedField::BloodGlucose),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ThirdpartyApp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.ThirdpartyApp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ThirdpartyApp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AppItemList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appItemList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::AppItemList)
;
                        }
                        GeneratedField::InstallRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("installRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::InstallRequest)
;
                        }
                        GeneratedField::InstallResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("installResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::InstallResponse)
;
                        }
                        GeneratedField::InstallResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("installResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::InstallResult)
;
                        }
                        GeneratedField::BasicInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::BasicInfo)
;
                        }
                        GeneratedField::LaunchInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("launchInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::LaunchInfo)
;
                        }
                        GeneratedField::PermissionInfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("permissionInfoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::PermissionInfoList)
;
                        }
                        GeneratedField::AppStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::AppStatus)
;
                        }
                        GeneratedField::MessageContent => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("messageContent"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::MessageContent)
;
                        }
                        GeneratedField::WechatLicenseRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wechatLicenseRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::WechatLicenseRequest)
;
                        }
                        GeneratedField::WechatLicenseResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wechatLicenseResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::WechatLicenseResponse)
;
                        }
                        GeneratedField::MihomeRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mihomeRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::MihomeRequest)
;
                        }
                        GeneratedField::MihomeList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mihomeList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::MihomeList)
;
                        }
                        GeneratedField::SceneRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sceneRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::SceneRequest)
;
                        }
                        GeneratedField::SceneList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sceneList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::SceneList)
;
                        }
                        GeneratedField::SceneExcutor => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sceneExcutor"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::SceneExcutor)
;
                        }
                        GeneratedField::SceneResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sceneResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::SceneResult)
;
                        }
                        GeneratedField::CourseTable => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("courseTable"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::CourseTable)
;
                        }
                        GeneratedField::BloodGlucose => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bloodGlucose"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(thirdparty_app::Payload::BloodGlucose)
;
                        }
                    }
                }
                Ok(ThirdpartyApp {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.ThirdpartyApp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for thirdparty_app::ThirdpartyAppId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GetInstalledList => "GET_INSTALLED_LIST",
            Self::PrepareInstallApp => "PREPARE_INSTALL_APP",
            Self::ReportInstallResult => "REPORT_INSTALL_RESULT",
            Self::RemoveApp => "REMOVE_APP",
            Self::LaunchApp => "LAUNCH_APP",
            Self::SyncPermissionInfo => "SYNC_PERMISSION_INFO",
            Self::RequestPhoneAppStatus => "REQUEST_PHONE_APP_STATUS",
            Self::SyncPhoneAppStatus => "SYNC_PHONE_APP_STATUS",
            Self::SendPhoneMessage => "SEND_PHONE_MESSAGE",
            Self::SendWearMessage => "SEND_WEAR_MESSAGE",
            Self::RequestWechatLicense => "REQUEST_WECHAT_LICENSE",
            Self::ResponseWechatLicense => "RESPONSE_WECHAT_LICENSE",
            Self::RequestMihome => "REQUEST_MIHOME",
            Self::ResponseMihome => "RESPONSE_MIHOME",
            Self::RequestScene => "REQUEST_SCENE",
            Self::ResponseScene => "RESPONSE_SCENE",
            Self::ExecuteScene => "EXECUTE_SCENE",
            Self::ResultScene => "RESULT_SCENE",
            Self::RequestCourseTable => "REQUEST_COURSE_TABLE",
            Self::SyncCourseTable => "SYNC_COURSE_TABLE",
            Self::SyncCurrentBloodGlucose => "SYNC_CURRENT_BLOOD_GLUCOSE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for thirdparty_app::ThirdpartyAppId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GET_INSTALLED_LIST",
            "PREPARE_INSTALL_APP",
            "REPORT_INSTALL_RESULT",
            "REMOVE_APP",
            "LAUNCH_APP",
            "SYNC_PERMISSION_INFO",
            "REQUEST_PHONE_APP_STATUS",
            "SYNC_PHONE_APP_STATUS",
            "SEND_PHONE_MESSAGE",
            "SEND_WEAR_MESSAGE",
            "REQUEST_WECHAT_LICENSE",
            "RESPONSE_WECHAT_LICENSE",
            "REQUEST_MIHOME",
            "RESPONSE_MIHOME",
            "REQUEST_SCENE",
            "RESPONSE_SCENE",
            "EXECUTE_SCENE",
            "RESULT_SCENE",
            "REQUEST_COURSE_TABLE",
            "SYNC_COURSE_TABLE",
            "SYNC_CURRENT_BLOOD_GLUCOSE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = thirdparty_app::ThirdpartyAppId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GET_INSTALLED_LIST" => Ok(thirdparty_app::ThirdpartyAppId::GetInstalledList),
                    "PREPARE_INSTALL_APP" => Ok(thirdparty_app::ThirdpartyAppId::PrepareInstallApp),
                    "REPORT_INSTALL_RESULT" => Ok(thirdparty_app::ThirdpartyAppId::ReportInstallResult),
                    "REMOVE_APP" => Ok(thirdparty_app::ThirdpartyAppId::RemoveApp),
                    "LAUNCH_APP" => Ok(thirdparty_app::ThirdpartyAppId::LaunchApp),
                    "SYNC_PERMISSION_INFO" => Ok(thirdparty_app::ThirdpartyAppId::SyncPermissionInfo),
                    "REQUEST_PHONE_APP_STATUS" => Ok(thirdparty_app::ThirdpartyAppId::RequestPhoneAppStatus),
                    "SYNC_PHONE_APP_STATUS" => Ok(thirdparty_app::ThirdpartyAppId::SyncPhoneAppStatus),
                    "SEND_PHONE_MESSAGE" => Ok(thirdparty_app::ThirdpartyAppId::SendPhoneMessage),
                    "SEND_WEAR_MESSAGE" => Ok(thirdparty_app::ThirdpartyAppId::SendWearMessage),
                    "REQUEST_WECHAT_LICENSE" => Ok(thirdparty_app::ThirdpartyAppId::RequestWechatLicense),
                    "RESPONSE_WECHAT_LICENSE" => Ok(thirdparty_app::ThirdpartyAppId::ResponseWechatLicense),
                    "REQUEST_MIHOME" => Ok(thirdparty_app::ThirdpartyAppId::RequestMihome),
                    "RESPONSE_MIHOME" => Ok(thirdparty_app::ThirdpartyAppId::ResponseMihome),
                    "REQUEST_SCENE" => Ok(thirdparty_app::ThirdpartyAppId::RequestScene),
                    "RESPONSE_SCENE" => Ok(thirdparty_app::ThirdpartyAppId::ResponseScene),
                    "EXECUTE_SCENE" => Ok(thirdparty_app::ThirdpartyAppId::ExecuteScene),
                    "RESULT_SCENE" => Ok(thirdparty_app::ThirdpartyAppId::ResultScene),
                    "REQUEST_COURSE_TABLE" => Ok(thirdparty_app::ThirdpartyAppId::RequestCourseTable),
                    "SYNC_COURSE_TABLE" => Ok(thirdparty_app::ThirdpartyAppId::SyncCourseTable),
                    "SYNC_CURRENT_BLOOD_GLUCOSE" => Ok(thirdparty_app::ThirdpartyAppId::SyncCurrentBloodGlucose),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Time {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.second.is_some() {
            len += 1;
        }
        if self.millisecond.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Time", len)?;
        struct_ser.serialize_field("hour", &self.hour)?;
        struct_ser.serialize_field("minuter", &self.minuter)?;
        if let Some(v) = self.second.as_ref() {
            struct_ser.serialize_field("second", v)?;
        }
        if let Some(v) = self.millisecond.as_ref() {
            struct_ser.serialize_field("millisecond", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Time {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "hour",
            "minuter",
            "second",
            "millisecond",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Hour,
            Minuter,
            Second,
            Millisecond,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "hour" => Ok(GeneratedField::Hour),
                            "minuter" => Ok(GeneratedField::Minuter),
                            "second" => Ok(GeneratedField::Second),
                            "millisecond" => Ok(GeneratedField::Millisecond),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Time;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Time")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Time, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hour__ = None;
                let mut minuter__ = None;
                let mut second__ = None;
                let mut millisecond__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Hour => {
                            if hour__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hour"));
                            }
                            hour__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Minuter => {
                            if minuter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minuter"));
                            }
                            minuter__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Second => {
                            if second__.is_some() {
                                return Err(serde::de::Error::duplicate_field("second"));
                            }
                            second__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Millisecond => {
                            if millisecond__.is_some() {
                                return Err(serde::de::Error::duplicate_field("millisecond"));
                            }
                            millisecond__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Time {
                    hour: hour__.ok_or_else(|| serde::de::Error::missing_field("hour"))?,
                    minuter: minuter__.ok_or_else(|| serde::de::Error::missing_field("minuter"))?,
                    second: second__,
                    millisecond: millisecond__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Time", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Timezone {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.dst_saving.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Timezone", len)?;
        struct_ser.serialize_field("offset", &self.offset)?;
        if let Some(v) = self.dst_saving.as_ref() {
            struct_ser.serialize_field("dstSaving", v)?;
        }
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("idSpec", &self.id_spec)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Timezone {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "offset",
            "dst_saving",
            "dstSaving",
            "id",
            "id_spec",
            "idSpec",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Offset,
            DstSaving,
            Id,
            IdSpec,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "offset" => Ok(GeneratedField::Offset),
                            "dstSaving" | "dst_saving" => Ok(GeneratedField::DstSaving),
                            "id" => Ok(GeneratedField::Id),
                            "idSpec" | "id_spec" => Ok(GeneratedField::IdSpec),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Timezone;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Timezone")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Timezone, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut offset__ = None;
                let mut dst_saving__ = None;
                let mut id__ = None;
                let mut id_spec__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Offset => {
                            if offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offset"));
                            }
                            offset__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::DstSaving => {
                            if dst_saving__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dstSaving"));
                            }
                            dst_saving__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IdSpec => {
                            if id_spec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("idSpec"));
                            }
                            id_spec__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Timezone {
                    offset: offset__.ok_or_else(|| serde::de::Error::missing_field("offset"))?,
                    dst_saving: dst_saving__,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    id_spec: id_spec__.ok_or_else(|| serde::de::Error::missing_field("idSpec"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Timezone", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TimingMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::AllDayOn => "ALL_DAY_ON",
            Self::TimedOn => "TIMED_ON",
            Self::AllDayOff => "ALL_DAY_OFF",
            Self::SmartOn => "SMART_ON",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for TimingMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ALL_DAY_ON",
            "TIMED_ON",
            "ALL_DAY_OFF",
            "SMART_ON",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TimingMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ALL_DAY_ON" => Ok(TimingMode::AllDayOn),
                    "TIMED_ON" => Ok(TimingMode::TimedOn),
                    "ALL_DAY_OFF" => Ok(TimingMode::AllDayOff),
                    "SMART_ON" => Ok(TimingMode::SmartOn),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TimingSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.start_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.repeat_days.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.TimingSetting", len)?;
        let v = TimingMode::try_from(self.timing_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.timing_mode)))?;
        struct_ser.serialize_field("timingMode", &v)?;
        if let Some(v) = self.start_time.as_ref() {
            struct_ser.serialize_field("startTime", v)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            struct_ser.serialize_field("endTime", v)?;
        }
        if let Some(v) = self.repeat_days.as_ref() {
            struct_ser.serialize_field("repeatDays", v)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TimingSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timing_mode",
            "timingMode",
            "start_time",
            "startTime",
            "end_time",
            "endTime",
            "repeat_days",
            "repeatDays",
            "timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TimingMode,
            StartTime,
            EndTime,
            RepeatDays,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timingMode" | "timing_mode" => Ok(GeneratedField::TimingMode),
                            "startTime" | "start_time" => Ok(GeneratedField::StartTime),
                            "endTime" | "end_time" => Ok(GeneratedField::EndTime),
                            "repeatDays" | "repeat_days" => Ok(GeneratedField::RepeatDays),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TimingSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.TimingSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TimingSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timing_mode__ = None;
                let mut start_time__ = None;
                let mut end_time__ = None;
                let mut repeat_days__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TimingMode => {
                            if timing_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timingMode"));
                            }
                            timing_mode__ = Some(map_.next_value::<TimingMode>()? as i32);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = map_.next_value()?;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endTime"));
                            }
                            end_time__ = map_.next_value()?;
                        }
                        GeneratedField::RepeatDays => {
                            if repeat_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("repeatDays"));
                            }
                            repeat_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TimingSetting {
                    timing_mode: timing_mode__.ok_or_else(|| serde::de::Error::missing_field("timingMode"))?,
                    start_time: start_time__,
                    end_time: end_time__,
                    repeat_days: repeat_days__,
                    timestamp: timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.TimingSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Title {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Title", len)?;
        struct_ser.serialize_field("mainTitle", &self.main_title)?;
        struct_ser.serialize_field("subTitle", &self.sub_title)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Title {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "main_title",
            "mainTitle",
            "sub_title",
            "subTitle",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MainTitle,
            SubTitle,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "mainTitle" | "main_title" => Ok(GeneratedField::MainTitle),
                            "subTitle" | "sub_title" => Ok(GeneratedField::SubTitle),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Title;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Title")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Title, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut main_title__ = None;
                let mut sub_title__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MainTitle => {
                            if main_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mainTitle"));
                            }
                            main_title__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SubTitle => {
                            if sub_title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subTitle"));
                            }
                            sub_title__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(Title {
                    main_title: main_title__.ok_or_else(|| serde::de::Error::missing_field("mainTitle"))?,
                    sub_title: sub_title__.ok_or_else(|| serde::de::Error::missing_field("subTitle"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Title", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Training {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.Training", len)?;
        struct_ser.serialize_field("type", &self.r#type)?;
        #[allow(clippy::needless_borrow)]
        #[allow(clippy::needless_borrows_for_generic_args)]
        struct_ser.serialize_field("id", ToString::to_string(&self.id).as_str())?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Training {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Training;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Training")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Training, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(Training {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Training", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for training::Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Training.Item", len)?;
        struct_ser.serialize_field("course", &self.course)?;
        struct_ser.serialize_field("finished", &self.finished)?;
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for training::Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "course",
            "finished",
            "timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Course,
            Finished,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "course" => Ok(GeneratedField::Course),
                            "finished" => Ok(GeneratedField::Finished),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = training::Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Training.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<training::Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut course__ = None;
                let mut finished__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Course => {
                            if course__.is_some() {
                                return Err(serde::de::Error::duplicate_field("course"));
                            }
                            course__ = map_.next_value()?;
                        }
                        GeneratedField::Finished => {
                            if finished__.is_some() {
                                return Err(serde::de::Error::duplicate_field("finished"));
                            }
                            finished__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(training::Item {
                    course: course__.ok_or_else(|| serde::de::Error::missing_field("course"))?,
                    finished: finished__.ok_or_else(|| serde::de::Error::missing_field("finished"))?,
                    timestamp: timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Training.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for training::Plan {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Training.Plan", len)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for training::Plan {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = training::Plan;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Training.Plan")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<training::Plan, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(training::Plan {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Training.Plan", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UsageGuide {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.UsageGuide", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("needFeedback", &self.need_feedback)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UsageGuide {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "need_feedback",
            "needFeedback",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            NeedFeedback,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "needFeedback" | "need_feedback" => Ok(GeneratedField::NeedFeedback),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UsageGuide;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.UsageGuide")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UsageGuide, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut need_feedback__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::NeedFeedback => {
                            if need_feedback__.is_some() {
                                return Err(serde::de::Error::duplicate_field("needFeedback"));
                            }
                            need_feedback__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UsageGuide {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    need_feedback: need_feedback__.ok_or_else(|| serde::de::Error::missing_field("needFeedback"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.UsageGuide", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for usage_guide::Feedback {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.UsageGuide.Feedback", len)?;
        struct_ser.serialize_field("guideId", &self.guide_id)?;
        struct_ser.serialize_field("success", &self.success)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for usage_guide::Feedback {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "guide_id",
            "guideId",
            "success",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GuideId,
            Success,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "guideId" | "guide_id" => Ok(GeneratedField::GuideId),
                            "success" => Ok(GeneratedField::Success),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = usage_guide::Feedback;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.UsageGuide.Feedback")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<usage_guide::Feedback, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut guide_id__ = None;
                let mut success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::GuideId => {
                            if guide_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("guideId"));
                            }
                            guide_id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(usage_guide::Feedback {
                    guide_id: guide_id__.ok_or_else(|| serde::de::Error::missing_field("guideId"))?,
                    success: success__.ok_or_else(|| serde::de::Error::missing_field("success"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.UsageGuide.Feedback", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserProfile {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.height.is_some() {
            len += 1;
        }
        if self.weight.is_some() {
            len += 1;
        }
        if self.birth.is_some() {
            len += 1;
        }
        if self.sex.is_some() {
            len += 1;
        }
        if self.max_hr.is_some() {
            len += 1;
        }
        if self.goal_calorie.is_some() {
            len += 1;
        }
        if self.goal_step.is_some() {
            len += 1;
        }
        if self.maximal_met.is_some() {
            len += 1;
        }
        if self.goal_valid_stand.is_some() {
            len += 1;
        }
        if self.goal_sleep.is_some() {
            len += 1;
        }
        if self.goal_intensity.is_some() {
            len += 1;
        }
        if self.default_height.is_some() {
            len += 1;
        }
        if self.default_weight.is_some() {
            len += 1;
        }
        if self.default_birth.is_some() {
            len += 1;
        }
        if self.default_sex.is_some() {
            len += 1;
        }
        if self.blood_type.is_some() {
            len += 1;
        }
        if self.rh_blood_type.is_some() {
            len += 1;
        }
        if self.organ_donation_volunteer.is_some() {
            len += 1;
        }
        if self.contact.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.UserProfile", len)?;
        if let Some(v) = self.height.as_ref() {
            struct_ser.serialize_field("height", v)?;
        }
        if let Some(v) = self.weight.as_ref() {
            struct_ser.serialize_field("weight", v)?;
        }
        if let Some(v) = self.birth.as_ref() {
            struct_ser.serialize_field("birth", v)?;
        }
        if let Some(v) = self.sex.as_ref() {
            let v = Sex::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sex", &v)?;
        }
        if let Some(v) = self.max_hr.as_ref() {
            struct_ser.serialize_field("maxHr", v)?;
        }
        if let Some(v) = self.goal_calorie.as_ref() {
            struct_ser.serialize_field("goalCalorie", v)?;
        }
        if let Some(v) = self.goal_step.as_ref() {
            struct_ser.serialize_field("goalStep", v)?;
        }
        if let Some(v) = self.maximal_met.as_ref() {
            struct_ser.serialize_field("maximalMet", v)?;
        }
        if let Some(v) = self.goal_valid_stand.as_ref() {
            struct_ser.serialize_field("goalValidStand", v)?;
        }
        if let Some(v) = self.goal_sleep.as_ref() {
            struct_ser.serialize_field("goalSleep", v)?;
        }
        if let Some(v) = self.goal_intensity.as_ref() {
            struct_ser.serialize_field("goalIntensity", v)?;
        }
        if let Some(v) = self.default_height.as_ref() {
            struct_ser.serialize_field("defaultHeight", v)?;
        }
        if let Some(v) = self.default_weight.as_ref() {
            struct_ser.serialize_field("defaultWeight", v)?;
        }
        if let Some(v) = self.default_birth.as_ref() {
            struct_ser.serialize_field("defaultBirth", v)?;
        }
        if let Some(v) = self.default_sex.as_ref() {
            struct_ser.serialize_field("defaultSex", v)?;
        }
        struct_ser.serialize_field("name", &self.name)?;
        if let Some(v) = self.blood_type.as_ref() {
            struct_ser.serialize_field("bloodType", v)?;
        }
        if let Some(v) = self.rh_blood_type.as_ref() {
            struct_ser.serialize_field("rhBloodType", v)?;
        }
        if let Some(v) = self.organ_donation_volunteer.as_ref() {
            struct_ser.serialize_field("organDonationVolunteer", v)?;
        }
        if let Some(v) = self.contact.as_ref() {
            struct_ser.serialize_field("contact", v)?;
        }
        struct_ser.serialize_field("allergyMedicine", &self.allergy_medicine)?;
        struct_ser.serialize_field("chronicDisease", &self.chronic_disease)?;
        struct_ser.serialize_field("medicalProgram", &self.medical_program)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserProfile {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "height",
            "weight",
            "birth",
            "sex",
            "max_hr",
            "maxHr",
            "goal_calorie",
            "goalCalorie",
            "goal_step",
            "goalStep",
            "maximal_met",
            "maximalMet",
            "goal_valid_stand",
            "goalValidStand",
            "goal_sleep",
            "goalSleep",
            "goal_intensity",
            "goalIntensity",
            "default_height",
            "defaultHeight",
            "default_weight",
            "defaultWeight",
            "default_birth",
            "defaultBirth",
            "default_sex",
            "defaultSex",
            "name",
            "blood_type",
            "bloodType",
            "rh_blood_type",
            "rhBloodType",
            "organ_donation_volunteer",
            "organDonationVolunteer",
            "contact",
            "allergy_medicine",
            "allergyMedicine",
            "chronic_disease",
            "chronicDisease",
            "medical_program",
            "medicalProgram",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Height,
            Weight,
            Birth,
            Sex,
            MaxHr,
            GoalCalorie,
            GoalStep,
            MaximalMet,
            GoalValidStand,
            GoalSleep,
            GoalIntensity,
            DefaultHeight,
            DefaultWeight,
            DefaultBirth,
            DefaultSex,
            Name,
            BloodType,
            RhBloodType,
            OrganDonationVolunteer,
            Contact,
            AllergyMedicine,
            ChronicDisease,
            MedicalProgram,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "height" => Ok(GeneratedField::Height),
                            "weight" => Ok(GeneratedField::Weight),
                            "birth" => Ok(GeneratedField::Birth),
                            "sex" => Ok(GeneratedField::Sex),
                            "maxHr" | "max_hr" => Ok(GeneratedField::MaxHr),
                            "goalCalorie" | "goal_calorie" => Ok(GeneratedField::GoalCalorie),
                            "goalStep" | "goal_step" => Ok(GeneratedField::GoalStep),
                            "maximalMet" | "maximal_met" => Ok(GeneratedField::MaximalMet),
                            "goalValidStand" | "goal_valid_stand" => Ok(GeneratedField::GoalValidStand),
                            "goalSleep" | "goal_sleep" => Ok(GeneratedField::GoalSleep),
                            "goalIntensity" | "goal_intensity" => Ok(GeneratedField::GoalIntensity),
                            "defaultHeight" | "default_height" => Ok(GeneratedField::DefaultHeight),
                            "defaultWeight" | "default_weight" => Ok(GeneratedField::DefaultWeight),
                            "defaultBirth" | "default_birth" => Ok(GeneratedField::DefaultBirth),
                            "defaultSex" | "default_sex" => Ok(GeneratedField::DefaultSex),
                            "name" => Ok(GeneratedField::Name),
                            "bloodType" | "blood_type" => Ok(GeneratedField::BloodType),
                            "rhBloodType" | "rh_blood_type" => Ok(GeneratedField::RhBloodType),
                            "organDonationVolunteer" | "organ_donation_volunteer" => Ok(GeneratedField::OrganDonationVolunteer),
                            "contact" => Ok(GeneratedField::Contact),
                            "allergyMedicine" | "allergy_medicine" => Ok(GeneratedField::AllergyMedicine),
                            "chronicDisease" | "chronic_disease" => Ok(GeneratedField::ChronicDisease),
                            "medicalProgram" | "medical_program" => Ok(GeneratedField::MedicalProgram),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserProfile;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.UserProfile")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserProfile, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut height__ = None;
                let mut weight__ = None;
                let mut birth__ = None;
                let mut sex__ = None;
                let mut max_hr__ = None;
                let mut goal_calorie__ = None;
                let mut goal_step__ = None;
                let mut maximal_met__ = None;
                let mut goal_valid_stand__ = None;
                let mut goal_sleep__ = None;
                let mut goal_intensity__ = None;
                let mut default_height__ = None;
                let mut default_weight__ = None;
                let mut default_birth__ = None;
                let mut default_sex__ = None;
                let mut name__ = None;
                let mut blood_type__ = None;
                let mut rh_blood_type__ = None;
                let mut organ_donation_volunteer__ = None;
                let mut contact__ = None;
                let mut allergy_medicine__ = None;
                let mut chronic_disease__ = None;
                let mut medical_program__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Height => {
                            if height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("height"));
                            }
                            height__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Weight => {
                            if weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weight"));
                            }
                            weight__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Birth => {
                            if birth__.is_some() {
                                return Err(serde::de::Error::duplicate_field("birth"));
                            }
                            birth__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Sex => {
                            if sex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sex"));
                            }
                            sex__ = map_.next_value::<::std::option::Option<Sex>>()?.map(|x| x as i32);
                        }
                        GeneratedField::MaxHr => {
                            if max_hr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxHr"));
                            }
                            max_hr__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GoalCalorie => {
                            if goal_calorie__.is_some() {
                                return Err(serde::de::Error::duplicate_field("goalCalorie"));
                            }
                            goal_calorie__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GoalStep => {
                            if goal_step__.is_some() {
                                return Err(serde::de::Error::duplicate_field("goalStep"));
                            }
                            goal_step__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaximalMet => {
                            if maximal_met__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maximalMet"));
                            }
                            maximal_met__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GoalValidStand => {
                            if goal_valid_stand__.is_some() {
                                return Err(serde::de::Error::duplicate_field("goalValidStand"));
                            }
                            goal_valid_stand__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GoalSleep => {
                            if goal_sleep__.is_some() {
                                return Err(serde::de::Error::duplicate_field("goalSleep"));
                            }
                            goal_sleep__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GoalIntensity => {
                            if goal_intensity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("goalIntensity"));
                            }
                            goal_intensity__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DefaultHeight => {
                            if default_height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultHeight"));
                            }
                            default_height__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DefaultWeight => {
                            if default_weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultWeight"));
                            }
                            default_weight__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DefaultBirth => {
                            if default_birth__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultBirth"));
                            }
                            default_birth__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DefaultSex => {
                            if default_sex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("defaultSex"));
                            }
                            default_sex__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BloodType => {
                            if blood_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bloodType"));
                            }
                            blood_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RhBloodType => {
                            if rh_blood_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rhBloodType"));
                            }
                            rh_blood_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OrganDonationVolunteer => {
                            if organ_donation_volunteer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("organDonationVolunteer"));
                            }
                            organ_donation_volunteer__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Contact => {
                            if contact__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contact"));
                            }
                            contact__ = map_.next_value()?;
                        }
                        GeneratedField::AllergyMedicine => {
                            if allergy_medicine__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allergyMedicine"));
                            }
                            allergy_medicine__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ChronicDisease => {
                            if chronic_disease__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chronicDisease"));
                            }
                            chronic_disease__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MedicalProgram => {
                            if medical_program__.is_some() {
                                return Err(serde::de::Error::duplicate_field("medicalProgram"));
                            }
                            medical_program__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UserProfile {
                    height: height__,
                    weight: weight__,
                    birth: birth__,
                    sex: sex__,
                    max_hr: max_hr__,
                    goal_calorie: goal_calorie__,
                    goal_step: goal_step__,
                    maximal_met: maximal_met__,
                    goal_valid_stand: goal_valid_stand__,
                    goal_sleep: goal_sleep__,
                    goal_intensity: goal_intensity__,
                    default_height: default_height__,
                    default_weight: default_weight__,
                    default_birth: default_birth__,
                    default_sex: default_sex__,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    blood_type: blood_type__,
                    rh_blood_type: rh_blood_type__,
                    organ_donation_volunteer: organ_donation_volunteer__,
                    contact: contact__,
                    allergy_medicine: allergy_medicine__.ok_or_else(|| serde::de::Error::missing_field("allergyMedicine"))?,
                    chronic_disease: chronic_disease__.ok_or_else(|| serde::de::Error::missing_field("chronicDisease"))?,
                    medical_program: medical_program__.ok_or_else(|| serde::de::Error::missing_field("medicalProgram"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.UserProfile", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for user_profile::Contact {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.UserProfile.Contact", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("number", &self.number)?;
        struct_ser.serialize_field("relation", &self.relation)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for user_profile::Contact {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "number",
            "relation",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Number,
            Relation,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "number" => Ok(GeneratedField::Number),
                            "relation" => Ok(GeneratedField::Relation),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = user_profile::Contact;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.UserProfile.Contact")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<user_profile::Contact, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut number__ = None;
                let mut relation__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Number => {
                            if number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("number"));
                            }
                            number__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Relation => {
                            if relation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("relation"));
                            }
                            relation__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(user_profile::Contact {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    number: number__.ok_or_else(|| serde::de::Error::missing_field("number"))?,
                    relation: relation__.ok_or_else(|| serde::de::Error::missing_field("relation"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.UserProfile.Contact", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VerifyMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ServerPsk => "SERVER_PSK",
            Self::AppLocal => "APP_LOCAL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for VerifyMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SERVER_PSK",
            "APP_LOCAL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VerifyMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SERVER_PSK" => Ok(VerifyMode::ServerPsk),
                    "APP_LOCAL" => Ok(VerifyMode::AppLocal),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Vibrator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.segments.is_empty() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Vibrator", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        if !self.segments.is_empty() {
            struct_ser.serialize_field("segments", &self.segments)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            let v = vibrator::Type::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Vibrator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "segments",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            Segments,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "segments" => Ok(GeneratedField::Segments),
                            "type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Vibrator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Vibrator")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Vibrator, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut segments__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Segments => {
                            if segments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("segments"));
                            }
                            segments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<vibrator::Type>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(Vibrator {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    segments: segments__.unwrap_or_default(),
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Vibrator", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for vibrator::Removal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Vibrator.Removal", len)?;
        if !self.ids.is_empty() {
            struct_ser.serialize_field("ids", &self.ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for vibrator::Removal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ids,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ids" => Ok(GeneratedField::Ids),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = vibrator::Removal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Vibrator.Removal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<vibrator::Removal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ids => {
                            if ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ids"));
                            }
                            ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(vibrator::Removal {
                    ids: ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.Vibrator.Removal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for vibrator::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "NONE",
            Self::Call => "CALL",
            Self::Event => "EVENT",
            Self::Clock => "CLOCK",
            Self::Notification => "NOTIFICATION",
            Self::Sedentary => "SEDENTARY",
            Self::Message => "MESSAGE",
            Self::Goal => "GOAL",
            Self::Calendar => "CALENDAR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for vibrator::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NONE",
            "CALL",
            "EVENT",
            "CLOCK",
            "NOTIFICATION",
            "SEDENTARY",
            "MESSAGE",
            "GOAL",
            "CALENDAR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = vibrator::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NONE" => Ok(vibrator::Type::None),
                    "CALL" => Ok(vibrator::Type::Call),
                    "EVENT" => Ok(vibrator::Type::Event),
                    "CLOCK" => Ok(vibrator::Type::Clock),
                    "NOTIFICATION" => Ok(vibrator::Type::Notification),
                    "SEDENTARY" => Ok(vibrator::Type::Sedentary),
                    "MESSAGE" => Ok(vibrator::Type::Message),
                    "GOAL" => Ok(vibrator::Type::Goal),
                    "CALENDAR" => Ok(vibrator::Type::Calendar),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for VibratorEffect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.segments.is_empty() {
            len += 1;
        }
        if self.item.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.VibratorEffect", len)?;
        if !self.segments.is_empty() {
            struct_ser.serialize_field("segments", &self.segments)?;
        }
        if let Some(v) = self.item.as_ref() {
            struct_ser.serialize_field("item", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VibratorEffect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "segments",
            "item",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Segments,
            Item,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "segments" => Ok(GeneratedField::Segments),
                            "item" => Ok(GeneratedField::Item),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VibratorEffect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VibratorEffect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VibratorEffect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut segments__ = None;
                let mut item__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Segments => {
                            if segments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("segments"));
                            }
                            segments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Item => {
                            if item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("item"));
                            }
                            item__ = map_.next_value()?;
                        }
                    }
                }
                Ok(VibratorEffect {
                    segments: segments__.unwrap_or_default(),
                    item: item__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.VibratorEffect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for vibrator_effect::Segment {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.strength.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.VibratorEffect.Segment", len)?;
        struct_ser.serialize_field("on", &self.on)?;
        struct_ser.serialize_field("duration", &self.duration)?;
        if let Some(v) = self.strength.as_ref() {
            struct_ser.serialize_field("strength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for vibrator_effect::Segment {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "on",
            "duration",
            "strength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            On,
            Duration,
            Strength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "on" => Ok(GeneratedField::On),
                            "duration" => Ok(GeneratedField::Duration),
                            "strength" => Ok(GeneratedField::Strength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = vibrator_effect::Segment;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VibratorEffect.Segment")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<vibrator_effect::Segment, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut on__ = None;
                let mut duration__ = None;
                let mut strength__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::On => {
                            if on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("on"));
                            }
                            on__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Strength => {
                            if strength__.is_some() {
                                return Err(serde::de::Error::duplicate_field("strength"));
                            }
                            strength__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(vibrator_effect::Segment {
                    on: on__.ok_or_else(|| serde::de::Error::missing_field("on"))?,
                    duration: duration__.ok_or_else(|| serde::de::Error::missing_field("duration"))?,
                    strength: strength__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.VibratorEffect.Segment", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VibratorError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.VibratorError", len)?;
        let v = vibrator_error::Code::try_from(self.code)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.code)))?;
        struct_ser.serialize_field("code", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VibratorError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VibratorError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VibratorError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VibratorError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = Some(map_.next_value::<vibrator_error::Code>()? as i32);
                        }
                    }
                }
                Ok(VibratorError {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.VibratorError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for vibrator_error::Code {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ok => "OK",
            Self::NumberLimit => "NUMBER_LIMIT",
            Self::IdNotExist => "ID_NOT_EXIST",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for vibrator_error::Code {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OK",
            "NUMBER_LIMIT",
            "ID_NOT_EXIST",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = vibrator_error::Code;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OK" => Ok(vibrator_error::Code::Ok),
                    "NUMBER_LIMIT" => Ok(vibrator_error::Code::NumberLimit),
                    "ID_NOT_EXIST" => Ok(vibrator_error::Code::IdNotExist),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for VibratorItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.supported_builtin_ids.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.VibratorItem", len)?;
        let v = vibrator::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("id", &self.id)?;
        if let Some(v) = self.supported_builtin_ids.as_ref() {
            struct_ser.serialize_field("supportedBuiltinIds", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VibratorItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "id",
            "supported_builtin_ids",
            "supportedBuiltinIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
            SupportedBuiltinIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "id" => Ok(GeneratedField::Id),
                            "supportedBuiltinIds" | "supported_builtin_ids" => Ok(GeneratedField::SupportedBuiltinIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VibratorItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VibratorItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VibratorItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                let mut supported_builtin_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<vibrator::Type>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SupportedBuiltinIds => {
                            if supported_builtin_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportedBuiltinIds"));
                            }
                            supported_builtin_ids__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(VibratorItem {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    supported_builtin_ids: supported_builtin_ids__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.VibratorItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VibratorSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.items.is_empty() {
            len += 1;
        }
        if !self.vibrators.is_empty() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.VibratorSetting", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("items", &self.items)?;
        }
        struct_ser.serialize_field("maxNumber", &self.max_number)?;
        if !self.vibrators.is_empty() {
            struct_ser.serialize_field("vibrators", &self.vibrators)?;
        }
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VibratorSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "max_number",
            "maxNumber",
            "vibrators",
            "version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            MaxNumber,
            Vibrators,
            Version,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "maxNumber" | "max_number" => Ok(GeneratedField::MaxNumber),
                            "vibrators" => Ok(GeneratedField::Vibrators),
                            "version" => Ok(GeneratedField::Version),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VibratorSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VibratorSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VibratorSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut max_number__ = None;
                let mut vibrators__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MaxNumber => {
                            if max_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxNumber"));
                            }
                            max_number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Vibrators => {
                            if vibrators__.is_some() {
                                return Err(serde::de::Error::duplicate_field("vibrators"));
                            }
                            vibrators__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(VibratorSetting {
                    items: items__.unwrap_or_default(),
                    max_number: max_number__.ok_or_else(|| serde::de::Error::missing_field("maxNumber"))?,
                    vibrators: vibrators__.unwrap_or_default(),
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.VibratorSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VitalityData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.VitalityData", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VitalityData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VitalityData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VitalityData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VitalityData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(VitalityData {
                })
            }
        }
        deserializer.deserialize_struct("protocol.VitalityData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for vitality_data::Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.interval.is_some() {
            len += 1;
        }
        if !self.detail.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.VitalityData.Item", len)?;
        let v = goal::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("total", &self.total)?;
        if let Some(v) = self.interval.as_ref() {
            struct_ser.serialize_field("interval", v)?;
        }
        if !self.detail.is_empty() {
            struct_ser.serialize_field("detail", &self.detail)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for vitality_data::Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "total",
            "interval",
            "detail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Total,
            Interval,
            Detail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "total" => Ok(GeneratedField::Total),
                            "interval" => Ok(GeneratedField::Interval),
                            "detail" => Ok(GeneratedField::Detail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = vitality_data::Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VitalityData.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<vitality_data::Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut total__ = None;
                let mut interval__ = None;
                let mut detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<goal::Type>()? as i32);
                        }
                        GeneratedField::Total => {
                            if total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("total"));
                            }
                            total__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Interval => {
                            if interval__.is_some() {
                                return Err(serde::de::Error::duplicate_field("interval"));
                            }
                            interval__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Detail => {
                            if detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("detail"));
                            }
                            detail__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(vitality_data::Item {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    total: total__.ok_or_else(|| serde::de::Error::missing_field("total"))?,
                    interval: interval__,
                    detail: detail__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.VitalityData.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for vitality_data::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.timestamp.is_some() {
            len += 1;
        }
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.VitalityData.List", len)?;
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", v)?;
        }
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for vitality_data::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = vitality_data::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VitalityData.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<vitality_data::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(vitality_data::List {
                    timestamp: timestamp__,
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.VitalityData.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VitalityReminder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.VitalityReminder", len)?;
        struct_ser.serialize_field("reachGoal", &self.reach_goal)?;
        struct_ser.serialize_field("reachHelp", &self.reach_help)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VitalityReminder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reach_goal",
            "reachGoal",
            "reach_help",
            "reachHelp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReachGoal,
            ReachHelp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reachGoal" | "reach_goal" => Ok(GeneratedField::ReachGoal),
                            "reachHelp" | "reach_help" => Ok(GeneratedField::ReachHelp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VitalityReminder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.VitalityReminder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VitalityReminder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reach_goal__ = None;
                let mut reach_help__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReachGoal => {
                            if reach_goal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reachGoal"));
                            }
                            reach_goal__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReachHelp => {
                            if reach_help__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reachHelp"));
                            }
                            reach_help__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(VitalityReminder {
                    reach_goal: reach_goal__.ok_or_else(|| serde::de::Error::missing_field("reachGoal"))?,
                    reach_help: reach_help__.ok_or_else(|| serde::de::Error::missing_field("reachHelp"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.VitalityReminder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WarningOption {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WarningOption", len)?;
        struct_ser.serialize_field("warning", &self.warning)?;
        struct_ser.serialize_field("warningValue", &self.warning_value)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WarningOption {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "warning",
            "warning_value",
            "warningValue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Warning,
            WarningValue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "warning" => Ok(GeneratedField::Warning),
                            "warningValue" | "warning_value" => Ok(GeneratedField::WarningValue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WarningOption;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WarningOption")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WarningOption, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut warning__ = None;
                let mut warning_value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Warning => {
                            if warning__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warning"));
                            }
                            warning__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WarningValue => {
                            if warning_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("warningValue"));
                            }
                            warning_value__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(WarningOption {
                    warning: warning__.ok_or_else(|| serde::de::Error::missing_field("warning"))?,
                    warning_value: warning_value__.ok_or_else(|| serde::de::Error::missing_field("warningValue"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WarningOption", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WatchFace {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFace", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                watch_face::Payload::WatchFaceList(v) => {
                    struct_ser.serialize_field("watchFaceList", v)?;
                }
                watch_face::Payload::Id(v) => {
                    struct_ser.serialize_field("id", v)?;
                }
                watch_face::Payload::Path(v) => {
                    struct_ser.serialize_field("path", v)?;
                }
                watch_face::Payload::Success(v) => {
                    struct_ser.serialize_field("success", v)?;
                }
                watch_face::Payload::PrepareStatus(v) => {
                    let v = PrepareStatus::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("prepareStatus", &v)?;
                }
                watch_face::Payload::PrepareInfo(v) => {
                    struct_ser.serialize_field("prepareInfo", v)?;
                }
                watch_face::Payload::InstallResult(v) => {
                    struct_ser.serialize_field("installResult", v)?;
                }
                watch_face::Payload::InfoList(v) => {
                    struct_ser.serialize_field("infoList", v)?;
                }
                watch_face::Payload::PrepareReply(v) => {
                    struct_ser.serialize_field("prepareReply", v)?;
                }
                watch_face::Payload::SupportDataList(v) => {
                    struct_ser.serialize_field("supportDataList", v)?;
                }
                watch_face::Payload::EditRequest(v) => {
                    struct_ser.serialize_field("editRequest", v)?;
                }
                watch_face::Payload::EditResponse(v) => {
                    struct_ser.serialize_field("editResponse", v)?;
                }
                watch_face::Payload::BgImageResult(v) => {
                    struct_ser.serialize_field("bgImageResult", v)?;
                }
                watch_face::Payload::FontResult(v) => {
                    struct_ser.serialize_field("fontResult", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WatchFace {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "watch_face_list",
            "watchFaceList",
            "id",
            "path",
            "success",
            "prepare_status",
            "prepareStatus",
            "prepare_info",
            "prepareInfo",
            "install_result",
            "installResult",
            "info_list",
            "infoList",
            "prepare_reply",
            "prepareReply",
            "support_data_list",
            "supportDataList",
            "edit_request",
            "editRequest",
            "edit_response",
            "editResponse",
            "bg_image_result",
            "bgImageResult",
            "font_result",
            "fontResult",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WatchFaceList,
            Id,
            Path,
            Success,
            PrepareStatus,
            PrepareInfo,
            InstallResult,
            InfoList,
            PrepareReply,
            SupportDataList,
            EditRequest,
            EditResponse,
            BgImageResult,
            FontResult,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "watchFaceList" | "watch_face_list" => Ok(GeneratedField::WatchFaceList),
                            "id" => Ok(GeneratedField::Id),
                            "path" => Ok(GeneratedField::Path),
                            "success" => Ok(GeneratedField::Success),
                            "prepareStatus" | "prepare_status" => Ok(GeneratedField::PrepareStatus),
                            "prepareInfo" | "prepare_info" => Ok(GeneratedField::PrepareInfo),
                            "installResult" | "install_result" => Ok(GeneratedField::InstallResult),
                            "infoList" | "info_list" => Ok(GeneratedField::InfoList),
                            "prepareReply" | "prepare_reply" => Ok(GeneratedField::PrepareReply),
                            "supportDataList" | "support_data_list" => Ok(GeneratedField::SupportDataList),
                            "editRequest" | "edit_request" => Ok(GeneratedField::EditRequest),
                            "editResponse" | "edit_response" => Ok(GeneratedField::EditResponse),
                            "bgImageResult" | "bg_image_result" => Ok(GeneratedField::BgImageResult),
                            "fontResult" | "font_result" => Ok(GeneratedField::FontResult),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WatchFace;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFace")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WatchFace, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WatchFaceList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("watchFaceList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::WatchFaceList)
;
                        }
                        GeneratedField::Id => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::Id);
                        }
                        GeneratedField::Path => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("path"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::Path);
                        }
                        GeneratedField::Success => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::Success);
                        }
                        GeneratedField::PrepareStatus => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareStatus"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<PrepareStatus>>()?.map(|x| watch_face::Payload::PrepareStatus(x as i32));
                        }
                        GeneratedField::PrepareInfo => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareInfo"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::PrepareInfo)
;
                        }
                        GeneratedField::InstallResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("installResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::InstallResult)
;
                        }
                        GeneratedField::InfoList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("infoList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::InfoList)
;
                        }
                        GeneratedField::PrepareReply => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("prepareReply"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::PrepareReply)
;
                        }
                        GeneratedField::SupportDataList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportDataList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::SupportDataList)
;
                        }
                        GeneratedField::EditRequest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("editRequest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::EditRequest)
;
                        }
                        GeneratedField::EditResponse => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("editResponse"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::EditResponse)
;
                        }
                        GeneratedField::BgImageResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bgImageResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::BgImageResult)
;
                        }
                        GeneratedField::FontResult => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fontResult"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(watch_face::Payload::FontResult)
;
                        }
                    }
                }
                Ok(WatchFace {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFace", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face::WatchFaceId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GetInstalledList => "GET_INSTALLED_LIST",
            Self::SetWatchFace => "SET_WATCH_FACE",
            Self::RemoveWatchFace => "REMOVE_WATCH_FACE",
            Self::RemoveWatchFacePhoto => "REMOVE_WATCH_FACE_PHOTO",
            Self::PrepareInstallWatchFace => "PREPARE_INSTALL_WATCH_FACE",
            Self::ReportInstallResult => "REPORT_INSTALL_RESULT",
            Self::RemoveMultiWatchFace => "REMOVE_MULTI_WATCH_FACE",
            Self::GetSupportData => "GET_SUPPORT_DATA",
            Self::EditWatchFace => "EDIT_WATCH_FACE",
            Self::BgImageResult => "BG_IMAGE_RESULT",
            Self::FontResult => "FONT_RESULT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for watch_face::WatchFaceId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GET_INSTALLED_LIST",
            "SET_WATCH_FACE",
            "REMOVE_WATCH_FACE",
            "REMOVE_WATCH_FACE_PHOTO",
            "PREPARE_INSTALL_WATCH_FACE",
            "REPORT_INSTALL_RESULT",
            "REMOVE_MULTI_WATCH_FACE",
            "GET_SUPPORT_DATA",
            "EDIT_WATCH_FACE",
            "BG_IMAGE_RESULT",
            "FONT_RESULT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face::WatchFaceId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GET_INSTALLED_LIST" => Ok(watch_face::WatchFaceId::GetInstalledList),
                    "SET_WATCH_FACE" => Ok(watch_face::WatchFaceId::SetWatchFace),
                    "REMOVE_WATCH_FACE" => Ok(watch_face::WatchFaceId::RemoveWatchFace),
                    "REMOVE_WATCH_FACE_PHOTO" => Ok(watch_face::WatchFaceId::RemoveWatchFacePhoto),
                    "PREPARE_INSTALL_WATCH_FACE" => Ok(watch_face::WatchFaceId::PrepareInstallWatchFace),
                    "REPORT_INSTALL_RESULT" => Ok(watch_face::WatchFaceId::ReportInstallResult),
                    "REMOVE_MULTI_WATCH_FACE" => Ok(watch_face::WatchFaceId::RemoveMultiWatchFace),
                    "GET_SUPPORT_DATA" => Ok(watch_face::WatchFaceId::GetSupportData),
                    "EDIT_WATCH_FACE" => Ok(watch_face::WatchFaceId::EditWatchFace),
                    "BG_IMAGE_RESULT" => Ok(watch_face::WatchFaceId::BgImageResult),
                    "FONT_RESULT" => Ok(watch_face::WatchFaceId::FontResult),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WatchFaceImage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceImage", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("size", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WatchFaceImage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "size",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Size,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "size" => Ok(GeneratedField::Size),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WatchFaceImage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceImage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WatchFaceImage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WatchFaceImage {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    size: size__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceImage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_image::Group {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.fg_image.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceImage.Group", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("contentPosIndex", &self.content_pos_index)?;
        struct_ser.serialize_field("bgImage", &self.bg_image)?;
        if let Some(v) = self.fg_image.as_ref() {
            struct_ser.serialize_field("fgImage", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_image::Group {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "content_pos_index",
            "contentPosIndex",
            "bg_image",
            "bgImage",
            "fg_image",
            "fgImage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            ContentPosIndex,
            BgImage,
            FgImage,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "contentPosIndex" | "content_pos_index" => Ok(GeneratedField::ContentPosIndex),
                            "bgImage" | "bg_image" => Ok(GeneratedField::BgImage),
                            "fgImage" | "fg_image" => Ok(GeneratedField::FgImage),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_image::Group;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceImage.Group")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_image::Group, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut content_pos_index__ = None;
                let mut bg_image__ = None;
                let mut fg_image__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ContentPosIndex => {
                            if content_pos_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contentPosIndex"));
                            }
                            content_pos_index__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::BgImage => {
                            if bg_image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bgImage"));
                            }
                            bg_image__ = map_.next_value()?;
                        }
                        GeneratedField::FgImage => {
                            if fg_image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fgImage"));
                            }
                            fg_image__ = map_.next_value()?;
                        }
                    }
                }
                Ok(watch_face_image::Group {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    content_pos_index: content_pos_index__.ok_or_else(|| serde::de::Error::missing_field("contentPosIndex"))?,
                    bg_image: bg_image__.ok_or_else(|| serde::de::Error::missing_field("bgImage"))?,
                    fg_image: fg_image__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceImage.Group", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_image::GroupList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceImage.GroupList", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.serialize_field("supportMaxCount", &self.support_max_count)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_image::GroupList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "support_max_count",
            "supportMaxCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            SupportMaxCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "supportMaxCount" | "support_max_count" => Ok(GeneratedField::SupportMaxCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_image::GroupList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceImage.GroupList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_image::GroupList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut support_max_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportMaxCount => {
                            if support_max_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMaxCount"));
                            }
                            support_max_count__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(watch_face_image::GroupList {
                    list: list__.unwrap_or_default(),
                    support_max_count: support_max_count__.ok_or_else(|| serde::de::Error::missing_field("supportMaxCount"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceImage.GroupList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WatchFaceInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceInfo", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WatchFaceInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WatchFaceInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WatchFaceInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WatchFaceInfo {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_info::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceInfo.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_info::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_info::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceInfo.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_info::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(watch_face_info::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceInfo.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WatchFaceItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 6;
        if self.can_remove.is_some() {
            len += 1;
        }
        if self.version_code.is_some() {
            len += 1;
        }
        if self.can_edit.is_some() {
            len += 1;
        }
        if !self.data_list.is_empty() {
            len += 1;
        }
        if self.support_image_format.is_some() {
            len += 1;
        }
        if !self.background_image_list.is_empty() {
            len += 1;
        }
        if !self.slot_item_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceItem", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("isCurrent", &self.is_current)?;
        if let Some(v) = self.can_remove.as_ref() {
            struct_ser.serialize_field("canRemove", v)?;
        }
        if let Some(v) = self.version_code.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("versionCode", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.can_edit.as_ref() {
            struct_ser.serialize_field("canEdit", v)?;
        }
        struct_ser.serialize_field("backgroundColor", &self.background_color)?;
        struct_ser.serialize_field("backgroundImage", &self.background_image)?;
        struct_ser.serialize_field("style", &self.style)?;
        if !self.data_list.is_empty() {
            let v = self.data_list.iter().cloned().map(|v| {
                watch_face_slot::Data::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("dataList", &v)?;
        }
        if let Some(v) = self.support_image_format.as_ref() {
            let v = ImageFormat::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("supportImageFormat", &v)?;
        }
        if !self.background_image_list.is_empty() {
            struct_ser.serialize_field("backgroundImageList", &self.background_image_list)?;
        }
        if !self.slot_item_list.is_empty() {
            struct_ser.serialize_field("slotItemList", &self.slot_item_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WatchFaceItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "is_current",
            "isCurrent",
            "can_remove",
            "canRemove",
            "version_code",
            "versionCode",
            "can_edit",
            "canEdit",
            "background_color",
            "backgroundColor",
            "background_image",
            "backgroundImage",
            "style",
            "data_list",
            "dataList",
            "support_image_format",
            "supportImageFormat",
            "background_image_list",
            "backgroundImageList",
            "slot_item_list",
            "slotItemList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            IsCurrent,
            CanRemove,
            VersionCode,
            CanEdit,
            BackgroundColor,
            BackgroundImage,
            Style,
            DataList,
            SupportImageFormat,
            BackgroundImageList,
            SlotItemList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "isCurrent" | "is_current" => Ok(GeneratedField::IsCurrent),
                            "canRemove" | "can_remove" => Ok(GeneratedField::CanRemove),
                            "versionCode" | "version_code" => Ok(GeneratedField::VersionCode),
                            "canEdit" | "can_edit" => Ok(GeneratedField::CanEdit),
                            "backgroundColor" | "background_color" => Ok(GeneratedField::BackgroundColor),
                            "backgroundImage" | "background_image" => Ok(GeneratedField::BackgroundImage),
                            "style" => Ok(GeneratedField::Style),
                            "dataList" | "data_list" => Ok(GeneratedField::DataList),
                            "supportImageFormat" | "support_image_format" => Ok(GeneratedField::SupportImageFormat),
                            "backgroundImageList" | "background_image_list" => Ok(GeneratedField::BackgroundImageList),
                            "slotItemList" | "slot_item_list" => Ok(GeneratedField::SlotItemList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WatchFaceItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WatchFaceItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut is_current__ = None;
                let mut can_remove__ = None;
                let mut version_code__ = None;
                let mut can_edit__ = None;
                let mut background_color__ = None;
                let mut background_image__ = None;
                let mut style__ = None;
                let mut data_list__ = None;
                let mut support_image_format__ = None;
                let mut background_image_list__ = None;
                let mut slot_item_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsCurrent => {
                            if is_current__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isCurrent"));
                            }
                            is_current__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CanRemove => {
                            if can_remove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canRemove"));
                            }
                            can_remove__ = map_.next_value()?;
                        }
                        GeneratedField::VersionCode => {
                            if version_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionCode"));
                            }
                            version_code__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CanEdit => {
                            if can_edit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canEdit"));
                            }
                            can_edit__ = map_.next_value()?;
                        }
                        GeneratedField::BackgroundColor => {
                            if background_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundColor"));
                            }
                            background_color__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BackgroundImage => {
                            if background_image__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImage"));
                            }
                            background_image__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Style => {
                            if style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("style"));
                            }
                            style__ = Some(map_.next_value()?);
                        }
                        GeneratedField::DataList => {
                            if data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataList"));
                            }
                            data_list__ = Some(map_.next_value::<Vec<watch_face_slot::Data>>()?.into_iter().map(|x| x as i32).collect());
                        }
                        GeneratedField::SupportImageFormat => {
                            if support_image_format__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportImageFormat"));
                            }
                            support_image_format__ = map_.next_value::<::std::option::Option<ImageFormat>>()?.map(|x| x as i32);
                        }
                        GeneratedField::BackgroundImageList => {
                            if background_image_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("backgroundImageList"));
                            }
                            background_image_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SlotItemList => {
                            if slot_item_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("slotItemList"));
                            }
                            slot_item_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WatchFaceItem {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    is_current: is_current__.ok_or_else(|| serde::de::Error::missing_field("isCurrent"))?,
                    can_remove: can_remove__,
                    version_code: version_code__,
                    can_edit: can_edit__,
                    background_color: background_color__.ok_or_else(|| serde::de::Error::missing_field("backgroundColor"))?,
                    background_image: background_image__.ok_or_else(|| serde::de::Error::missing_field("backgroundImage"))?,
                    style: style__.ok_or_else(|| serde::de::Error::missing_field("style"))?,
                    data_list: data_list__.unwrap_or_default(),
                    support_image_format: support_image_format__,
                    background_image_list: background_image_list__.unwrap_or_default(),
                    slot_item_list: slot_item_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(watch_face_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WatchFaceLiteral {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.font_size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceLiteral", len)?;
        struct_ser.serialize_field("items", &self.items)?;
        struct_ser.serialize_field("font", &self.font)?;
        if let Some(v) = self.font_size.as_ref() {
            struct_ser.serialize_field("fontSize", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WatchFaceLiteral {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "items",
            "font",
            "font_size",
            "fontSize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            Font,
            FontSize,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "items" => Ok(GeneratedField::Items),
                            "font" => Ok(GeneratedField::Font),
                            "fontSize" | "font_size" => Ok(GeneratedField::FontSize),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WatchFaceLiteral;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceLiteral")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WatchFaceLiteral, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut font__ = None;
                let mut font_size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("items"));
                            }
                            items__ = map_.next_value()?;
                        }
                        GeneratedField::Font => {
                            if font__.is_some() {
                                return Err(serde::de::Error::duplicate_field("font"));
                            }
                            font__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FontSize => {
                            if font_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fontSize"));
                            }
                            font_size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WatchFaceLiteral {
                    items: items__.ok_or_else(|| serde::de::Error::missing_field("items"))?,
                    font: font__.ok_or_else(|| serde::de::Error::missing_field("font"))?,
                    font_size: font_size__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceLiteral", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_literal::Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if !self.text_list.is_empty() {
            len += 1;
        }
        if self.source.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceLiteral.Item", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        if !self.text_list.is_empty() {
            struct_ser.serialize_field("textList", &self.text_list)?;
        }
        if let Some(v) = self.source.as_ref() {
            struct_ser.serialize_field("source", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_literal::Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "text_list",
            "textList",
            "source",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TextList,
            Source,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "textList" | "text_list" => Ok(GeneratedField::TextList),
                            "source" => Ok(GeneratedField::Source),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_literal::Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceLiteral.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_literal::Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut text_list__ = None;
                let mut source__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TextList => {
                            if text_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("textList"));
                            }
                            text_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(watch_face_literal::Item {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    text_list: text_list__.unwrap_or_default(),
                    source: source__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceLiteral.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_literal::item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.literal_items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceLiteral.Item.List", len)?;
        if !self.literal_items.is_empty() {
            struct_ser.serialize_field("literalItems", &self.literal_items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_literal::item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "literal_items",
            "literalItems",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LiteralItems,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "literalItems" | "literal_items" => Ok(GeneratedField::LiteralItems),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_literal::item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceLiteral.Item.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_literal::item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut literal_items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LiteralItems => {
                            if literal_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("literalItems"));
                            }
                            literal_items__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(watch_face_literal::item::List {
                    literal_items: literal_items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceLiteral.Item.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WatchFaceSlot {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.WatchFaceSlot", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WatchFaceSlot {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WatchFaceSlot;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceSlot")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WatchFaceSlot, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(WatchFaceSlot {
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceSlot", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_slot::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Empty => "EMPTY",
            Self::HeartRate => "HEART_RATE",
            Self::Pressure => "PRESSURE",
            Self::Sleep => "SLEEP",
            Self::Energy => "ENERGY",
            Self::Step => "STEP",
            Self::Calorie => "CALORIE",
            Self::ValidStand => "VALID_STAND",
            Self::Battery => "BATTERY",
            Self::Date => "DATE",
            Self::Weather => "WEATHER",
            Self::AirPressure => "AIR_PRESSURE",
            Self::Altitude => "ALTITUDE",
            Self::Timer => "TIMER",
            Self::Clock => "CLOCK",
            Self::Aqi => "AQI",
            Self::Humidity => "HUMIDITY",
            Self::SportMode => "SPORT_MODE",
            Self::Uvi => "UVI",
            Self::SunriseSunset => "SUNRISE_SUNSET",
            Self::WindDirection => "WIND_DIRECTION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_slot::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EMPTY",
            "HEART_RATE",
            "PRESSURE",
            "SLEEP",
            "ENERGY",
            "STEP",
            "CALORIE",
            "VALID_STAND",
            "BATTERY",
            "DATE",
            "WEATHER",
            "AIR_PRESSURE",
            "ALTITUDE",
            "TIMER",
            "CLOCK",
            "AQI",
            "HUMIDITY",
            "SPORT_MODE",
            "UVI",
            "SUNRISE_SUNSET",
            "WIND_DIRECTION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_slot::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EMPTY" => Ok(watch_face_slot::Data::Empty),
                    "HEART_RATE" => Ok(watch_face_slot::Data::HeartRate),
                    "PRESSURE" => Ok(watch_face_slot::Data::Pressure),
                    "SLEEP" => Ok(watch_face_slot::Data::Sleep),
                    "ENERGY" => Ok(watch_face_slot::Data::Energy),
                    "STEP" => Ok(watch_face_slot::Data::Step),
                    "CALORIE" => Ok(watch_face_slot::Data::Calorie),
                    "VALID_STAND" => Ok(watch_face_slot::Data::ValidStand),
                    "BATTERY" => Ok(watch_face_slot::Data::Battery),
                    "DATE" => Ok(watch_face_slot::Data::Date),
                    "WEATHER" => Ok(watch_face_slot::Data::Weather),
                    "AIR_PRESSURE" => Ok(watch_face_slot::Data::AirPressure),
                    "ALTITUDE" => Ok(watch_face_slot::Data::Altitude),
                    "TIMER" => Ok(watch_face_slot::Data::Timer),
                    "CLOCK" => Ok(watch_face_slot::Data::Clock),
                    "AQI" => Ok(watch_face_slot::Data::Aqi),
                    "HUMIDITY" => Ok(watch_face_slot::Data::Humidity),
                    "SPORT_MODE" => Ok(watch_face_slot::Data::SportMode),
                    "UVI" => Ok(watch_face_slot::Data::Uvi),
                    "SUNRISE_SUNSET" => Ok(watch_face_slot::Data::SunriseSunset),
                    "WIND_DIRECTION" => Ok(watch_face_slot::Data::WindDirection),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_slot::Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceSlot.Item", len)?;
        struct_ser.serialize_field("slotId", &self.slot_id)?;
        struct_ser.serialize_field("widgetId", &self.widget_id)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_slot::Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "slot_id",
            "slotId",
            "widget_id",
            "widgetId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SlotId,
            WidgetId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "slotId" | "slot_id" => Ok(GeneratedField::SlotId),
                            "widgetId" | "widget_id" => Ok(GeneratedField::WidgetId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_slot::Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceSlot.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_slot::Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slot_id__ = None;
                let mut widget_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SlotId => {
                            if slot_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("slotId"));
                            }
                            slot_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WidgetId => {
                            if widget_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgetId"));
                            }
                            widget_id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(watch_face_slot::Item {
                    slot_id: slot_id__.ok_or_else(|| serde::de::Error::missing_field("slotId"))?,
                    widget_id: widget_id__.ok_or_else(|| serde::de::Error::missing_field("widgetId"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceSlot.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for watch_face_slot::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WatchFaceSlot.List", len)?;
        if !self.list.is_empty() {
            let v = self.list.iter().cloned().map(|v| {
                watch_face_slot::Data::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("list", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for watch_face_slot::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = watch_face_slot::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WatchFaceSlot.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<watch_face_slot::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value::<Vec<watch_face_slot::Data>>()?.into_iter().map(|x| x as i32).collect());
                        }
                    }
                }
                Ok(watch_face_slot::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WatchFaceSlot.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WearControlData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.key_event.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WearControlData", len)?;
        if let Some(v) = self.key_event.as_ref() {
            struct_ser.serialize_field("keyEvent", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WearControlData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "key_event",
            "keyEvent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            KeyEvent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "keyEvent" | "key_event" => Ok(GeneratedField::KeyEvent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearControlData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearControlData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WearControlData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut key_event__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::KeyEvent => {
                            if key_event__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyEvent"));
                            }
                            key_event__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WearControlData {
                    key_event: key_event__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearControlData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WearMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Band => "BAND",
            Self::Bean => "BEAN",
            Self::Ring => "RING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for WearMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BAND",
            "BEAN",
            "RING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BAND" => Ok(WearMode::Band),
                    "BEAN" => Ok(WearMode::Bean),
                    "RING" => Ok(WearMode::Ring),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WearPacket {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WearPacket", len)?;
        let v = wear_packet::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("id", &self.id)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                wear_packet::Payload::Account(v) => {
                    struct_ser.serialize_field("account", v)?;
                }
                wear_packet::Payload::System(v) => {
                    struct_ser.serialize_field("system", v)?;
                }
                wear_packet::Payload::WatchFace(v) => {
                    struct_ser.serialize_field("watchFace", v)?;
                }
                wear_packet::Payload::Nfc(v) => {
                    struct_ser.serialize_field("nfc", v)?;
                }
                wear_packet::Payload::Notification(v) => {
                    struct_ser.serialize_field("notification", v)?;
                }
                wear_packet::Payload::Fitness(v) => {
                    struct_ser.serialize_field("fitness", v)?;
                }
                wear_packet::Payload::Lpa(v) => {
                    struct_ser.serialize_field("lpa", v)?;
                }
                wear_packet::Payload::Weather(v) => {
                    struct_ser.serialize_field("weather", v)?;
                }
                wear_packet::Payload::Stock(v) => {
                    struct_ser.serialize_field("stock", v)?;
                }
                wear_packet::Payload::Calendar(v) => {
                    struct_ser.serialize_field("calendar", v)?;
                }
                wear_packet::Payload::Factory(v) => {
                    struct_ser.serialize_field("factory", v)?;
                }
                wear_packet::Payload::Aivs(v) => {
                    struct_ser.serialize_field("aivs", v)?;
                }
                wear_packet::Payload::Market(v) => {
                    struct_ser.serialize_field("market", v)?;
                }
                wear_packet::Payload::Gnss(v) => {
                    struct_ser.serialize_field("gnss", v)?;
                }
                wear_packet::Payload::Clock(v) => {
                    struct_ser.serialize_field("clock", v)?;
                }
                wear_packet::Payload::Media(v) => {
                    struct_ser.serialize_field("media", v)?;
                }
                wear_packet::Payload::Alexa(v) => {
                    struct_ser.serialize_field("alexa", v)?;
                }
                wear_packet::Payload::ThirdpartyApp(v) => {
                    struct_ser.serialize_field("thirdpartyApp", v)?;
                }
                wear_packet::Payload::Contact(v) => {
                    struct_ser.serialize_field("contact", v)?;
                }
                wear_packet::Payload::Mass(v) => {
                    struct_ser.serialize_field("mass", v)?;
                }
                wear_packet::Payload::Interconnection(v) => {
                    struct_ser.serialize_field("interconnection", v)?;
                }
                wear_packet::Payload::ErrorCode(v) => {
                    let v = ErrorCode::try_from(*v)
                        .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
                    struct_ser.serialize_field("errorCode", &v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WearPacket {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "id",
            "account",
            "system",
            "watch_face",
            "watchFace",
            "nfc",
            "notification",
            "fitness",
            "lpa",
            "weather",
            "stock",
            "calendar",
            "factory",
            "aivs",
            "market",
            "gnss",
            "clock",
            "media",
            "alexa",
            "thirdparty_app",
            "thirdpartyApp",
            "contact",
            "mass",
            "interconnection",
            "error_code",
            "errorCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
            Account,
            System,
            WatchFace,
            Nfc,
            Notification,
            Fitness,
            Lpa,
            Weather,
            Stock,
            Calendar,
            Factory,
            Aivs,
            Market,
            Gnss,
            Clock,
            Media,
            Alexa,
            ThirdpartyApp,
            Contact,
            Mass,
            Interconnection,
            ErrorCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "id" => Ok(GeneratedField::Id),
                            "account" => Ok(GeneratedField::Account),
                            "system" => Ok(GeneratedField::System),
                            "watchFace" | "watch_face" => Ok(GeneratedField::WatchFace),
                            "nfc" => Ok(GeneratedField::Nfc),
                            "notification" => Ok(GeneratedField::Notification),
                            "fitness" => Ok(GeneratedField::Fitness),
                            "lpa" => Ok(GeneratedField::Lpa),
                            "weather" => Ok(GeneratedField::Weather),
                            "stock" => Ok(GeneratedField::Stock),
                            "calendar" => Ok(GeneratedField::Calendar),
                            "factory" => Ok(GeneratedField::Factory),
                            "aivs" => Ok(GeneratedField::Aivs),
                            "market" => Ok(GeneratedField::Market),
                            "gnss" => Ok(GeneratedField::Gnss),
                            "clock" => Ok(GeneratedField::Clock),
                            "media" => Ok(GeneratedField::Media),
                            "alexa" => Ok(GeneratedField::Alexa),
                            "thirdpartyApp" | "thirdparty_app" => Ok(GeneratedField::ThirdpartyApp),
                            "contact" => Ok(GeneratedField::Contact),
                            "mass" => Ok(GeneratedField::Mass),
                            "interconnection" => Ok(GeneratedField::Interconnection),
                            "errorCode" | "error_code" => Ok(GeneratedField::ErrorCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearPacket;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearPacket")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WearPacket, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<wear_packet::Type>()? as i32);
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Account => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("account"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Account)
;
                        }
                        GeneratedField::System => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("system"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::System)
;
                        }
                        GeneratedField::WatchFace => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("watchFace"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::WatchFace)
;
                        }
                        GeneratedField::Nfc => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nfc"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Nfc)
;
                        }
                        GeneratedField::Notification => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("notification"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Notification)
;
                        }
                        GeneratedField::Fitness => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fitness"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Fitness)
;
                        }
                        GeneratedField::Lpa => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lpa"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Lpa)
;
                        }
                        GeneratedField::Weather => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weather"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Weather)
;
                        }
                        GeneratedField::Stock => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stock"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Stock)
;
                        }
                        GeneratedField::Calendar => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calendar"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Calendar)
;
                        }
                        GeneratedField::Factory => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("factory"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Factory)
;
                        }
                        GeneratedField::Aivs => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aivs"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Aivs)
;
                        }
                        GeneratedField::Market => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("market"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Market)
;
                        }
                        GeneratedField::Gnss => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gnss"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Gnss)
;
                        }
                        GeneratedField::Clock => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clock"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Clock)
;
                        }
                        GeneratedField::Media => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("media"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Media)
;
                        }
                        GeneratedField::Alexa => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alexa"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Alexa)
;
                        }
                        GeneratedField::ThirdpartyApp => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("thirdpartyApp"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::ThirdpartyApp)
;
                        }
                        GeneratedField::Contact => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contact"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Contact)
;
                        }
                        GeneratedField::Mass => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mass"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Mass)
;
                        }
                        GeneratedField::Interconnection => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("interconnection"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(wear_packet::Payload::Interconnection)
;
                        }
                        GeneratedField::ErrorCode => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorCode"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<ErrorCode>>()?.map(|x| wear_packet::Payload::ErrorCode(x as i32));
                        }
                    }
                }
                Ok(WearPacket {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearPacket", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wear_packet::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Other => "OTHER",
            Self::Account => "ACCOUNT",
            Self::System => "SYSTEM",
            Self::WatchFace => "WATCH_FACE",
            Self::Nfc => "NFC",
            Self::Notification => "NOTIFICATION",
            Self::Fitness => "FITNESS",
            Self::Lpa => "LPA",
            Self::Weather => "WEATHER",
            Self::Stock => "STOCK",
            Self::Calendar => "CALENDAR",
            Self::Factory => "FACTORY",
            Self::Aivs => "AIVS",
            Self::Market => "MARKET",
            Self::Gnss => "GNSS",
            Self::Clock => "CLOCK",
            Self::Media => "MEDIA",
            Self::Alexa => "ALEXA",
            Self::ThirdpartyApp => "THIRDPARTY_APP",
            Self::Contact => "CONTACT",
            Self::Mass => "MASS",
            Self::Interconnection => "INTERCONNECTION",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for wear_packet::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OTHER",
            "ACCOUNT",
            "SYSTEM",
            "WATCH_FACE",
            "NFC",
            "NOTIFICATION",
            "FITNESS",
            "LPA",
            "WEATHER",
            "STOCK",
            "CALENDAR",
            "FACTORY",
            "AIVS",
            "MARKET",
            "GNSS",
            "CLOCK",
            "MEDIA",
            "ALEXA",
            "THIRDPARTY_APP",
            "CONTACT",
            "MASS",
            "INTERCONNECTION",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wear_packet::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OTHER" => Ok(wear_packet::Type::Other),
                    "ACCOUNT" => Ok(wear_packet::Type::Account),
                    "SYSTEM" => Ok(wear_packet::Type::System),
                    "WATCH_FACE" => Ok(wear_packet::Type::WatchFace),
                    "NFC" => Ok(wear_packet::Type::Nfc),
                    "NOTIFICATION" => Ok(wear_packet::Type::Notification),
                    "FITNESS" => Ok(wear_packet::Type::Fitness),
                    "LPA" => Ok(wear_packet::Type::Lpa),
                    "WEATHER" => Ok(wear_packet::Type::Weather),
                    "STOCK" => Ok(wear_packet::Type::Stock),
                    "CALENDAR" => Ok(wear_packet::Type::Calendar),
                    "FACTORY" => Ok(wear_packet::Type::Factory),
                    "AIVS" => Ok(wear_packet::Type::Aivs),
                    "MARKET" => Ok(wear_packet::Type::Market),
                    "GNSS" => Ok(wear_packet::Type::Gnss),
                    "CLOCK" => Ok(wear_packet::Type::Clock),
                    "MEDIA" => Ok(wear_packet::Type::Media),
                    "ALEXA" => Ok(wear_packet::Type::Alexa),
                    "THIRDPARTY_APP" => Ok(wear_packet::Type::ThirdpartyApp),
                    "CONTACT" => Ok(wear_packet::Type::Contact),
                    "MASS" => Ok(wear_packet::Type::Mass),
                    "INTERCONNECTION" => Ok(wear_packet::Type::Interconnection),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WearSensorData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.accel.is_empty() {
            len += 1;
        }
        if !self.gyro.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WearSensorData", len)?;
        if !self.accel.is_empty() {
            struct_ser.serialize_field("accel", &self.accel)?;
        }
        if !self.gyro.is_empty() {
            struct_ser.serialize_field("gyro", &self.gyro)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WearSensorData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "accel",
            "gyro",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Accel,
            Gyro,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "accel" => Ok(GeneratedField::Accel),
                            "gyro" => Ok(GeneratedField::Gyro),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearSensorData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearSensorData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WearSensorData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut accel__ = None;
                let mut gyro__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Accel => {
                            if accel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accel"));
                            }
                            accel__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Gyro => {
                            if gyro__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gyro"));
                            }
                            gyro__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WearSensorData {
                    accel: accel__.unwrap_or_default(),
                    gyro: gyro__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearSensorData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WearSportData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.max_heart_rate.is_some() {
            len += 1;
        }
        if self.min_heart_rate.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WearSportData", len)?;
        struct_ser.serialize_field("steps", &self.steps)?;
        struct_ser.serialize_field("calories", &self.calories)?;
        struct_ser.serialize_field("heartRate", &self.heart_rate)?;
        if let Some(v) = self.max_heart_rate.as_ref() {
            struct_ser.serialize_field("maxHeartRate", v)?;
        }
        if let Some(v) = self.min_heart_rate.as_ref() {
            struct_ser.serialize_field("minHeartRate", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WearSportData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "steps",
            "calories",
            "heart_rate",
            "heartRate",
            "max_heart_rate",
            "maxHeartRate",
            "min_heart_rate",
            "minHeartRate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Steps,
            Calories,
            HeartRate,
            MaxHeartRate,
            MinHeartRate,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "steps" => Ok(GeneratedField::Steps),
                            "calories" => Ok(GeneratedField::Calories),
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "maxHeartRate" | "max_heart_rate" => Ok(GeneratedField::MaxHeartRate),
                            "minHeartRate" | "min_heart_rate" => Ok(GeneratedField::MinHeartRate),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearSportData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearSportData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WearSportData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut steps__ = None;
                let mut calories__ = None;
                let mut heart_rate__ = None;
                let mut max_heart_rate__ = None;
                let mut min_heart_rate__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Steps => {
                            if steps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("steps"));
                            }
                            steps__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MaxHeartRate => {
                            if max_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxHeartRate"));
                            }
                            max_heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinHeartRate => {
                            if min_heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minHeartRate"));
                            }
                            min_heart_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WearSportData {
                    steps: steps__.ok_or_else(|| serde::de::Error::missing_field("steps"))?,
                    calories: calories__.ok_or_else(|| serde::de::Error::missing_field("calories"))?,
                    heart_rate: heart_rate__.ok_or_else(|| serde::de::Error::missing_field("heartRate"))?,
                    max_heart_rate: max_heart_rate__,
                    min_heart_rate: min_heart_rate__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearSportData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WearSportDataV2a {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.steps.is_some() {
            len += 1;
        }
        if self.distance.is_some() {
            len += 1;
        }
        if self.error_state.is_some() {
            len += 1;
        }
        if self.stride.is_some() {
            len += 1;
        }
        if self.revolution_count.is_some() {
            len += 1;
        }
        if self.frequency.is_some() {
            len += 1;
        }
        if self.run_style.is_some() {
            len += 1;
        }
        if self.impact.is_some() {
            len += 1;
        }
        if self.on_ground.is_some() {
            len += 1;
        }
        if self.off_ground.is_some() {
            len += 1;
        }
        if self.on_off_ratio.is_some() {
            len += 1;
        }
        if self.current_pace.is_some() {
            len += 1;
        }
        if self.current_speed.is_some() {
            len += 1;
        }
        if self.vertical_stride_ratio.is_some() {
            len += 1;
        }
        if self.vertical_amplitude.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WearSportDataV2A", len)?;
        struct_ser.serialize_field("heartRate", &self.heart_rate)?;
        struct_ser.serialize_field("calories", &self.calories)?;
        if let Some(v) = self.steps.as_ref() {
            struct_ser.serialize_field("steps", v)?;
        }
        if let Some(v) = self.distance.as_ref() {
            struct_ser.serialize_field("distance", v)?;
        }
        if let Some(v) = self.error_state.as_ref() {
            struct_ser.serialize_field("errorState", v)?;
        }
        if let Some(v) = self.stride.as_ref() {
            struct_ser.serialize_field("stride", v)?;
        }
        if let Some(v) = self.revolution_count.as_ref() {
            struct_ser.serialize_field("revolutionCount", v)?;
        }
        if let Some(v) = self.frequency.as_ref() {
            struct_ser.serialize_field("frequency", v)?;
        }
        if let Some(v) = self.run_style.as_ref() {
            struct_ser.serialize_field("runStyle", v)?;
        }
        if let Some(v) = self.impact.as_ref() {
            struct_ser.serialize_field("impact", v)?;
        }
        if let Some(v) = self.on_ground.as_ref() {
            struct_ser.serialize_field("onGround", v)?;
        }
        if let Some(v) = self.off_ground.as_ref() {
            struct_ser.serialize_field("offGround", v)?;
        }
        if let Some(v) = self.on_off_ratio.as_ref() {
            struct_ser.serialize_field("onOffRatio", v)?;
        }
        if let Some(v) = self.current_pace.as_ref() {
            struct_ser.serialize_field("currentPace", v)?;
        }
        if let Some(v) = self.current_speed.as_ref() {
            struct_ser.serialize_field("currentSpeed", v)?;
        }
        if let Some(v) = self.vertical_stride_ratio.as_ref() {
            struct_ser.serialize_field("verticalStrideRatio", v)?;
        }
        if let Some(v) = self.vertical_amplitude.as_ref() {
            struct_ser.serialize_field("verticalAmplitude", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WearSportDataV2a {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "heart_rate",
            "heartRate",
            "calories",
            "steps",
            "distance",
            "error_state",
            "errorState",
            "stride",
            "revolution_count",
            "revolutionCount",
            "frequency",
            "run_style",
            "runStyle",
            "impact",
            "on_ground",
            "onGround",
            "off_ground",
            "offGround",
            "on_off_ratio",
            "onOffRatio",
            "current_pace",
            "currentPace",
            "current_speed",
            "currentSpeed",
            "vertical_stride_ratio",
            "verticalStrideRatio",
            "vertical_amplitude",
            "verticalAmplitude",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HeartRate,
            Calories,
            Steps,
            Distance,
            ErrorState,
            Stride,
            RevolutionCount,
            Frequency,
            RunStyle,
            Impact,
            OnGround,
            OffGround,
            OnOffRatio,
            CurrentPace,
            CurrentSpeed,
            VerticalStrideRatio,
            VerticalAmplitude,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "heartRate" | "heart_rate" => Ok(GeneratedField::HeartRate),
                            "calories" => Ok(GeneratedField::Calories),
                            "steps" => Ok(GeneratedField::Steps),
                            "distance" => Ok(GeneratedField::Distance),
                            "errorState" | "error_state" => Ok(GeneratedField::ErrorState),
                            "stride" => Ok(GeneratedField::Stride),
                            "revolutionCount" | "revolution_count" => Ok(GeneratedField::RevolutionCount),
                            "frequency" => Ok(GeneratedField::Frequency),
                            "runStyle" | "run_style" => Ok(GeneratedField::RunStyle),
                            "impact" => Ok(GeneratedField::Impact),
                            "onGround" | "on_ground" => Ok(GeneratedField::OnGround),
                            "offGround" | "off_ground" => Ok(GeneratedField::OffGround),
                            "onOffRatio" | "on_off_ratio" => Ok(GeneratedField::OnOffRatio),
                            "currentPace" | "current_pace" => Ok(GeneratedField::CurrentPace),
                            "currentSpeed" | "current_speed" => Ok(GeneratedField::CurrentSpeed),
                            "verticalStrideRatio" | "vertical_stride_ratio" => Ok(GeneratedField::VerticalStrideRatio),
                            "verticalAmplitude" | "vertical_amplitude" => Ok(GeneratedField::VerticalAmplitude),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearSportDataV2a;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearSportDataV2A")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WearSportDataV2a, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut heart_rate__ = None;
                let mut calories__ = None;
                let mut steps__ = None;
                let mut distance__ = None;
                let mut error_state__ = None;
                let mut stride__ = None;
                let mut revolution_count__ = None;
                let mut frequency__ = None;
                let mut run_style__ = None;
                let mut impact__ = None;
                let mut on_ground__ = None;
                let mut off_ground__ = None;
                let mut on_off_ratio__ = None;
                let mut current_pace__ = None;
                let mut current_speed__ = None;
                let mut vertical_stride_ratio__ = None;
                let mut vertical_amplitude__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HeartRate => {
                            if heart_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("heartRate"));
                            }
                            heart_rate__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Calories => {
                            if calories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("calories"));
                            }
                            calories__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Steps => {
                            if steps__.is_some() {
                                return Err(serde::de::Error::duplicate_field("steps"));
                            }
                            steps__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Distance => {
                            if distance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distance"));
                            }
                            distance__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ErrorState => {
                            if error_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorState"));
                            }
                            error_state__ = map_.next_value()?;
                        }
                        GeneratedField::Stride => {
                            if stride__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stride"));
                            }
                            stride__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RevolutionCount => {
                            if revolution_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("revolutionCount"));
                            }
                            revolution_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Frequency => {
                            if frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frequency"));
                            }
                            frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RunStyle => {
                            if run_style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("runStyle"));
                            }
                            run_style__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Impact => {
                            if impact__.is_some() {
                                return Err(serde::de::Error::duplicate_field("impact"));
                            }
                            impact__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OnGround => {
                            if on_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onGround"));
                            }
                            on_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OffGround => {
                            if off_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("offGround"));
                            }
                            off_ground__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OnOffRatio => {
                            if on_off_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("onOffRatio"));
                            }
                            on_off_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentPace => {
                            if current_pace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentPace"));
                            }
                            current_pace__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentSpeed => {
                            if current_speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentSpeed"));
                            }
                            current_speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VerticalStrideRatio => {
                            if vertical_stride_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verticalStrideRatio"));
                            }
                            vertical_stride_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VerticalAmplitude => {
                            if vertical_amplitude__.is_some() {
                                return Err(serde::de::Error::duplicate_field("verticalAmplitude"));
                            }
                            vertical_amplitude__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WearSportDataV2a {
                    heart_rate: heart_rate__.ok_or_else(|| serde::de::Error::missing_field("heartRate"))?,
                    calories: calories__.ok_or_else(|| serde::de::Error::missing_field("calories"))?,
                    steps: steps__,
                    distance: distance__,
                    error_state: error_state__,
                    stride: stride__,
                    revolution_count: revolution_count__,
                    frequency: frequency__,
                    run_style: run_style__,
                    impact: impact__,
                    on_ground: on_ground__,
                    off_ground: off_ground__,
                    on_off_ratio: on_off_ratio__,
                    current_pace: current_pace__,
                    current_speed: current_speed__,
                    vertical_stride_ratio: vertical_stride_ratio__,
                    vertical_amplitude: vertical_amplitude__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearSportDataV2A", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wear_sport_data_v2a::ErrorState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.mode_changed.is_some() {
            len += 1;
        }
        if self.low_battery.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WearSportDataV2A.ErrorState", len)?;
        if let Some(v) = self.mode_changed.as_ref() {
            struct_ser.serialize_field("modeChanged", v)?;
        }
        if let Some(v) = self.low_battery.as_ref() {
            struct_ser.serialize_field("lowBattery", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wear_sport_data_v2a::ErrorState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "mode_changed",
            "modeChanged",
            "low_battery",
            "lowBattery",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ModeChanged,
            LowBattery,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "modeChanged" | "mode_changed" => Ok(GeneratedField::ModeChanged),
                            "lowBattery" | "low_battery" => Ok(GeneratedField::LowBattery),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wear_sport_data_v2a::ErrorState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearSportDataV2A.ErrorState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wear_sport_data_v2a::ErrorState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mode_changed__ = None;
                let mut low_battery__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ModeChanged => {
                            if mode_changed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("modeChanged"));
                            }
                            mode_changed__ = map_.next_value()?;
                        }
                        GeneratedField::LowBattery => {
                            if low_battery__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowBattery"));
                            }
                            low_battery__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(wear_sport_data_v2a::ErrorState {
                    mode_changed: mode_changed__,
                    low_battery: low_battery__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearSportDataV2A.ErrorState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WearableController {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.WearableController", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WearableController {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WearableController;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearableController")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WearableController, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(WearableController {
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearableController", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wearable_controller::Action {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WearableController.Action", len)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.serialize_field("payload", &self.payload)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wearable_controller::Action {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "payload",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Payload,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "payload" => Ok(GeneratedField::Payload),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wearable_controller::Action;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearableController.Action")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wearable_controller::Action, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Payload => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("payload"));
                            }
                            payload__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(wearable_controller::Action {
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    payload: payload__.ok_or_else(|| serde::de::Error::missing_field("payload"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearableController.Action", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wearable_controller::Execute {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.WearableController.Execute", len)?;
        struct_ser.serialize_field("directive", &self.directive)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wearable_controller::Execute {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "directive",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Directive,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "directive" => Ok(GeneratedField::Directive),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wearable_controller::Execute;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearableController.Execute")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wearable_controller::Execute, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut directive__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Directive => {
                            if directive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("directive"));
                            }
                            directive__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(wearable_controller::Execute {
                    directive: directive__.ok_or_else(|| serde::de::Error::missing_field("directive"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearableController.Execute", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wearable_controller::Switch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WearableController.Switch", len)?;
        let v = SportState::try_from(self.sport_state)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_state)))?;
        struct_ser.serialize_field("sportState", &v)?;
        let v = SportType::try_from(self.sport_type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.sport_type)))?;
        struct_ser.serialize_field("sportType", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wearable_controller::Switch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sport_state",
            "sportState",
            "sport_type",
            "sportType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SportState,
            SportType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sportState" | "sport_state" => Ok(GeneratedField::SportState),
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wearable_controller::Switch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WearableController.Switch")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wearable_controller::Switch, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sport_state__ = None;
                let mut sport_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SportState => {
                            if sport_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportState"));
                            }
                            sport_state__ = Some(map_.next_value::<SportState>()? as i32);
                        }
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = Some(map_.next_value::<SportType>()? as i32);
                        }
                    }
                }
                Ok(wearable_controller::Switch {
                    sport_state: sport_state__.ok_or_else(|| serde::de::Error::missing_field("sportState"))?,
                    sport_type: sport_type__.ok_or_else(|| serde::de::Error::missing_field("sportType"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WearableController.Switch", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Weather {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.payload.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Weather", len)?;
        if let Some(v) = self.payload.as_ref() {
            match v {
                weather::Payload::Latest(v) => {
                    struct_ser.serialize_field("latest", v)?;
                }
                weather::Payload::Forecast(v) => {
                    struct_ser.serialize_field("forecast", v)?;
                }
                weather::Payload::Pressure(v) => {
                    struct_ser.serialize_field("pressure", v)?;
                }
                weather::Payload::CityKeyList(v) => {
                    struct_ser.serialize_field("cityKeyList", v)?;
                }
                weather::Payload::CityKey(v) => {
                    struct_ser.serialize_field("cityKey", v)?;
                }
                weather::Payload::WeatherConfig(v) => {
                    struct_ser.serialize_field("weatherConfig", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Weather {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "latest",
            "forecast",
            "pressure",
            "city_key_list",
            "cityKeyList",
            "city_key",
            "cityKey",
            "weather_config",
            "weatherConfig",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Latest,
            Forecast,
            Pressure,
            CityKeyList,
            CityKey,
            WeatherConfig,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "latest" => Ok(GeneratedField::Latest),
                            "forecast" => Ok(GeneratedField::Forecast),
                            "pressure" => Ok(GeneratedField::Pressure),
                            "cityKeyList" | "city_key_list" => Ok(GeneratedField::CityKeyList),
                            "cityKey" | "city_key" => Ok(GeneratedField::CityKey),
                            "weatherConfig" | "weather_config" => Ok(GeneratedField::WeatherConfig),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Weather;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Weather")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Weather, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut payload__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Latest => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("latest"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(weather::Payload::Latest)
;
                        }
                        GeneratedField::Forecast => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("forecast"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(weather::Payload::Forecast)
;
                        }
                        GeneratedField::Pressure => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pressure"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| weather::Payload::Pressure(x.0));
                        }
                        GeneratedField::CityKeyList => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cityKeyList"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(weather::Payload::CityKeyList)
;
                        }
                        GeneratedField::CityKey => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cityKey"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(weather::Payload::CityKey)
;
                        }
                        GeneratedField::WeatherConfig => {
                            if payload__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weatherConfig"));
                            }
                            payload__ = map_.next_value::<::std::option::Option<_>>()?.map(weather::Payload::WeatherConfig)
;
                        }
                    }
                }
                Ok(Weather {
                    payload: payload__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Weather", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for weather::WeatherId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::LatestWeather => "LATEST_WEATHER",
            Self::DailyForecast => "DAILY_FORECAST",
            Self::HourlyForecast => "HOURLY_FORECAST",
            Self::WearRequest => "WEAR_REQUEST",
            Self::SetPressure => "SET_PRESSURE",
            Self::GetCityKeys => "GET_CITY_KEYS",
            Self::UpdateCityKeys => "UPDATE_CITY_KEYS",
            Self::AddCityKey => "ADD_CITY_KEY",
            Self::RemoveCityKeys => "REMOVE_CITY_KEYS",
            Self::GetConfig => "GET_CONFIG",
            Self::SetConfig => "SET_CONFIG",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for weather::WeatherId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LATEST_WEATHER",
            "DAILY_FORECAST",
            "HOURLY_FORECAST",
            "WEAR_REQUEST",
            "SET_PRESSURE",
            "GET_CITY_KEYS",
            "UPDATE_CITY_KEYS",
            "ADD_CITY_KEY",
            "REMOVE_CITY_KEYS",
            "GET_CONFIG",
            "SET_CONFIG",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = weather::WeatherId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LATEST_WEATHER" => Ok(weather::WeatherId::LatestWeather),
                    "DAILY_FORECAST" => Ok(weather::WeatherId::DailyForecast),
                    "HOURLY_FORECAST" => Ok(weather::WeatherId::HourlyForecast),
                    "WEAR_REQUEST" => Ok(weather::WeatherId::WearRequest),
                    "SET_PRESSURE" => Ok(weather::WeatherId::SetPressure),
                    "GET_CITY_KEYS" => Ok(weather::WeatherId::GetCityKeys),
                    "UPDATE_CITY_KEYS" => Ok(weather::WeatherId::UpdateCityKeys),
                    "ADD_CITY_KEY" => Ok(weather::WeatherId::AddCityKey),
                    "REMOVE_CITY_KEYS" => Ok(weather::WeatherId::RemoveCityKeys),
                    "GET_CONFIG" => Ok(weather::WeatherId::GetConfig),
                    "SET_CONFIG" => Ok(weather::WeatherId::SetConfig),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherCode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherCode", len)?;
        struct_ser.serialize_field("current", &self.current)?;
        struct_ser.serialize_field("from", &self.from)?;
        struct_ser.serialize_field("to", &self.to)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherCode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "current",
            "from",
            "to",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Current,
            From,
            To,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "current" => Ok(GeneratedField::Current),
                            "from" => Ok(GeneratedField::From),
                            "to" => Ok(GeneratedField::To),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherCode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherCode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherCode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut current__ = None;
                let mut from__ = None;
                let mut to__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Current => {
                            if current__.is_some() {
                                return Err(serde::de::Error::duplicate_field("current"));
                            }
                            current__ = Some(map_.next_value()?);
                        }
                        GeneratedField::From => {
                            if from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("from"));
                            }
                            from__ = Some(map_.next_value()?);
                        }
                        GeneratedField::To => {
                            if to__.is_some() {
                                return Err(serde::de::Error::duplicate_field("to"));
                            }
                            to__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WeatherCode {
                    current: current__.ok_or_else(|| serde::de::Error::missing_field("current"))?,
                    from: from__.ok_or_else(|| serde::de::Error::missing_field("from"))?,
                    to: to__.ok_or_else(|| serde::de::Error::missing_field("to"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherCode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.temperature_unit.is_some() {
            len += 1;
        }
        if self.alert.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherConfig", len)?;
        if let Some(v) = self.temperature_unit.as_ref() {
            let v = TemperatureUnit::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("temperatureUnit", &v)?;
        }
        if let Some(v) = self.alert.as_ref() {
            let v = OptionalSwitcher::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("alert", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "temperature_unit",
            "temperatureUnit",
            "alert",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TemperatureUnit,
            Alert,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "temperatureUnit" | "temperature_unit" => Ok(GeneratedField::TemperatureUnit),
                            "alert" => Ok(GeneratedField::Alert),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherConfig")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut temperature_unit__ = None;
                let mut alert__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TemperatureUnit => {
                            if temperature_unit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("temperatureUnit"));
                            }
                            temperature_unit__ = map_.next_value::<::std::option::Option<TemperatureUnit>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Alert => {
                            if alert__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alert"));
                            }
                            alert__ = map_.next_value::<::std::option::Option<OptionalSwitcher>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(WeatherConfig {
                    temperature_unit: temperature_unit__,
                    alert: alert__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherForecast {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherForecast", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("dataList", &self.data_list)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherForecast {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "data_list",
            "dataList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            DataList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "dataList" | "data_list" => Ok(GeneratedField::DataList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherForecast;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherForecast")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherForecast, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut data_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::DataList => {
                            if data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataList"));
                            }
                            data_list__ = map_.next_value()?;
                        }
                    }
                }
                Ok(WeatherForecast {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    data_list: data_list__.ok_or_else(|| serde::de::Error::missing_field("dataList"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherForecast", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for weather_forecast::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.weather.is_some() {
            len += 1;
        }
        if self.temperature.is_some() {
            len += 1;
        }
        if self.sun_rise_set.is_some() {
            len += 1;
        }
        if self.wind_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherForecast.Data", len)?;
        struct_ser.serialize_field("aqi", &self.aqi)?;
        if let Some(v) = self.weather.as_ref() {
            struct_ser.serialize_field("weather", v)?;
        }
        if let Some(v) = self.temperature.as_ref() {
            struct_ser.serialize_field("temperature", v)?;
        }
        struct_ser.serialize_field("temperatureUnit", &self.temperature_unit)?;
        if let Some(v) = self.sun_rise_set.as_ref() {
            struct_ser.serialize_field("sunRiseSet", v)?;
        }
        if let Some(v) = self.wind_info.as_ref() {
            struct_ser.serialize_field("windInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for weather_forecast::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "aqi",
            "weather",
            "temperature",
            "temperature_unit",
            "temperatureUnit",
            "sun_rise_set",
            "sunRiseSet",
            "wind_info",
            "windInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Aqi,
            Weather,
            Temperature,
            TemperatureUnit,
            SunRiseSet,
            WindInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "aqi" => Ok(GeneratedField::Aqi),
                            "weather" => Ok(GeneratedField::Weather),
                            "temperature" => Ok(GeneratedField::Temperature),
                            "temperatureUnit" | "temperature_unit" => Ok(GeneratedField::TemperatureUnit),
                            "sunRiseSet" | "sun_rise_set" => Ok(GeneratedField::SunRiseSet),
                            "windInfo" | "wind_info" => Ok(GeneratedField::WindInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = weather_forecast::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherForecast.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<weather_forecast::Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut aqi__ = None;
                let mut weather__ = None;
                let mut temperature__ = None;
                let mut temperature_unit__ = None;
                let mut sun_rise_set__ = None;
                let mut wind_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Aqi => {
                            if aqi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aqi"));
                            }
                            aqi__ = map_.next_value()?;
                        }
                        GeneratedField::Weather => {
                            if weather__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weather"));
                            }
                            weather__ = map_.next_value()?;
                        }
                        GeneratedField::Temperature => {
                            if temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("temperature"));
                            }
                            temperature__ = map_.next_value()?;
                        }
                        GeneratedField::TemperatureUnit => {
                            if temperature_unit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("temperatureUnit"));
                            }
                            temperature_unit__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SunRiseSet => {
                            if sun_rise_set__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sunRiseSet"));
                            }
                            sun_rise_set__ = map_.next_value()?;
                        }
                        GeneratedField::WindInfo => {
                            if wind_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windInfo"));
                            }
                            wind_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(weather_forecast::Data {
                    aqi: aqi__.ok_or_else(|| serde::de::Error::missing_field("aqi"))?,
                    weather: weather__,
                    temperature: temperature__,
                    temperature_unit: temperature_unit__.ok_or_else(|| serde::de::Error::missing_field("temperatureUnit"))?,
                    sun_rise_set: sun_rise_set__,
                    wind_info: wind_info__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherForecast.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for weather_forecast::data::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherForecast.Data.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for weather_forecast::data::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = weather_forecast::data::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherForecast.Data.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<weather_forecast::data::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(weather_forecast::data::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherForecast.Data.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 4;
        if self.is_current_location.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherId", len)?;
        struct_ser.serialize_field("pubTime", &self.pub_time)?;
        struct_ser.serialize_field("cityName", &self.city_name)?;
        struct_ser.serialize_field("locationName", &self.location_name)?;
        struct_ser.serialize_field("locationKey", &self.location_key)?;
        if let Some(v) = self.is_current_location.as_ref() {
            struct_ser.serialize_field("isCurrentLocation", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "pub_time",
            "pubTime",
            "city_name",
            "cityName",
            "location_name",
            "locationName",
            "location_key",
            "locationKey",
            "is_current_location",
            "isCurrentLocation",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PubTime,
            CityName,
            LocationName,
            LocationKey,
            IsCurrentLocation,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "pubTime" | "pub_time" => Ok(GeneratedField::PubTime),
                            "cityName" | "city_name" => Ok(GeneratedField::CityName),
                            "locationName" | "location_name" => Ok(GeneratedField::LocationName),
                            "locationKey" | "location_key" => Ok(GeneratedField::LocationKey),
                            "isCurrentLocation" | "is_current_location" => Ok(GeneratedField::IsCurrentLocation),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherId")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherId, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pub_time__ = None;
                let mut city_name__ = None;
                let mut location_name__ = None;
                let mut location_key__ = None;
                let mut is_current_location__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PubTime => {
                            if pub_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pubTime"));
                            }
                            pub_time__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CityName => {
                            if city_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cityName"));
                            }
                            city_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LocationName => {
                            if location_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("locationName"));
                            }
                            location_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LocationKey => {
                            if location_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("locationKey"));
                            }
                            location_key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsCurrentLocation => {
                            if is_current_location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isCurrentLocation"));
                            }
                            is_current_location__ = map_.next_value()?;
                        }
                    }
                }
                Ok(WeatherId {
                    pub_time: pub_time__.ok_or_else(|| serde::de::Error::missing_field("pubTime"))?,
                    city_name: city_name__.ok_or_else(|| serde::de::Error::missing_field("cityName"))?,
                    location_name: location_name__.ok_or_else(|| serde::de::Error::missing_field("locationName"))?,
                    location_key: location_key__.ok_or_else(|| serde::de::Error::missing_field("locationKey"))?,
                    is_current_location: is_current_location__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherId", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 8;
        if self.weather_code.is_some() {
            len += 1;
        }
        if self.wind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherItem", len)?;
        struct_ser.serialize_field("date", &self.date)?;
        struct_ser.serialize_field("location", &self.location)?;
        struct_ser.serialize_field("aqi", &self.aqi)?;
        struct_ser.serialize_field("currentTemperature", &self.current_temperature)?;
        struct_ser.serialize_field("highTemperature", &self.high_temperature)?;
        struct_ser.serialize_field("lowTemperature", &self.low_temperature)?;
        struct_ser.serialize_field("iconDescription", &self.icon_description)?;
        if let Some(v) = self.weather_code.as_ref() {
            struct_ser.serialize_field("weatherCode", v)?;
        }
        if let Some(v) = self.wind.as_ref() {
            struct_ser.serialize_field("wind", v)?;
        }
        struct_ser.serialize_field("weekday", &self.weekday)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "date",
            "location",
            "aqi",
            "current_temperature",
            "currentTemperature",
            "high_temperature",
            "highTemperature",
            "low_temperature",
            "lowTemperature",
            "icon_description",
            "iconDescription",
            "weather_code",
            "weatherCode",
            "wind",
            "weekday",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Date,
            Location,
            Aqi,
            CurrentTemperature,
            HighTemperature,
            LowTemperature,
            IconDescription,
            WeatherCode,
            Wind,
            Weekday,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "date" => Ok(GeneratedField::Date),
                            "location" => Ok(GeneratedField::Location),
                            "aqi" => Ok(GeneratedField::Aqi),
                            "currentTemperature" | "current_temperature" => Ok(GeneratedField::CurrentTemperature),
                            "highTemperature" | "high_temperature" => Ok(GeneratedField::HighTemperature),
                            "lowTemperature" | "low_temperature" => Ok(GeneratedField::LowTemperature),
                            "iconDescription" | "icon_description" => Ok(GeneratedField::IconDescription),
                            "weatherCode" | "weather_code" => Ok(GeneratedField::WeatherCode),
                            "wind" => Ok(GeneratedField::Wind),
                            "weekday" => Ok(GeneratedField::Weekday),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut date__ = None;
                let mut location__ = None;
                let mut aqi__ = None;
                let mut current_temperature__ = None;
                let mut high_temperature__ = None;
                let mut low_temperature__ = None;
                let mut icon_description__ = None;
                let mut weather_code__ = None;
                let mut wind__ = None;
                let mut weekday__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Date => {
                            if date__.is_some() {
                                return Err(serde::de::Error::duplicate_field("date"));
                            }
                            date__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Aqi => {
                            if aqi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aqi"));
                            }
                            aqi__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CurrentTemperature => {
                            if current_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentTemperature"));
                            }
                            current_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::HighTemperature => {
                            if high_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("highTemperature"));
                            }
                            high_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LowTemperature => {
                            if low_temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowTemperature"));
                            }
                            low_temperature__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IconDescription => {
                            if icon_description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iconDescription"));
                            }
                            icon_description__ = Some(map_.next_value()?);
                        }
                        GeneratedField::WeatherCode => {
                            if weather_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weatherCode"));
                            }
                            weather_code__ = map_.next_value()?;
                        }
                        GeneratedField::Wind => {
                            if wind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wind"));
                            }
                            wind__ = map_.next_value()?;
                        }
                        GeneratedField::Weekday => {
                            if weekday__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weekday"));
                            }
                            weekday__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WeatherItem {
                    date: date__.ok_or_else(|| serde::de::Error::missing_field("date"))?,
                    location: location__.ok_or_else(|| serde::de::Error::missing_field("location"))?,
                    aqi: aqi__.ok_or_else(|| serde::de::Error::missing_field("aqi"))?,
                    current_temperature: current_temperature__.ok_or_else(|| serde::de::Error::missing_field("currentTemperature"))?,
                    high_temperature: high_temperature__.ok_or_else(|| serde::de::Error::missing_field("highTemperature"))?,
                    low_temperature: low_temperature__.ok_or_else(|| serde::de::Error::missing_field("lowTemperature"))?,
                    icon_description: icon_description__.ok_or_else(|| serde::de::Error::missing_field("iconDescription"))?,
                    weather_code: weather_code__,
                    wind: wind__,
                    weekday: weekday__.ok_or_else(|| serde::de::Error::missing_field("weekday"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for weather_item::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherItem.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for weather_item::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = weather_item::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherItem.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<weather_item::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(weather_item::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherItem.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherLatest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 8;
        if self.pressure.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherLatest", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("weather", &self.weather)?;
        struct_ser.serialize_field("temperature", &self.temperature)?;
        struct_ser.serialize_field("humidity", &self.humidity)?;
        struct_ser.serialize_field("windInfo", &self.wind_info)?;
        struct_ser.serialize_field("uvindex", &self.uvindex)?;
        struct_ser.serialize_field("aqi", &self.aqi)?;
        struct_ser.serialize_field("alertsList", &self.alerts_list)?;
        if let Some(v) = self.pressure.as_ref() {
            struct_ser.serialize_field("pressure", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherLatest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "weather",
            "temperature",
            "humidity",
            "wind_info",
            "windInfo",
            "uvindex",
            "aqi",
            "alerts_list",
            "alertsList",
            "pressure",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Weather,
            Temperature,
            Humidity,
            WindInfo,
            Uvindex,
            Aqi,
            AlertsList,
            Pressure,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "weather" => Ok(GeneratedField::Weather),
                            "temperature" => Ok(GeneratedField::Temperature),
                            "humidity" => Ok(GeneratedField::Humidity),
                            "windInfo" | "wind_info" => Ok(GeneratedField::WindInfo),
                            "uvindex" => Ok(GeneratedField::Uvindex),
                            "aqi" => Ok(GeneratedField::Aqi),
                            "alertsList" | "alerts_list" => Ok(GeneratedField::AlertsList),
                            "pressure" => Ok(GeneratedField::Pressure),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherLatest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherLatest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherLatest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut weather__ = None;
                let mut temperature__ = None;
                let mut humidity__ = None;
                let mut wind_info__ = None;
                let mut uvindex__ = None;
                let mut aqi__ = None;
                let mut alerts_list__ = None;
                let mut pressure__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::Weather => {
                            if weather__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weather"));
                            }
                            weather__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Temperature => {
                            if temperature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("temperature"));
                            }
                            temperature__ = map_.next_value()?;
                        }
                        GeneratedField::Humidity => {
                            if humidity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("humidity"));
                            }
                            humidity__ = map_.next_value()?;
                        }
                        GeneratedField::WindInfo => {
                            if wind_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("windInfo"));
                            }
                            wind_info__ = map_.next_value()?;
                        }
                        GeneratedField::Uvindex => {
                            if uvindex__.is_some() {
                                return Err(serde::de::Error::duplicate_field("uvindex"));
                            }
                            uvindex__ = map_.next_value()?;
                        }
                        GeneratedField::Aqi => {
                            if aqi__.is_some() {
                                return Err(serde::de::Error::duplicate_field("aqi"));
                            }
                            aqi__ = map_.next_value()?;
                        }
                        GeneratedField::AlertsList => {
                            if alerts_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alertsList"));
                            }
                            alerts_list__ = map_.next_value()?;
                        }
                        GeneratedField::Pressure => {
                            if pressure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pressure"));
                            }
                            pressure__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WeatherLatest {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    weather: weather__.ok_or_else(|| serde::de::Error::missing_field("weather"))?,
                    temperature: temperature__.ok_or_else(|| serde::de::Error::missing_field("temperature"))?,
                    humidity: humidity__.ok_or_else(|| serde::de::Error::missing_field("humidity"))?,
                    wind_info: wind_info__.ok_or_else(|| serde::de::Error::missing_field("windInfo"))?,
                    uvindex: uvindex__.ok_or_else(|| serde::de::Error::missing_field("uvindex"))?,
                    aqi: aqi__.ok_or_else(|| serde::de::Error::missing_field("aqi"))?,
                    alerts_list: alerts_list__.ok_or_else(|| serde::de::Error::missing_field("alertsList"))?,
                    pressure: pressure__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherLatest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherWind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.direction.is_some() {
            len += 1;
        }
        if self.speed.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherWind", len)?;
        if let Some(v) = self.direction.as_ref() {
            struct_ser.serialize_field("direction", v)?;
        }
        if let Some(v) = self.speed.as_ref() {
            struct_ser.serialize_field("speed", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherWind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "direction",
            "speed",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Direction,
            Speed,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "direction" => Ok(GeneratedField::Direction),
                            "speed" => Ok(GeneratedField::Speed),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherWind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherWind")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherWind, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut direction__ = None;
                let mut speed__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Direction => {
                            if direction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("direction"));
                            }
                            direction__ = map_.next_value()?;
                        }
                        GeneratedField::Speed => {
                            if speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("speed"));
                            }
                            speed__ = map_.next_value()?;
                        }
                    }
                }
                Ok(WeatherWind {
                    direction: direction__,
                    speed: speed__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherWind", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherWindDirection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherWindDirection", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.serialize_field("current", &self.current)?;
        struct_ser.serialize_field("from", &self.from)?;
        struct_ser.serialize_field("to", &self.to)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherWindDirection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
            "current",
            "from",
            "to",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
            Current,
            From,
            To,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            "current" => Ok(GeneratedField::Current),
                            "from" => Ok(GeneratedField::From),
                            "to" => Ok(GeneratedField::To),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherWindDirection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherWindDirection")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherWindDirection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                let mut current__ = None;
                let mut from__ = None;
                let mut to__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Current => {
                            if current__.is_some() {
                                return Err(serde::de::Error::duplicate_field("current"));
                            }
                            current__ = Some(map_.next_value()?);
                        }
                        GeneratedField::From => {
                            if from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("from"));
                            }
                            from__ = Some(map_.next_value()?);
                        }
                        GeneratedField::To => {
                            if to__.is_some() {
                                return Err(serde::de::Error::duplicate_field("to"));
                            }
                            to__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WeatherWindDirection {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                    current: current__.ok_or_else(|| serde::de::Error::missing_field("current"))?,
                    from: from__.ok_or_else(|| serde::de::Error::missing_field("from"))?,
                    to: to__.ok_or_else(|| serde::de::Error::missing_field("to"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherWindDirection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeatherWindSpeed {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 4;
        let mut struct_ser = serializer.serialize_struct("protocol.WeatherWindSpeed", len)?;
        struct_ser.serialize_field("text", &self.text)?;
        struct_ser.serialize_field("current", &self.current)?;
        struct_ser.serialize_field("from", &self.from)?;
        struct_ser.serialize_field("to", &self.to)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeatherWindSpeed {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "text",
            "current",
            "from",
            "to",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
            Current,
            From,
            To,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "text" => Ok(GeneratedField::Text),
                            "current" => Ok(GeneratedField::Current),
                            "from" => Ok(GeneratedField::From),
                            "to" => Ok(GeneratedField::To),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeatherWindSpeed;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WeatherWindSpeed")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeatherWindSpeed, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                let mut current__ = None;
                let mut from__ = None;
                let mut to__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("text"));
                            }
                            text__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Current => {
                            if current__.is_some() {
                                return Err(serde::de::Error::duplicate_field("current"));
                            }
                            current__ = Some(map_.next_value()?);
                        }
                        GeneratedField::From => {
                            if from__.is_some() {
                                return Err(serde::de::Error::duplicate_field("from"));
                            }
                            from__ = Some(map_.next_value()?);
                        }
                        GeneratedField::To => {
                            if to__.is_some() {
                                return Err(serde::de::Error::duplicate_field("to"));
                            }
                            to__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WeatherWindSpeed {
                    text: text__.ok_or_else(|| serde::de::Error::missing_field("text"))?,
                    current: current__.ok_or_else(|| serde::de::Error::missing_field("current"))?,
                    from: from__.ok_or_else(|| serde::de::Error::missing_field("from"))?,
                    to: to__.ok_or_else(|| serde::de::Error::missing_field("to"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WeatherWindSpeed", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WechatLicense {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.WechatLicense", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WechatLicense {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WechatLicense;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WechatLicense")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WechatLicense, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(WechatLicense {
                })
            }
        }
        deserializer.deserialize_struct("protocol.WechatLicense", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wechat_license::Request {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("protocol.WechatLicense.Request", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wechat_license::Request {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wechat_license::Request;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WechatLicense.Request")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wechat_license::Request, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(wechat_license::Request {
                })
            }
        }
        deserializer.deserialize_struct("protocol.WechatLicense.Request", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wechat_license::Response {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.key_version.is_some() {
            len += 1;
        }
        if self.product_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WechatLicense.Response", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        if let Some(v) = self.key_version.as_ref() {
            struct_ser.serialize_field("keyVersion", v)?;
        }
        if let Some(v) = self.product_id.as_ref() {
            struct_ser.serialize_field("productId", v)?;
        }
        struct_ser.serialize_field("signature", &self.signature)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wechat_license::Response {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "key_version",
            "keyVersion",
            "product_id",
            "productId",
            "signature",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            KeyVersion,
            ProductId,
            Signature,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "keyVersion" | "key_version" => Ok(GeneratedField::KeyVersion),
                            "productId" | "product_id" => Ok(GeneratedField::ProductId),
                            "signature" => Ok(GeneratedField::Signature),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wechat_license::Response;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WechatLicense.Response")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wechat_license::Response, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut key_version__ = None;
                let mut product_id__ = None;
                let mut signature__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::KeyVersion => {
                            if key_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("keyVersion"));
                            }
                            key_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProductId => {
                            if product_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("productId"));
                            }
                            product_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(wechat_license::Response {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    key_version: key_version__,
                    product_id: product_id__,
                    signature: signature__.ok_or_else(|| serde::de::Error::missing_field("signature"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WechatLicense.Response", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WiFiAp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiAP", len)?;
        struct_ser.serialize_field("ssid", &self.ssid)?;
        struct_ser.serialize_field("password", &self.password)?;
        struct_ser.serialize_field("gateway", &self.gateway)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WiFiAp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ssid",
            "password",
            "gateway",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ssid,
            Password,
            Gateway,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ssid" => Ok(GeneratedField::Ssid),
                            "password" => Ok(GeneratedField::Password),
                            "gateway" => Ok(GeneratedField::Gateway),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WiFiAp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiAP")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WiFiAp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ssid__ = None;
                let mut password__ = None;
                let mut gateway__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ssid => {
                            if ssid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ssid"));
                            }
                            ssid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Password => {
                            if password__.is_some() {
                                return Err(serde::de::Error::duplicate_field("password"));
                            }
                            password__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Gateway => {
                            if gateway__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gateway"));
                            }
                            gateway__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WiFiAp {
                    ssid: ssid__.ok_or_else(|| serde::de::Error::missing_field("ssid"))?,
                    password: password__.ok_or_else(|| serde::de::Error::missing_field("password"))?,
                    gateway: gateway__.ok_or_else(|| serde::de::Error::missing_field("gateway"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiAP", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_ap::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.wifi_ap.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiAP.Result", len)?;
        struct_ser.serialize_field("code", &self.code)?;
        if let Some(v) = self.wifi_ap.as_ref() {
            struct_ser.serialize_field("wifiAp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_ap::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "code",
            "wifi_ap",
            "wifiAp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Code,
            WifiAp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "code" => Ok(GeneratedField::Code),
                            "wifiAp" | "wifi_ap" => Ok(GeneratedField::WifiAp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_ap::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiAP.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_ap::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut code__ = None;
                let mut wifi_ap__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::WifiAp => {
                            if wifi_ap__.is_some() {
                                return Err(serde::de::Error::duplicate_field("wifiAp"));
                            }
                            wifi_ap__ = map_.next_value()?;
                        }
                    }
                }
                Ok(wi_fi_ap::Result {
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                    wifi_ap: wifi_ap__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiAP.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WiFiConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.auth_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig", len)?;
        struct_ser.serialize_field("basicInfo", &self.basic_info)?;
        if let Some(v) = self.auth_info.as_ref() {
            match v {
                wi_fi_config::AuthInfo::PskInfo(v) => {
                    struct_ser.serialize_field("pskInfo", v)?;
                }
                wi_fi_config::AuthInfo::EapInfo(v) => {
                    struct_ser.serialize_field("eapInfo", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WiFiConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "basic_info",
            "basicInfo",
            "psk_info",
            "pskInfo",
            "eap_info",
            "eapInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicInfo,
            PskInfo,
            EapInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "basicInfo" | "basic_info" => Ok(GeneratedField::BasicInfo),
                            "pskInfo" | "psk_info" => Ok(GeneratedField::PskInfo),
                            "eapInfo" | "eap_info" => Ok(GeneratedField::EapInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WiFiConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WiFiConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_info__ = None;
                let mut auth_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicInfo => {
                            if basic_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("basicInfo"));
                            }
                            basic_info__ = map_.next_value()?;
                        }
                        GeneratedField::PskInfo => {
                            if auth_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pskInfo"));
                            }
                            auth_info__ = map_.next_value::<::std::option::Option<_>>()?.map(wi_fi_config::AuthInfo::PskInfo)
;
                        }
                        GeneratedField::EapInfo => {
                            if auth_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eapInfo"));
                            }
                            auth_info__ = map_.next_value::<::std::option::Option<_>>()?.map(wi_fi_config::AuthInfo::EapInfo)
;
                        }
                    }
                }
                Ok(WiFiConfig {
                    basic_info: basic_info__.ok_or_else(|| serde::de::Error::missing_field("basicInfo"))?,
                    auth_info: auth_info__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::AuthMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::WpaNone => "WPA_NONE",
            Self::WpaPsk => "WPA_PSK",
            Self::WpaEap => "WPA_EAP",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::AuthMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WPA_NONE",
            "WPA_PSK",
            "WPA_EAP",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::AuthMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "WPA_NONE" => Ok(wi_fi_config::AuthMode::WpaNone),
                    "WPA_PSK" => Ok(wi_fi_config::AuthMode::WpaPsk),
                    "WPA_EAP" => Ok(wi_fi_config::AuthMode::WpaEap),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::BasicInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig.BasicInfo", len)?;
        struct_ser.serialize_field("ssid", &self.ssid)?;
        let v = wi_fi_config::AuthMode::try_from(self.auth_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.auth_mode)))?;
        struct_ser.serialize_field("authMode", &v)?;
        let v = wi_fi_config::Frequency::try_from(self.frequency)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.frequency)))?;
        struct_ser.serialize_field("frequency", &v)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::BasicInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ssid",
            "auth_mode",
            "authMode",
            "frequency",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ssid,
            AuthMode,
            Frequency,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ssid" => Ok(GeneratedField::Ssid),
                            "authMode" | "auth_mode" => Ok(GeneratedField::AuthMode),
                            "frequency" => Ok(GeneratedField::Frequency),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::BasicInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig.BasicInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_config::BasicInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ssid__ = None;
                let mut auth_mode__ = None;
                let mut frequency__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ssid => {
                            if ssid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ssid"));
                            }
                            ssid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AuthMode => {
                            if auth_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authMode"));
                            }
                            auth_mode__ = Some(map_.next_value::<wi_fi_config::AuthMode>()? as i32);
                        }
                        GeneratedField::Frequency => {
                            if frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("frequency"));
                            }
                            frequency__ = Some(map_.next_value::<wi_fi_config::Frequency>()? as i32);
                        }
                    }
                }
                Ok(wi_fi_config::BasicInfo {
                    ssid: ssid__.ok_or_else(|| serde::de::Error::missing_field("ssid"))?,
                    auth_mode: auth_mode__.ok_or_else(|| serde::de::Error::missing_field("authMode"))?,
                    frequency: frequency__.ok_or_else(|| serde::de::Error::missing_field("frequency"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig.BasicInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::Capability {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.support_auth_mode.is_some() {
            len += 1;
        }
        if self.support_frequency.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig.Capability", len)?;
        if let Some(v) = self.support_auth_mode.as_ref() {
            struct_ser.serialize_field("supportAuthMode", v)?;
        }
        if let Some(v) = self.support_frequency.as_ref() {
            struct_ser.serialize_field("supportFrequency", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::Capability {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "support_auth_mode",
            "supportAuthMode",
            "support_frequency",
            "supportFrequency",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SupportAuthMode,
            SupportFrequency,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "supportAuthMode" | "support_auth_mode" => Ok(GeneratedField::SupportAuthMode),
                            "supportFrequency" | "support_frequency" => Ok(GeneratedField::SupportFrequency),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::Capability;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig.Capability")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_config::Capability, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut support_auth_mode__ = None;
                let mut support_frequency__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SupportAuthMode => {
                            if support_auth_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportAuthMode"));
                            }
                            support_auth_mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SupportFrequency => {
                            if support_frequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportFrequency"));
                            }
                            support_frequency__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(wi_fi_config::Capability {
                    support_auth_mode: support_auth_mode__,
                    support_frequency: support_frequency__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig.Capability", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::EapInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig.EAPInfo", len)?;
        struct_ser.serialize_field("identity", &self.identity)?;
        struct_ser.serialize_field("password", &self.password)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::EapInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "identity",
            "password",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Identity,
            Password,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "identity" => Ok(GeneratedField::Identity),
                            "password" => Ok(GeneratedField::Password),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::EapInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig.EAPInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_config::EapInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut identity__ = None;
                let mut password__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Identity => {
                            if identity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("identity"));
                            }
                            identity__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Password => {
                            if password__.is_some() {
                                return Err(serde::de::Error::duplicate_field("password"));
                            }
                            password__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(wi_fi_config::EapInfo {
                    identity: identity__.ok_or_else(|| serde::de::Error::missing_field("identity"))?,
                    password: password__.ok_or_else(|| serde::de::Error::missing_field("password"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig.EAPInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::Frequency {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::F24g => "F_24G",
            Self::F5g => "F_5G",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::Frequency {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "F_24G",
            "F_5G",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::Frequency;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "F_24G" => Ok(wi_fi_config::Frequency::F24g),
                    "F_5G" => Ok(wi_fi_config::Frequency::F5g),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_config::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(wi_fi_config::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::PskInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 1;
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig.PSKInfo", len)?;
        struct_ser.serialize_field("password", &self.password)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::PskInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "password",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Password,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "password" => Ok(GeneratedField::Password),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::PskInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig.PSKInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_config::PskInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut password__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Password => {
                            if password__.is_some() {
                                return Err(serde::de::Error::duplicate_field("password"));
                            }
                            password__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(wi_fi_config::PskInfo {
                    password: password__.ok_or_else(|| serde::de::Error::missing_field("password"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig.PSKInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wi_fi_config::Result {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WiFiConfig.Result", len)?;
        struct_ser.serialize_field("ssid", &self.ssid)?;
        struct_ser.serialize_field("code", &self.code)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for wi_fi_config::Result {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ssid",
            "code",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Ssid,
            Code,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ssid" => Ok(GeneratedField::Ssid),
                            "code" => Ok(GeneratedField::Code),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wi_fi_config::Result;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WiFiConfig.Result")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<wi_fi_config::Result, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ssid__ = None;
                let mut code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Ssid => {
                            if ssid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ssid"));
                            }
                            ssid__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Code => {
                            if code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("code"));
                            }
                            code__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(wi_fi_config::Result {
                    ssid: ssid__.ok_or_else(|| serde::de::Error::missing_field("ssid"))?,
                    code: code__.ok_or_else(|| serde::de::Error::missing_field("code"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WiFiConfig.Result", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Widget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if self.order.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Widget", len)?;
        struct_ser.serialize_field("function", &self.function)?;
        struct_ser.serialize_field("enable", &self.enable)?;
        if let Some(v) = self.order.as_ref() {
            struct_ser.serialize_field("order", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Widget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function",
            "enable",
            "order",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Function,
            Enable,
            Order,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "function" => Ok(GeneratedField::Function),
                            "enable" => Ok(GeneratedField::Enable),
                            "order" => Ok(GeneratedField::Order),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Widget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Widget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Widget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function__ = None;
                let mut enable__ = None;
                let mut order__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Function => {
                            if function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("function"));
                            }
                            function__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Enable => {
                            if enable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enable"));
                            }
                            enable__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Order => {
                            if order__.is_some() {
                                return Err(serde::de::Error::duplicate_field("order"));
                            }
                            order__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Widget {
                    function: function__.ok_or_else(|| serde::de::Error::missing_field("function"))?,
                    enable: enable__.ok_or_else(|| serde::de::Error::missing_field("enable"))?,
                    order: order__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Widget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.support_max_number.is_some() {
            len += 1;
        }
        if self.support_min_number.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.Widget.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.support_max_number.as_ref() {
            struct_ser.serialize_field("supportMaxNumber", v)?;
        }
        if let Some(v) = self.support_min_number.as_ref() {
            struct_ser.serialize_field("supportMinNumber", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
            "support_max_number",
            "supportMaxNumber",
            "support_min_number",
            "supportMinNumber",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
            SupportMaxNumber,
            SupportMinNumber,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            "supportMaxNumber" | "support_max_number" => Ok(GeneratedField::SupportMaxNumber),
                            "supportMinNumber" | "support_min_number" => Ok(GeneratedField::SupportMinNumber),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.Widget.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                let mut support_max_number__ = None;
                let mut support_min_number__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SupportMaxNumber => {
                            if support_max_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMaxNumber"));
                            }
                            support_max_number__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SupportMinNumber => {
                            if support_min_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportMinNumber"));
                            }
                            support_min_number__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(widget::List {
                    list: list__.unwrap_or_default(),
                    support_max_number: support_max_number__,
                    support_min_number: support_min_number__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.Widget.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WidgetGroup {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.widgets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetGroup", len)?;
        struct_ser.serialize_field("sequency", &self.sequency)?;
        let v = widget_group::Style::try_from(self.style)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.style)))?;
        struct_ser.serialize_field("style", &v)?;
        if !self.widgets.is_empty() {
            struct_ser.serialize_field("widgets", &self.widgets)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WidgetGroup {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sequency",
            "style",
            "widgets",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Sequency,
            Style,
            Widgets,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sequency" => Ok(GeneratedField::Sequency),
                            "style" => Ok(GeneratedField::Style),
                            "widgets" => Ok(GeneratedField::Widgets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WidgetGroup;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetGroup")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WidgetGroup, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sequency__ = None;
                let mut style__ = None;
                let mut widgets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Sequency => {
                            if sequency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequency"));
                            }
                            sequency__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Style => {
                            if style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("style"));
                            }
                            style__ = Some(map_.next_value::<widget_group::Style>()? as i32);
                        }
                        GeneratedField::Widgets => {
                            if widgets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("widgets"));
                            }
                            widgets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WidgetGroup {
                    sequency: sequency__.ok_or_else(|| serde::de::Error::missing_field("sequency"))?,
                    style: style__.ok_or_else(|| serde::de::Error::missing_field("style"))?,
                    widgets: widgets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetGroup", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_group::Config {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetGroup.Config", len)?;
        struct_ser.serialize_field("minGroupNumber", &self.min_group_number)?;
        struct_ser.serialize_field("maxGroupNumber", &self.max_group_number)?;
        struct_ser.serialize_field("supportGroupStyles", &self.support_group_styles)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget_group::Config {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "min_group_number",
            "minGroupNumber",
            "max_group_number",
            "maxGroupNumber",
            "support_group_styles",
            "supportGroupStyles",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MinGroupNumber,
            MaxGroupNumber,
            SupportGroupStyles,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "minGroupNumber" | "min_group_number" => Ok(GeneratedField::MinGroupNumber),
                            "maxGroupNumber" | "max_group_number" => Ok(GeneratedField::MaxGroupNumber),
                            "supportGroupStyles" | "support_group_styles" => Ok(GeneratedField::SupportGroupStyles),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_group::Config;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetGroup.Config")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget_group::Config, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut min_group_number__ = None;
                let mut max_group_number__ = None;
                let mut support_group_styles__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MinGroupNumber => {
                            if min_group_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minGroupNumber"));
                            }
                            min_group_number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::MaxGroupNumber => {
                            if max_group_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxGroupNumber"));
                            }
                            max_group_number__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SupportGroupStyles => {
                            if support_group_styles__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportGroupStyles"));
                            }
                            support_group_styles__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(widget_group::Config {
                    min_group_number: min_group_number__.ok_or_else(|| serde::de::Error::missing_field("minGroupNumber"))?,
                    max_group_number: max_group_number__.ok_or_else(|| serde::de::Error::missing_field("maxGroupNumber"))?,
                    support_group_styles: support_group_styles__.ok_or_else(|| serde::de::Error::missing_field("supportGroupStyles"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetGroup.Config", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_group::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.groups.is_empty() {
            len += 1;
        }
        if self.full.is_some() {
            len += 1;
        }
        if self.config.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetGroup.List", len)?;
        if !self.groups.is_empty() {
            struct_ser.serialize_field("groups", &self.groups)?;
        }
        if let Some(v) = self.full.as_ref() {
            struct_ser.serialize_field("full", v)?;
        }
        if let Some(v) = self.config.as_ref() {
            struct_ser.serialize_field("config", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget_group::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "groups",
            "full",
            "config",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Groups,
            Full,
            Config,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "groups" => Ok(GeneratedField::Groups),
                            "full" => Ok(GeneratedField::Full),
                            "config" => Ok(GeneratedField::Config),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_group::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetGroup.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget_group::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut groups__ = None;
                let mut full__ = None;
                let mut config__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Groups => {
                            if groups__.is_some() {
                                return Err(serde::de::Error::duplicate_field("groups"));
                            }
                            groups__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Full => {
                            if full__.is_some() {
                                return Err(serde::de::Error::duplicate_field("full"));
                            }
                            full__ = map_.next_value()?;
                        }
                        GeneratedField::Config => {
                            if config__.is_some() {
                                return Err(serde::de::Error::duplicate_field("config"));
                            }
                            config__ = map_.next_value()?;
                        }
                    }
                }
                Ok(widget_group::List {
                    groups: groups__.unwrap_or_default(),
                    full: full__,
                    config: config__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetGroup.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_group::Style {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Style1 => "STYLE_1",
            Self::Style2 => "STYLE_2",
            Self::Style3 => "STYLE_3",
            Self::Style4 => "STYLE_4",
            Self::Style5 => "STYLE_5",
            Self::Style6 => "STYLE_6",
            Self::Style7 => "STYLE_7",
            Self::Style8 => "STYLE_8",
            Self::Style9 => "STYLE_9",
            Self::Style10 => "STYLE_10",
            Self::Style11 => "STYLE_11",
            Self::Style12 => "STYLE_12",
            Self::Style13 => "STYLE_13",
            Self::Style14 => "STYLE_14",
            Self::Style15 => "STYLE_15",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for widget_group::Style {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "STYLE_1",
            "STYLE_2",
            "STYLE_3",
            "STYLE_4",
            "STYLE_5",
            "STYLE_6",
            "STYLE_7",
            "STYLE_8",
            "STYLE_9",
            "STYLE_10",
            "STYLE_11",
            "STYLE_12",
            "STYLE_13",
            "STYLE_14",
            "STYLE_15",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_group::Style;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "STYLE_1" => Ok(widget_group::Style::Style1),
                    "STYLE_2" => Ok(widget_group::Style::Style2),
                    "STYLE_3" => Ok(widget_group::Style::Style3),
                    "STYLE_4" => Ok(widget_group::Style::Style4),
                    "STYLE_5" => Ok(widget_group::Style::Style5),
                    "STYLE_6" => Ok(widget_group::Style::Style6),
                    "STYLE_7" => Ok(widget_group::Style::Style7),
                    "STYLE_8" => Ok(widget_group::Style::Style8),
                    "STYLE_9" => Ok(widget_group::Style::Style9),
                    "STYLE_10" => Ok(widget_group::Style::Style10),
                    "STYLE_11" => Ok(widget_group::Style::Style11),
                    "STYLE_12" => Ok(widget_group::Style::Style12),
                    "STYLE_13" => Ok(widget_group::Style::Style13),
                    "STYLE_14" => Ok(widget_group::Style::Style14),
                    "STYLE_15" => Ok(widget_group::Style::Style15),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WidgetStyle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Style11 => "STYLE_11",
            Self::Style12 => "STYLE_12",
            Self::Style21 => "STYLE_21",
            Self::Style22 => "STYLE_22",
            Self::StyleSquare => "STYLE_SQUARE",
            Self::StyleRect => "STYLE_RECT",
            Self::StyleCircle => "STYLE_CIRCLE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for WidgetStyle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "STYLE_11",
            "STYLE_12",
            "STYLE_21",
            "STYLE_22",
            "STYLE_SQUARE",
            "STYLE_RECT",
            "STYLE_CIRCLE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WidgetStyle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "STYLE_11" => Ok(WidgetStyle::Style11),
                    "STYLE_12" => Ok(WidgetStyle::Style12),
                    "STYLE_21" => Ok(WidgetStyle::Style21),
                    "STYLE_22" => Ok(WidgetStyle::Style22),
                    "STYLE_SQUARE" => Ok(WidgetStyle::StyleSquare),
                    "STYLE_RECT" => Ok(WidgetStyle::StyleRect),
                    "STYLE_CIRCLE" => Ok(WidgetStyle::StyleCircle),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WidgetSubType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SystemDarkStyle11Battery => "SYSTEM_DARK_STYLE11_BATTERY",
            Self::SystemDarkStyle11Flashlight => "SYSTEM_DARK_STYLE11_FLASHLIGHT",
            Self::SystemDarkStyle21Control => "SYSTEM_DARK_STYLE21_CONTROL",
            Self::AppListDarkStyle11Entry => "APP_LIST_DARK_STYLE11_ENTRY",
            Self::SportListDarkStyle11Start => "SPORT_LIST_DARK_STYLE11_START",
            Self::SportListDarkStyle12Start => "SPORT_LIST_DARK_STYLE12_START",
            Self::SportListLightStyle11Start => "SPORT_LIST_LIGHT_STYLE11_START",
            Self::SportListLightStyle12Start => "SPORT_LIST_LIGHT_STYLE12_START",
            Self::FitnessDarkStyle11Vitality => "FITNESS_DARK_STYLE11_VITALITY",
            Self::FitnessDarkStyle11Step => "FITNESS_DARK_STYLE11_STEP",
            Self::FitnessDarkStyle11Calorie => "FITNESS_DARK_STYLE11_CALORIE",
            Self::FitnessDarkStyle11Stand => "FITNESS_DARK_STYLE11_STAND",
            Self::FitnessDarkStyle11Activity => "FITNESS_DARK_STYLE11_ACTIVITY",
            Self::FitnessDarkStyle12Vitality => "FITNESS_DARK_STYLE12_VITALITY",
            Self::FitnessDarkStyle12Step => "FITNESS_DARK_STYLE12_STEP",
            Self::FitnessDarkStyle12Calorie => "FITNESS_DARK_STYLE12_CALORIE",
            Self::FitnessDarkStyle12Stand => "FITNESS_DARK_STYLE12_STAND",
            Self::FitnessDarkStyle12Activity => "FITNESS_DARK_STYLE12_ACTIVITY",
            Self::FitnessDarkStyle21Vitality => "FITNESS_DARK_STYLE21_VITALITY",
            Self::FitnessDarkStyle22Vitality => "FITNESS_DARK_STYLE22_VITALITY",
            Self::FitnessLightStyle11Step => "FITNESS_LIGHT_STYLE11_STEP",
            Self::FitnessLightStyle11Calorie => "FITNESS_LIGHT_STYLE11_CALORIE",
            Self::FitnessLightStyle11Stand => "FITNESS_LIGHT_STYLE11_STAND",
            Self::FitnessLightStyle11Activity => "FITNESS_LIGHT_STYLE11_ACTIVITY",
            Self::FitnessLightStyle12Step => "FITNESS_LIGHT_STYLE12_STEP",
            Self::FitnessLightStyle12Calorie => "FITNESS_LIGHT_STYLE12_CALORIE",
            Self::FitnessLightStyle12Stand => "FITNESS_LIGHT_STYLE12_STAND",
            Self::FitnessLightStyle12Activity => "FITNESS_LIGHT_STYLE12_ACTIVITY",
            Self::FitnessDarkSquareVitality => "FITNESS_DARK_SQUARE_VITALITY",
            Self::FitnessDarkRectVitality => "FITNESS_DARK_RECT_VITALITY",
            Self::FitnessDarkRectStep => "FITNESS_DARK_RECT_STEP",
            Self::FitnessDarkRectCalorie => "FITNESS_DARK_RECT_CALORIE",
            Self::FitnessDarkRectStand => "FITNESS_DARK_RECT_STAND",
            Self::FitnessDarkRectActivity => "FITNESS_DARK_RECT_ACTIVITY",
            Self::FitnessLightRectStand => "FITNESS_LIGHT_RECT_STAND",
            Self::HeartRateDarkStyle11Current => "HEART_RATE_DARK_STYLE11_CURRENT",
            Self::HeartRateDarkStyle12Splash => "HEART_RATE_DARK_STYLE12_SPLASH",
            Self::HeartRateDarkStyle12Line => "HEART_RATE_DARK_STYLE12_LINE",
            Self::HeartRateDarkStyle21Current => "HEART_RATE_DARK_STYLE21_CURRENT",
            Self::HeartRateDarkStyle22Splash => "HEART_RATE_DARK_STYLE22_SPLASH",
            Self::HeartRateDarkStyle32Current => "HEART_RATE_DARK_STYLE32_CURRENT",
            Self::HeartRateLightStyle11Current => "HEART_RATE_LIGHT_STYLE11_CURRENT",
            Self::HeartRateLightStyle12Splash => "HEART_RATE_LIGHT_STYLE12_SPLASH",
            Self::HeartRateLightStyle12Line => "HEART_RATE_LIGHT_STYLE12_LINE",
            Self::HeartRateLightStyle22Splash => "HEART_RATE_LIGHT_STYLE22_SPLASH",
            Self::HeartRateDarkRectSplash => "HEART_RATE_DARK_RECT_SPLASH",
            Self::HeartRateLightRectSplash => "HEART_RATE_LIGHT_RECT_SPLASH",
            Self::BreathDarkStyle11Entry => "BREATH_DARK_STYLE11_ENTRY",
            Self::BreathDarkStyle12Entry => "BREATH_DARK_STYLE12_ENTRY",
            Self::BreathDarkStyle21Entry => "BREATH_DARK_STYLE21_ENTRY",
            Self::BreathLightStyle11Entry => "BREATH_LIGHT_STYLE11_ENTRY",
            Self::BreathLightStyle12Entry => "BREATH_LIGHT_STYLE12_ENTRY",
            Self::PressureDarkStyle11Current => "PRESSURE_DARK_STYLE11_CURRENT",
            Self::PressureDarkStyle12Splash => "PRESSURE_DARK_STYLE12_SPLASH",
            Self::PressureDarkStyle21Current => "PRESSURE_DARK_STYLE21_CURRENT",
            Self::PressureDarkStyle22Current => "PRESSURE_DARK_STYLE22_CURRENT",
            Self::PressureDarkStyle32Current => "PRESSURE_DARK_STYLE32_CURRENT",
            Self::PressureLightStyle11Current => "PRESSURE_LIGHT_STYLE11_CURRENT",
            Self::PressureLightStyle12Splash => "PRESSURE_LIGHT_STYLE12_SPLASH",
            Self::PressureDarkRectSplash => "PRESSURE_DARK_RECT_SPLASH",
            Self::PressureDarkRectLine => "PRESSURE_DARK_RECT_LINE",
            Self::BloodOxygenDarkStyle11Current => "BLOOD_OXYGEN_DARK_STYLE11_CURRENT",
            Self::BloodOxygenDarkStyle12Splash => "BLOOD_OXYGEN_DARK_STYLE12_SPLASH",
            Self::BloodOxygenDarkStyle21Current => "BLOOD_OXYGEN_DARK_STYLE21_CURRENT",
            Self::BloodOxygenDarkStyle22Splash => "BLOOD_OXYGEN_DARK_STYLE22_SPLASH",
            Self::BloodOxygenDarkStyle32Current => "BLOOD_OXYGEN_DARK_STYLE32_CURRENT",
            Self::BloodOxygenLightStyle11Current => "BLOOD_OXYGEN_LIGHT_STYLE11_CURRENT",
            Self::BloodOxygenLightStyle12Splash => "BLOOD_OXYGEN_LIGHT_STYLE12_SPLASH",
            Self::BloodOxygenLightStyle22Splash => "BLOOD_OXYGEN_LIGHT_STYLE22_SPLASH",
            Self::BloodOxygenDarkRectSplash => "BLOOD_OXYGEN_DARK_RECT_SPLASH",
            Self::SleepDarkStyle11Result => "SLEEP_DARK_STYLE11_RESULT",
            Self::SleepDarkStyle12Result => "SLEEP_DARK_STYLE12_RESULT",
            Self::SleepDarkStyle21Result => "SLEEP_DARK_STYLE21_RESULT",
            Self::SleepDarkStyle22Result => "SLEEP_DARK_STYLE22_RESULT",
            Self::SleepDarkStyle32Result => "SLEEP_DARK_STYLE32_RESULT",
            Self::SleepLightStyle11Result => "SLEEP_LIGHT_STYLE11_RESULT",
            Self::SleepLightStyle12Result => "SLEEP_LIGHT_STYLE12_RESULT",
            Self::SleepLightStyle22Result => "SLEEP_LIGHT_STYLE22_RESULT",
            Self::SleepDarkRectResult => "SLEEP_DARK_RECT_RESULT",
            Self::SleepDarkRectLong => "SLEEP_DARK_RECT_LONG",
            Self::SleepDarkRectStructure => "SLEEP_DARK_RECT_STRUCTURE",
            Self::WomenHealthDarkStyle12Days => "WOMEN_HEALTH_DARK_STYLE12_DAYS",
            Self::WomenHealthDarkStyle21Data => "WOMEN_HEALTH_DARK_STYLE21_DATA",
            Self::WomenHealthDarkStyle22Days => "WOMEN_HEALTH_DARK_STYLE22_DAYS",
            Self::WomenHealthDarkStyle32Days => "WOMEN_HEALTH_DARK_STYLE32_DAYS",
            Self::WomenHealthLightStyle12Days => "WOMEN_HEALTH_LIGHT_STYLE12_DAYS",
            Self::WeatherDarkStyle11Basic => "WEATHER_DARK_STYLE11_BASIC",
            Self::WeatherDarkStyle12Basic => "WEATHER_DARK_STYLE12_BASIC",
            Self::WeatherDarkStyle21Basic => "WEATHER_DARK_STYLE21_BASIC",
            Self::WeatherDarkStyle22Basic => "WEATHER_DARK_STYLE22_BASIC",
            Self::WeatherDarkStyle22Hourly => "WEATHER_DARK_STYLE22_HOURLY",
            Self::WeatherLightStyle11Basic => "WEATHER_LIGHT_STYLE11_BASIC",
            Self::WeatherLightStyle12Basic => "WEATHER_LIGHT_STYLE12_BASIC",
            Self::WeatherDarkRectWeek => "WEATHER_DARK_RECT_WEEK",
            Self::WeatherLightRectWeek => "WEATHER_LIGHT_RECT_WEEK",
            Self::WeatherDarkRectHourly => "WEATHER_DARK_RECT_HOURLY",
            Self::WeatherLightRectHourly => "WEATHER_LIGHT_RECT_HOURLY",
            Self::WeatherDarkRectSun => "WEATHER_DARK_RECT_SUN",
            Self::WeatherLightRectSun => "WEATHER_LIGHT_RECT_SUN",
            Self::WeatherDarkRectHourly2 => "WEATHER_DARK_RECT_HOURLY_2",
            Self::WeatherDarkRectHourly3 => "WEATHER_DARK_RECT_HOURLY_3",
            Self::WeatherDarkRectHourly4 => "WEATHER_DARK_RECT_HOURLY_4",
            Self::VoiceAssistantDarkStyle21Xiaoai => "VOICE_ASSISTANT_DARK_STYLE21_XIAOAI",
            Self::VoiceAssistantDarkStyle21Alexa => "VOICE_ASSISTANT_DARK_STYLE21_ALEXA",
            Self::VoiceAssistantDarkStyle22Xiaoai => "VOICE_ASSISTANT_DARK_STYLE22_XIAOAI",
            Self::VoiceAssistantDarkStyle22Alexa => "VOICE_ASSISTANT_DARK_STYLE22_ALEXA",
            Self::VoiceAssistantDarkStyle32Xiaoai => "VOICE_ASSISTANT_DARK_STYLE32_XIAOAI",
            Self::VoiceAssistantDarkStyle32Alexa => "VOICE_ASSISTANT_DARK_STYLE32_ALEXA",
            Self::AlipayDarkStyle11Entry => "ALIPAY_DARK_STYLE11_ENTRY",
            Self::AlipayDarkStyle21Code => "ALIPAY_DARK_STYLE21_CODE",
            Self::AlipayDarkStyle22Code => "ALIPAY_DARK_STYLE22_CODE",
            Self::AlipayDarkStyle32Code => "ALIPAY_DARK_STYLE32_CODE",
            Self::AlipayLightStyle11Entry => "ALIPAY_LIGHT_STYLE11_ENTRY",
            Self::AlipayLightStyle21Code => "ALIPAY_LIGHT_STYLE21_CODE",
            Self::AlipayLightStyle22Code => "ALIPAY_LIGHT_STYLE22_CODE",
            Self::AlipayLightStyle32Code => "ALIPAY_LIGHT_STYLE32_CODE",
            Self::WechatPayDarkStyle11Entry => "WECHAT_PAY_DARK_STYLE11_ENTRY",
            Self::WechatPayDarkStyle21Code => "WECHAT_PAY_DARK_STYLE21_CODE",
            Self::WechatPayDarkStyle22Code => "WECHAT_PAY_DARK_STYLE22_CODE",
            Self::WechatPayDarkStyle32Code => "WECHAT_PAY_DARK_STYLE32_CODE",
            Self::WechatPayLightStyle11Entry => "WECHAT_PAY_LIGHT_STYLE11_ENTRY",
            Self::WechatPayLightStyle21Code => "WECHAT_PAY_LIGHT_STYLE21_CODE",
            Self::WechatPayLightStyle22Code => "WECHAT_PAY_LIGHT_STYLE22_CODE",
            Self::WechatPayLightStyle32Code => "WECHAT_PAY_LIGHT_STYLE32_CODE",
            Self::MusicDarkStyle11Control => "MUSIC_DARK_STYLE11_CONTROL",
            Self::MusicDarkStyle12Control => "MUSIC_DARK_STYLE12_CONTROL",
            Self::MusicDarkStyle21Control => "MUSIC_DARK_STYLE21_CONTROL",
            Self::MusicDarkStyle22Control => "MUSIC_DARK_STYLE22_CONTROL",
            Self::MusicLightStyle11Control => "MUSIC_LIGHT_STYLE11_CONTROL",
            Self::MusicLightStyle12Control => "MUSIC_LIGHT_STYLE12_CONTROL",
            Self::MusicLightStyle22Control => "MUSIC_LIGHT_STYLE22_CONTROL",
            Self::CardDarkStyle21SwitchCard => "CARD_DARK_STYLE21_SWITCH_CARD",
            Self::CardDarkStyle22SwitchCard => "CARD_DARK_STYLE22_SWITCH_CARD",
            Self::CardDarkStyle32SwitchCard => "CARD_DARK_STYLE32_SWITCH_CARD",
            Self::StopwatchDarkStyle11Entry => "STOPWATCH_DARK_STYLE11_ENTRY",
            Self::StopwatchDarkStyle12Control => "STOPWATCH_DARK_STYLE12_CONTROL",
            Self::StopwatchLightStyle11Entry => "STOPWATCH_LIGHT_STYLE11_ENTRY",
            Self::StopwatchLightStyle12Control => "STOPWATCH_LIGHT_STYLE12_CONTROL",
            Self::TimeKeepingDarkStyle11Entry => "TIME_KEEPING_DARK_STYLE11_ENTRY",
            Self::TimeKeepingDarkStyle12Control => "TIME_KEEPING_DARK_STYLE12_CONTROL",
            Self::TimeKeepingLightStyle11Entry => "TIME_KEEPING_LIGHT_STYLE11_ENTRY",
            Self::TimeKeepingLightStyle12Control => "TIME_KEEPING_LIGHT_STYLE12_CONTROL",
            Self::TimeKeepingDarkSquareEntry => "TIME_KEEPING_DARK_SQUARE_ENTRY",
            Self::CalendarDarkStyle11Entry => "CALENDAR_DARK_STYLE11_ENTRY",
            Self::CalendarDarkStyle12Next => "CALENDAR_DARK_STYLE12_NEXT",
            Self::CalendarDarkStyle21Next => "CALENDAR_DARK_STYLE21_NEXT",
            Self::CalendarDarkStyle22Next => "CALENDAR_DARK_STYLE22_NEXT",
            Self::CalendarLightStyle11Entry => "CALENDAR_LIGHT_STYLE11_ENTRY",
            Self::CalendarDarkRectNext => "CALENDAR_DARK_RECT_NEXT",
            Self::CalendarLightRectNext => "CALENDAR_LIGHT_RECT_NEXT",
            Self::CalendarDarkCircleDay => "CALENDAR_DARK_CIRCLE_DAY",
            Self::CalendarLightSquareNext => "CALENDAR_LIGHT_SQUARE_NEXT",
            Self::TemperatureDarkStyle11Entry => "TEMPERATURE_DARK_STYLE11_ENTRY",
            Self::TemperatureLightStyle11Entry => "TEMPERATURE_LIGHT_STYLE11_ENTRY",
            Self::BloodPressureDarkStyle11Entry => "BLOOD_PRESSURE_DARK_STYLE11_ENTRY",
            Self::BloodPressureDarkStyle12Recent => "BLOOD_PRESSURE_DARK_STYLE12_RECENT",
            Self::BloodPressureLightStyle11Entry => "BLOOD_PRESSURE_LIGHT_STYLE11_ENTRY",
            Self::BloodPressureLightStyle12Recent => "BLOOD_PRESSURE_LIGHT_STYLE12_RECENT",
            Self::EcgDarkStyle11Entry => "ECG_DARK_STYLE11_ENTRY",
            Self::EcgDarkStyle12Recent => "ECG_DARK_STYLE12_RECENT",
            Self::EcgLightStyle11Entry => "ECG_LIGHT_STYLE11_ENTRY",
            Self::EcgLightStyle12Recent => "ECG_LIGHT_STYLE12_RECENT",
            Self::EventDarkStyle12Next => "EVENT_DARK_STYLE12_NEXT",
            Self::EventDarkStyle21Next => "EVENT_DARK_STYLE21_NEXT",
            Self::MihomeDarkStyle11Entry => "MIHOME_DARK_STYLE11_ENTRY",
            Self::MihomeLightStyle11Entry => "MIHOME_LIGHT_STYLE11_ENTRY",
            Self::ActivityDarkStyle11Current => "ACTIVITY_DARK_STYLE11_CURRENT",
            Self::ActivityDarkStyle12Current => "ACTIVITY_DARK_STYLE12_CURRENT",
            Self::ActivityDarkStyle21Current => "ACTIVITY_DARK_STYLE21_CURRENT",
            Self::ActivityDarkStyle22Current => "ACTIVITY_DARK_STYLE22_CURRENT",
            Self::ActivityDarkStyle32Current => "ACTIVITY_DARK_STYLE32_CURRENT",
            Self::ActivityLightStyle11Current => "ACTIVITY_LIGHT_STYLE11_CURRENT",
            Self::ActivityLightStyle12Current => "ACTIVITY_LIGHT_STYLE12_CURRENT",
            Self::ActivityLightStyle21Current => "ACTIVITY_LIGHT_STYLE21_CURRENT",
            Self::ActivityLightStyle22Current => "ACTIVITY_LIGHT_STYLE22_CURRENT",
            Self::ActivityLightStyle32Current => "ACTIVITY_LIGHT_STYLE32_CURRENT",
            Self::ClockDarkStyle11Entry => "CLOCK_DARK_STYLE11_ENTRY",
            Self::ClockLightStyle11Entry => "CLOCK_LIGHT_STYLE11_ENTRY",
            Self::ShareDarkStyle11Entry => "SHARE_DARK_STYLE11_ENTRY",
            Self::ShareDarkStyle12Entry => "SHARE_DARK_STYLE12_ENTRY",
            Self::TodoListDarkStyle11Entry => "TODO_LIST_DARK_STYLE11_ENTRY",
            Self::TodoListDarkStyle12Next => "TODO_LIST_DARK_STYLE12_NEXT",
            Self::TodoListDarkStyle21Next => "TODO_LIST_DARK_STYLE21_NEXT",
            Self::TodoListLightStyle11Entry => "TODO_LIST_LIGHT_STYLE11_ENTRY",
            Self::PhoneDarkStyle11Entry => "PHONE_DARK_STYLE11_ENTRY",
            Self::PhoneLightStyle11Entry => "PHONE_LIGHT_STYLE11_ENTRY",
            Self::LactateThresholdDarkStyle11Entry => "LACTATE_THRESHOLD_DARK_STYLE11_ENTRY",
            Self::LactateThresholdLightStyle11Entry => "LACTATE_THRESHOLD_LIGHT_STYLE11_ENTRY",
            Self::CompassDarkStyle11Entry => "COMPASS_DARK_STYLE11_ENTRY",
            Self::CompassLightStyle11Entry => "COMPASS_LIGHT_STYLE11_ENTRY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for WidgetSubType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SYSTEM_DARK_STYLE11_BATTERY",
            "SYSTEM_DARK_STYLE11_FLASHLIGHT",
            "SYSTEM_DARK_STYLE21_CONTROL",
            "APP_LIST_DARK_STYLE11_ENTRY",
            "SPORT_LIST_DARK_STYLE11_START",
            "SPORT_LIST_DARK_STYLE12_START",
            "SPORT_LIST_LIGHT_STYLE11_START",
            "SPORT_LIST_LIGHT_STYLE12_START",
            "FITNESS_DARK_STYLE11_VITALITY",
            "FITNESS_DARK_STYLE11_STEP",
            "FITNESS_DARK_STYLE11_CALORIE",
            "FITNESS_DARK_STYLE11_STAND",
            "FITNESS_DARK_STYLE11_ACTIVITY",
            "FITNESS_DARK_STYLE12_VITALITY",
            "FITNESS_DARK_STYLE12_STEP",
            "FITNESS_DARK_STYLE12_CALORIE",
            "FITNESS_DARK_STYLE12_STAND",
            "FITNESS_DARK_STYLE12_ACTIVITY",
            "FITNESS_DARK_STYLE21_VITALITY",
            "FITNESS_DARK_STYLE22_VITALITY",
            "FITNESS_LIGHT_STYLE11_STEP",
            "FITNESS_LIGHT_STYLE11_CALORIE",
            "FITNESS_LIGHT_STYLE11_STAND",
            "FITNESS_LIGHT_STYLE11_ACTIVITY",
            "FITNESS_LIGHT_STYLE12_STEP",
            "FITNESS_LIGHT_STYLE12_CALORIE",
            "FITNESS_LIGHT_STYLE12_STAND",
            "FITNESS_LIGHT_STYLE12_ACTIVITY",
            "FITNESS_DARK_SQUARE_VITALITY",
            "FITNESS_DARK_RECT_VITALITY",
            "FITNESS_DARK_RECT_STEP",
            "FITNESS_DARK_RECT_CALORIE",
            "FITNESS_DARK_RECT_STAND",
            "FITNESS_DARK_RECT_ACTIVITY",
            "FITNESS_LIGHT_RECT_STAND",
            "HEART_RATE_DARK_STYLE11_CURRENT",
            "HEART_RATE_DARK_STYLE12_SPLASH",
            "HEART_RATE_DARK_STYLE12_LINE",
            "HEART_RATE_DARK_STYLE21_CURRENT",
            "HEART_RATE_DARK_STYLE22_SPLASH",
            "HEART_RATE_DARK_STYLE32_CURRENT",
            "HEART_RATE_LIGHT_STYLE11_CURRENT",
            "HEART_RATE_LIGHT_STYLE12_SPLASH",
            "HEART_RATE_LIGHT_STYLE12_LINE",
            "HEART_RATE_LIGHT_STYLE22_SPLASH",
            "HEART_RATE_DARK_RECT_SPLASH",
            "HEART_RATE_LIGHT_RECT_SPLASH",
            "BREATH_DARK_STYLE11_ENTRY",
            "BREATH_DARK_STYLE12_ENTRY",
            "BREATH_DARK_STYLE21_ENTRY",
            "BREATH_LIGHT_STYLE11_ENTRY",
            "BREATH_LIGHT_STYLE12_ENTRY",
            "PRESSURE_DARK_STYLE11_CURRENT",
            "PRESSURE_DARK_STYLE12_SPLASH",
            "PRESSURE_DARK_STYLE21_CURRENT",
            "PRESSURE_DARK_STYLE22_CURRENT",
            "PRESSURE_DARK_STYLE32_CURRENT",
            "PRESSURE_LIGHT_STYLE11_CURRENT",
            "PRESSURE_LIGHT_STYLE12_SPLASH",
            "PRESSURE_DARK_RECT_SPLASH",
            "PRESSURE_DARK_RECT_LINE",
            "BLOOD_OXYGEN_DARK_STYLE11_CURRENT",
            "BLOOD_OXYGEN_DARK_STYLE12_SPLASH",
            "BLOOD_OXYGEN_DARK_STYLE21_CURRENT",
            "BLOOD_OXYGEN_DARK_STYLE22_SPLASH",
            "BLOOD_OXYGEN_DARK_STYLE32_CURRENT",
            "BLOOD_OXYGEN_LIGHT_STYLE11_CURRENT",
            "BLOOD_OXYGEN_LIGHT_STYLE12_SPLASH",
            "BLOOD_OXYGEN_LIGHT_STYLE22_SPLASH",
            "BLOOD_OXYGEN_DARK_RECT_SPLASH",
            "SLEEP_DARK_STYLE11_RESULT",
            "SLEEP_DARK_STYLE12_RESULT",
            "SLEEP_DARK_STYLE21_RESULT",
            "SLEEP_DARK_STYLE22_RESULT",
            "SLEEP_DARK_STYLE32_RESULT",
            "SLEEP_LIGHT_STYLE11_RESULT",
            "SLEEP_LIGHT_STYLE12_RESULT",
            "SLEEP_LIGHT_STYLE22_RESULT",
            "SLEEP_DARK_RECT_RESULT",
            "SLEEP_DARK_RECT_LONG",
            "SLEEP_DARK_RECT_STRUCTURE",
            "WOMEN_HEALTH_DARK_STYLE12_DAYS",
            "WOMEN_HEALTH_DARK_STYLE21_DATA",
            "WOMEN_HEALTH_DARK_STYLE22_DAYS",
            "WOMEN_HEALTH_DARK_STYLE32_DAYS",
            "WOMEN_HEALTH_LIGHT_STYLE12_DAYS",
            "WEATHER_DARK_STYLE11_BASIC",
            "WEATHER_DARK_STYLE12_BASIC",
            "WEATHER_DARK_STYLE21_BASIC",
            "WEATHER_DARK_STYLE22_BASIC",
            "WEATHER_DARK_STYLE22_HOURLY",
            "WEATHER_LIGHT_STYLE11_BASIC",
            "WEATHER_LIGHT_STYLE12_BASIC",
            "WEATHER_DARK_RECT_WEEK",
            "WEATHER_LIGHT_RECT_WEEK",
            "WEATHER_DARK_RECT_HOURLY",
            "WEATHER_LIGHT_RECT_HOURLY",
            "WEATHER_DARK_RECT_SUN",
            "WEATHER_LIGHT_RECT_SUN",
            "WEATHER_DARK_RECT_HOURLY_2",
            "WEATHER_DARK_RECT_HOURLY_3",
            "WEATHER_DARK_RECT_HOURLY_4",
            "VOICE_ASSISTANT_DARK_STYLE21_XIAOAI",
            "VOICE_ASSISTANT_DARK_STYLE21_ALEXA",
            "VOICE_ASSISTANT_DARK_STYLE22_XIAOAI",
            "VOICE_ASSISTANT_DARK_STYLE22_ALEXA",
            "VOICE_ASSISTANT_DARK_STYLE32_XIAOAI",
            "VOICE_ASSISTANT_DARK_STYLE32_ALEXA",
            "ALIPAY_DARK_STYLE11_ENTRY",
            "ALIPAY_DARK_STYLE21_CODE",
            "ALIPAY_DARK_STYLE22_CODE",
            "ALIPAY_DARK_STYLE32_CODE",
            "ALIPAY_LIGHT_STYLE11_ENTRY",
            "ALIPAY_LIGHT_STYLE21_CODE",
            "ALIPAY_LIGHT_STYLE22_CODE",
            "ALIPAY_LIGHT_STYLE32_CODE",
            "WECHAT_PAY_DARK_STYLE11_ENTRY",
            "WECHAT_PAY_DARK_STYLE21_CODE",
            "WECHAT_PAY_DARK_STYLE22_CODE",
            "WECHAT_PAY_DARK_STYLE32_CODE",
            "WECHAT_PAY_LIGHT_STYLE11_ENTRY",
            "WECHAT_PAY_LIGHT_STYLE21_CODE",
            "WECHAT_PAY_LIGHT_STYLE22_CODE",
            "WECHAT_PAY_LIGHT_STYLE32_CODE",
            "MUSIC_DARK_STYLE11_CONTROL",
            "MUSIC_DARK_STYLE12_CONTROL",
            "MUSIC_DARK_STYLE21_CONTROL",
            "MUSIC_DARK_STYLE22_CONTROL",
            "MUSIC_LIGHT_STYLE11_CONTROL",
            "MUSIC_LIGHT_STYLE12_CONTROL",
            "MUSIC_LIGHT_STYLE22_CONTROL",
            "CARD_DARK_STYLE21_SWITCH_CARD",
            "CARD_DARK_STYLE22_SWITCH_CARD",
            "CARD_DARK_STYLE32_SWITCH_CARD",
            "STOPWATCH_DARK_STYLE11_ENTRY",
            "STOPWATCH_DARK_STYLE12_CONTROL",
            "STOPWATCH_LIGHT_STYLE11_ENTRY",
            "STOPWATCH_LIGHT_STYLE12_CONTROL",
            "TIME_KEEPING_DARK_STYLE11_ENTRY",
            "TIME_KEEPING_DARK_STYLE12_CONTROL",
            "TIME_KEEPING_LIGHT_STYLE11_ENTRY",
            "TIME_KEEPING_LIGHT_STYLE12_CONTROL",
            "TIME_KEEPING_DARK_SQUARE_ENTRY",
            "CALENDAR_DARK_STYLE11_ENTRY",
            "CALENDAR_DARK_STYLE12_NEXT",
            "CALENDAR_DARK_STYLE21_NEXT",
            "CALENDAR_DARK_STYLE22_NEXT",
            "CALENDAR_LIGHT_STYLE11_ENTRY",
            "CALENDAR_DARK_RECT_NEXT",
            "CALENDAR_LIGHT_RECT_NEXT",
            "CALENDAR_DARK_CIRCLE_DAY",
            "CALENDAR_LIGHT_SQUARE_NEXT",
            "TEMPERATURE_DARK_STYLE11_ENTRY",
            "TEMPERATURE_LIGHT_STYLE11_ENTRY",
            "BLOOD_PRESSURE_DARK_STYLE11_ENTRY",
            "BLOOD_PRESSURE_DARK_STYLE12_RECENT",
            "BLOOD_PRESSURE_LIGHT_STYLE11_ENTRY",
            "BLOOD_PRESSURE_LIGHT_STYLE12_RECENT",
            "ECG_DARK_STYLE11_ENTRY",
            "ECG_DARK_STYLE12_RECENT",
            "ECG_LIGHT_STYLE11_ENTRY",
            "ECG_LIGHT_STYLE12_RECENT",
            "EVENT_DARK_STYLE12_NEXT",
            "EVENT_DARK_STYLE21_NEXT",
            "MIHOME_DARK_STYLE11_ENTRY",
            "MIHOME_LIGHT_STYLE11_ENTRY",
            "ACTIVITY_DARK_STYLE11_CURRENT",
            "ACTIVITY_DARK_STYLE12_CURRENT",
            "ACTIVITY_DARK_STYLE21_CURRENT",
            "ACTIVITY_DARK_STYLE22_CURRENT",
            "ACTIVITY_DARK_STYLE32_CURRENT",
            "ACTIVITY_LIGHT_STYLE11_CURRENT",
            "ACTIVITY_LIGHT_STYLE12_CURRENT",
            "ACTIVITY_LIGHT_STYLE21_CURRENT",
            "ACTIVITY_LIGHT_STYLE22_CURRENT",
            "ACTIVITY_LIGHT_STYLE32_CURRENT",
            "CLOCK_DARK_STYLE11_ENTRY",
            "CLOCK_LIGHT_STYLE11_ENTRY",
            "SHARE_DARK_STYLE11_ENTRY",
            "SHARE_DARK_STYLE12_ENTRY",
            "TODO_LIST_DARK_STYLE11_ENTRY",
            "TODO_LIST_DARK_STYLE12_NEXT",
            "TODO_LIST_DARK_STYLE21_NEXT",
            "TODO_LIST_LIGHT_STYLE11_ENTRY",
            "PHONE_DARK_STYLE11_ENTRY",
            "PHONE_LIGHT_STYLE11_ENTRY",
            "LACTATE_THRESHOLD_DARK_STYLE11_ENTRY",
            "LACTATE_THRESHOLD_LIGHT_STYLE11_ENTRY",
            "COMPASS_DARK_STYLE11_ENTRY",
            "COMPASS_LIGHT_STYLE11_ENTRY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WidgetSubType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SYSTEM_DARK_STYLE11_BATTERY" => Ok(WidgetSubType::SystemDarkStyle11Battery),
                    "SYSTEM_DARK_STYLE11_FLASHLIGHT" => Ok(WidgetSubType::SystemDarkStyle11Flashlight),
                    "SYSTEM_DARK_STYLE21_CONTROL" => Ok(WidgetSubType::SystemDarkStyle21Control),
                    "APP_LIST_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::AppListDarkStyle11Entry),
                    "SPORT_LIST_DARK_STYLE11_START" => Ok(WidgetSubType::SportListDarkStyle11Start),
                    "SPORT_LIST_DARK_STYLE12_START" => Ok(WidgetSubType::SportListDarkStyle12Start),
                    "SPORT_LIST_LIGHT_STYLE11_START" => Ok(WidgetSubType::SportListLightStyle11Start),
                    "SPORT_LIST_LIGHT_STYLE12_START" => Ok(WidgetSubType::SportListLightStyle12Start),
                    "FITNESS_DARK_STYLE11_VITALITY" => Ok(WidgetSubType::FitnessDarkStyle11Vitality),
                    "FITNESS_DARK_STYLE11_STEP" => Ok(WidgetSubType::FitnessDarkStyle11Step),
                    "FITNESS_DARK_STYLE11_CALORIE" => Ok(WidgetSubType::FitnessDarkStyle11Calorie),
                    "FITNESS_DARK_STYLE11_STAND" => Ok(WidgetSubType::FitnessDarkStyle11Stand),
                    "FITNESS_DARK_STYLE11_ACTIVITY" => Ok(WidgetSubType::FitnessDarkStyle11Activity),
                    "FITNESS_DARK_STYLE12_VITALITY" => Ok(WidgetSubType::FitnessDarkStyle12Vitality),
                    "FITNESS_DARK_STYLE12_STEP" => Ok(WidgetSubType::FitnessDarkStyle12Step),
                    "FITNESS_DARK_STYLE12_CALORIE" => Ok(WidgetSubType::FitnessDarkStyle12Calorie),
                    "FITNESS_DARK_STYLE12_STAND" => Ok(WidgetSubType::FitnessDarkStyle12Stand),
                    "FITNESS_DARK_STYLE12_ACTIVITY" => Ok(WidgetSubType::FitnessDarkStyle12Activity),
                    "FITNESS_DARK_STYLE21_VITALITY" => Ok(WidgetSubType::FitnessDarkStyle21Vitality),
                    "FITNESS_DARK_STYLE22_VITALITY" => Ok(WidgetSubType::FitnessDarkStyle22Vitality),
                    "FITNESS_LIGHT_STYLE11_STEP" => Ok(WidgetSubType::FitnessLightStyle11Step),
                    "FITNESS_LIGHT_STYLE11_CALORIE" => Ok(WidgetSubType::FitnessLightStyle11Calorie),
                    "FITNESS_LIGHT_STYLE11_STAND" => Ok(WidgetSubType::FitnessLightStyle11Stand),
                    "FITNESS_LIGHT_STYLE11_ACTIVITY" => Ok(WidgetSubType::FitnessLightStyle11Activity),
                    "FITNESS_LIGHT_STYLE12_STEP" => Ok(WidgetSubType::FitnessLightStyle12Step),
                    "FITNESS_LIGHT_STYLE12_CALORIE" => Ok(WidgetSubType::FitnessLightStyle12Calorie),
                    "FITNESS_LIGHT_STYLE12_STAND" => Ok(WidgetSubType::FitnessLightStyle12Stand),
                    "FITNESS_LIGHT_STYLE12_ACTIVITY" => Ok(WidgetSubType::FitnessLightStyle12Activity),
                    "FITNESS_DARK_SQUARE_VITALITY" => Ok(WidgetSubType::FitnessDarkSquareVitality),
                    "FITNESS_DARK_RECT_VITALITY" => Ok(WidgetSubType::FitnessDarkRectVitality),
                    "FITNESS_DARK_RECT_STEP" => Ok(WidgetSubType::FitnessDarkRectStep),
                    "FITNESS_DARK_RECT_CALORIE" => Ok(WidgetSubType::FitnessDarkRectCalorie),
                    "FITNESS_DARK_RECT_STAND" => Ok(WidgetSubType::FitnessDarkRectStand),
                    "FITNESS_DARK_RECT_ACTIVITY" => Ok(WidgetSubType::FitnessDarkRectActivity),
                    "FITNESS_LIGHT_RECT_STAND" => Ok(WidgetSubType::FitnessLightRectStand),
                    "HEART_RATE_DARK_STYLE11_CURRENT" => Ok(WidgetSubType::HeartRateDarkStyle11Current),
                    "HEART_RATE_DARK_STYLE12_SPLASH" => Ok(WidgetSubType::HeartRateDarkStyle12Splash),
                    "HEART_RATE_DARK_STYLE12_LINE" => Ok(WidgetSubType::HeartRateDarkStyle12Line),
                    "HEART_RATE_DARK_STYLE21_CURRENT" => Ok(WidgetSubType::HeartRateDarkStyle21Current),
                    "HEART_RATE_DARK_STYLE22_SPLASH" => Ok(WidgetSubType::HeartRateDarkStyle22Splash),
                    "HEART_RATE_DARK_STYLE32_CURRENT" => Ok(WidgetSubType::HeartRateDarkStyle32Current),
                    "HEART_RATE_LIGHT_STYLE11_CURRENT" => Ok(WidgetSubType::HeartRateLightStyle11Current),
                    "HEART_RATE_LIGHT_STYLE12_SPLASH" => Ok(WidgetSubType::HeartRateLightStyle12Splash),
                    "HEART_RATE_LIGHT_STYLE12_LINE" => Ok(WidgetSubType::HeartRateLightStyle12Line),
                    "HEART_RATE_LIGHT_STYLE22_SPLASH" => Ok(WidgetSubType::HeartRateLightStyle22Splash),
                    "HEART_RATE_DARK_RECT_SPLASH" => Ok(WidgetSubType::HeartRateDarkRectSplash),
                    "HEART_RATE_LIGHT_RECT_SPLASH" => Ok(WidgetSubType::HeartRateLightRectSplash),
                    "BREATH_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::BreathDarkStyle11Entry),
                    "BREATH_DARK_STYLE12_ENTRY" => Ok(WidgetSubType::BreathDarkStyle12Entry),
                    "BREATH_DARK_STYLE21_ENTRY" => Ok(WidgetSubType::BreathDarkStyle21Entry),
                    "BREATH_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::BreathLightStyle11Entry),
                    "BREATH_LIGHT_STYLE12_ENTRY" => Ok(WidgetSubType::BreathLightStyle12Entry),
                    "PRESSURE_DARK_STYLE11_CURRENT" => Ok(WidgetSubType::PressureDarkStyle11Current),
                    "PRESSURE_DARK_STYLE12_SPLASH" => Ok(WidgetSubType::PressureDarkStyle12Splash),
                    "PRESSURE_DARK_STYLE21_CURRENT" => Ok(WidgetSubType::PressureDarkStyle21Current),
                    "PRESSURE_DARK_STYLE22_CURRENT" => Ok(WidgetSubType::PressureDarkStyle22Current),
                    "PRESSURE_DARK_STYLE32_CURRENT" => Ok(WidgetSubType::PressureDarkStyle32Current),
                    "PRESSURE_LIGHT_STYLE11_CURRENT" => Ok(WidgetSubType::PressureLightStyle11Current),
                    "PRESSURE_LIGHT_STYLE12_SPLASH" => Ok(WidgetSubType::PressureLightStyle12Splash),
                    "PRESSURE_DARK_RECT_SPLASH" => Ok(WidgetSubType::PressureDarkRectSplash),
                    "PRESSURE_DARK_RECT_LINE" => Ok(WidgetSubType::PressureDarkRectLine),
                    "BLOOD_OXYGEN_DARK_STYLE11_CURRENT" => Ok(WidgetSubType::BloodOxygenDarkStyle11Current),
                    "BLOOD_OXYGEN_DARK_STYLE12_SPLASH" => Ok(WidgetSubType::BloodOxygenDarkStyle12Splash),
                    "BLOOD_OXYGEN_DARK_STYLE21_CURRENT" => Ok(WidgetSubType::BloodOxygenDarkStyle21Current),
                    "BLOOD_OXYGEN_DARK_STYLE22_SPLASH" => Ok(WidgetSubType::BloodOxygenDarkStyle22Splash),
                    "BLOOD_OXYGEN_DARK_STYLE32_CURRENT" => Ok(WidgetSubType::BloodOxygenDarkStyle32Current),
                    "BLOOD_OXYGEN_LIGHT_STYLE11_CURRENT" => Ok(WidgetSubType::BloodOxygenLightStyle11Current),
                    "BLOOD_OXYGEN_LIGHT_STYLE12_SPLASH" => Ok(WidgetSubType::BloodOxygenLightStyle12Splash),
                    "BLOOD_OXYGEN_LIGHT_STYLE22_SPLASH" => Ok(WidgetSubType::BloodOxygenLightStyle22Splash),
                    "BLOOD_OXYGEN_DARK_RECT_SPLASH" => Ok(WidgetSubType::BloodOxygenDarkRectSplash),
                    "SLEEP_DARK_STYLE11_RESULT" => Ok(WidgetSubType::SleepDarkStyle11Result),
                    "SLEEP_DARK_STYLE12_RESULT" => Ok(WidgetSubType::SleepDarkStyle12Result),
                    "SLEEP_DARK_STYLE21_RESULT" => Ok(WidgetSubType::SleepDarkStyle21Result),
                    "SLEEP_DARK_STYLE22_RESULT" => Ok(WidgetSubType::SleepDarkStyle22Result),
                    "SLEEP_DARK_STYLE32_RESULT" => Ok(WidgetSubType::SleepDarkStyle32Result),
                    "SLEEP_LIGHT_STYLE11_RESULT" => Ok(WidgetSubType::SleepLightStyle11Result),
                    "SLEEP_LIGHT_STYLE12_RESULT" => Ok(WidgetSubType::SleepLightStyle12Result),
                    "SLEEP_LIGHT_STYLE22_RESULT" => Ok(WidgetSubType::SleepLightStyle22Result),
                    "SLEEP_DARK_RECT_RESULT" => Ok(WidgetSubType::SleepDarkRectResult),
                    "SLEEP_DARK_RECT_LONG" => Ok(WidgetSubType::SleepDarkRectLong),
                    "SLEEP_DARK_RECT_STRUCTURE" => Ok(WidgetSubType::SleepDarkRectStructure),
                    "WOMEN_HEALTH_DARK_STYLE12_DAYS" => Ok(WidgetSubType::WomenHealthDarkStyle12Days),
                    "WOMEN_HEALTH_DARK_STYLE21_DATA" => Ok(WidgetSubType::WomenHealthDarkStyle21Data),
                    "WOMEN_HEALTH_DARK_STYLE22_DAYS" => Ok(WidgetSubType::WomenHealthDarkStyle22Days),
                    "WOMEN_HEALTH_DARK_STYLE32_DAYS" => Ok(WidgetSubType::WomenHealthDarkStyle32Days),
                    "WOMEN_HEALTH_LIGHT_STYLE12_DAYS" => Ok(WidgetSubType::WomenHealthLightStyle12Days),
                    "WEATHER_DARK_STYLE11_BASIC" => Ok(WidgetSubType::WeatherDarkStyle11Basic),
                    "WEATHER_DARK_STYLE12_BASIC" => Ok(WidgetSubType::WeatherDarkStyle12Basic),
                    "WEATHER_DARK_STYLE21_BASIC" => Ok(WidgetSubType::WeatherDarkStyle21Basic),
                    "WEATHER_DARK_STYLE22_BASIC" => Ok(WidgetSubType::WeatherDarkStyle22Basic),
                    "WEATHER_DARK_STYLE22_HOURLY" => Ok(WidgetSubType::WeatherDarkStyle22Hourly),
                    "WEATHER_LIGHT_STYLE11_BASIC" => Ok(WidgetSubType::WeatherLightStyle11Basic),
                    "WEATHER_LIGHT_STYLE12_BASIC" => Ok(WidgetSubType::WeatherLightStyle12Basic),
                    "WEATHER_DARK_RECT_WEEK" => Ok(WidgetSubType::WeatherDarkRectWeek),
                    "WEATHER_LIGHT_RECT_WEEK" => Ok(WidgetSubType::WeatherLightRectWeek),
                    "WEATHER_DARK_RECT_HOURLY" => Ok(WidgetSubType::WeatherDarkRectHourly),
                    "WEATHER_LIGHT_RECT_HOURLY" => Ok(WidgetSubType::WeatherLightRectHourly),
                    "WEATHER_DARK_RECT_SUN" => Ok(WidgetSubType::WeatherDarkRectSun),
                    "WEATHER_LIGHT_RECT_SUN" => Ok(WidgetSubType::WeatherLightRectSun),
                    "WEATHER_DARK_RECT_HOURLY_2" => Ok(WidgetSubType::WeatherDarkRectHourly2),
                    "WEATHER_DARK_RECT_HOURLY_3" => Ok(WidgetSubType::WeatherDarkRectHourly3),
                    "WEATHER_DARK_RECT_HOURLY_4" => Ok(WidgetSubType::WeatherDarkRectHourly4),
                    "VOICE_ASSISTANT_DARK_STYLE21_XIAOAI" => Ok(WidgetSubType::VoiceAssistantDarkStyle21Xiaoai),
                    "VOICE_ASSISTANT_DARK_STYLE21_ALEXA" => Ok(WidgetSubType::VoiceAssistantDarkStyle21Alexa),
                    "VOICE_ASSISTANT_DARK_STYLE22_XIAOAI" => Ok(WidgetSubType::VoiceAssistantDarkStyle22Xiaoai),
                    "VOICE_ASSISTANT_DARK_STYLE22_ALEXA" => Ok(WidgetSubType::VoiceAssistantDarkStyle22Alexa),
                    "VOICE_ASSISTANT_DARK_STYLE32_XIAOAI" => Ok(WidgetSubType::VoiceAssistantDarkStyle32Xiaoai),
                    "VOICE_ASSISTANT_DARK_STYLE32_ALEXA" => Ok(WidgetSubType::VoiceAssistantDarkStyle32Alexa),
                    "ALIPAY_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::AlipayDarkStyle11Entry),
                    "ALIPAY_DARK_STYLE21_CODE" => Ok(WidgetSubType::AlipayDarkStyle21Code),
                    "ALIPAY_DARK_STYLE22_CODE" => Ok(WidgetSubType::AlipayDarkStyle22Code),
                    "ALIPAY_DARK_STYLE32_CODE" => Ok(WidgetSubType::AlipayDarkStyle32Code),
                    "ALIPAY_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::AlipayLightStyle11Entry),
                    "ALIPAY_LIGHT_STYLE21_CODE" => Ok(WidgetSubType::AlipayLightStyle21Code),
                    "ALIPAY_LIGHT_STYLE22_CODE" => Ok(WidgetSubType::AlipayLightStyle22Code),
                    "ALIPAY_LIGHT_STYLE32_CODE" => Ok(WidgetSubType::AlipayLightStyle32Code),
                    "WECHAT_PAY_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::WechatPayDarkStyle11Entry),
                    "WECHAT_PAY_DARK_STYLE21_CODE" => Ok(WidgetSubType::WechatPayDarkStyle21Code),
                    "WECHAT_PAY_DARK_STYLE22_CODE" => Ok(WidgetSubType::WechatPayDarkStyle22Code),
                    "WECHAT_PAY_DARK_STYLE32_CODE" => Ok(WidgetSubType::WechatPayDarkStyle32Code),
                    "WECHAT_PAY_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::WechatPayLightStyle11Entry),
                    "WECHAT_PAY_LIGHT_STYLE21_CODE" => Ok(WidgetSubType::WechatPayLightStyle21Code),
                    "WECHAT_PAY_LIGHT_STYLE22_CODE" => Ok(WidgetSubType::WechatPayLightStyle22Code),
                    "WECHAT_PAY_LIGHT_STYLE32_CODE" => Ok(WidgetSubType::WechatPayLightStyle32Code),
                    "MUSIC_DARK_STYLE11_CONTROL" => Ok(WidgetSubType::MusicDarkStyle11Control),
                    "MUSIC_DARK_STYLE12_CONTROL" => Ok(WidgetSubType::MusicDarkStyle12Control),
                    "MUSIC_DARK_STYLE21_CONTROL" => Ok(WidgetSubType::MusicDarkStyle21Control),
                    "MUSIC_DARK_STYLE22_CONTROL" => Ok(WidgetSubType::MusicDarkStyle22Control),
                    "MUSIC_LIGHT_STYLE11_CONTROL" => Ok(WidgetSubType::MusicLightStyle11Control),
                    "MUSIC_LIGHT_STYLE12_CONTROL" => Ok(WidgetSubType::MusicLightStyle12Control),
                    "MUSIC_LIGHT_STYLE22_CONTROL" => Ok(WidgetSubType::MusicLightStyle22Control),
                    "CARD_DARK_STYLE21_SWITCH_CARD" => Ok(WidgetSubType::CardDarkStyle21SwitchCard),
                    "CARD_DARK_STYLE22_SWITCH_CARD" => Ok(WidgetSubType::CardDarkStyle22SwitchCard),
                    "CARD_DARK_STYLE32_SWITCH_CARD" => Ok(WidgetSubType::CardDarkStyle32SwitchCard),
                    "STOPWATCH_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::StopwatchDarkStyle11Entry),
                    "STOPWATCH_DARK_STYLE12_CONTROL" => Ok(WidgetSubType::StopwatchDarkStyle12Control),
                    "STOPWATCH_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::StopwatchLightStyle11Entry),
                    "STOPWATCH_LIGHT_STYLE12_CONTROL" => Ok(WidgetSubType::StopwatchLightStyle12Control),
                    "TIME_KEEPING_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::TimeKeepingDarkStyle11Entry),
                    "TIME_KEEPING_DARK_STYLE12_CONTROL" => Ok(WidgetSubType::TimeKeepingDarkStyle12Control),
                    "TIME_KEEPING_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::TimeKeepingLightStyle11Entry),
                    "TIME_KEEPING_LIGHT_STYLE12_CONTROL" => Ok(WidgetSubType::TimeKeepingLightStyle12Control),
                    "TIME_KEEPING_DARK_SQUARE_ENTRY" => Ok(WidgetSubType::TimeKeepingDarkSquareEntry),
                    "CALENDAR_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::CalendarDarkStyle11Entry),
                    "CALENDAR_DARK_STYLE12_NEXT" => Ok(WidgetSubType::CalendarDarkStyle12Next),
                    "CALENDAR_DARK_STYLE21_NEXT" => Ok(WidgetSubType::CalendarDarkStyle21Next),
                    "CALENDAR_DARK_STYLE22_NEXT" => Ok(WidgetSubType::CalendarDarkStyle22Next),
                    "CALENDAR_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::CalendarLightStyle11Entry),
                    "CALENDAR_DARK_RECT_NEXT" => Ok(WidgetSubType::CalendarDarkRectNext),
                    "CALENDAR_LIGHT_RECT_NEXT" => Ok(WidgetSubType::CalendarLightRectNext),
                    "CALENDAR_DARK_CIRCLE_DAY" => Ok(WidgetSubType::CalendarDarkCircleDay),
                    "CALENDAR_LIGHT_SQUARE_NEXT" => Ok(WidgetSubType::CalendarLightSquareNext),
                    "TEMPERATURE_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::TemperatureDarkStyle11Entry),
                    "TEMPERATURE_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::TemperatureLightStyle11Entry),
                    "BLOOD_PRESSURE_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::BloodPressureDarkStyle11Entry),
                    "BLOOD_PRESSURE_DARK_STYLE12_RECENT" => Ok(WidgetSubType::BloodPressureDarkStyle12Recent),
                    "BLOOD_PRESSURE_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::BloodPressureLightStyle11Entry),
                    "BLOOD_PRESSURE_LIGHT_STYLE12_RECENT" => Ok(WidgetSubType::BloodPressureLightStyle12Recent),
                    "ECG_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::EcgDarkStyle11Entry),
                    "ECG_DARK_STYLE12_RECENT" => Ok(WidgetSubType::EcgDarkStyle12Recent),
                    "ECG_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::EcgLightStyle11Entry),
                    "ECG_LIGHT_STYLE12_RECENT" => Ok(WidgetSubType::EcgLightStyle12Recent),
                    "EVENT_DARK_STYLE12_NEXT" => Ok(WidgetSubType::EventDarkStyle12Next),
                    "EVENT_DARK_STYLE21_NEXT" => Ok(WidgetSubType::EventDarkStyle21Next),
                    "MIHOME_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::MihomeDarkStyle11Entry),
                    "MIHOME_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::MihomeLightStyle11Entry),
                    "ACTIVITY_DARK_STYLE11_CURRENT" => Ok(WidgetSubType::ActivityDarkStyle11Current),
                    "ACTIVITY_DARK_STYLE12_CURRENT" => Ok(WidgetSubType::ActivityDarkStyle12Current),
                    "ACTIVITY_DARK_STYLE21_CURRENT" => Ok(WidgetSubType::ActivityDarkStyle21Current),
                    "ACTIVITY_DARK_STYLE22_CURRENT" => Ok(WidgetSubType::ActivityDarkStyle22Current),
                    "ACTIVITY_DARK_STYLE32_CURRENT" => Ok(WidgetSubType::ActivityDarkStyle32Current),
                    "ACTIVITY_LIGHT_STYLE11_CURRENT" => Ok(WidgetSubType::ActivityLightStyle11Current),
                    "ACTIVITY_LIGHT_STYLE12_CURRENT" => Ok(WidgetSubType::ActivityLightStyle12Current),
                    "ACTIVITY_LIGHT_STYLE21_CURRENT" => Ok(WidgetSubType::ActivityLightStyle21Current),
                    "ACTIVITY_LIGHT_STYLE22_CURRENT" => Ok(WidgetSubType::ActivityLightStyle22Current),
                    "ACTIVITY_LIGHT_STYLE32_CURRENT" => Ok(WidgetSubType::ActivityLightStyle32Current),
                    "CLOCK_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::ClockDarkStyle11Entry),
                    "CLOCK_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::ClockLightStyle11Entry),
                    "SHARE_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::ShareDarkStyle11Entry),
                    "SHARE_DARK_STYLE12_ENTRY" => Ok(WidgetSubType::ShareDarkStyle12Entry),
                    "TODO_LIST_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::TodoListDarkStyle11Entry),
                    "TODO_LIST_DARK_STYLE12_NEXT" => Ok(WidgetSubType::TodoListDarkStyle12Next),
                    "TODO_LIST_DARK_STYLE21_NEXT" => Ok(WidgetSubType::TodoListDarkStyle21Next),
                    "TODO_LIST_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::TodoListLightStyle11Entry),
                    "PHONE_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::PhoneDarkStyle11Entry),
                    "PHONE_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::PhoneLightStyle11Entry),
                    "LACTATE_THRESHOLD_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::LactateThresholdDarkStyle11Entry),
                    "LACTATE_THRESHOLD_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::LactateThresholdLightStyle11Entry),
                    "COMPASS_DARK_STYLE11_ENTRY" => Ok(WidgetSubType::CompassDarkStyle11Entry),
                    "COMPASS_LIGHT_STYLE11_ENTRY" => Ok(WidgetSubType::CompassLightStyle11Entry),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WidgetV2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 6;
        if self.sport_type.is_some() {
            len += 1;
        }
        if self.phone_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetV2", len)?;
        let v = WidgetStyle::try_from(self.style)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.style)))?;
        struct_ser.serialize_field("style", &v)?;
        struct_ser.serialize_field("function", &self.function)?;
        struct_ser.serialize_field("subType", &self.sub_type)?;
        struct_ser.serialize_field("name", &self.name)?;
        if let Some(v) = self.sport_type.as_ref() {
            let v = SportType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sportType", &v)?;
        }
        struct_ser.serialize_field("appId", &self.app_id)?;
        struct_ser.serialize_field("appName", &self.app_name)?;
        if let Some(v) = self.phone_type.as_ref() {
            struct_ser.serialize_field("phoneType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WidgetV2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "style",
            "function",
            "sub_type",
            "subType",
            "name",
            "sport_type",
            "sportType",
            "app_id",
            "appId",
            "app_name",
            "appName",
            "phone_type",
            "phoneType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Style,
            Function,
            SubType,
            Name,
            SportType,
            AppId,
            AppName,
            PhoneType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "style" => Ok(GeneratedField::Style),
                            "function" => Ok(GeneratedField::Function),
                            "subType" | "sub_type" => Ok(GeneratedField::SubType),
                            "name" => Ok(GeneratedField::Name),
                            "sportType" | "sport_type" => Ok(GeneratedField::SportType),
                            "appId" | "app_id" => Ok(GeneratedField::AppId),
                            "appName" | "app_name" => Ok(GeneratedField::AppName),
                            "phoneType" | "phone_type" => Ok(GeneratedField::PhoneType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WidgetV2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetV2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WidgetV2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut style__ = None;
                let mut function__ = None;
                let mut sub_type__ = None;
                let mut name__ = None;
                let mut sport_type__ = None;
                let mut app_id__ = None;
                let mut app_name__ = None;
                let mut phone_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Style => {
                            if style__.is_some() {
                                return Err(serde::de::Error::duplicate_field("style"));
                            }
                            style__ = Some(map_.next_value::<WidgetStyle>()? as i32);
                        }
                        GeneratedField::Function => {
                            if function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("function"));
                            }
                            function__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::SubType => {
                            if sub_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subType"));
                            }
                            sub_type__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SportType => {
                            if sport_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sportType"));
                            }
                            sport_type__ = map_.next_value::<::std::option::Option<SportType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::AppId => {
                            if app_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appId"));
                            }
                            app_id__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AppName => {
                            if app_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("appName"));
                            }
                            app_name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PhoneType => {
                            if phone_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("phoneType"));
                            }
                            phone_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WidgetV2 {
                    style: style__.ok_or_else(|| serde::de::Error::missing_field("style"))?,
                    function: function__.ok_or_else(|| serde::de::Error::missing_field("function"))?,
                    sub_type: sub_type__.ok_or_else(|| serde::de::Error::missing_field("subType"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    sport_type: sport_type__,
                    app_id: app_id__.ok_or_else(|| serde::de::Error::missing_field("appId"))?,
                    app_name: app_name__.ok_or_else(|| serde::de::Error::missing_field("appName"))?,
                    phone_type: phone_type__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetV2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_v2::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.support_widgets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetV2.List", len)?;
        if !self.support_widgets.is_empty() {
            struct_ser.serialize_field("supportWidgets", &self.support_widgets)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget_v2::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "support_widgets",
            "supportWidgets",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SupportWidgets,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "supportWidgets" | "support_widgets" => Ok(GeneratedField::SupportWidgets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_v2::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetV2.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget_v2::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut support_widgets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SupportWidgets => {
                            if support_widgets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supportWidgets"));
                            }
                            support_widgets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(widget_v2::List {
                    support_widgets: support_widgets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetV2.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WidgetV3 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.builtin_widgets.is_empty() {
            len += 1;
        }
        if self.min_count.is_some() {
            len += 1;
        }
        if self.max_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetV3", len)?;
        if !self.builtin_widgets.is_empty() {
            struct_ser.serialize_field("builtinWidgets", &self.builtin_widgets)?;
        }
        if let Some(v) = self.min_count.as_ref() {
            struct_ser.serialize_field("minCount", v)?;
        }
        if let Some(v) = self.max_count.as_ref() {
            struct_ser.serialize_field("maxCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WidgetV3 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "builtin_widgets",
            "builtinWidgets",
            "min_count",
            "minCount",
            "max_count",
            "maxCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuiltinWidgets,
            MinCount,
            MaxCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "builtinWidgets" | "builtin_widgets" => Ok(GeneratedField::BuiltinWidgets),
                            "minCount" | "min_count" => Ok(GeneratedField::MinCount),
                            "maxCount" | "max_count" => Ok(GeneratedField::MaxCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WidgetV3;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetV3")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WidgetV3, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut builtin_widgets__ = None;
                let mut min_count__ = None;
                let mut max_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuiltinWidgets => {
                            if builtin_widgets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("builtinWidgets"));
                            }
                            builtin_widgets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MinCount => {
                            if min_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minCount"));
                            }
                            min_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxCount => {
                            if max_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxCount"));
                            }
                            max_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WidgetV3 {
                    builtin_widgets: builtin_widgets__.unwrap_or_default(),
                    min_count: min_count__,
                    max_count: max_count__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetV3", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_v3::NativeBuiltin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetV3.NativeBuiltin", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget_v3::NativeBuiltin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_v3::NativeBuiltin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetV3.NativeBuiltin")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget_v3::NativeBuiltin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(widget_v3::NativeBuiltin {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetV3.NativeBuiltin", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_v3::NativeBuiltinGroup {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.builtin_widgets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetV3.NativeBuiltinGroup", len)?;
        struct_ser.serialize_field("id", &self.id)?;
        struct_ser.serialize_field("name", &self.name)?;
        if !self.builtin_widgets.is_empty() {
            struct_ser.serialize_field("builtinWidgets", &self.builtin_widgets)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget_v3::NativeBuiltinGroup {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "builtin_widgets",
            "builtinWidgets",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            BuiltinWidgets,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "builtinWidgets" | "builtin_widgets" => Ok(GeneratedField::BuiltinWidgets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_v3::NativeBuiltinGroup;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetV3.NativeBuiltinGroup")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget_v3::NativeBuiltinGroup, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut builtin_widgets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = Some(map_.next_value()?);
                        }
                        GeneratedField::BuiltinWidgets => {
                            if builtin_widgets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("builtinWidgets"));
                            }
                            builtin_widgets__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(widget_v3::NativeBuiltinGroup {
                    id: id__.ok_or_else(|| serde::de::Error::missing_field("id"))?,
                    name: name__.ok_or_else(|| serde::de::Error::missing_field("name"))?,
                    builtin_widgets: builtin_widgets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetV3.NativeBuiltinGroup", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for widget_v3::SupportedList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.builtin_groups.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WidgetV3.SupportedList", len)?;
        if !self.builtin_groups.is_empty() {
            struct_ser.serialize_field("builtinGroups", &self.builtin_groups)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for widget_v3::SupportedList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "builtin_groups",
            "builtinGroups",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuiltinGroups,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "builtinGroups" | "builtin_groups" => Ok(GeneratedField::BuiltinGroups),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = widget_v3::SupportedList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WidgetV3.SupportedList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<widget_v3::SupportedList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut builtin_groups__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuiltinGroups => {
                            if builtin_groups__.is_some() {
                                return Err(serde::de::Error::duplicate_field("builtinGroups"));
                            }
                            builtin_groups__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(widget_v3::SupportedList {
                    builtin_groups: builtin_groups__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WidgetV3.SupportedList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WomenHealth {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.forcast_on.is_some() {
            len += 1;
        }
        if self.reminder_list.is_some() {
            len += 1;
        }
        if self.data_list.is_some() {
            len += 1;
        }
        if self.menstruation_days.is_some() {
            len += 1;
        }
        if self.menstruation_peroid.is_some() {
            len += 1;
        }
        if self.init_timestamp.is_some() {
            len += 1;
        }
        if self.sections.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth", len)?;
        struct_ser.serialize_field("enabled", &self.enabled)?;
        if let Some(v) = self.forcast_on.as_ref() {
            struct_ser.serialize_field("forcastOn", v)?;
        }
        if let Some(v) = self.reminder_list.as_ref() {
            struct_ser.serialize_field("reminderList", v)?;
        }
        if let Some(v) = self.data_list.as_ref() {
            struct_ser.serialize_field("dataList", v)?;
        }
        if let Some(v) = self.menstruation_days.as_ref() {
            struct_ser.serialize_field("menstruationDays", v)?;
        }
        if let Some(v) = self.menstruation_peroid.as_ref() {
            struct_ser.serialize_field("menstruationPeroid", v)?;
        }
        if let Some(v) = self.init_timestamp.as_ref() {
            struct_ser.serialize_field("initTimestamp", v)?;
        }
        if let Some(v) = self.sections.as_ref() {
            struct_ser.serialize_field("sections", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WomenHealth {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "enabled",
            "forcast_on",
            "forcastOn",
            "reminder_list",
            "reminderList",
            "data_list",
            "dataList",
            "menstruation_days",
            "menstruationDays",
            "menstruation_peroid",
            "menstruationPeroid",
            "init_timestamp",
            "initTimestamp",
            "sections",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Enabled,
            ForcastOn,
            ReminderList,
            DataList,
            MenstruationDays,
            MenstruationPeroid,
            InitTimestamp,
            Sections,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "enabled" => Ok(GeneratedField::Enabled),
                            "forcastOn" | "forcast_on" => Ok(GeneratedField::ForcastOn),
                            "reminderList" | "reminder_list" => Ok(GeneratedField::ReminderList),
                            "dataList" | "data_list" => Ok(GeneratedField::DataList),
                            "menstruationDays" | "menstruation_days" => Ok(GeneratedField::MenstruationDays),
                            "menstruationPeroid" | "menstruation_peroid" => Ok(GeneratedField::MenstruationPeroid),
                            "initTimestamp" | "init_timestamp" => Ok(GeneratedField::InitTimestamp),
                            "sections" => Ok(GeneratedField::Sections),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WomenHealth;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WomenHealth, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enabled__ = None;
                let mut forcast_on__ = None;
                let mut reminder_list__ = None;
                let mut data_list__ = None;
                let mut menstruation_days__ = None;
                let mut menstruation_peroid__ = None;
                let mut init_timestamp__ = None;
                let mut sections__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Enabled => {
                            if enabled__.is_some() {
                                return Err(serde::de::Error::duplicate_field("enabled"));
                            }
                            enabled__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ForcastOn => {
                            if forcast_on__.is_some() {
                                return Err(serde::de::Error::duplicate_field("forcastOn"));
                            }
                            forcast_on__ = map_.next_value()?;
                        }
                        GeneratedField::ReminderList => {
                            if reminder_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reminderList"));
                            }
                            reminder_list__ = map_.next_value()?;
                        }
                        GeneratedField::DataList => {
                            if data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dataList"));
                            }
                            data_list__ = map_.next_value()?;
                        }
                        GeneratedField::MenstruationDays => {
                            if menstruation_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("menstruationDays"));
                            }
                            menstruation_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MenstruationPeroid => {
                            if menstruation_peroid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("menstruationPeroid"));
                            }
                            menstruation_peroid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InitTimestamp => {
                            if init_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("initTimestamp"));
                            }
                            init_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Sections => {
                            if sections__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sections"));
                            }
                            sections__ = map_.next_value()?;
                        }
                    }
                }
                Ok(WomenHealth {
                    enabled: enabled__.ok_or_else(|| serde::de::Error::missing_field("enabled"))?,
                    forcast_on: forcast_on__,
                    reminder_list: reminder_list__,
                    data_list: data_list__,
                    menstruation_days: menstruation_days__,
                    menstruation_peroid: menstruation_peroid__,
                    init_timestamp: init_timestamp__,
                    sections: sections__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth.Data", len)?;
        let v = women_health::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("forcast", &self.forcast)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for women_health::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "forcast",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Forcast,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "forcast" => Ok(GeneratedField::Forcast),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<women_health::Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut forcast__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<women_health::Type>()? as i32);
                        }
                        GeneratedField::Forcast => {
                            if forcast__.is_some() {
                                return Err(serde::de::Error::duplicate_field("forcast"));
                            }
                            forcast__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(women_health::Data {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    forcast: forcast__.ok_or_else(|| serde::de::Error::missing_field("forcast"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::data::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 2;
        if !self.list.is_empty() {
            len += 1;
        }
        if self.last_timestamp.is_some() {
            len += 1;
        }
        if self.last_days.is_some() {
            len += 1;
        }
        if self.next_timestamp.is_some() {
            len += 1;
        }
        if self.next_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth.Data.List", len)?;
        struct_ser.serialize_field("timestamp", &self.timestamp)?;
        struct_ser.serialize_field("timezone", &self.timezone)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        if let Some(v) = self.last_timestamp.as_ref() {
            struct_ser.serialize_field("lastTimestamp", v)?;
        }
        if let Some(v) = self.last_days.as_ref() {
            struct_ser.serialize_field("lastDays", v)?;
        }
        if let Some(v) = self.next_timestamp.as_ref() {
            struct_ser.serialize_field("nextTimestamp", v)?;
        }
        if let Some(v) = self.next_type.as_ref() {
            let v = women_health::Type::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("nextType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for women_health::data::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timestamp",
            "timezone",
            "list",
            "last_timestamp",
            "lastTimestamp",
            "last_days",
            "lastDays",
            "next_timestamp",
            "nextTimestamp",
            "next_type",
            "nextType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
            Timezone,
            List,
            LastTimestamp,
            LastDays,
            NextTimestamp,
            NextType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "timezone" => Ok(GeneratedField::Timezone),
                            "list" => Ok(GeneratedField::List),
                            "lastTimestamp" | "last_timestamp" => Ok(GeneratedField::LastTimestamp),
                            "lastDays" | "last_days" => Ok(GeneratedField::LastDays),
                            "nextTimestamp" | "next_timestamp" => Ok(GeneratedField::NextTimestamp),
                            "nextType" | "next_type" => Ok(GeneratedField::NextType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::data::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth.Data.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<women_health::data::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                let mut timezone__ = None;
                let mut list__ = None;
                let mut last_timestamp__ = None;
                let mut last_days__ = None;
                let mut next_timestamp__ = None;
                let mut next_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::Timezone => {
                            if timezone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timezone"));
                            }
                            timezone__ = map_.next_value()?;
                        }
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LastTimestamp => {
                            if last_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastTimestamp"));
                            }
                            last_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastDays => {
                            if last_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastDays"));
                            }
                            last_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextTimestamp => {
                            if next_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextTimestamp"));
                            }
                            next_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextType => {
                            if next_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextType"));
                            }
                            next_type__ = map_.next_value::<::std::option::Option<women_health::Type>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(women_health::data::List {
                    timestamp: timestamp__.ok_or_else(|| serde::de::Error::missing_field("timestamp"))?,
                    timezone: timezone__.ok_or_else(|| serde::de::Error::missing_field("timezone"))?,
                    list: list__.unwrap_or_default(),
                    last_timestamp: last_timestamp__,
                    last_days: last_days__,
                    next_timestamp: next_timestamp__,
                    next_type: next_type__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth.Data.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::Reminder {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 2;
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth.Reminder", len)?;
        let v = women_health::Type::try_from(self.r#type)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.r#type)))?;
        struct_ser.serialize_field("type", &v)?;
        struct_ser.serialize_field("advancedDays", &self.advanced_days)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for women_health::Reminder {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "advanced_days",
            "advancedDays",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            AdvancedDays,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "advancedDays" | "advanced_days" => Ok(GeneratedField::AdvancedDays),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::Reminder;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth.Reminder")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<women_health::Reminder, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut advanced_days__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = Some(map_.next_value::<women_health::Type>()? as i32);
                        }
                        GeneratedField::AdvancedDays => {
                            if advanced_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("advancedDays"));
                            }
                            advanced_days__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(women_health::Reminder {
                    r#type: r#type__.ok_or_else(|| serde::de::Error::missing_field("type"))?,
                    advanced_days: advanced_days__.ok_or_else(|| serde::de::Error::missing_field("advancedDays"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth.Reminder", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::reminder::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth.Reminder.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for women_health::reminder::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::reminder::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth.Reminder.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<women_health::reminder::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(women_health::reminder::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth.Reminder.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::Section {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 3;
        if self.is_deleted.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth.Section", len)?;
        struct_ser.serialize_field("startTimestamp", &self.start_timestamp)?;
        struct_ser.serialize_field("endTimestamp", &self.end_timestamp)?;
        struct_ser.serialize_field("updateTimestamp", &self.update_timestamp)?;
        if let Some(v) = self.is_deleted.as_ref() {
            struct_ser.serialize_field("isDeleted", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for women_health::Section {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "start_timestamp",
            "startTimestamp",
            "end_timestamp",
            "endTimestamp",
            "update_timestamp",
            "updateTimestamp",
            "is_deleted",
            "isDeleted",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StartTimestamp,
            EndTimestamp,
            UpdateTimestamp,
            IsDeleted,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "startTimestamp" | "start_timestamp" => Ok(GeneratedField::StartTimestamp),
                            "endTimestamp" | "end_timestamp" => Ok(GeneratedField::EndTimestamp),
                            "updateTimestamp" | "update_timestamp" => Ok(GeneratedField::UpdateTimestamp),
                            "isDeleted" | "is_deleted" => Ok(GeneratedField::IsDeleted),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::Section;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth.Section")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<women_health::Section, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut start_timestamp__ = None;
                let mut end_timestamp__ = None;
                let mut update_timestamp__ = None;
                let mut is_deleted__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StartTimestamp => {
                            if start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTimestamp"));
                            }
                            start_timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::EndTimestamp => {
                            if end_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endTimestamp"));
                            }
                            end_timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::UpdateTimestamp => {
                            if update_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("updateTimestamp"));
                            }
                            update_timestamp__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                        GeneratedField::IsDeleted => {
                            if is_deleted__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isDeleted"));
                            }
                            is_deleted__ = map_.next_value()?;
                        }
                    }
                }
                Ok(women_health::Section {
                    start_timestamp: start_timestamp__.ok_or_else(|| serde::de::Error::missing_field("startTimestamp"))?,
                    end_timestamp: end_timestamp__.ok_or_else(|| serde::de::Error::missing_field("endTimestamp"))?,
                    update_timestamp: update_timestamp__.ok_or_else(|| serde::de::Error::missing_field("updateTimestamp"))?,
                    is_deleted: is_deleted__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth.Section", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::section::List {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WomenHealth.Section.List", len)?;
        if !self.list.is_empty() {
            struct_ser.serialize_field("list", &self.list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for women_health::section::List {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "list",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            List,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "list" => Ok(GeneratedField::List),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::section::List;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WomenHealth.Section.List")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<women_health::section::List, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::List => {
                            if list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("list"));
                            }
                            list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(women_health::section::List {
                    list: list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WomenHealth.Section.List", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for women_health::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Normal => "NORMAL",
            Self::Menstruation => "MENSTRUATION",
            Self::Ovulation => "OVULATION",
            Self::EasyPregnancy => "EASY_PREGNANCY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for women_health::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NORMAL",
            "MENSTRUATION",
            "OVULATION",
            "EASY_PREGNANCY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = women_health::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NORMAL" => Ok(women_health::Type::Normal),
                    "MENSTRUATION" => Ok(women_health::Type::Menstruation),
                    "OVULATION" => Ok(women_health::Type::Ovulation),
                    "EASY_PREGNANCY" => Ok(women_health::Type::EasyPregnancy),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WorkAndRest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WorkAndRest", len)?;
        let v = work_and_rest::Source::try_from(self.source)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.source)))?;
        struct_ser.serialize_field("source", &v)?;
        if let Some(v) = self.data.as_ref() {
            struct_ser.serialize_field("data", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorkAndRest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "source",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Source,
            Data,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "source" => Ok(GeneratedField::Source),
                            "data" => Ok(GeneratedField::Data),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorkAndRest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WorkAndRest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorkAndRest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut source__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Source => {
                            if source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("source"));
                            }
                            source__ = Some(map_.next_value::<work_and_rest::Source>()? as i32);
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(WorkAndRest {
                    source: source__.ok_or_else(|| serde::de::Error::missing_field("source"))?,
                    data: data__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WorkAndRest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for work_and_rest::Data {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 3;
        let mut struct_ser = serializer.serialize_struct("protocol.WorkAndRest.Data", len)?;
        struct_ser.serialize_field("bedtime", &self.bedtime)?;
        struct_ser.serialize_field("getupTime", &self.getup_time)?;
        struct_ser.serialize_field("remindBed", &self.remind_bed)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for work_and_rest::Data {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bedtime",
            "getup_time",
            "getupTime",
            "remind_bed",
            "remindBed",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bedtime,
            GetupTime,
            RemindBed,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bedtime" => Ok(GeneratedField::Bedtime),
                            "getupTime" | "getup_time" => Ok(GeneratedField::GetupTime),
                            "remindBed" | "remind_bed" => Ok(GeneratedField::RemindBed),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = work_and_rest::Data;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WorkAndRest.Data")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<work_and_rest::Data, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bedtime__ = None;
                let mut getup_time__ = None;
                let mut remind_bed__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bedtime => {
                            if bedtime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bedtime"));
                            }
                            bedtime__ = map_.next_value()?;
                        }
                        GeneratedField::GetupTime => {
                            if getup_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("getupTime"));
                            }
                            getup_time__ = map_.next_value()?;
                        }
                        GeneratedField::RemindBed => {
                            if remind_bed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("remindBed"));
                            }
                            remind_bed__ = 
                                Some(map_.next_value::<::pbjson::private::NumberDeserialize<_>>()?.0)
                            ;
                        }
                    }
                }
                Ok(work_and_rest::Data {
                    bedtime: bedtime__.ok_or_else(|| serde::de::Error::missing_field("bedtime"))?,
                    getup_time: getup_time__.ok_or_else(|| serde::de::Error::missing_field("getupTime"))?,
                    remind_bed: remind_bed__.ok_or_else(|| serde::de::Error::missing_field("remindBed"))?,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WorkAndRest.Data", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for work_and_rest::Source {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "NONE",
            Self::Miui => "MIUI",
            Self::Manual => "MANUAL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for work_and_rest::Source {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NONE",
            "MIUI",
            "MANUAL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = work_and_rest::Source;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NONE" => Ok(work_and_rest::Source::None),
                    "MIUI" => Ok(work_and_rest::Source::Miui),
                    "MANUAL" => Ok(work_and_rest::Source::Manual),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WorldClockIdList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WorldClockIdList", len)?;
        if !self.id.is_empty() {
            struct_ser.serialize_field("id", &self.id)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorldClockIdList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldClockIdList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WorldClockIdList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorldClockIdList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(WorldClockIdList {
                    id: id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("protocol.WorldClockIdList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldClockResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::OperateSuccess => "OPERATE_SUCCESS",
            Self::IdNotSupport => "ID_NOT_SUPPORT",
            Self::OverLimit => "OVER_LIMIT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for WorldClockResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OPERATE_SUCCESS",
            "ID_NOT_SUPPORT",
            "OVER_LIMIT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldClockResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OPERATE_SUCCESS" => Ok(WorldClockResult::OperateSuccess),
                    "ID_NOT_SUPPORT" => Ok(WorldClockResult::IdNotSupport),
                    "OVER_LIMIT" => Ok(WorldClockResult::OverLimit),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for WristScreen {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 1;
        if self.start_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.sensitivity.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("protocol.WristScreen", len)?;
        let v = TimingMode::try_from(self.timing_mode)
            .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", self.timing_mode)))?;
        struct_ser.serialize_field("timingMode", &v)?;
        if let Some(v) = self.start_time.as_ref() {
            struct_ser.serialize_field("startTime", v)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            struct_ser.serialize_field("endTime", v)?;
        }
        if let Some(v) = self.sensitivity.as_ref() {
            let v = wrist_screen::Sensitivity::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("sensitivity", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WristScreen {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "timing_mode",
            "timingMode",
            "start_time",
            "startTime",
            "end_time",
            "endTime",
            "sensitivity",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TimingMode,
            StartTime,
            EndTime,
            Sensitivity,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "timingMode" | "timing_mode" => Ok(GeneratedField::TimingMode),
                            "startTime" | "start_time" => Ok(GeneratedField::StartTime),
                            "endTime" | "end_time" => Ok(GeneratedField::EndTime),
                            "sensitivity" => Ok(GeneratedField::Sensitivity),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WristScreen;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct protocol.WristScreen")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WristScreen, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timing_mode__ = None;
                let mut start_time__ = None;
                let mut end_time__ = None;
                let mut sensitivity__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TimingMode => {
                            if timing_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timingMode"));
                            }
                            timing_mode__ = Some(map_.next_value::<TimingMode>()? as i32);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startTime"));
                            }
                            start_time__ = map_.next_value()?;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endTime"));
                            }
                            end_time__ = map_.next_value()?;
                        }
                        GeneratedField::Sensitivity => {
                            if sensitivity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sensitivity"));
                            }
                            sensitivity__ = map_.next_value::<::std::option::Option<wrist_screen::Sensitivity>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(WristScreen {
                    timing_mode: timing_mode__.ok_or_else(|| serde::de::Error::missing_field("timingMode"))?,
                    start_time: start_time__,
                    end_time: end_time__,
                    sensitivity: sensitivity__,
                })
            }
        }
        deserializer.deserialize_struct("protocol.WristScreen", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for wrist_screen::Sensitivity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "NONE",
            Self::Standard => "STANDARD",
            Self::High => "HIGH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for wrist_screen::Sensitivity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NONE",
            "STANDARD",
            "HIGH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = wrist_screen::Sensitivity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "NONE" => Ok(wrist_screen::Sensitivity::None),
                    "STANDARD" => Ok(wrist_screen::Sensitivity::Standard),
                    "HIGH" => Ok(wrist_screen::Sensitivity::High),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}

include!("protocol.rs");