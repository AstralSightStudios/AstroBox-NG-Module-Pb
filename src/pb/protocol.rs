// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockHoliday {
    #[prost(uint32, required, tag = "1")]
    pub year: u32,
    #[prost(string, repeated, tag = "2")]
    pub free_days: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub work_days: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timezone {
    #[prost(int32, required, tag = "1")]
    pub offset: i32,
    #[prost(int32, optional, tag = "2")]
    pub dst_saving: ::core::option::Option<i32>,
    #[prost(string, required, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub id_spec: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Date {
    #[prost(uint32, required, tag = "1")]
    pub year: u32,
    #[prost(uint32, required, tag = "2")]
    pub month: u32,
    #[prost(uint32, required, tag = "3")]
    pub day: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Time {
    #[prost(uint32, required, tag = "1")]
    pub hour: u32,
    #[prost(uint32, required, tag = "2")]
    pub minuter: u32,
    #[prost(uint32, optional, tag = "3")]
    pub second: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub millisecond: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValue {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "2")]
    pub value: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValueStr {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RangeValue {
    #[prost(sint32, required, tag = "1")]
    pub from: i32,
    #[prost(sint32, required, tag = "2")]
    pub to: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LimitValue {
    #[prost(uint32, required, tag = "1")]
    pub current: u32,
    #[prost(uint32, required, tag = "2")]
    pub max: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    NoError = 0,
    NotSupport = 1,
    DependencyNotReady = 2,
    SetFailed = 3,
    ParamError = 4,
    BusyInOta = 5,
    BusyInUploadLog = 6,
    BusyInA2dp = 7,
    Unknown = 255,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoError => "NO_ERROR",
            Self::NotSupport => "NOT_SUPPORT",
            Self::DependencyNotReady => "DEPENDENCY_NOT_READY",
            Self::SetFailed => "SET_FAILED",
            Self::ParamError => "PARAM_ERROR",
            Self::BusyInOta => "BUSY_IN_OTA",
            Self::BusyInUploadLog => "BUSY_IN_UPLOAD_LOG",
            Self::BusyInA2dp => "BUSY_IN_A2DP",
            Self::Unknown => "UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_ERROR" => Some(Self::NoError),
            "NOT_SUPPORT" => Some(Self::NotSupport),
            "DEPENDENCY_NOT_READY" => Some(Self::DependencyNotReady),
            "SET_FAILED" => Some(Self::SetFailed),
            "PARAM_ERROR" => Some(Self::ParamError),
            "BUSY_IN_OTA" => Some(Self::BusyInOta),
            "BUSY_IN_UPLOAD_LOG" => Some(Self::BusyInUploadLog),
            "BUSY_IN_A2DP" => Some(Self::BusyInA2dp),
            "UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrepareStatus {
    Ready = 0,
    Busy = 1,
    Duplicated = 2,
    LowStorage = 3,
    LowBattery = 4,
    Downgrade = 5,
    OpNotSupport = 6,
    ExceedQuantityLimit = 7,
    NetworkError = 8,
    Failed = 255,
}
impl PrepareStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ready => "READY",
            Self::Busy => "BUSY",
            Self::Duplicated => "DUPLICATED",
            Self::LowStorage => "LOW_STORAGE",
            Self::LowBattery => "LOW_BATTERY",
            Self::Downgrade => "DOWNGRADE",
            Self::OpNotSupport => "OP_NOT_SUPPORT",
            Self::ExceedQuantityLimit => "EXCEED_QUANTITY_LIMIT",
            Self::NetworkError => "NETWORK_ERROR",
            Self::Failed => "FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "READY" => Some(Self::Ready),
            "BUSY" => Some(Self::Busy),
            "DUPLICATED" => Some(Self::Duplicated),
            "LOW_STORAGE" => Some(Self::LowStorage),
            "LOW_BATTERY" => Some(Self::LowBattery),
            "DOWNGRADE" => Some(Self::Downgrade),
            "OP_NOT_SUPPORT" => Some(Self::OpNotSupport),
            "EXCEED_QUANTITY_LIMIT" => Some(Self::ExceedQuantityLimit),
            "NETWORK_ERROR" => Some(Self::NetworkError),
            "FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Sex {
    Neutral = 0,
    Male = 1,
    Female = 2,
}
impl Sex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Neutral => "NEUTRAL",
            Self::Male => "MALE",
            Self::Female => "FEMALE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEUTRAL" => Some(Self::Neutral),
            "MALE" => Some(Self::Male),
            "FEMALE" => Some(Self::Female),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SportType {
    None = 0,
    RunOutdoor = 1,
    WalkOutdoor = 2,
    RunIndoor = 3,
    Climbing = 4,
    CrossCountry = 5,
    RideOutdoor = 6,
    RideIndoor = 7,
    FreeTraining = 8,
    SwimIndoor = 9,
    SwimOutdoor = 10,
    EllipticalMachine = 11,
    Yoga = 12,
    RowingMachine = 13,
    RopeSkipping = 14,
    HikingOutdoor = 15,
    HighIntervalTraining = 16,
    Triathlon = 17,
    GeneralBall = 18,
    BasketballS = 19,
    GolfS = 20,
    Skiing = 21,
    OutdoorWalkCategory = 22,
    OutdoorNonWalkCategory = 23,
    RockClimbingS = 24,
    Diving = 25,
    Sailboat = 100,
    PaddleBoard = 101,
    WaterPolo = 102,
    AquaticSport = 103,
    Surfing = 104,
    Canoeing = 105,
    KayakRafting = 106,
    Rowing = 107,
    Motorboat = 108,
    WebSwimming = 109,
    Driving = 110,
    FancySwimming = 111,
    Snorkeling = 112,
    KiteSurfing = 113,
    IndoorSurfing = 114,
    DragonBoat = 115,
    FreeDiving = 116,
    ScubaDiving = 117,
    InstrumentDiving = 118,
    RockClimbing = 200,
    Skate = 201,
    RollerSkating = 202,
    Parkour = 203,
    Atv = 204,
    Paraglider = 205,
    BicycleMoto = 206,
    HeelAndToe = 207,
    ClimbingMachine = 300,
    ClimbStairs = 301,
    Stepper = 302,
    CoreTraining = 303,
    FlexibilityTraining = 304,
    Pilates = 305,
    Gymnastics = 306,
    Stretch = 307,
    StrengthTraining = 308,
    CrossFit = 309,
    Aerobics = 310,
    PhysicalTraining = 311,
    WallBall = 312,
    DumbbellTraining = 313,
    BarbellTraining = 314,
    Weightlifting = 315,
    Deadlift = 316,
    BobbyJump = 317,
    SitUps = 318,
    FunctionalTraining = 319,
    UpperLimbTraining = 320,
    LowerLimbTraining = 321,
    WaistTraining = 322,
    BackTraining = 323,
    Spinning = 324,
    WalkingMachine = 325,
    StepTraining = 326,
    SingleBar = 327,
    ParallelBars = 328,
    GroupCallisthenics = 329,
    Strike = 330,
    BattleRope = 331,
    MixedAerobic = 332,
    WalkIndoor = 333,
    Gym = 399,
    SquareDance = 400,
    BellyDance = 401,
    Ballet = 402,
    StreetDance = 403,
    Zumba = 404,
    NationalDance = 405,
    Jazz = 406,
    LatinDance = 407,
    HipHopDance = 408,
    PoleDance = 409,
    Breakdancing = 410,
    SocialDancing = 411,
    ModernDancing = 412,
    Dance = 499,
    Boxing = 500,
    Wrestling = 501,
    MartialArts = 502,
    Taichi = 503,
    MuayThai = 504,
    Judo = 505,
    Taekwondo = 506,
    Karate = 507,
    FreeSparring = 508,
    Swordsmanship = 509,
    Fencing = 510,
    Jujitsu = 511,
    Football = 600,
    Basketball = 601,
    Volleyball = 602,
    Baseball = 603,
    Softball = 604,
    Rugby = 605,
    Hockey = 606,
    Pingpong = 607,
    Badminton = 608,
    Tennis = 609,
    Cricket = 610,
    Handball = 611,
    Bowling = 612,
    Squash = 613,
    Billiards = 614,
    Shuttlecock = 615,
    BeachFootball = 616,
    BeachVolleyball = 617,
    SepakTakraw = 618,
    Golf = 619,
    Foosball = 620,
    IndoorFootball = 621,
    SandbagsBall = 622,
    Bocci = 623,
    HihiBall = 624,
    Gateball = 625,
    Dodgeball = 626,
    ShuffleBall = 627,
    OutdoorSkating = 700,
    Curling = 701,
    SnowSports = 702,
    Snowmobile = 703,
    Puck = 704,
    SnowCar = 705,
    Sled = 706,
    IndoorSkating = 707,
    Snowboarding = 708,
    DoubleBoardSkiing = 709,
    CrossCountrySkiing = 710,
    Archery = 800,
    Darts = 801,
    HorseRiding = 802,
    TugOfWar = 803,
    HulaHoop = 804,
    FlyKite = 805,
    Fishing = 806,
    Frisbee = 807,
    ShuttlecockKicking = 808,
    Swing = 809,
    MotionSensingGame = 810,
    ElectronicSports = 811,
    NintendoJustdance = 812,
    Chess = 900,
    Draughts = 901,
    Weiqi = 902,
    Bridge = 903,
    BoardGames = 904,
    IndoorRockClimbing = 1000,
    OutdoorRockClimbing = 1001,
    Equesttrian = 10000,
    TrackAndField = 10001,
    RacingCar = 10002,
}
impl SportType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::RunOutdoor => "RUN_OUTDOOR",
            Self::WalkOutdoor => "WALK_OUTDOOR",
            Self::RunIndoor => "RUN_INDOOR",
            Self::Climbing => "CLIMBING",
            Self::CrossCountry => "CROSS_COUNTRY",
            Self::RideOutdoor => "RIDE_OUTDOOR",
            Self::RideIndoor => "RIDE_INDOOR",
            Self::FreeTraining => "FREE_TRAINING",
            Self::SwimIndoor => "SWIM_INDOOR",
            Self::SwimOutdoor => "SWIM_OUTDOOR",
            Self::EllipticalMachine => "ELLIPTICAL_MACHINE",
            Self::Yoga => "YOGA",
            Self::RowingMachine => "ROWING_MACHINE",
            Self::RopeSkipping => "ROPE_SKIPPING",
            Self::HikingOutdoor => "HIKING_OUTDOOR",
            Self::HighIntervalTraining => "HIGH_INTERVAL_TRAINING",
            Self::Triathlon => "TRIATHLON",
            Self::GeneralBall => "GENERAL_BALL",
            Self::BasketballS => "BASKETBALL_S",
            Self::GolfS => "GOLF_S",
            Self::Skiing => "SKIING",
            Self::OutdoorWalkCategory => "OUTDOOR_WALK_CATEGORY",
            Self::OutdoorNonWalkCategory => "OUTDOOR_NON_WALK_CATEGORY",
            Self::RockClimbingS => "ROCK_CLIMBING_S",
            Self::Diving => "DIVING",
            Self::Sailboat => "SAILBOAT",
            Self::PaddleBoard => "PADDLE_BOARD",
            Self::WaterPolo => "WATER_POLO",
            Self::AquaticSport => "AQUATIC_SPORT",
            Self::Surfing => "SURFING",
            Self::Canoeing => "CANOEING",
            Self::KayakRafting => "KAYAK_RAFTING",
            Self::Rowing => "ROWING",
            Self::Motorboat => "MOTORBOAT",
            Self::WebSwimming => "WEB_SWIMMING",
            Self::Driving => "DRIVING",
            Self::FancySwimming => "FANCY_SWIMMING",
            Self::Snorkeling => "SNORKELING",
            Self::KiteSurfing => "KITE_SURFING",
            Self::IndoorSurfing => "INDOOR_SURFING",
            Self::DragonBoat => "DRAGON_BOAT",
            Self::FreeDiving => "FREE_DIVING",
            Self::ScubaDiving => "SCUBA_DIVING",
            Self::InstrumentDiving => "INSTRUMENT_DIVING",
            Self::RockClimbing => "ROCK_CLIMBING",
            Self::Skate => "SKATE",
            Self::RollerSkating => "ROLLER_SKATING",
            Self::Parkour => "PARKOUR",
            Self::Atv => "ATV",
            Self::Paraglider => "PARAGLIDER",
            Self::BicycleMoto => "BICYCLE_MOTO",
            Self::HeelAndToe => "HEEL_AND_TOE",
            Self::ClimbingMachine => "CLIMBING_MACHINE",
            Self::ClimbStairs => "CLIMB_STAIRS",
            Self::Stepper => "STEPPER",
            Self::CoreTraining => "CORE_TRAINING",
            Self::FlexibilityTraining => "FLEXIBILITY_TRAINING",
            Self::Pilates => "PILATES",
            Self::Gymnastics => "GYMNASTICS",
            Self::Stretch => "STRETCH",
            Self::StrengthTraining => "STRENGTH_TRAINING",
            Self::CrossFit => "CROSS_FIT",
            Self::Aerobics => "AEROBICS",
            Self::PhysicalTraining => "PHYSICAL_TRAINING",
            Self::WallBall => "WALL_BALL",
            Self::DumbbellTraining => "DUMBBELL_TRAINING",
            Self::BarbellTraining => "BARBELL_TRAINING",
            Self::Weightlifting => "WEIGHTLIFTING",
            Self::Deadlift => "DEADLIFT",
            Self::BobbyJump => "BOBBY_JUMP",
            Self::SitUps => "SIT_UPS",
            Self::FunctionalTraining => "FUNCTIONAL_TRAINING",
            Self::UpperLimbTraining => "UPPER_LIMB_TRAINING",
            Self::LowerLimbTraining => "LOWER_LIMB_TRAINING",
            Self::WaistTraining => "WAIST_TRAINING",
            Self::BackTraining => "BACK_TRAINING",
            Self::Spinning => "SPINNING",
            Self::WalkingMachine => "WALKING_MACHINE",
            Self::StepTraining => "STEP_TRAINING",
            Self::SingleBar => "SINGLE_BAR",
            Self::ParallelBars => "PARALLEL_BARS",
            Self::GroupCallisthenics => "GROUP_CALLISTHENICS",
            Self::Strike => "STRIKE",
            Self::BattleRope => "BATTLE_ROPE",
            Self::MixedAerobic => "MIXED_AEROBIC",
            Self::WalkIndoor => "WALK_INDOOR",
            Self::Gym => "GYM",
            Self::SquareDance => "SQUARE_DANCE",
            Self::BellyDance => "BELLY_DANCE",
            Self::Ballet => "BALLET",
            Self::StreetDance => "STREET_DANCE",
            Self::Zumba => "ZUMBA",
            Self::NationalDance => "NATIONAL_DANCE",
            Self::Jazz => "JAZZ",
            Self::LatinDance => "LATIN_DANCE",
            Self::HipHopDance => "HIP_HOP_DANCE",
            Self::PoleDance => "POLE_DANCE",
            Self::Breakdancing => "BREAKDANCING",
            Self::SocialDancing => "SOCIAL_DANCING",
            Self::ModernDancing => "MODERN_DANCING",
            Self::Dance => "DANCE",
            Self::Boxing => "BOXING",
            Self::Wrestling => "WRESTLING",
            Self::MartialArts => "MARTIAL_ARTS",
            Self::Taichi => "TAICHI",
            Self::MuayThai => "MUAY_THAI",
            Self::Judo => "JUDO",
            Self::Taekwondo => "TAEKWONDO",
            Self::Karate => "KARATE",
            Self::FreeSparring => "FREE_SPARRING",
            Self::Swordsmanship => "SWORDSMANSHIP",
            Self::Fencing => "FENCING",
            Self::Jujitsu => "JUJITSU",
            Self::Football => "FOOTBALL",
            Self::Basketball => "BASKETBALL",
            Self::Volleyball => "VOLLEYBALL",
            Self::Baseball => "BASEBALL",
            Self::Softball => "SOFTBALL",
            Self::Rugby => "RUGBY",
            Self::Hockey => "HOCKEY",
            Self::Pingpong => "PINGPONG",
            Self::Badminton => "BADMINTON",
            Self::Tennis => "TENNIS",
            Self::Cricket => "CRICKET",
            Self::Handball => "HANDBALL",
            Self::Bowling => "BOWLING",
            Self::Squash => "SQUASH",
            Self::Billiards => "BILLIARDS",
            Self::Shuttlecock => "SHUTTLECOCK",
            Self::BeachFootball => "BEACH_FOOTBALL",
            Self::BeachVolleyball => "BEACH_VOLLEYBALL",
            Self::SepakTakraw => "SEPAK_TAKRAW",
            Self::Golf => "GOLF",
            Self::Foosball => "FOOSBALL",
            Self::IndoorFootball => "INDOOR_FOOTBALL",
            Self::SandbagsBall => "SANDBAGS_BALL",
            Self::Bocci => "BOCCI",
            Self::HihiBall => "HIHI_BALL",
            Self::Gateball => "GATEBALL",
            Self::Dodgeball => "DODGEBALL",
            Self::ShuffleBall => "SHUFFLE_BALL",
            Self::OutdoorSkating => "OUTDOOR_SKATING",
            Self::Curling => "CURLING",
            Self::SnowSports => "SNOW_SPORTS",
            Self::Snowmobile => "SNOWMOBILE",
            Self::Puck => "PUCK",
            Self::SnowCar => "SNOW_CAR",
            Self::Sled => "SLED",
            Self::IndoorSkating => "INDOOR__SKATING",
            Self::Snowboarding => "SNOWBOARDING",
            Self::DoubleBoardSkiing => "DOUBLE_BOARD_SKIING",
            Self::CrossCountrySkiing => "CROSS_COUNTRY_SKIING",
            Self::Archery => "ARCHERY",
            Self::Darts => "DARTS",
            Self::HorseRiding => "HORSE_RIDING",
            Self::TugOfWar => "TUG_OF_WAR",
            Self::HulaHoop => "HULA_HOOP",
            Self::FlyKite => "FLY_KITE",
            Self::Fishing => "FISHING",
            Self::Frisbee => "FRISBEE",
            Self::ShuttlecockKicking => "SHUTTLECOCK_KICKING",
            Self::Swing => "SWING",
            Self::MotionSensingGame => "MOTION_SENSING_GAME",
            Self::ElectronicSports => "ELECTRONIC_SPORTS",
            Self::NintendoJustdance => "NINTENDO_JUSTDANCE",
            Self::Chess => "CHESS",
            Self::Draughts => "DRAUGHTS",
            Self::Weiqi => "WEIQI",
            Self::Bridge => "BRIDGE",
            Self::BoardGames => "BOARD_GAMES",
            Self::IndoorRockClimbing => "INDOOR_ROCK_CLIMBING",
            Self::OutdoorRockClimbing => "OUTDOOR_ROCK_CLIMBING",
            Self::Equesttrian => "EQUESTTRIAN",
            Self::TrackAndField => "TRACK_AND_FIELD",
            Self::RacingCar => "RACING_CAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "RUN_OUTDOOR" => Some(Self::RunOutdoor),
            "WALK_OUTDOOR" => Some(Self::WalkOutdoor),
            "RUN_INDOOR" => Some(Self::RunIndoor),
            "CLIMBING" => Some(Self::Climbing),
            "CROSS_COUNTRY" => Some(Self::CrossCountry),
            "RIDE_OUTDOOR" => Some(Self::RideOutdoor),
            "RIDE_INDOOR" => Some(Self::RideIndoor),
            "FREE_TRAINING" => Some(Self::FreeTraining),
            "SWIM_INDOOR" => Some(Self::SwimIndoor),
            "SWIM_OUTDOOR" => Some(Self::SwimOutdoor),
            "ELLIPTICAL_MACHINE" => Some(Self::EllipticalMachine),
            "YOGA" => Some(Self::Yoga),
            "ROWING_MACHINE" => Some(Self::RowingMachine),
            "ROPE_SKIPPING" => Some(Self::RopeSkipping),
            "HIKING_OUTDOOR" => Some(Self::HikingOutdoor),
            "HIGH_INTERVAL_TRAINING" => Some(Self::HighIntervalTraining),
            "TRIATHLON" => Some(Self::Triathlon),
            "GENERAL_BALL" => Some(Self::GeneralBall),
            "BASKETBALL_S" => Some(Self::BasketballS),
            "GOLF_S" => Some(Self::GolfS),
            "SKIING" => Some(Self::Skiing),
            "OUTDOOR_WALK_CATEGORY" => Some(Self::OutdoorWalkCategory),
            "OUTDOOR_NON_WALK_CATEGORY" => Some(Self::OutdoorNonWalkCategory),
            "ROCK_CLIMBING_S" => Some(Self::RockClimbingS),
            "DIVING" => Some(Self::Diving),
            "SAILBOAT" => Some(Self::Sailboat),
            "PADDLE_BOARD" => Some(Self::PaddleBoard),
            "WATER_POLO" => Some(Self::WaterPolo),
            "AQUATIC_SPORT" => Some(Self::AquaticSport),
            "SURFING" => Some(Self::Surfing),
            "CANOEING" => Some(Self::Canoeing),
            "KAYAK_RAFTING" => Some(Self::KayakRafting),
            "ROWING" => Some(Self::Rowing),
            "MOTORBOAT" => Some(Self::Motorboat),
            "WEB_SWIMMING" => Some(Self::WebSwimming),
            "DRIVING" => Some(Self::Driving),
            "FANCY_SWIMMING" => Some(Self::FancySwimming),
            "SNORKELING" => Some(Self::Snorkeling),
            "KITE_SURFING" => Some(Self::KiteSurfing),
            "INDOOR_SURFING" => Some(Self::IndoorSurfing),
            "DRAGON_BOAT" => Some(Self::DragonBoat),
            "FREE_DIVING" => Some(Self::FreeDiving),
            "SCUBA_DIVING" => Some(Self::ScubaDiving),
            "INSTRUMENT_DIVING" => Some(Self::InstrumentDiving),
            "ROCK_CLIMBING" => Some(Self::RockClimbing),
            "SKATE" => Some(Self::Skate),
            "ROLLER_SKATING" => Some(Self::RollerSkating),
            "PARKOUR" => Some(Self::Parkour),
            "ATV" => Some(Self::Atv),
            "PARAGLIDER" => Some(Self::Paraglider),
            "BICYCLE_MOTO" => Some(Self::BicycleMoto),
            "HEEL_AND_TOE" => Some(Self::HeelAndToe),
            "CLIMBING_MACHINE" => Some(Self::ClimbingMachine),
            "CLIMB_STAIRS" => Some(Self::ClimbStairs),
            "STEPPER" => Some(Self::Stepper),
            "CORE_TRAINING" => Some(Self::CoreTraining),
            "FLEXIBILITY_TRAINING" => Some(Self::FlexibilityTraining),
            "PILATES" => Some(Self::Pilates),
            "GYMNASTICS" => Some(Self::Gymnastics),
            "STRETCH" => Some(Self::Stretch),
            "STRENGTH_TRAINING" => Some(Self::StrengthTraining),
            "CROSS_FIT" => Some(Self::CrossFit),
            "AEROBICS" => Some(Self::Aerobics),
            "PHYSICAL_TRAINING" => Some(Self::PhysicalTraining),
            "WALL_BALL" => Some(Self::WallBall),
            "DUMBBELL_TRAINING" => Some(Self::DumbbellTraining),
            "BARBELL_TRAINING" => Some(Self::BarbellTraining),
            "WEIGHTLIFTING" => Some(Self::Weightlifting),
            "DEADLIFT" => Some(Self::Deadlift),
            "BOBBY_JUMP" => Some(Self::BobbyJump),
            "SIT_UPS" => Some(Self::SitUps),
            "FUNCTIONAL_TRAINING" => Some(Self::FunctionalTraining),
            "UPPER_LIMB_TRAINING" => Some(Self::UpperLimbTraining),
            "LOWER_LIMB_TRAINING" => Some(Self::LowerLimbTraining),
            "WAIST_TRAINING" => Some(Self::WaistTraining),
            "BACK_TRAINING" => Some(Self::BackTraining),
            "SPINNING" => Some(Self::Spinning),
            "WALKING_MACHINE" => Some(Self::WalkingMachine),
            "STEP_TRAINING" => Some(Self::StepTraining),
            "SINGLE_BAR" => Some(Self::SingleBar),
            "PARALLEL_BARS" => Some(Self::ParallelBars),
            "GROUP_CALLISTHENICS" => Some(Self::GroupCallisthenics),
            "STRIKE" => Some(Self::Strike),
            "BATTLE_ROPE" => Some(Self::BattleRope),
            "MIXED_AEROBIC" => Some(Self::MixedAerobic),
            "WALK_INDOOR" => Some(Self::WalkIndoor),
            "GYM" => Some(Self::Gym),
            "SQUARE_DANCE" => Some(Self::SquareDance),
            "BELLY_DANCE" => Some(Self::BellyDance),
            "BALLET" => Some(Self::Ballet),
            "STREET_DANCE" => Some(Self::StreetDance),
            "ZUMBA" => Some(Self::Zumba),
            "NATIONAL_DANCE" => Some(Self::NationalDance),
            "JAZZ" => Some(Self::Jazz),
            "LATIN_DANCE" => Some(Self::LatinDance),
            "HIP_HOP_DANCE" => Some(Self::HipHopDance),
            "POLE_DANCE" => Some(Self::PoleDance),
            "BREAKDANCING" => Some(Self::Breakdancing),
            "SOCIAL_DANCING" => Some(Self::SocialDancing),
            "MODERN_DANCING" => Some(Self::ModernDancing),
            "DANCE" => Some(Self::Dance),
            "BOXING" => Some(Self::Boxing),
            "WRESTLING" => Some(Self::Wrestling),
            "MARTIAL_ARTS" => Some(Self::MartialArts),
            "TAICHI" => Some(Self::Taichi),
            "MUAY_THAI" => Some(Self::MuayThai),
            "JUDO" => Some(Self::Judo),
            "TAEKWONDO" => Some(Self::Taekwondo),
            "KARATE" => Some(Self::Karate),
            "FREE_SPARRING" => Some(Self::FreeSparring),
            "SWORDSMANSHIP" => Some(Self::Swordsmanship),
            "FENCING" => Some(Self::Fencing),
            "JUJITSU" => Some(Self::Jujitsu),
            "FOOTBALL" => Some(Self::Football),
            "BASKETBALL" => Some(Self::Basketball),
            "VOLLEYBALL" => Some(Self::Volleyball),
            "BASEBALL" => Some(Self::Baseball),
            "SOFTBALL" => Some(Self::Softball),
            "RUGBY" => Some(Self::Rugby),
            "HOCKEY" => Some(Self::Hockey),
            "PINGPONG" => Some(Self::Pingpong),
            "BADMINTON" => Some(Self::Badminton),
            "TENNIS" => Some(Self::Tennis),
            "CRICKET" => Some(Self::Cricket),
            "HANDBALL" => Some(Self::Handball),
            "BOWLING" => Some(Self::Bowling),
            "SQUASH" => Some(Self::Squash),
            "BILLIARDS" => Some(Self::Billiards),
            "SHUTTLECOCK" => Some(Self::Shuttlecock),
            "BEACH_FOOTBALL" => Some(Self::BeachFootball),
            "BEACH_VOLLEYBALL" => Some(Self::BeachVolleyball),
            "SEPAK_TAKRAW" => Some(Self::SepakTakraw),
            "GOLF" => Some(Self::Golf),
            "FOOSBALL" => Some(Self::Foosball),
            "INDOOR_FOOTBALL" => Some(Self::IndoorFootball),
            "SANDBAGS_BALL" => Some(Self::SandbagsBall),
            "BOCCI" => Some(Self::Bocci),
            "HIHI_BALL" => Some(Self::HihiBall),
            "GATEBALL" => Some(Self::Gateball),
            "DODGEBALL" => Some(Self::Dodgeball),
            "SHUFFLE_BALL" => Some(Self::ShuffleBall),
            "OUTDOOR_SKATING" => Some(Self::OutdoorSkating),
            "CURLING" => Some(Self::Curling),
            "SNOW_SPORTS" => Some(Self::SnowSports),
            "SNOWMOBILE" => Some(Self::Snowmobile),
            "PUCK" => Some(Self::Puck),
            "SNOW_CAR" => Some(Self::SnowCar),
            "SLED" => Some(Self::Sled),
            "INDOOR__SKATING" => Some(Self::IndoorSkating),
            "SNOWBOARDING" => Some(Self::Snowboarding),
            "DOUBLE_BOARD_SKIING" => Some(Self::DoubleBoardSkiing),
            "CROSS_COUNTRY_SKIING" => Some(Self::CrossCountrySkiing),
            "ARCHERY" => Some(Self::Archery),
            "DARTS" => Some(Self::Darts),
            "HORSE_RIDING" => Some(Self::HorseRiding),
            "TUG_OF_WAR" => Some(Self::TugOfWar),
            "HULA_HOOP" => Some(Self::HulaHoop),
            "FLY_KITE" => Some(Self::FlyKite),
            "FISHING" => Some(Self::Fishing),
            "FRISBEE" => Some(Self::Frisbee),
            "SHUTTLECOCK_KICKING" => Some(Self::ShuttlecockKicking),
            "SWING" => Some(Self::Swing),
            "MOTION_SENSING_GAME" => Some(Self::MotionSensingGame),
            "ELECTRONIC_SPORTS" => Some(Self::ElectronicSports),
            "NINTENDO_JUSTDANCE" => Some(Self::NintendoJustdance),
            "CHESS" => Some(Self::Chess),
            "DRAUGHTS" => Some(Self::Draughts),
            "WEIQI" => Some(Self::Weiqi),
            "BRIDGE" => Some(Self::Bridge),
            "BOARD_GAMES" => Some(Self::BoardGames),
            "INDOOR_ROCK_CLIMBING" => Some(Self::IndoorRockClimbing),
            "OUTDOOR_ROCK_CLIMBING" => Some(Self::OutdoorRockClimbing),
            "EQUESTTRIAN" => Some(Self::Equesttrian),
            "TRACK_AND_FIELD" => Some(Self::TrackAndField),
            "RACING_CAR" => Some(Self::RacingCar),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SportTargetType {
    TargetDuration = 1,
    TargetCalorie = 2,
    TargetDistance = 3,
    TargetPace = 4,
    TargetStepFrequency = 5,
    TargetCount = 6,
    TargetHeartrate = 7,
}
impl SportTargetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TargetDuration => "TARGET_DURATION",
            Self::TargetCalorie => "TARGET_CALORIE",
            Self::TargetDistance => "TARGET_DISTANCE",
            Self::TargetPace => "TARGET_PACE",
            Self::TargetStepFrequency => "TARGET_STEP_FREQUENCY",
            Self::TargetCount => "TARGET_COUNT",
            Self::TargetHeartrate => "TARGET_HEARTRATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_DURATION" => Some(Self::TargetDuration),
            "TARGET_CALORIE" => Some(Self::TargetCalorie),
            "TARGET_DISTANCE" => Some(Self::TargetDistance),
            "TARGET_PACE" => Some(Self::TargetPace),
            "TARGET_STEP_FREQUENCY" => Some(Self::TargetStepFrequency),
            "TARGET_COUNT" => Some(Self::TargetCount),
            "TARGET_HEARTRATE" => Some(Self::TargetHeartrate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SportState {
    SportStart = 0,
    SportPause = 1,
    SportResume = 2,
    SportStop = 3,
}
impl SportState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SportStart => "SPORT_START",
            Self::SportPause => "SPORT_PAUSE",
            Self::SportResume => "SPORT_RESUME",
            Self::SportStop => "SPORT_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPORT_START" => Some(Self::SportStart),
            "SPORT_PAUSE" => Some(Self::SportPause),
            "SPORT_RESUME" => Some(Self::SportResume),
            "SPORT_STOP" => Some(Self::SportStop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Function {
    Setting = 1,
    Fitness = 2,
    HeartRate = 3,
    Pressure = 4,
    Energy = 5,
    Sleep = 6,
    Breath = 7,
    AnaerobicThreshold = 8,
    Calendar = 9,
    Clock = 10,
    Stopwatch = 11,
    TimeKeeping = 12,
    Weather = 13,
    Stock = 14,
    AppList = 15,
    SportList = 16,
    Home = 17,
    MusicController = 18,
    VoiceAssistant = 19,
    BloodOxygen = 20,
    ControlCenter = 21,
    WomenHealth = 22,
    System = 23,
    Temperature = 24,
    BloodPressure = 25,
    Ecg = 26,
    Event = 27,
    Mihome = 28,
    Activity = 29,
    SportRecord = 30,
    Share = 31,
    TodoList = 38,
    Phone = 39,
    LactateThreshold = 40,
    Compass = 41,
    Alipay = 32,
    Card = 33,
    Door = 34,
    Bus = 35,
    Bank = 36,
    WechatPay = 37,
}
impl Function {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Setting => "SETTING",
            Self::Fitness => "FITNESS",
            Self::HeartRate => "HEART_RATE",
            Self::Pressure => "PRESSURE",
            Self::Energy => "ENERGY",
            Self::Sleep => "SLEEP",
            Self::Breath => "BREATH",
            Self::AnaerobicThreshold => "ANAEROBIC_THRESHOLD",
            Self::Calendar => "CALENDAR",
            Self::Clock => "CLOCK",
            Self::Stopwatch => "STOPWATCH",
            Self::TimeKeeping => "TIME_KEEPING",
            Self::Weather => "WEATHER",
            Self::Stock => "STOCK",
            Self::AppList => "APP_LIST",
            Self::SportList => "SPORT_LIST",
            Self::Home => "HOME",
            Self::MusicController => "MUSIC_CONTROLLER",
            Self::VoiceAssistant => "VOICE_ASSISTANT",
            Self::BloodOxygen => "BLOOD_OXYGEN",
            Self::ControlCenter => "CONTROL_CENTER",
            Self::WomenHealth => "WOMEN_HEALTH",
            Self::System => "SYSTEM",
            Self::Temperature => "TEMPERATURE",
            Self::BloodPressure => "BLOOD_PRESSURE",
            Self::Ecg => "ECG",
            Self::Event => "EVENT",
            Self::Mihome => "MIHOME",
            Self::Activity => "ACTIVITY",
            Self::SportRecord => "SPORT_RECORD",
            Self::Share => "SHARE",
            Self::TodoList => "TODO_LIST",
            Self::Phone => "PHONE",
            Self::LactateThreshold => "LACTATE_THRESHOLD",
            Self::Compass => "COMPASS",
            Self::Alipay => "ALIPAY",
            Self::Card => "CARD",
            Self::Door => "DOOR",
            Self::Bus => "BUS",
            Self::Bank => "BANK",
            Self::WechatPay => "WECHAT_PAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTING" => Some(Self::Setting),
            "FITNESS" => Some(Self::Fitness),
            "HEART_RATE" => Some(Self::HeartRate),
            "PRESSURE" => Some(Self::Pressure),
            "ENERGY" => Some(Self::Energy),
            "SLEEP" => Some(Self::Sleep),
            "BREATH" => Some(Self::Breath),
            "ANAEROBIC_THRESHOLD" => Some(Self::AnaerobicThreshold),
            "CALENDAR" => Some(Self::Calendar),
            "CLOCK" => Some(Self::Clock),
            "STOPWATCH" => Some(Self::Stopwatch),
            "TIME_KEEPING" => Some(Self::TimeKeeping),
            "WEATHER" => Some(Self::Weather),
            "STOCK" => Some(Self::Stock),
            "APP_LIST" => Some(Self::AppList),
            "SPORT_LIST" => Some(Self::SportList),
            "HOME" => Some(Self::Home),
            "MUSIC_CONTROLLER" => Some(Self::MusicController),
            "VOICE_ASSISTANT" => Some(Self::VoiceAssistant),
            "BLOOD_OXYGEN" => Some(Self::BloodOxygen),
            "CONTROL_CENTER" => Some(Self::ControlCenter),
            "WOMEN_HEALTH" => Some(Self::WomenHealth),
            "SYSTEM" => Some(Self::System),
            "TEMPERATURE" => Some(Self::Temperature),
            "BLOOD_PRESSURE" => Some(Self::BloodPressure),
            "ECG" => Some(Self::Ecg),
            "EVENT" => Some(Self::Event),
            "MIHOME" => Some(Self::Mihome),
            "ACTIVITY" => Some(Self::Activity),
            "SPORT_RECORD" => Some(Self::SportRecord),
            "SHARE" => Some(Self::Share),
            "TODO_LIST" => Some(Self::TodoList),
            "PHONE" => Some(Self::Phone),
            "LACTATE_THRESHOLD" => Some(Self::LactateThreshold),
            "COMPASS" => Some(Self::Compass),
            "ALIPAY" => Some(Self::Alipay),
            "CARD" => Some(Self::Card),
            "DOOR" => Some(Self::Door),
            "BUS" => Some(Self::Bus),
            "BANK" => Some(Self::Bank),
            "WECHAT_PAY" => Some(Self::WechatPay),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WidgetStyle {
    Style11 = 1,
    Style12 = 2,
    Style21 = 3,
    Style22 = 4,
    StyleSquare = 8,
    StyleRect = 9,
    StyleCircle = 10,
}
impl WidgetStyle {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Style11 => "STYLE_11",
            Self::Style12 => "STYLE_12",
            Self::Style21 => "STYLE_21",
            Self::Style22 => "STYLE_22",
            Self::StyleSquare => "STYLE_SQUARE",
            Self::StyleRect => "STYLE_RECT",
            Self::StyleCircle => "STYLE_CIRCLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STYLE_11" => Some(Self::Style11),
            "STYLE_12" => Some(Self::Style12),
            "STYLE_21" => Some(Self::Style21),
            "STYLE_22" => Some(Self::Style22),
            "STYLE_SQUARE" => Some(Self::StyleSquare),
            "STYLE_RECT" => Some(Self::StyleRect),
            "STYLE_CIRCLE" => Some(Self::StyleCircle),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WidgetSubType {
    SystemDarkStyle11Battery = 17,
    SystemDarkStyle11Flashlight = 18,
    SystemDarkStyle21Control = 19,
    AppListDarkStyle11Entry = 1041,
    SportListDarkStyle11Start = 2065,
    SportListDarkStyle12Start = 2081,
    SportListLightStyle11Start = 2321,
    SportListLightStyle12Start = 2337,
    FitnessDarkStyle11Vitality = 3089,
    FitnessDarkStyle11Step = 3090,
    FitnessDarkStyle11Calorie = 3091,
    FitnessDarkStyle11Stand = 3092,
    FitnessDarkStyle11Activity = 3093,
    FitnessDarkStyle12Vitality = 3105,
    FitnessDarkStyle12Step = 3106,
    FitnessDarkStyle12Calorie = 3107,
    FitnessDarkStyle12Stand = 3108,
    FitnessDarkStyle12Activity = 3109,
    FitnessDarkStyle21Vitality = 3121,
    FitnessDarkStyle22Vitality = 3137,
    FitnessLightStyle11Step = 3346,
    FitnessLightStyle11Calorie = 3347,
    FitnessLightStyle11Stand = 3348,
    FitnessLightStyle11Activity = 3349,
    FitnessLightStyle12Step = 3362,
    FitnessLightStyle12Calorie = 3363,
    FitnessLightStyle12Stand = 3364,
    FitnessLightStyle12Activity = 3365,
    FitnessDarkSquareVitality = 3201,
    FitnessDarkRectVitality = 3217,
    FitnessDarkRectStep = 3218,
    FitnessDarkRectCalorie = 3219,
    FitnessDarkRectStand = 3220,
    FitnessDarkRectActivity = 3221,
    FitnessLightRectStand = 3476,
    HeartRateDarkStyle11Current = 4113,
    HeartRateDarkStyle12Splash = 4130,
    HeartRateDarkStyle12Line = 4131,
    HeartRateDarkStyle21Current = 4145,
    HeartRateDarkStyle22Splash = 4162,
    HeartRateDarkStyle32Current = 4177,
    HeartRateLightStyle11Current = 4369,
    HeartRateLightStyle12Splash = 4386,
    HeartRateLightStyle12Line = 4387,
    HeartRateLightStyle22Splash = 4418,
    HeartRateDarkRectSplash = 4242,
    HeartRateLightRectSplash = 4498,
    BreathDarkStyle11Entry = 5137,
    BreathDarkStyle12Entry = 5153,
    BreathDarkStyle21Entry = 5169,
    BreathLightStyle11Entry = 5393,
    BreathLightStyle12Entry = 5409,
    PressureDarkStyle11Current = 6161,
    PressureDarkStyle12Splash = 6178,
    PressureDarkStyle21Current = 6193,
    PressureDarkStyle22Current = 6209,
    PressureDarkStyle32Current = 6225,
    PressureLightStyle11Current = 6417,
    PressureLightStyle12Splash = 6434,
    PressureDarkRectSplash = 6290,
    PressureDarkRectLine = 6291,
    BloodOxygenDarkStyle11Current = 7185,
    BloodOxygenDarkStyle12Splash = 7202,
    BloodOxygenDarkStyle21Current = 7217,
    BloodOxygenDarkStyle22Splash = 7234,
    BloodOxygenDarkStyle32Current = 7249,
    BloodOxygenLightStyle11Current = 7441,
    BloodOxygenLightStyle12Splash = 7458,
    BloodOxygenLightStyle22Splash = 7490,
    BloodOxygenDarkRectSplash = 7314,
    SleepDarkStyle11Result = 8209,
    SleepDarkStyle12Result = 8225,
    SleepDarkStyle21Result = 8241,
    SleepDarkStyle22Result = 8257,
    SleepDarkStyle32Result = 8273,
    SleepLightStyle11Result = 8465,
    SleepLightStyle12Result = 8481,
    SleepLightStyle22Result = 8513,
    SleepDarkRectResult = 8337,
    SleepDarkRectLong = 8338,
    SleepDarkRectStructure = 8339,
    WomenHealthDarkStyle12Days = 9249,
    WomenHealthDarkStyle21Data = 9266,
    WomenHealthDarkStyle22Days = 9281,
    WomenHealthDarkStyle32Days = 9297,
    WomenHealthLightStyle12Days = 9505,
    WeatherDarkStyle11Basic = 10257,
    WeatherDarkStyle12Basic = 10273,
    WeatherDarkStyle21Basic = 10289,
    WeatherDarkStyle22Basic = 10305,
    WeatherDarkStyle22Hourly = 10306,
    WeatherLightStyle11Basic = 10513,
    WeatherLightStyle12Basic = 10529,
    WeatherDarkRectWeek = 10386,
    WeatherLightRectWeek = 10642,
    WeatherDarkRectHourly = 10387,
    WeatherLightRectHourly = 10643,
    WeatherDarkRectSun = 10388,
    WeatherLightRectSun = 10644,
    WeatherDarkRectHourly2 = 10389,
    WeatherDarkRectHourly3 = 10390,
    WeatherDarkRectHourly4 = 10391,
    VoiceAssistantDarkStyle21Xiaoai = 11313,
    VoiceAssistantDarkStyle21Alexa = 11314,
    VoiceAssistantDarkStyle22Xiaoai = 11329,
    VoiceAssistantDarkStyle22Alexa = 11330,
    VoiceAssistantDarkStyle32Xiaoai = 11345,
    VoiceAssistantDarkStyle32Alexa = 11346,
    AlipayDarkStyle11Entry = 12305,
    AlipayDarkStyle21Code = 12338,
    AlipayDarkStyle22Code = 12354,
    AlipayDarkStyle32Code = 12370,
    AlipayLightStyle11Entry = 12561,
    AlipayLightStyle21Code = 12594,
    AlipayLightStyle22Code = 12610,
    AlipayLightStyle32Code = 12626,
    WechatPayDarkStyle11Entry = 13329,
    WechatPayDarkStyle21Code = 13362,
    WechatPayDarkStyle22Code = 13378,
    WechatPayDarkStyle32Code = 13394,
    WechatPayLightStyle11Entry = 13585,
    WechatPayLightStyle21Code = 13618,
    WechatPayLightStyle22Code = 13634,
    WechatPayLightStyle32Code = 13650,
    MusicDarkStyle11Control = 14353,
    MusicDarkStyle12Control = 14369,
    MusicDarkStyle21Control = 14385,
    MusicDarkStyle22Control = 14401,
    MusicLightStyle11Control = 14609,
    MusicLightStyle12Control = 14625,
    MusicLightStyle22Control = 14657,
    CardDarkStyle21SwitchCard = 15409,
    CardDarkStyle22SwitchCard = 15425,
    CardDarkStyle32SwitchCard = 15441,
    StopwatchDarkStyle11Entry = 16401,
    StopwatchDarkStyle12Control = 16418,
    StopwatchLightStyle11Entry = 16657,
    StopwatchLightStyle12Control = 16674,
    TimeKeepingDarkStyle11Entry = 17425,
    TimeKeepingDarkStyle12Control = 17442,
    TimeKeepingLightStyle11Entry = 17681,
    TimeKeepingLightStyle12Control = 17698,
    TimeKeepingDarkSquareEntry = 17537,
    CalendarDarkStyle11Entry = 18450,
    CalendarDarkStyle12Next = 18465,
    CalendarDarkStyle21Next = 18481,
    CalendarDarkStyle22Next = 18497,
    CalendarLightStyle11Entry = 18706,
    CalendarDarkRectNext = 18577,
    CalendarLightRectNext = 18833,
    CalendarDarkCircleDay = 18594,
    CalendarLightSquareNext = 18817,
    TemperatureDarkStyle11Entry = 19473,
    TemperatureLightStyle11Entry = 19729,
    BloodPressureDarkStyle11Entry = 20497,
    BloodPressureDarkStyle12Recent = 20514,
    BloodPressureLightStyle11Entry = 20753,
    BloodPressureLightStyle12Recent = 20770,
    EcgDarkStyle11Entry = 21521,
    EcgDarkStyle12Recent = 21538,
    EcgLightStyle11Entry = 21777,
    EcgLightStyle12Recent = 21794,
    EventDarkStyle12Next = 22561,
    EventDarkStyle21Next = 22577,
    MihomeDarkStyle11Entry = 23569,
    MihomeLightStyle11Entry = 23825,
    ActivityDarkStyle11Current = 24593,
    ActivityDarkStyle12Current = 24609,
    ActivityDarkStyle21Current = 24625,
    ActivityDarkStyle22Current = 24641,
    ActivityDarkStyle32Current = 24657,
    ActivityLightStyle11Current = 24849,
    ActivityLightStyle12Current = 24865,
    ActivityLightStyle21Current = 24881,
    ActivityLightStyle22Current = 24897,
    ActivityLightStyle32Current = 24913,
    ClockDarkStyle11Entry = 25617,
    ClockLightStyle11Entry = 25873,
    ShareDarkStyle11Entry = 26641,
    ShareDarkStyle12Entry = 26657,
    TodoListDarkStyle11Entry = 27665,
    TodoListDarkStyle12Next = 27682,
    TodoListDarkStyle21Next = 27698,
    TodoListLightStyle11Entry = 27921,
    PhoneDarkStyle11Entry = 28689,
    PhoneLightStyle11Entry = 28945,
    LactateThresholdDarkStyle11Entry = 29713,
    LactateThresholdLightStyle11Entry = 29969,
    CompassDarkStyle11Entry = 30737,
    CompassLightStyle11Entry = 30993,
}
impl WidgetSubType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SystemDarkStyle11Battery => "SYSTEM_DARK_STYLE11_BATTERY",
            Self::SystemDarkStyle11Flashlight => "SYSTEM_DARK_STYLE11_FLASHLIGHT",
            Self::SystemDarkStyle21Control => "SYSTEM_DARK_STYLE21_CONTROL",
            Self::AppListDarkStyle11Entry => "APP_LIST_DARK_STYLE11_ENTRY",
            Self::SportListDarkStyle11Start => "SPORT_LIST_DARK_STYLE11_START",
            Self::SportListDarkStyle12Start => "SPORT_LIST_DARK_STYLE12_START",
            Self::SportListLightStyle11Start => "SPORT_LIST_LIGHT_STYLE11_START",
            Self::SportListLightStyle12Start => "SPORT_LIST_LIGHT_STYLE12_START",
            Self::FitnessDarkStyle11Vitality => "FITNESS_DARK_STYLE11_VITALITY",
            Self::FitnessDarkStyle11Step => "FITNESS_DARK_STYLE11_STEP",
            Self::FitnessDarkStyle11Calorie => "FITNESS_DARK_STYLE11_CALORIE",
            Self::FitnessDarkStyle11Stand => "FITNESS_DARK_STYLE11_STAND",
            Self::FitnessDarkStyle11Activity => "FITNESS_DARK_STYLE11_ACTIVITY",
            Self::FitnessDarkStyle12Vitality => "FITNESS_DARK_STYLE12_VITALITY",
            Self::FitnessDarkStyle12Step => "FITNESS_DARK_STYLE12_STEP",
            Self::FitnessDarkStyle12Calorie => "FITNESS_DARK_STYLE12_CALORIE",
            Self::FitnessDarkStyle12Stand => "FITNESS_DARK_STYLE12_STAND",
            Self::FitnessDarkStyle12Activity => "FITNESS_DARK_STYLE12_ACTIVITY",
            Self::FitnessDarkStyle21Vitality => "FITNESS_DARK_STYLE21_VITALITY",
            Self::FitnessDarkStyle22Vitality => "FITNESS_DARK_STYLE22_VITALITY",
            Self::FitnessLightStyle11Step => "FITNESS_LIGHT_STYLE11_STEP",
            Self::FitnessLightStyle11Calorie => "FITNESS_LIGHT_STYLE11_CALORIE",
            Self::FitnessLightStyle11Stand => "FITNESS_LIGHT_STYLE11_STAND",
            Self::FitnessLightStyle11Activity => "FITNESS_LIGHT_STYLE11_ACTIVITY",
            Self::FitnessLightStyle12Step => "FITNESS_LIGHT_STYLE12_STEP",
            Self::FitnessLightStyle12Calorie => "FITNESS_LIGHT_STYLE12_CALORIE",
            Self::FitnessLightStyle12Stand => "FITNESS_LIGHT_STYLE12_STAND",
            Self::FitnessLightStyle12Activity => "FITNESS_LIGHT_STYLE12_ACTIVITY",
            Self::FitnessDarkSquareVitality => "FITNESS_DARK_SQUARE_VITALITY",
            Self::FitnessDarkRectVitality => "FITNESS_DARK_RECT_VITALITY",
            Self::FitnessDarkRectStep => "FITNESS_DARK_RECT_STEP",
            Self::FitnessDarkRectCalorie => "FITNESS_DARK_RECT_CALORIE",
            Self::FitnessDarkRectStand => "FITNESS_DARK_RECT_STAND",
            Self::FitnessDarkRectActivity => "FITNESS_DARK_RECT_ACTIVITY",
            Self::FitnessLightRectStand => "FITNESS_LIGHT_RECT_STAND",
            Self::HeartRateDarkStyle11Current => "HEART_RATE_DARK_STYLE11_CURRENT",
            Self::HeartRateDarkStyle12Splash => "HEART_RATE_DARK_STYLE12_SPLASH",
            Self::HeartRateDarkStyle12Line => "HEART_RATE_DARK_STYLE12_LINE",
            Self::HeartRateDarkStyle21Current => "HEART_RATE_DARK_STYLE21_CURRENT",
            Self::HeartRateDarkStyle22Splash => "HEART_RATE_DARK_STYLE22_SPLASH",
            Self::HeartRateDarkStyle32Current => "HEART_RATE_DARK_STYLE32_CURRENT",
            Self::HeartRateLightStyle11Current => "HEART_RATE_LIGHT_STYLE11_CURRENT",
            Self::HeartRateLightStyle12Splash => "HEART_RATE_LIGHT_STYLE12_SPLASH",
            Self::HeartRateLightStyle12Line => "HEART_RATE_LIGHT_STYLE12_LINE",
            Self::HeartRateLightStyle22Splash => "HEART_RATE_LIGHT_STYLE22_SPLASH",
            Self::HeartRateDarkRectSplash => "HEART_RATE_DARK_RECT_SPLASH",
            Self::HeartRateLightRectSplash => "HEART_RATE_LIGHT_RECT_SPLASH",
            Self::BreathDarkStyle11Entry => "BREATH_DARK_STYLE11_ENTRY",
            Self::BreathDarkStyle12Entry => "BREATH_DARK_STYLE12_ENTRY",
            Self::BreathDarkStyle21Entry => "BREATH_DARK_STYLE21_ENTRY",
            Self::BreathLightStyle11Entry => "BREATH_LIGHT_STYLE11_ENTRY",
            Self::BreathLightStyle12Entry => "BREATH_LIGHT_STYLE12_ENTRY",
            Self::PressureDarkStyle11Current => "PRESSURE_DARK_STYLE11_CURRENT",
            Self::PressureDarkStyle12Splash => "PRESSURE_DARK_STYLE12_SPLASH",
            Self::PressureDarkStyle21Current => "PRESSURE_DARK_STYLE21_CURRENT",
            Self::PressureDarkStyle22Current => "PRESSURE_DARK_STYLE22_CURRENT",
            Self::PressureDarkStyle32Current => "PRESSURE_DARK_STYLE32_CURRENT",
            Self::PressureLightStyle11Current => "PRESSURE_LIGHT_STYLE11_CURRENT",
            Self::PressureLightStyle12Splash => "PRESSURE_LIGHT_STYLE12_SPLASH",
            Self::PressureDarkRectSplash => "PRESSURE_DARK_RECT_SPLASH",
            Self::PressureDarkRectLine => "PRESSURE_DARK_RECT_LINE",
            Self::BloodOxygenDarkStyle11Current => "BLOOD_OXYGEN_DARK_STYLE11_CURRENT",
            Self::BloodOxygenDarkStyle12Splash => "BLOOD_OXYGEN_DARK_STYLE12_SPLASH",
            Self::BloodOxygenDarkStyle21Current => "BLOOD_OXYGEN_DARK_STYLE21_CURRENT",
            Self::BloodOxygenDarkStyle22Splash => "BLOOD_OXYGEN_DARK_STYLE22_SPLASH",
            Self::BloodOxygenDarkStyle32Current => "BLOOD_OXYGEN_DARK_STYLE32_CURRENT",
            Self::BloodOxygenLightStyle11Current => "BLOOD_OXYGEN_LIGHT_STYLE11_CURRENT",
            Self::BloodOxygenLightStyle12Splash => "BLOOD_OXYGEN_LIGHT_STYLE12_SPLASH",
            Self::BloodOxygenLightStyle22Splash => "BLOOD_OXYGEN_LIGHT_STYLE22_SPLASH",
            Self::BloodOxygenDarkRectSplash => "BLOOD_OXYGEN_DARK_RECT_SPLASH",
            Self::SleepDarkStyle11Result => "SLEEP_DARK_STYLE11_RESULT",
            Self::SleepDarkStyle12Result => "SLEEP_DARK_STYLE12_RESULT",
            Self::SleepDarkStyle21Result => "SLEEP_DARK_STYLE21_RESULT",
            Self::SleepDarkStyle22Result => "SLEEP_DARK_STYLE22_RESULT",
            Self::SleepDarkStyle32Result => "SLEEP_DARK_STYLE32_RESULT",
            Self::SleepLightStyle11Result => "SLEEP_LIGHT_STYLE11_RESULT",
            Self::SleepLightStyle12Result => "SLEEP_LIGHT_STYLE12_RESULT",
            Self::SleepLightStyle22Result => "SLEEP_LIGHT_STYLE22_RESULT",
            Self::SleepDarkRectResult => "SLEEP_DARK_RECT_RESULT",
            Self::SleepDarkRectLong => "SLEEP_DARK_RECT_LONG",
            Self::SleepDarkRectStructure => "SLEEP_DARK_RECT_STRUCTURE",
            Self::WomenHealthDarkStyle12Days => "WOMEN_HEALTH_DARK_STYLE12_DAYS",
            Self::WomenHealthDarkStyle21Data => "WOMEN_HEALTH_DARK_STYLE21_DATA",
            Self::WomenHealthDarkStyle22Days => "WOMEN_HEALTH_DARK_STYLE22_DAYS",
            Self::WomenHealthDarkStyle32Days => "WOMEN_HEALTH_DARK_STYLE32_DAYS",
            Self::WomenHealthLightStyle12Days => "WOMEN_HEALTH_LIGHT_STYLE12_DAYS",
            Self::WeatherDarkStyle11Basic => "WEATHER_DARK_STYLE11_BASIC",
            Self::WeatherDarkStyle12Basic => "WEATHER_DARK_STYLE12_BASIC",
            Self::WeatherDarkStyle21Basic => "WEATHER_DARK_STYLE21_BASIC",
            Self::WeatherDarkStyle22Basic => "WEATHER_DARK_STYLE22_BASIC",
            Self::WeatherDarkStyle22Hourly => "WEATHER_DARK_STYLE22_HOURLY",
            Self::WeatherLightStyle11Basic => "WEATHER_LIGHT_STYLE11_BASIC",
            Self::WeatherLightStyle12Basic => "WEATHER_LIGHT_STYLE12_BASIC",
            Self::WeatherDarkRectWeek => "WEATHER_DARK_RECT_WEEK",
            Self::WeatherLightRectWeek => "WEATHER_LIGHT_RECT_WEEK",
            Self::WeatherDarkRectHourly => "WEATHER_DARK_RECT_HOURLY",
            Self::WeatherLightRectHourly => "WEATHER_LIGHT_RECT_HOURLY",
            Self::WeatherDarkRectSun => "WEATHER_DARK_RECT_SUN",
            Self::WeatherLightRectSun => "WEATHER_LIGHT_RECT_SUN",
            Self::WeatherDarkRectHourly2 => "WEATHER_DARK_RECT_HOURLY_2",
            Self::WeatherDarkRectHourly3 => "WEATHER_DARK_RECT_HOURLY_3",
            Self::WeatherDarkRectHourly4 => "WEATHER_DARK_RECT_HOURLY_4",
            Self::VoiceAssistantDarkStyle21Xiaoai => {
                "VOICE_ASSISTANT_DARK_STYLE21_XIAOAI"
            }
            Self::VoiceAssistantDarkStyle21Alexa => "VOICE_ASSISTANT_DARK_STYLE21_ALEXA",
            Self::VoiceAssistantDarkStyle22Xiaoai => {
                "VOICE_ASSISTANT_DARK_STYLE22_XIAOAI"
            }
            Self::VoiceAssistantDarkStyle22Alexa => "VOICE_ASSISTANT_DARK_STYLE22_ALEXA",
            Self::VoiceAssistantDarkStyle32Xiaoai => {
                "VOICE_ASSISTANT_DARK_STYLE32_XIAOAI"
            }
            Self::VoiceAssistantDarkStyle32Alexa => "VOICE_ASSISTANT_DARK_STYLE32_ALEXA",
            Self::AlipayDarkStyle11Entry => "ALIPAY_DARK_STYLE11_ENTRY",
            Self::AlipayDarkStyle21Code => "ALIPAY_DARK_STYLE21_CODE",
            Self::AlipayDarkStyle22Code => "ALIPAY_DARK_STYLE22_CODE",
            Self::AlipayDarkStyle32Code => "ALIPAY_DARK_STYLE32_CODE",
            Self::AlipayLightStyle11Entry => "ALIPAY_LIGHT_STYLE11_ENTRY",
            Self::AlipayLightStyle21Code => "ALIPAY_LIGHT_STYLE21_CODE",
            Self::AlipayLightStyle22Code => "ALIPAY_LIGHT_STYLE22_CODE",
            Self::AlipayLightStyle32Code => "ALIPAY_LIGHT_STYLE32_CODE",
            Self::WechatPayDarkStyle11Entry => "WECHAT_PAY_DARK_STYLE11_ENTRY",
            Self::WechatPayDarkStyle21Code => "WECHAT_PAY_DARK_STYLE21_CODE",
            Self::WechatPayDarkStyle22Code => "WECHAT_PAY_DARK_STYLE22_CODE",
            Self::WechatPayDarkStyle32Code => "WECHAT_PAY_DARK_STYLE32_CODE",
            Self::WechatPayLightStyle11Entry => "WECHAT_PAY_LIGHT_STYLE11_ENTRY",
            Self::WechatPayLightStyle21Code => "WECHAT_PAY_LIGHT_STYLE21_CODE",
            Self::WechatPayLightStyle22Code => "WECHAT_PAY_LIGHT_STYLE22_CODE",
            Self::WechatPayLightStyle32Code => "WECHAT_PAY_LIGHT_STYLE32_CODE",
            Self::MusicDarkStyle11Control => "MUSIC_DARK_STYLE11_CONTROL",
            Self::MusicDarkStyle12Control => "MUSIC_DARK_STYLE12_CONTROL",
            Self::MusicDarkStyle21Control => "MUSIC_DARK_STYLE21_CONTROL",
            Self::MusicDarkStyle22Control => "MUSIC_DARK_STYLE22_CONTROL",
            Self::MusicLightStyle11Control => "MUSIC_LIGHT_STYLE11_CONTROL",
            Self::MusicLightStyle12Control => "MUSIC_LIGHT_STYLE12_CONTROL",
            Self::MusicLightStyle22Control => "MUSIC_LIGHT_STYLE22_CONTROL",
            Self::CardDarkStyle21SwitchCard => "CARD_DARK_STYLE21_SWITCH_CARD",
            Self::CardDarkStyle22SwitchCard => "CARD_DARK_STYLE22_SWITCH_CARD",
            Self::CardDarkStyle32SwitchCard => "CARD_DARK_STYLE32_SWITCH_CARD",
            Self::StopwatchDarkStyle11Entry => "STOPWATCH_DARK_STYLE11_ENTRY",
            Self::StopwatchDarkStyle12Control => "STOPWATCH_DARK_STYLE12_CONTROL",
            Self::StopwatchLightStyle11Entry => "STOPWATCH_LIGHT_STYLE11_ENTRY",
            Self::StopwatchLightStyle12Control => "STOPWATCH_LIGHT_STYLE12_CONTROL",
            Self::TimeKeepingDarkStyle11Entry => "TIME_KEEPING_DARK_STYLE11_ENTRY",
            Self::TimeKeepingDarkStyle12Control => "TIME_KEEPING_DARK_STYLE12_CONTROL",
            Self::TimeKeepingLightStyle11Entry => "TIME_KEEPING_LIGHT_STYLE11_ENTRY",
            Self::TimeKeepingLightStyle12Control => "TIME_KEEPING_LIGHT_STYLE12_CONTROL",
            Self::TimeKeepingDarkSquareEntry => "TIME_KEEPING_DARK_SQUARE_ENTRY",
            Self::CalendarDarkStyle11Entry => "CALENDAR_DARK_STYLE11_ENTRY",
            Self::CalendarDarkStyle12Next => "CALENDAR_DARK_STYLE12_NEXT",
            Self::CalendarDarkStyle21Next => "CALENDAR_DARK_STYLE21_NEXT",
            Self::CalendarDarkStyle22Next => "CALENDAR_DARK_STYLE22_NEXT",
            Self::CalendarLightStyle11Entry => "CALENDAR_LIGHT_STYLE11_ENTRY",
            Self::CalendarDarkRectNext => "CALENDAR_DARK_RECT_NEXT",
            Self::CalendarLightRectNext => "CALENDAR_LIGHT_RECT_NEXT",
            Self::CalendarDarkCircleDay => "CALENDAR_DARK_CIRCLE_DAY",
            Self::CalendarLightSquareNext => "CALENDAR_LIGHT_SQUARE_NEXT",
            Self::TemperatureDarkStyle11Entry => "TEMPERATURE_DARK_STYLE11_ENTRY",
            Self::TemperatureLightStyle11Entry => "TEMPERATURE_LIGHT_STYLE11_ENTRY",
            Self::BloodPressureDarkStyle11Entry => "BLOOD_PRESSURE_DARK_STYLE11_ENTRY",
            Self::BloodPressureDarkStyle12Recent => "BLOOD_PRESSURE_DARK_STYLE12_RECENT",
            Self::BloodPressureLightStyle11Entry => "BLOOD_PRESSURE_LIGHT_STYLE11_ENTRY",
            Self::BloodPressureLightStyle12Recent => {
                "BLOOD_PRESSURE_LIGHT_STYLE12_RECENT"
            }
            Self::EcgDarkStyle11Entry => "ECG_DARK_STYLE11_ENTRY",
            Self::EcgDarkStyle12Recent => "ECG_DARK_STYLE12_RECENT",
            Self::EcgLightStyle11Entry => "ECG_LIGHT_STYLE11_ENTRY",
            Self::EcgLightStyle12Recent => "ECG_LIGHT_STYLE12_RECENT",
            Self::EventDarkStyle12Next => "EVENT_DARK_STYLE12_NEXT",
            Self::EventDarkStyle21Next => "EVENT_DARK_STYLE21_NEXT",
            Self::MihomeDarkStyle11Entry => "MIHOME_DARK_STYLE11_ENTRY",
            Self::MihomeLightStyle11Entry => "MIHOME_LIGHT_STYLE11_ENTRY",
            Self::ActivityDarkStyle11Current => "ACTIVITY_DARK_STYLE11_CURRENT",
            Self::ActivityDarkStyle12Current => "ACTIVITY_DARK_STYLE12_CURRENT",
            Self::ActivityDarkStyle21Current => "ACTIVITY_DARK_STYLE21_CURRENT",
            Self::ActivityDarkStyle22Current => "ACTIVITY_DARK_STYLE22_CURRENT",
            Self::ActivityDarkStyle32Current => "ACTIVITY_DARK_STYLE32_CURRENT",
            Self::ActivityLightStyle11Current => "ACTIVITY_LIGHT_STYLE11_CURRENT",
            Self::ActivityLightStyle12Current => "ACTIVITY_LIGHT_STYLE12_CURRENT",
            Self::ActivityLightStyle21Current => "ACTIVITY_LIGHT_STYLE21_CURRENT",
            Self::ActivityLightStyle22Current => "ACTIVITY_LIGHT_STYLE22_CURRENT",
            Self::ActivityLightStyle32Current => "ACTIVITY_LIGHT_STYLE32_CURRENT",
            Self::ClockDarkStyle11Entry => "CLOCK_DARK_STYLE11_ENTRY",
            Self::ClockLightStyle11Entry => "CLOCK_LIGHT_STYLE11_ENTRY",
            Self::ShareDarkStyle11Entry => "SHARE_DARK_STYLE11_ENTRY",
            Self::ShareDarkStyle12Entry => "SHARE_DARK_STYLE12_ENTRY",
            Self::TodoListDarkStyle11Entry => "TODO_LIST_DARK_STYLE11_ENTRY",
            Self::TodoListDarkStyle12Next => "TODO_LIST_DARK_STYLE12_NEXT",
            Self::TodoListDarkStyle21Next => "TODO_LIST_DARK_STYLE21_NEXT",
            Self::TodoListLightStyle11Entry => "TODO_LIST_LIGHT_STYLE11_ENTRY",
            Self::PhoneDarkStyle11Entry => "PHONE_DARK_STYLE11_ENTRY",
            Self::PhoneLightStyle11Entry => "PHONE_LIGHT_STYLE11_ENTRY",
            Self::LactateThresholdDarkStyle11Entry => {
                "LACTATE_THRESHOLD_DARK_STYLE11_ENTRY"
            }
            Self::LactateThresholdLightStyle11Entry => {
                "LACTATE_THRESHOLD_LIGHT_STYLE11_ENTRY"
            }
            Self::CompassDarkStyle11Entry => "COMPASS_DARK_STYLE11_ENTRY",
            Self::CompassLightStyle11Entry => "COMPASS_LIGHT_STYLE11_ENTRY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYSTEM_DARK_STYLE11_BATTERY" => Some(Self::SystemDarkStyle11Battery),
            "SYSTEM_DARK_STYLE11_FLASHLIGHT" => Some(Self::SystemDarkStyle11Flashlight),
            "SYSTEM_DARK_STYLE21_CONTROL" => Some(Self::SystemDarkStyle21Control),
            "APP_LIST_DARK_STYLE11_ENTRY" => Some(Self::AppListDarkStyle11Entry),
            "SPORT_LIST_DARK_STYLE11_START" => Some(Self::SportListDarkStyle11Start),
            "SPORT_LIST_DARK_STYLE12_START" => Some(Self::SportListDarkStyle12Start),
            "SPORT_LIST_LIGHT_STYLE11_START" => Some(Self::SportListLightStyle11Start),
            "SPORT_LIST_LIGHT_STYLE12_START" => Some(Self::SportListLightStyle12Start),
            "FITNESS_DARK_STYLE11_VITALITY" => Some(Self::FitnessDarkStyle11Vitality),
            "FITNESS_DARK_STYLE11_STEP" => Some(Self::FitnessDarkStyle11Step),
            "FITNESS_DARK_STYLE11_CALORIE" => Some(Self::FitnessDarkStyle11Calorie),
            "FITNESS_DARK_STYLE11_STAND" => Some(Self::FitnessDarkStyle11Stand),
            "FITNESS_DARK_STYLE11_ACTIVITY" => Some(Self::FitnessDarkStyle11Activity),
            "FITNESS_DARK_STYLE12_VITALITY" => Some(Self::FitnessDarkStyle12Vitality),
            "FITNESS_DARK_STYLE12_STEP" => Some(Self::FitnessDarkStyle12Step),
            "FITNESS_DARK_STYLE12_CALORIE" => Some(Self::FitnessDarkStyle12Calorie),
            "FITNESS_DARK_STYLE12_STAND" => Some(Self::FitnessDarkStyle12Stand),
            "FITNESS_DARK_STYLE12_ACTIVITY" => Some(Self::FitnessDarkStyle12Activity),
            "FITNESS_DARK_STYLE21_VITALITY" => Some(Self::FitnessDarkStyle21Vitality),
            "FITNESS_DARK_STYLE22_VITALITY" => Some(Self::FitnessDarkStyle22Vitality),
            "FITNESS_LIGHT_STYLE11_STEP" => Some(Self::FitnessLightStyle11Step),
            "FITNESS_LIGHT_STYLE11_CALORIE" => Some(Self::FitnessLightStyle11Calorie),
            "FITNESS_LIGHT_STYLE11_STAND" => Some(Self::FitnessLightStyle11Stand),
            "FITNESS_LIGHT_STYLE11_ACTIVITY" => Some(Self::FitnessLightStyle11Activity),
            "FITNESS_LIGHT_STYLE12_STEP" => Some(Self::FitnessLightStyle12Step),
            "FITNESS_LIGHT_STYLE12_CALORIE" => Some(Self::FitnessLightStyle12Calorie),
            "FITNESS_LIGHT_STYLE12_STAND" => Some(Self::FitnessLightStyle12Stand),
            "FITNESS_LIGHT_STYLE12_ACTIVITY" => Some(Self::FitnessLightStyle12Activity),
            "FITNESS_DARK_SQUARE_VITALITY" => Some(Self::FitnessDarkSquareVitality),
            "FITNESS_DARK_RECT_VITALITY" => Some(Self::FitnessDarkRectVitality),
            "FITNESS_DARK_RECT_STEP" => Some(Self::FitnessDarkRectStep),
            "FITNESS_DARK_RECT_CALORIE" => Some(Self::FitnessDarkRectCalorie),
            "FITNESS_DARK_RECT_STAND" => Some(Self::FitnessDarkRectStand),
            "FITNESS_DARK_RECT_ACTIVITY" => Some(Self::FitnessDarkRectActivity),
            "FITNESS_LIGHT_RECT_STAND" => Some(Self::FitnessLightRectStand),
            "HEART_RATE_DARK_STYLE11_CURRENT" => Some(Self::HeartRateDarkStyle11Current),
            "HEART_RATE_DARK_STYLE12_SPLASH" => Some(Self::HeartRateDarkStyle12Splash),
            "HEART_RATE_DARK_STYLE12_LINE" => Some(Self::HeartRateDarkStyle12Line),
            "HEART_RATE_DARK_STYLE21_CURRENT" => Some(Self::HeartRateDarkStyle21Current),
            "HEART_RATE_DARK_STYLE22_SPLASH" => Some(Self::HeartRateDarkStyle22Splash),
            "HEART_RATE_DARK_STYLE32_CURRENT" => Some(Self::HeartRateDarkStyle32Current),
            "HEART_RATE_LIGHT_STYLE11_CURRENT" => {
                Some(Self::HeartRateLightStyle11Current)
            }
            "HEART_RATE_LIGHT_STYLE12_SPLASH" => Some(Self::HeartRateLightStyle12Splash),
            "HEART_RATE_LIGHT_STYLE12_LINE" => Some(Self::HeartRateLightStyle12Line),
            "HEART_RATE_LIGHT_STYLE22_SPLASH" => Some(Self::HeartRateLightStyle22Splash),
            "HEART_RATE_DARK_RECT_SPLASH" => Some(Self::HeartRateDarkRectSplash),
            "HEART_RATE_LIGHT_RECT_SPLASH" => Some(Self::HeartRateLightRectSplash),
            "BREATH_DARK_STYLE11_ENTRY" => Some(Self::BreathDarkStyle11Entry),
            "BREATH_DARK_STYLE12_ENTRY" => Some(Self::BreathDarkStyle12Entry),
            "BREATH_DARK_STYLE21_ENTRY" => Some(Self::BreathDarkStyle21Entry),
            "BREATH_LIGHT_STYLE11_ENTRY" => Some(Self::BreathLightStyle11Entry),
            "BREATH_LIGHT_STYLE12_ENTRY" => Some(Self::BreathLightStyle12Entry),
            "PRESSURE_DARK_STYLE11_CURRENT" => Some(Self::PressureDarkStyle11Current),
            "PRESSURE_DARK_STYLE12_SPLASH" => Some(Self::PressureDarkStyle12Splash),
            "PRESSURE_DARK_STYLE21_CURRENT" => Some(Self::PressureDarkStyle21Current),
            "PRESSURE_DARK_STYLE22_CURRENT" => Some(Self::PressureDarkStyle22Current),
            "PRESSURE_DARK_STYLE32_CURRENT" => Some(Self::PressureDarkStyle32Current),
            "PRESSURE_LIGHT_STYLE11_CURRENT" => Some(Self::PressureLightStyle11Current),
            "PRESSURE_LIGHT_STYLE12_SPLASH" => Some(Self::PressureLightStyle12Splash),
            "PRESSURE_DARK_RECT_SPLASH" => Some(Self::PressureDarkRectSplash),
            "PRESSURE_DARK_RECT_LINE" => Some(Self::PressureDarkRectLine),
            "BLOOD_OXYGEN_DARK_STYLE11_CURRENT" => {
                Some(Self::BloodOxygenDarkStyle11Current)
            }
            "BLOOD_OXYGEN_DARK_STYLE12_SPLASH" => {
                Some(Self::BloodOxygenDarkStyle12Splash)
            }
            "BLOOD_OXYGEN_DARK_STYLE21_CURRENT" => {
                Some(Self::BloodOxygenDarkStyle21Current)
            }
            "BLOOD_OXYGEN_DARK_STYLE22_SPLASH" => {
                Some(Self::BloodOxygenDarkStyle22Splash)
            }
            "BLOOD_OXYGEN_DARK_STYLE32_CURRENT" => {
                Some(Self::BloodOxygenDarkStyle32Current)
            }
            "BLOOD_OXYGEN_LIGHT_STYLE11_CURRENT" => {
                Some(Self::BloodOxygenLightStyle11Current)
            }
            "BLOOD_OXYGEN_LIGHT_STYLE12_SPLASH" => {
                Some(Self::BloodOxygenLightStyle12Splash)
            }
            "BLOOD_OXYGEN_LIGHT_STYLE22_SPLASH" => {
                Some(Self::BloodOxygenLightStyle22Splash)
            }
            "BLOOD_OXYGEN_DARK_RECT_SPLASH" => Some(Self::BloodOxygenDarkRectSplash),
            "SLEEP_DARK_STYLE11_RESULT" => Some(Self::SleepDarkStyle11Result),
            "SLEEP_DARK_STYLE12_RESULT" => Some(Self::SleepDarkStyle12Result),
            "SLEEP_DARK_STYLE21_RESULT" => Some(Self::SleepDarkStyle21Result),
            "SLEEP_DARK_STYLE22_RESULT" => Some(Self::SleepDarkStyle22Result),
            "SLEEP_DARK_STYLE32_RESULT" => Some(Self::SleepDarkStyle32Result),
            "SLEEP_LIGHT_STYLE11_RESULT" => Some(Self::SleepLightStyle11Result),
            "SLEEP_LIGHT_STYLE12_RESULT" => Some(Self::SleepLightStyle12Result),
            "SLEEP_LIGHT_STYLE22_RESULT" => Some(Self::SleepLightStyle22Result),
            "SLEEP_DARK_RECT_RESULT" => Some(Self::SleepDarkRectResult),
            "SLEEP_DARK_RECT_LONG" => Some(Self::SleepDarkRectLong),
            "SLEEP_DARK_RECT_STRUCTURE" => Some(Self::SleepDarkRectStructure),
            "WOMEN_HEALTH_DARK_STYLE12_DAYS" => Some(Self::WomenHealthDarkStyle12Days),
            "WOMEN_HEALTH_DARK_STYLE21_DATA" => Some(Self::WomenHealthDarkStyle21Data),
            "WOMEN_HEALTH_DARK_STYLE22_DAYS" => Some(Self::WomenHealthDarkStyle22Days),
            "WOMEN_HEALTH_DARK_STYLE32_DAYS" => Some(Self::WomenHealthDarkStyle32Days),
            "WOMEN_HEALTH_LIGHT_STYLE12_DAYS" => Some(Self::WomenHealthLightStyle12Days),
            "WEATHER_DARK_STYLE11_BASIC" => Some(Self::WeatherDarkStyle11Basic),
            "WEATHER_DARK_STYLE12_BASIC" => Some(Self::WeatherDarkStyle12Basic),
            "WEATHER_DARK_STYLE21_BASIC" => Some(Self::WeatherDarkStyle21Basic),
            "WEATHER_DARK_STYLE22_BASIC" => Some(Self::WeatherDarkStyle22Basic),
            "WEATHER_DARK_STYLE22_HOURLY" => Some(Self::WeatherDarkStyle22Hourly),
            "WEATHER_LIGHT_STYLE11_BASIC" => Some(Self::WeatherLightStyle11Basic),
            "WEATHER_LIGHT_STYLE12_BASIC" => Some(Self::WeatherLightStyle12Basic),
            "WEATHER_DARK_RECT_WEEK" => Some(Self::WeatherDarkRectWeek),
            "WEATHER_LIGHT_RECT_WEEK" => Some(Self::WeatherLightRectWeek),
            "WEATHER_DARK_RECT_HOURLY" => Some(Self::WeatherDarkRectHourly),
            "WEATHER_LIGHT_RECT_HOURLY" => Some(Self::WeatherLightRectHourly),
            "WEATHER_DARK_RECT_SUN" => Some(Self::WeatherDarkRectSun),
            "WEATHER_LIGHT_RECT_SUN" => Some(Self::WeatherLightRectSun),
            "WEATHER_DARK_RECT_HOURLY_2" => Some(Self::WeatherDarkRectHourly2),
            "WEATHER_DARK_RECT_HOURLY_3" => Some(Self::WeatherDarkRectHourly3),
            "WEATHER_DARK_RECT_HOURLY_4" => Some(Self::WeatherDarkRectHourly4),
            "VOICE_ASSISTANT_DARK_STYLE21_XIAOAI" => {
                Some(Self::VoiceAssistantDarkStyle21Xiaoai)
            }
            "VOICE_ASSISTANT_DARK_STYLE21_ALEXA" => {
                Some(Self::VoiceAssistantDarkStyle21Alexa)
            }
            "VOICE_ASSISTANT_DARK_STYLE22_XIAOAI" => {
                Some(Self::VoiceAssistantDarkStyle22Xiaoai)
            }
            "VOICE_ASSISTANT_DARK_STYLE22_ALEXA" => {
                Some(Self::VoiceAssistantDarkStyle22Alexa)
            }
            "VOICE_ASSISTANT_DARK_STYLE32_XIAOAI" => {
                Some(Self::VoiceAssistantDarkStyle32Xiaoai)
            }
            "VOICE_ASSISTANT_DARK_STYLE32_ALEXA" => {
                Some(Self::VoiceAssistantDarkStyle32Alexa)
            }
            "ALIPAY_DARK_STYLE11_ENTRY" => Some(Self::AlipayDarkStyle11Entry),
            "ALIPAY_DARK_STYLE21_CODE" => Some(Self::AlipayDarkStyle21Code),
            "ALIPAY_DARK_STYLE22_CODE" => Some(Self::AlipayDarkStyle22Code),
            "ALIPAY_DARK_STYLE32_CODE" => Some(Self::AlipayDarkStyle32Code),
            "ALIPAY_LIGHT_STYLE11_ENTRY" => Some(Self::AlipayLightStyle11Entry),
            "ALIPAY_LIGHT_STYLE21_CODE" => Some(Self::AlipayLightStyle21Code),
            "ALIPAY_LIGHT_STYLE22_CODE" => Some(Self::AlipayLightStyle22Code),
            "ALIPAY_LIGHT_STYLE32_CODE" => Some(Self::AlipayLightStyle32Code),
            "WECHAT_PAY_DARK_STYLE11_ENTRY" => Some(Self::WechatPayDarkStyle11Entry),
            "WECHAT_PAY_DARK_STYLE21_CODE" => Some(Self::WechatPayDarkStyle21Code),
            "WECHAT_PAY_DARK_STYLE22_CODE" => Some(Self::WechatPayDarkStyle22Code),
            "WECHAT_PAY_DARK_STYLE32_CODE" => Some(Self::WechatPayDarkStyle32Code),
            "WECHAT_PAY_LIGHT_STYLE11_ENTRY" => Some(Self::WechatPayLightStyle11Entry),
            "WECHAT_PAY_LIGHT_STYLE21_CODE" => Some(Self::WechatPayLightStyle21Code),
            "WECHAT_PAY_LIGHT_STYLE22_CODE" => Some(Self::WechatPayLightStyle22Code),
            "WECHAT_PAY_LIGHT_STYLE32_CODE" => Some(Self::WechatPayLightStyle32Code),
            "MUSIC_DARK_STYLE11_CONTROL" => Some(Self::MusicDarkStyle11Control),
            "MUSIC_DARK_STYLE12_CONTROL" => Some(Self::MusicDarkStyle12Control),
            "MUSIC_DARK_STYLE21_CONTROL" => Some(Self::MusicDarkStyle21Control),
            "MUSIC_DARK_STYLE22_CONTROL" => Some(Self::MusicDarkStyle22Control),
            "MUSIC_LIGHT_STYLE11_CONTROL" => Some(Self::MusicLightStyle11Control),
            "MUSIC_LIGHT_STYLE12_CONTROL" => Some(Self::MusicLightStyle12Control),
            "MUSIC_LIGHT_STYLE22_CONTROL" => Some(Self::MusicLightStyle22Control),
            "CARD_DARK_STYLE21_SWITCH_CARD" => Some(Self::CardDarkStyle21SwitchCard),
            "CARD_DARK_STYLE22_SWITCH_CARD" => Some(Self::CardDarkStyle22SwitchCard),
            "CARD_DARK_STYLE32_SWITCH_CARD" => Some(Self::CardDarkStyle32SwitchCard),
            "STOPWATCH_DARK_STYLE11_ENTRY" => Some(Self::StopwatchDarkStyle11Entry),
            "STOPWATCH_DARK_STYLE12_CONTROL" => Some(Self::StopwatchDarkStyle12Control),
            "STOPWATCH_LIGHT_STYLE11_ENTRY" => Some(Self::StopwatchLightStyle11Entry),
            "STOPWATCH_LIGHT_STYLE12_CONTROL" => Some(Self::StopwatchLightStyle12Control),
            "TIME_KEEPING_DARK_STYLE11_ENTRY" => Some(Self::TimeKeepingDarkStyle11Entry),
            "TIME_KEEPING_DARK_STYLE12_CONTROL" => {
                Some(Self::TimeKeepingDarkStyle12Control)
            }
            "TIME_KEEPING_LIGHT_STYLE11_ENTRY" => {
                Some(Self::TimeKeepingLightStyle11Entry)
            }
            "TIME_KEEPING_LIGHT_STYLE12_CONTROL" => {
                Some(Self::TimeKeepingLightStyle12Control)
            }
            "TIME_KEEPING_DARK_SQUARE_ENTRY" => Some(Self::TimeKeepingDarkSquareEntry),
            "CALENDAR_DARK_STYLE11_ENTRY" => Some(Self::CalendarDarkStyle11Entry),
            "CALENDAR_DARK_STYLE12_NEXT" => Some(Self::CalendarDarkStyle12Next),
            "CALENDAR_DARK_STYLE21_NEXT" => Some(Self::CalendarDarkStyle21Next),
            "CALENDAR_DARK_STYLE22_NEXT" => Some(Self::CalendarDarkStyle22Next),
            "CALENDAR_LIGHT_STYLE11_ENTRY" => Some(Self::CalendarLightStyle11Entry),
            "CALENDAR_DARK_RECT_NEXT" => Some(Self::CalendarDarkRectNext),
            "CALENDAR_LIGHT_RECT_NEXT" => Some(Self::CalendarLightRectNext),
            "CALENDAR_DARK_CIRCLE_DAY" => Some(Self::CalendarDarkCircleDay),
            "CALENDAR_LIGHT_SQUARE_NEXT" => Some(Self::CalendarLightSquareNext),
            "TEMPERATURE_DARK_STYLE11_ENTRY" => Some(Self::TemperatureDarkStyle11Entry),
            "TEMPERATURE_LIGHT_STYLE11_ENTRY" => Some(Self::TemperatureLightStyle11Entry),
            "BLOOD_PRESSURE_DARK_STYLE11_ENTRY" => {
                Some(Self::BloodPressureDarkStyle11Entry)
            }
            "BLOOD_PRESSURE_DARK_STYLE12_RECENT" => {
                Some(Self::BloodPressureDarkStyle12Recent)
            }
            "BLOOD_PRESSURE_LIGHT_STYLE11_ENTRY" => {
                Some(Self::BloodPressureLightStyle11Entry)
            }
            "BLOOD_PRESSURE_LIGHT_STYLE12_RECENT" => {
                Some(Self::BloodPressureLightStyle12Recent)
            }
            "ECG_DARK_STYLE11_ENTRY" => Some(Self::EcgDarkStyle11Entry),
            "ECG_DARK_STYLE12_RECENT" => Some(Self::EcgDarkStyle12Recent),
            "ECG_LIGHT_STYLE11_ENTRY" => Some(Self::EcgLightStyle11Entry),
            "ECG_LIGHT_STYLE12_RECENT" => Some(Self::EcgLightStyle12Recent),
            "EVENT_DARK_STYLE12_NEXT" => Some(Self::EventDarkStyle12Next),
            "EVENT_DARK_STYLE21_NEXT" => Some(Self::EventDarkStyle21Next),
            "MIHOME_DARK_STYLE11_ENTRY" => Some(Self::MihomeDarkStyle11Entry),
            "MIHOME_LIGHT_STYLE11_ENTRY" => Some(Self::MihomeLightStyle11Entry),
            "ACTIVITY_DARK_STYLE11_CURRENT" => Some(Self::ActivityDarkStyle11Current),
            "ACTIVITY_DARK_STYLE12_CURRENT" => Some(Self::ActivityDarkStyle12Current),
            "ACTIVITY_DARK_STYLE21_CURRENT" => Some(Self::ActivityDarkStyle21Current),
            "ACTIVITY_DARK_STYLE22_CURRENT" => Some(Self::ActivityDarkStyle22Current),
            "ACTIVITY_DARK_STYLE32_CURRENT" => Some(Self::ActivityDarkStyle32Current),
            "ACTIVITY_LIGHT_STYLE11_CURRENT" => Some(Self::ActivityLightStyle11Current),
            "ACTIVITY_LIGHT_STYLE12_CURRENT" => Some(Self::ActivityLightStyle12Current),
            "ACTIVITY_LIGHT_STYLE21_CURRENT" => Some(Self::ActivityLightStyle21Current),
            "ACTIVITY_LIGHT_STYLE22_CURRENT" => Some(Self::ActivityLightStyle22Current),
            "ACTIVITY_LIGHT_STYLE32_CURRENT" => Some(Self::ActivityLightStyle32Current),
            "CLOCK_DARK_STYLE11_ENTRY" => Some(Self::ClockDarkStyle11Entry),
            "CLOCK_LIGHT_STYLE11_ENTRY" => Some(Self::ClockLightStyle11Entry),
            "SHARE_DARK_STYLE11_ENTRY" => Some(Self::ShareDarkStyle11Entry),
            "SHARE_DARK_STYLE12_ENTRY" => Some(Self::ShareDarkStyle12Entry),
            "TODO_LIST_DARK_STYLE11_ENTRY" => Some(Self::TodoListDarkStyle11Entry),
            "TODO_LIST_DARK_STYLE12_NEXT" => Some(Self::TodoListDarkStyle12Next),
            "TODO_LIST_DARK_STYLE21_NEXT" => Some(Self::TodoListDarkStyle21Next),
            "TODO_LIST_LIGHT_STYLE11_ENTRY" => Some(Self::TodoListLightStyle11Entry),
            "PHONE_DARK_STYLE11_ENTRY" => Some(Self::PhoneDarkStyle11Entry),
            "PHONE_LIGHT_STYLE11_ENTRY" => Some(Self::PhoneLightStyle11Entry),
            "LACTATE_THRESHOLD_DARK_STYLE11_ENTRY" => {
                Some(Self::LactateThresholdDarkStyle11Entry)
            }
            "LACTATE_THRESHOLD_LIGHT_STYLE11_ENTRY" => {
                Some(Self::LactateThresholdLightStyle11Entry)
            }
            "COMPASS_DARK_STYLE11_ENTRY" => Some(Self::CompassDarkStyle11Entry),
            "COMPASS_LIGHT_STYLE11_ENTRY" => Some(Self::CompassLightStyle11Entry),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImageFormat {
    Rgb565 = 0,
    Rgb565Swap = 1,
    Argb8888Le = 2,
    Argb8888 = 3,
    Rgb888 = 4,
    Argb8565Le = 7,
    Argb8565 = 8,
    Jpeg = 5,
    Png = 6,
    Gif = 9,
    Vector = 10,
    Mp4 = 11,
    Ezip = 12,
}
impl ImageFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Rgb565 => "RGB_565",
            Self::Rgb565Swap => "RGB_565_SWAP",
            Self::Argb8888Le => "ARGB_8888_LE",
            Self::Argb8888 => "ARGB_8888",
            Self::Rgb888 => "RGB888",
            Self::Argb8565Le => "ARGB_8565_LE",
            Self::Argb8565 => "ARGB_8565",
            Self::Jpeg => "JPEG",
            Self::Png => "PNG",
            Self::Gif => "GIF",
            Self::Vector => "VECTOR",
            Self::Mp4 => "MP4",
            Self::Ezip => "EZIP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RGB_565" => Some(Self::Rgb565),
            "RGB_565_SWAP" => Some(Self::Rgb565Swap),
            "ARGB_8888_LE" => Some(Self::Argb8888Le),
            "ARGB_8888" => Some(Self::Argb8888),
            "RGB888" => Some(Self::Rgb888),
            "ARGB_8565_LE" => Some(Self::Argb8565Le),
            "ARGB_8565" => Some(Self::Argb8565),
            "JPEG" => Some(Self::Jpeg),
            "PNG" => Some(Self::Png),
            "GIF" => Some(Self::Gif),
            "VECTOR" => Some(Self::Vector),
            "MP4" => Some(Self::Mp4),
            "EZIP" => Some(Self::Ezip),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressMode {
    NoCompress = 0,
}
impl CompressMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoCompress => "NO_COMPRESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_COMPRESS" => Some(Self::NoCompress),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionalSwitcher {
    NoFeature = 0,
    On = 1,
    Off = 2,
}
impl OptionalSwitcher {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoFeature => "NO_FEATURE",
            Self::On => "ON",
            Self::Off => "OFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_FEATURE" => Some(Self::NoFeature),
            "ON" => Some(Self::On),
            "OFF" => Some(Self::Off),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TemperatureUnit {
    NoUnit = 0,
    Centigrade = 1,
    Fahrenheit = 2,
}
impl TemperatureUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoUnit => "NO_UNIT",
            Self::Centigrade => "CENTIGRADE",
            Self::Fahrenheit => "FAHRENHEIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_UNIT" => Some(Self::NoUnit),
            "CENTIGRADE" => Some(Self::Centigrade),
            "FAHRENHEIT" => Some(Self::Fahrenheit),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClockMode {
    ClockOnce = 0,
    ClockEveryDay = 1,
    ClockWorkday = 2,
    ClockHoliday = 3,
    ClockMondayToFriday = 4,
    ClockCustom = 5,
    ClockEveryWeek = 6,
    ClockEveryMonth = 7,
    ClockEveryYear = 8,
    ClockNone = 15,
}
impl ClockMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ClockOnce => "CLOCK_ONCE",
            Self::ClockEveryDay => "CLOCK_EVERY_DAY",
            Self::ClockWorkday => "CLOCK_WORKDAY",
            Self::ClockHoliday => "CLOCK_HOLIDAY",
            Self::ClockMondayToFriday => "CLOCK_MONDAY_TO_FRIDAY",
            Self::ClockCustom => "CLOCK_CUSTOM",
            Self::ClockEveryWeek => "CLOCK_EVERY_WEEK",
            Self::ClockEveryMonth => "CLOCK_EVERY_MONTH",
            Self::ClockEveryYear => "CLOCK_EVERY_YEAR",
            Self::ClockNone => "CLOCK_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOCK_ONCE" => Some(Self::ClockOnce),
            "CLOCK_EVERY_DAY" => Some(Self::ClockEveryDay),
            "CLOCK_WORKDAY" => Some(Self::ClockWorkday),
            "CLOCK_HOLIDAY" => Some(Self::ClockHoliday),
            "CLOCK_MONDAY_TO_FRIDAY" => Some(Self::ClockMondayToFriday),
            "CLOCK_CUSTOM" => Some(Self::ClockCustom),
            "CLOCK_EVERY_WEEK" => Some(Self::ClockEveryWeek),
            "CLOCK_EVERY_MONTH" => Some(Self::ClockEveryMonth),
            "CLOCK_EVERY_YEAR" => Some(Self::ClockEveryYear),
            "CLOCK_NONE" => Some(Self::ClockNone),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WearMode {
    Band = 0,
    Bean = 1,
    Ring = 2,
}
impl WearMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Band => "BAND",
            Self::Bean => "BEAN",
            Self::Ring => "RING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BAND" => Some(Self::Band),
            "BEAN" => Some(Self::Bean),
            "RING" => Some(Self::Ring),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HeartRateSection {
    HrNone = 0,
    WarmUp = 1,
    FatBurning = 2,
    Aerobic = 3,
    Anaerobic = 4,
    Extreme = 5,
}
impl HeartRateSection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HrNone => "HR_NONE",
            Self::WarmUp => "WARM_UP",
            Self::FatBurning => "FAT_BURNING",
            Self::Aerobic => "AEROBIC",
            Self::Anaerobic => "ANAEROBIC",
            Self::Extreme => "EXTREME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HR_NONE" => Some(Self::HrNone),
            "WARM_UP" => Some(Self::WarmUp),
            "FAT_BURNING" => Some(Self::FatBurning),
            "AEROBIC" => Some(Self::Aerobic),
            "ANAEROBIC" => Some(Self::Anaerobic),
            "EXTREME" => Some(Self::Extreme),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(
        oneof = "account::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36"
    )]
    pub payload: ::core::option::Option<account::Payload>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountId {
        BindStatus = 0,
        BindStart = 1,
        BindResult = 2,
        LoginStatus = 3,
        LoginStart = 4,
        AccountVerify = 5,
        BondApply = 16,
        BindStartV2 = 17,
        BindVerify = 18,
        BindConfirm = 19,
        BindResultV2 = 25,
        AuthVerify = 26,
        AuthConfirm = 27,
        ApplyDevicePasstoken = 28,
        ReplyDevicePasstoken = 29,
        NotifyLoginStatusChanged = 30,
    }
    impl AccountId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BindStatus => "BIND_STATUS",
                Self::BindStart => "BIND_START",
                Self::BindResult => "BIND_RESULT",
                Self::LoginStatus => "LOGIN_STATUS",
                Self::LoginStart => "LOGIN_START",
                Self::AccountVerify => "ACCOUNT_VERIFY",
                Self::BondApply => "BOND_APPLY",
                Self::BindStartV2 => "BIND_START_V2",
                Self::BindVerify => "BIND_VERIFY",
                Self::BindConfirm => "BIND_CONFIRM",
                Self::BindResultV2 => "BIND_RESULT_V2",
                Self::AuthVerify => "AUTH_VERIFY",
                Self::AuthConfirm => "AUTH_CONFIRM",
                Self::ApplyDevicePasstoken => "APPLY_DEVICE_PASSTOKEN",
                Self::ReplyDevicePasstoken => "REPLY_DEVICE_PASSTOKEN",
                Self::NotifyLoginStatusChanged => "NOTIFY_LOGIN_STATUS_CHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BIND_STATUS" => Some(Self::BindStatus),
                "BIND_START" => Some(Self::BindStart),
                "BIND_RESULT" => Some(Self::BindResult),
                "LOGIN_STATUS" => Some(Self::LoginStatus),
                "LOGIN_START" => Some(Self::LoginStart),
                "ACCOUNT_VERIFY" => Some(Self::AccountVerify),
                "BOND_APPLY" => Some(Self::BondApply),
                "BIND_START_V2" => Some(Self::BindStartV2),
                "BIND_VERIFY" => Some(Self::BindVerify),
                "BIND_CONFIRM" => Some(Self::BindConfirm),
                "BIND_RESULT_V2" => Some(Self::BindResultV2),
                "AUTH_VERIFY" => Some(Self::AuthVerify),
                "AUTH_CONFIRM" => Some(Self::AuthConfirm),
                "APPLY_DEVICE_PASSTOKEN" => Some(Self::ApplyDevicePasstoken),
                "REPLY_DEVICE_PASSTOKEN" => Some(Self::ReplyDevicePasstoken),
                "NOTIFY_LOGIN_STATUS_CHANGED" => Some(Self::NotifyLoginStatusChanged),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        NoError = 0,
        HaveBound = 1,
        InfoMissing = 2,
        InvalidParam = 3,
        NoBound = 4,
        ServerError = 5,
        Cancel = 6,
        VerifyError = 7,
        StateNotMatch = 8,
        UserChanged = 9,
        ConnectionReachLimit = 10,
        Unknown = 100,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoError => "NO_ERROR",
                Self::HaveBound => "HAVE_BOUND",
                Self::InfoMissing => "INFO_MISSING",
                Self::InvalidParam => "INVALID_PARAM",
                Self::NoBound => "NO_BOUND",
                Self::ServerError => "SERVER_ERROR",
                Self::Cancel => "CANCEL",
                Self::VerifyError => "VERIFY_ERROR",
                Self::StateNotMatch => "STATE_NOT_MATCH",
                Self::UserChanged => "USER_CHANGED",
                Self::ConnectionReachLimit => "CONNECTION_REACH_LIMIT",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_ERROR" => Some(Self::NoError),
                "HAVE_BOUND" => Some(Self::HaveBound),
                "INFO_MISSING" => Some(Self::InfoMissing),
                "INVALID_PARAM" => Some(Self::InvalidParam),
                "NO_BOUND" => Some(Self::NoBound),
                "SERVER_ERROR" => Some(Self::ServerError),
                "CANCEL" => Some(Self::Cancel),
                "VERIFY_ERROR" => Some(Self::VerifyError),
                "STATE_NOT_MATCH" => Some(Self::StateNotMatch),
                "USER_CHANGED" => Some(Self::UserChanged),
                "CONNECTION_REACH_LIMIT" => Some(Self::ConnectionReachLimit),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(bool, tag = "1")]
        BindStatus(bool),
        #[prost(string, tag = "2")]
        BindKey(::prost::alloc::string::String),
        #[prost(enumeration = "ErrorCode", tag = "3")]
        ErrorCode(i32),
        #[prost(message, tag = "4")]
        BindInfo(super::BindInfo),
        #[prost(message, tag = "5")]
        BindResult(super::BindResult),
        #[prost(bool, tag = "6")]
        LoginStatus(bool),
        #[prost(string, tag = "7")]
        VerifyKey(::prost::alloc::string::String),
        #[prost(bool, tag = "8")]
        VerifyResult(bool),
        #[prost(message, tag = "9")]
        BondApply(super::BondApply),
        #[prost(message, tag = "10")]
        BondReply(super::BondReply),
        #[prost(message, tag = "11")]
        BindStartV2(super::BindStartV2),
        #[prost(message, tag = "12")]
        BindInfoV2(super::BindInfoV2),
        #[prost(message, tag = "13")]
        PskServerVerify(super::bind_psk::ServerVerify),
        #[prost(message, tag = "14")]
        PskDeviceVerify(super::bind_psk::DeviceVerify),
        #[prost(message, tag = "15")]
        PskAppConfirm(super::bind_psk::AppConfirm),
        #[prost(message, tag = "16")]
        PskDeviceConfirm(super::bind_psk::DeviceConfirm),
        #[prost(message, tag = "17")]
        LocalAppVerify(super::bind_local::AppVerify),
        #[prost(message, tag = "18")]
        LocalDeviceVerify(super::bind_local::DeviceVerify),
        #[prost(message, tag = "19")]
        LocalAppConfirm(super::bind_local::AppConfirm),
        #[prost(message, tag = "20")]
        LocalDeviceConfirm(super::bind_local::DeviceConfirm),
        #[prost(message, tag = "29")]
        BindResultV2(super::BindResultV2),
        #[prost(message, tag = "30")]
        AuthAppVerify(super::auth::AppVerify),
        #[prost(message, tag = "31")]
        AuthDeviceVerify(super::auth::DeviceVerify),
        #[prost(message, tag = "32")]
        AuthAppConfirm(super::auth::AppConfirm),
        #[prost(message, tag = "33")]
        AuthDeviceConfirm(super::auth::DeviceConfirm),
        #[prost(message, tag = "34")]
        PassTokenApply(super::login::PassTokenApply),
        #[prost(message, tag = "35")]
        PassTokenReply(super::login::PassTokenReply),
        #[prost(message, tag = "36")]
        StatusChange(super::login::StatusChange),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindInfo {
    #[prost(string, required, tag = "1")]
    pub bind_key: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub did: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub mac: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub sign: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub serial_number: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindResult {
    #[prost(string, required, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub companion_device: ::core::option::Option<CompanionDevice>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompanionDevice {
    #[prost(enumeration = "companion_device::DeviceType", required, tag = "1")]
    pub device_type: i32,
    #[prost(float, optional, tag = "2")]
    pub system_version: ::core::option::Option<f32>,
    #[prost(string, required, tag = "3")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "4")]
    pub app_capability: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub server_prefix: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CompanionDevice`.
pub mod companion_device {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeviceType {
        Android = 0,
        Ios = 1,
        Vela = 2,
        Other = 15,
    }
    impl DeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Android => "ANDROID",
                Self::Ios => "IOS",
                Self::Vela => "VELA",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANDROID" => Some(Self::Android),
                "IOS" => Some(Self::Ios),
                "VELA" => Some(Self::Vela),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BondApply {
    #[prost(bytes = "vec", required, tag = "1")]
    pub hash_user_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BondReply {
    #[prost(enumeration = "bond_reply::Status", required, tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `BondReply`.
pub mod bond_reply {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        NotSupport = 1,
        BondSuccess = 2,
        BondFail = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotSupport => "NOT_SUPPORT",
                Self::BondSuccess => "BOND_SUCCESS",
                Self::BondFail => "BOND_FAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_SUPPORT" => Some(Self::NotSupport),
                "BOND_SUCCESS" => Some(Self::BondSuccess),
                "BOND_FAIL" => Some(Self::BondFail),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindStartV2 {
    #[prost(bool, required, tag = "1")]
    pub check_dynamic_code: bool,
    #[prost(bytes = "vec", required, tag = "2")]
    pub hash_user_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, required, tag = "3")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "4")]
    pub pid: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindInfoV2 {
    #[prost(enumeration = "VerifyMode", required, tag = "1")]
    pub verify_mode: i32,
    #[prost(string, required, tag = "2")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub mac: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub model: ::prost::alloc::string::String,
    #[prost(enumeration = "OobMode", required, tag = "5")]
    pub oob_mode: i32,
    #[prost(bytes = "vec", required, tag = "6")]
    pub device_random: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, required, tag = "7")]
    pub did: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BindPsk {}
/// Nested message and enum types in `BindPsk`.
pub mod bind_psk {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServerVerify {
        #[prost(bytes = "vec", required, tag = "1")]
        pub server_public_key: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub server_sign: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "3")]
        pub server_random: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceVerify {
        #[prost(bytes = "vec", required, tag = "1")]
        pub device_public_key: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub device_sign: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppConfirm {
        #[prost(bytes = "vec", required, tag = "1")]
        pub app_random: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub app_sign: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "3")]
        pub bind_key: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceConfirm {
        #[prost(bytes = "vec", required, tag = "1")]
        pub device_random: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub device_sign: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "3")]
        pub bind_sign: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResultInfo {
        #[prost(string, required, tag = "1")]
        pub user_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub companion_device: ::core::option::Option<super::CompanionDevice>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BindLocal {}
/// Nested message and enum types in `BindLocal`.
pub mod bind_local {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppVerify {
        #[prost(string, required, tag = "1")]
        pub app_device_id: ::prost::alloc::string::String,
        #[prost(bytes = "vec", required, tag = "2")]
        pub app_public_key: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceVerify {
        #[prost(bytes = "vec", required, tag = "1")]
        pub device_public_key: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub device_random: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "3")]
        pub device_sign: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppConfirm {
        #[prost(bytes = "vec", required, tag = "1")]
        pub app_random: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub app_sign: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DeviceConfirm {
        #[prost(bool, required, tag = "1")]
        pub confirm_result: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResultInfo {
        #[prost(string, required, tag = "1")]
        pub user_id: ::prost::alloc::string::String,
        #[prost(message, required, tag = "2")]
        pub companion_device: super::CompanionDevice,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindResultV2 {
    #[prost(bytes = "vec", required, tag = "1")]
    pub encrypt_result_info: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Auth {}
/// Nested message and enum types in `Auth`.
pub mod auth {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppVerify {
        #[prost(bytes = "vec", required, tag = "1")]
        pub app_random: ::prost::alloc::vec::Vec<u8>,
        #[prost(string, optional, tag = "2")]
        pub app_device_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "3")]
        pub check_dynamic_code: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceVerify {
        #[prost(bytes = "vec", required, tag = "1")]
        pub device_random: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub device_sign: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppConfirm {
        #[prost(bytes = "vec", required, tag = "1")]
        pub app_sign: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", required, tag = "2")]
        pub encrypt_companion_device: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DeviceConfirm {
        #[prost(bool, required, tag = "1")]
        pub confirm_result: bool,
        #[prost(uint32, optional, tag = "2")]
        pub device_capability: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub device_capability_2: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Login {}
/// Nested message and enum types in `Login`.
pub mod login {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PassTokenApply {
        #[prost(uint64, required, tag = "1")]
        pub transaction_id: u64,
        #[prost(string, required, tag = "2")]
        pub ua: ::prost::alloc::string::String,
        #[prost(string, required, tag = "3")]
        pub nonce: ::prost::alloc::string::String,
        #[prost(string, required, tag = "4")]
        pub sign: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PassTokenReply {
        #[prost(uint64, required, tag = "1")]
        pub transaction_id: u64,
        #[prost(string, required, tag = "2")]
        pub login_data: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StatusChange {
        #[prost(uint32, required, tag = "1")]
        pub status: u32,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerifyMode {
    ServerPsk = 1,
    AppLocal = 2,
}
impl VerifyMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ServerPsk => "SERVER_PSK",
            Self::AppLocal => "APP_LOCAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVER_PSK" => Some(Self::ServerPsk),
            "APP_LOCAL" => Some(Self::AppLocal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OobMode {
    NoOob = 0,
    NumericComparison = 1,
    DynamicCode = 2,
    ButtonConfirm = 3,
}
impl OobMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoOob => "NO_OOB",
            Self::NumericComparison => "NUMERIC_COMPARISON",
            Self::DynamicCode => "DYNAMIC_CODE",
            Self::ButtonConfirm => "BUTTON_CONFIRM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_OOB" => Some(Self::NoOob),
            "NUMERIC_COMPARISON" => Some(Self::NumericComparison),
            "DYNAMIC_CODE" => Some(Self::DynamicCode),
            "BUTTON_CONFIRM" => Some(Self::ButtonConfirm),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct System {
    #[prost(
        oneof = "system::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64"
    )]
    pub payload: ::core::option::Option<system::Payload>,
}
/// Nested message and enum types in `System`.
pub mod system {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SystemId {
        Reset = 0,
        ApplyNewBind = 63,
        NotifyNewBind = 12,
        NotifyAppDisconnected = 13,
        ApplyLowLatency = 67,
        GetDeviceStatus = 1,
        GetDeviceInfo = 2,
        SetSystemTime = 3,
        ForceUpgrade = 4,
        PrepareOta = 5,
        ReportOtaProgress = 87,
        SetLanguage = 6,
        GetHidStatus = 7,
        SetHidStatus = 8,
        GetLockScreen = 9,
        SetLockScreen = 21,
        GetNightMode = 10,
        SetNightMode = 11,
        UnlockWatch = 16,
        FindPhone = 17,
        FindWear = 18,
        GetAuthorizeUnlock = 19,
        SetAuthorizeUnlock = 20,
        GetQuietMode = 22,
        SetQuietMode = 23,
        GetWristScreen = 24,
        SetWristScreen = 25,
        SetWidget = 26,
        SetWidgetList = 27,
        GetWidgetList = 28,
        GetOrderedAppList = 29,
        SetOrderedAppList = 30,
        GetAppLayout = 31,
        SetAppLayout = 41,
        SetShortcut1 = 32,
        SetShortcut2 = 33,
        SetShortcut3 = 34,
        GetShortcut1 = 35,
        GetShortcut2 = 36,
        GetShortcut3 = 37,
        GetSupportShortcutList = 38,
        GetSportOption = 39,
        SetSportOption = 40,
        AddOrUpdateSmallHabit = 48,
        SyncSmallHabit = 49,
        DeleteSmallHabit = 50,
        GetWidgetGroupList = 51,
        SetWidgetGroupList = 52,
        GetSupportWidgetList = 53,
        GetWifiCapability = 54,
        RequestWifiConfig = 55,
        AddWifiConfig = 56,
        NotifyWifiConfigResult = 98,
        SyncWifiConfigList = 57,
        GetWifiConfigList = 86,
        EnableWifiAp = 88,
        DisableWifiAp = 89,
        GetSystemSetting = 14,
        SetSystemSetting = 15,
        ReportSystemSetting = 42,
        RequestPhoneSetting = 43,
        SyncPhoneSetting = 44,
        ModifyPhoneSetting = 45,
        LackPhonePermission = 64,
        GetAodSetting = 65,
        SetAodSetting = 66,
        GetVibratorSetting = 46,
        SetVibratorItem = 47,
        AddVibrator = 58,
        TestVibrator = 59,
        UpdateVibrator = 60,
        RemoveVibrators = 61,
        GetStorageInfo = 62,
        GetWearStatus = 93,
        GetBasicStatus = 78,
        ReportBasicStatus = 79,
        ReportBatteryStatus = 97,
        GetAlertStatus = 90,
        ReportAlertStatus = 91,
        ReportData = 80,
        ReportDataResult = 81,
        RequestNetworkProxy = 82,
        SyncNetworkStatus = 92,
        GetWidgetV3 = 83,
        SetWidgetV3 = 84,
        GetSupportWidgetV3 = 85,
        StartUsageGuide = 94,
        ReportUsageGuideFeedback = 95,
        FinishUsageGuide = 96,
    }
    impl SystemId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Reset => "RESET",
                Self::ApplyNewBind => "APPLY_NEW_BIND",
                Self::NotifyNewBind => "NOTIFY_NEW_BIND",
                Self::NotifyAppDisconnected => "NOTIFY_APP_DISCONNECTED",
                Self::ApplyLowLatency => "APPLY_LOW_LATENCY",
                Self::GetDeviceStatus => "GET_DEVICE_STATUS",
                Self::GetDeviceInfo => "GET_DEVICE_INFO",
                Self::SetSystemTime => "SET_SYSTEM_TIME",
                Self::ForceUpgrade => "FORCE_UPGRADE",
                Self::PrepareOta => "PREPARE_OTA",
                Self::ReportOtaProgress => "REPORT_OTA_PROGRESS",
                Self::SetLanguage => "SET_LANGUAGE",
                Self::GetHidStatus => "GET_HID_STATUS",
                Self::SetHidStatus => "SET_HID_STATUS",
                Self::GetLockScreen => "GET_LOCK_SCREEN",
                Self::SetLockScreen => "SET_LOCK_SCREEN",
                Self::GetNightMode => "GET_NIGHT_MODE",
                Self::SetNightMode => "SET_NIGHT_MODE",
                Self::UnlockWatch => "UNLOCK_WATCH",
                Self::FindPhone => "FIND_PHONE",
                Self::FindWear => "FIND_WEAR",
                Self::GetAuthorizeUnlock => "GET_AUTHORIZE_UNLOCK",
                Self::SetAuthorizeUnlock => "SET_AUTHORIZE_UNLOCK",
                Self::GetQuietMode => "GET_QUIET_MODE",
                Self::SetQuietMode => "SET_QUIET_MODE",
                Self::GetWristScreen => "GET_WRIST_SCREEN",
                Self::SetWristScreen => "SET_WRIST_SCREEN",
                Self::SetWidget => "SET_WIDGET",
                Self::SetWidgetList => "SET_WIDGET_LIST",
                Self::GetWidgetList => "GET_WIDGET_LIST",
                Self::GetOrderedAppList => "GET_ORDERED_APP_LIST",
                Self::SetOrderedAppList => "SET_ORDERED_APP_LIST",
                Self::GetAppLayout => "GET_APP_LAYOUT",
                Self::SetAppLayout => "SET_APP_LAYOUT",
                Self::SetShortcut1 => "SET_SHORTCUT_1",
                Self::SetShortcut2 => "SET_SHORTCUT_2",
                Self::SetShortcut3 => "SET_SHORTCUT_3",
                Self::GetShortcut1 => "GET_SHORTCUT_1",
                Self::GetShortcut2 => "GET_SHORTCUT_2",
                Self::GetShortcut3 => "GET_SHORTCUT_3",
                Self::GetSupportShortcutList => "GET_SUPPORT_SHORTCUT_LIST",
                Self::GetSportOption => "GET_SPORT_OPTION",
                Self::SetSportOption => "SET_SPORT_OPTION",
                Self::AddOrUpdateSmallHabit => "ADD_OR_UPDATE_SMALL_HABIT",
                Self::SyncSmallHabit => "SYNC_SMALL_HABIT",
                Self::DeleteSmallHabit => "DELETE_SMALL_HABIT",
                Self::GetWidgetGroupList => "GET_WIDGET_GROUP_LIST",
                Self::SetWidgetGroupList => "SET_WIDGET_GROUP_LIST",
                Self::GetSupportWidgetList => "GET_SUPPORT_WIDGET_LIST",
                Self::GetWifiCapability => "GET_WIFI_CAPABILITY",
                Self::RequestWifiConfig => "REQUEST_WIFI_CONFIG",
                Self::AddWifiConfig => "ADD_WIFI_CONFIG",
                Self::NotifyWifiConfigResult => "NOTIFY_WIFI_CONFIG_RESULT",
                Self::SyncWifiConfigList => "SYNC_WIFI_CONFIG_LIST",
                Self::GetWifiConfigList => "GET_WIFI_CONFIG_LIST",
                Self::EnableWifiAp => "ENABLE_WIFI_AP",
                Self::DisableWifiAp => "DISABLE_WIFI_AP",
                Self::GetSystemSetting => "GET_SYSTEM_SETTING",
                Self::SetSystemSetting => "SET_SYSTEM_SETTING",
                Self::ReportSystemSetting => "REPORT_SYSTEM_SETTING",
                Self::RequestPhoneSetting => "REQUEST_PHONE_SETTING",
                Self::SyncPhoneSetting => "SYNC_PHONE_SETTING",
                Self::ModifyPhoneSetting => "MODIFY_PHONE_SETTING",
                Self::LackPhonePermission => "LACK_PHONE_PERMISSION",
                Self::GetAodSetting => "GET_AOD_SETTING",
                Self::SetAodSetting => "SET_AOD_SETTING",
                Self::GetVibratorSetting => "GET_VIBRATOR_SETTING",
                Self::SetVibratorItem => "SET_VIBRATOR_ITEM",
                Self::AddVibrator => "ADD_VIBRATOR",
                Self::TestVibrator => "TEST_VIBRATOR",
                Self::UpdateVibrator => "UPDATE_VIBRATOR",
                Self::RemoveVibrators => "REMOVE_VIBRATORS",
                Self::GetStorageInfo => "GET_STORAGE_INFO",
                Self::GetWearStatus => "GET_WEAR_STATUS",
                Self::GetBasicStatus => "GET_BASIC_STATUS",
                Self::ReportBasicStatus => "REPORT_BASIC_STATUS",
                Self::ReportBatteryStatus => "REPORT_BATTERY_STATUS",
                Self::GetAlertStatus => "GET_ALERT_STATUS",
                Self::ReportAlertStatus => "REPORT_ALERT_STATUS",
                Self::ReportData => "REPORT_DATA",
                Self::ReportDataResult => "REPORT_DATA_RESULT",
                Self::RequestNetworkProxy => "REQUEST_NETWORK_PROXY",
                Self::SyncNetworkStatus => "SYNC_NETWORK_STATUS",
                Self::GetWidgetV3 => "GET_WIDGET_V3",
                Self::SetWidgetV3 => "SET_WIDGET_V3",
                Self::GetSupportWidgetV3 => "GET_SUPPORT_WIDGET_V3",
                Self::StartUsageGuide => "START_USAGE_GUIDE",
                Self::ReportUsageGuideFeedback => "REPORT_USAGE_GUIDE_FEEDBACK",
                Self::FinishUsageGuide => "FINISH_USAGE_GUIDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESET" => Some(Self::Reset),
                "APPLY_NEW_BIND" => Some(Self::ApplyNewBind),
                "NOTIFY_NEW_BIND" => Some(Self::NotifyNewBind),
                "NOTIFY_APP_DISCONNECTED" => Some(Self::NotifyAppDisconnected),
                "APPLY_LOW_LATENCY" => Some(Self::ApplyLowLatency),
                "GET_DEVICE_STATUS" => Some(Self::GetDeviceStatus),
                "GET_DEVICE_INFO" => Some(Self::GetDeviceInfo),
                "SET_SYSTEM_TIME" => Some(Self::SetSystemTime),
                "FORCE_UPGRADE" => Some(Self::ForceUpgrade),
                "PREPARE_OTA" => Some(Self::PrepareOta),
                "REPORT_OTA_PROGRESS" => Some(Self::ReportOtaProgress),
                "SET_LANGUAGE" => Some(Self::SetLanguage),
                "GET_HID_STATUS" => Some(Self::GetHidStatus),
                "SET_HID_STATUS" => Some(Self::SetHidStatus),
                "GET_LOCK_SCREEN" => Some(Self::GetLockScreen),
                "SET_LOCK_SCREEN" => Some(Self::SetLockScreen),
                "GET_NIGHT_MODE" => Some(Self::GetNightMode),
                "SET_NIGHT_MODE" => Some(Self::SetNightMode),
                "UNLOCK_WATCH" => Some(Self::UnlockWatch),
                "FIND_PHONE" => Some(Self::FindPhone),
                "FIND_WEAR" => Some(Self::FindWear),
                "GET_AUTHORIZE_UNLOCK" => Some(Self::GetAuthorizeUnlock),
                "SET_AUTHORIZE_UNLOCK" => Some(Self::SetAuthorizeUnlock),
                "GET_QUIET_MODE" => Some(Self::GetQuietMode),
                "SET_QUIET_MODE" => Some(Self::SetQuietMode),
                "GET_WRIST_SCREEN" => Some(Self::GetWristScreen),
                "SET_WRIST_SCREEN" => Some(Self::SetWristScreen),
                "SET_WIDGET" => Some(Self::SetWidget),
                "SET_WIDGET_LIST" => Some(Self::SetWidgetList),
                "GET_WIDGET_LIST" => Some(Self::GetWidgetList),
                "GET_ORDERED_APP_LIST" => Some(Self::GetOrderedAppList),
                "SET_ORDERED_APP_LIST" => Some(Self::SetOrderedAppList),
                "GET_APP_LAYOUT" => Some(Self::GetAppLayout),
                "SET_APP_LAYOUT" => Some(Self::SetAppLayout),
                "SET_SHORTCUT_1" => Some(Self::SetShortcut1),
                "SET_SHORTCUT_2" => Some(Self::SetShortcut2),
                "SET_SHORTCUT_3" => Some(Self::SetShortcut3),
                "GET_SHORTCUT_1" => Some(Self::GetShortcut1),
                "GET_SHORTCUT_2" => Some(Self::GetShortcut2),
                "GET_SHORTCUT_3" => Some(Self::GetShortcut3),
                "GET_SUPPORT_SHORTCUT_LIST" => Some(Self::GetSupportShortcutList),
                "GET_SPORT_OPTION" => Some(Self::GetSportOption),
                "SET_SPORT_OPTION" => Some(Self::SetSportOption),
                "ADD_OR_UPDATE_SMALL_HABIT" => Some(Self::AddOrUpdateSmallHabit),
                "SYNC_SMALL_HABIT" => Some(Self::SyncSmallHabit),
                "DELETE_SMALL_HABIT" => Some(Self::DeleteSmallHabit),
                "GET_WIDGET_GROUP_LIST" => Some(Self::GetWidgetGroupList),
                "SET_WIDGET_GROUP_LIST" => Some(Self::SetWidgetGroupList),
                "GET_SUPPORT_WIDGET_LIST" => Some(Self::GetSupportWidgetList),
                "GET_WIFI_CAPABILITY" => Some(Self::GetWifiCapability),
                "REQUEST_WIFI_CONFIG" => Some(Self::RequestWifiConfig),
                "ADD_WIFI_CONFIG" => Some(Self::AddWifiConfig),
                "NOTIFY_WIFI_CONFIG_RESULT" => Some(Self::NotifyWifiConfigResult),
                "SYNC_WIFI_CONFIG_LIST" => Some(Self::SyncWifiConfigList),
                "GET_WIFI_CONFIG_LIST" => Some(Self::GetWifiConfigList),
                "ENABLE_WIFI_AP" => Some(Self::EnableWifiAp),
                "DISABLE_WIFI_AP" => Some(Self::DisableWifiAp),
                "GET_SYSTEM_SETTING" => Some(Self::GetSystemSetting),
                "SET_SYSTEM_SETTING" => Some(Self::SetSystemSetting),
                "REPORT_SYSTEM_SETTING" => Some(Self::ReportSystemSetting),
                "REQUEST_PHONE_SETTING" => Some(Self::RequestPhoneSetting),
                "SYNC_PHONE_SETTING" => Some(Self::SyncPhoneSetting),
                "MODIFY_PHONE_SETTING" => Some(Self::ModifyPhoneSetting),
                "LACK_PHONE_PERMISSION" => Some(Self::LackPhonePermission),
                "GET_AOD_SETTING" => Some(Self::GetAodSetting),
                "SET_AOD_SETTING" => Some(Self::SetAodSetting),
                "GET_VIBRATOR_SETTING" => Some(Self::GetVibratorSetting),
                "SET_VIBRATOR_ITEM" => Some(Self::SetVibratorItem),
                "ADD_VIBRATOR" => Some(Self::AddVibrator),
                "TEST_VIBRATOR" => Some(Self::TestVibrator),
                "UPDATE_VIBRATOR" => Some(Self::UpdateVibrator),
                "REMOVE_VIBRATORS" => Some(Self::RemoveVibrators),
                "GET_STORAGE_INFO" => Some(Self::GetStorageInfo),
                "GET_WEAR_STATUS" => Some(Self::GetWearStatus),
                "GET_BASIC_STATUS" => Some(Self::GetBasicStatus),
                "REPORT_BASIC_STATUS" => Some(Self::ReportBasicStatus),
                "REPORT_BATTERY_STATUS" => Some(Self::ReportBatteryStatus),
                "GET_ALERT_STATUS" => Some(Self::GetAlertStatus),
                "REPORT_ALERT_STATUS" => Some(Self::ReportAlertStatus),
                "REPORT_DATA" => Some(Self::ReportData),
                "REPORT_DATA_RESULT" => Some(Self::ReportDataResult),
                "REQUEST_NETWORK_PROXY" => Some(Self::RequestNetworkProxy),
                "SYNC_NETWORK_STATUS" => Some(Self::SyncNetworkStatus),
                "GET_WIDGET_V3" => Some(Self::GetWidgetV3),
                "SET_WIDGET_V3" => Some(Self::SetWidgetV3),
                "GET_SUPPORT_WIDGET_V3" => Some(Self::GetSupportWidgetV3),
                "START_USAGE_GUIDE" => Some(Self::StartUsageGuide),
                "REPORT_USAGE_GUIDE_FEEDBACK" => Some(Self::ReportUsageGuideFeedback),
                "FINISH_USAGE_GUIDE" => Some(Self::FinishUsageGuide),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(enumeration = "super::ResetMode", tag = "1")]
        ResetMode(i32),
        #[prost(message, tag = "2")]
        DeviceStatus(super::DeviceStatus),
        #[prost(message, tag = "3")]
        DeviceInfo(super::DeviceInfo),
        #[prost(message, tag = "4")]
        SystemTime(super::SystemTime),
        #[prost(enumeration = "super::FindMode", tag = "5")]
        FindMode(i32),
        #[prost(message, tag = "6")]
        ForceUpgrade(super::ForceUpgrade),
        #[prost(message, tag = "7")]
        WristScreen(super::WristScreen),
        #[prost(message, tag = "8")]
        Widget(super::Widget),
        #[prost(message, tag = "9")]
        WidgetList(super::widget::List),
        #[prost(message, tag = "10")]
        AppList(super::app::List),
        #[prost(message, tag = "11")]
        TimingSetting(super::TimingSetting),
        #[prost(message, tag = "12")]
        Shortcut(super::Shortcut),
        #[prost(message, tag = "13")]
        ShortcutList(super::shortcut::List),
        #[prost(message, tag = "14")]
        SportOptionList(super::sport_option::List),
        #[prost(message, tag = "15")]
        HidStatus(super::HidStatus),
        #[prost(message, tag = "16")]
        PrepareOtaRequest(super::prepare_ota::Request),
        #[prost(message, tag = "17")]
        PrepareOtaResponse(super::prepare_ota::Response),
        #[prost(message, tag = "18")]
        AppLayout(super::AppLayout),
        #[prost(message, tag = "19")]
        LockScreen(super::LockScreen),
        #[prost(message, tag = "20")]
        Language(super::Language),
        #[prost(message, tag = "21")]
        AuthorizeUnlockList(super::authorize_unlock::List),
        #[prost(message, tag = "22")]
        AuthorizeUnlock(super::AuthorizeUnlock),
        #[prost(message, tag = "23")]
        NightMode(super::NightMode),
        #[prost(message, tag = "24")]
        SmallHabit(super::SmallHabit),
        #[prost(message, tag = "25")]
        SmallHabitList(super::small_habit::List),
        #[prost(enumeration = "super::small_habit::Type", tag = "26")]
        SmallHabitType(i32),
        #[prost(message, tag = "27")]
        SmallHabitTypeList(super::small_habit::TypeList),
        #[prost(message, tag = "28")]
        WidgetGroupList(super::widget_group::List),
        #[prost(message, tag = "29")]
        WidgetV2List(super::widget_v2::List),
        #[prost(message, tag = "30")]
        WifiCapability(super::wi_fi_config::Capability),
        #[prost(message, tag = "31")]
        WifiBasicInfo(super::wi_fi_config::BasicInfo),
        #[prost(message, tag = "32")]
        WifiConfig(super::WiFiConfig),
        #[prost(message, tag = "33")]
        WifiConfigList(super::wi_fi_config::List),
        #[prost(message, tag = "34")]
        SystemSettingRequest(super::system_setting::Request),
        #[prost(message, tag = "35")]
        SystemSetting(super::SystemSetting),
        #[prost(message, tag = "36")]
        PhoneSettingRequest(super::phone_setting::Request),
        #[prost(message, tag = "37")]
        PhoneSetting(super::PhoneSetting),
        #[prost(message, tag = "38")]
        VibratorSetting(super::VibratorSetting),
        #[prost(message, tag = "39")]
        VibratorItem(super::VibratorItem),
        #[prost(message, tag = "40")]
        Vibrator(super::Vibrator),
        #[prost(message, tag = "41")]
        VibratorEffect(super::VibratorEffect),
        #[prost(message, tag = "42")]
        VibratorRemoval(super::vibrator::Removal),
        #[prost(message, tag = "43")]
        VibratorError(super::VibratorError),
        #[prost(message, tag = "44")]
        StorageInfo(super::StorageInfo),
        #[prost(message, tag = "45")]
        PhonePermission(super::PhonePermission),
        #[prost(message, tag = "46")]
        LowLatency(super::LowLatency),
        #[prost(message, tag = "48")]
        PresentBasicStatus(super::basic_status::Present),
        #[prost(message, tag = "49")]
        ReportBasicStatus(super::basic_status::Report),
        #[prost(message, tag = "50")]
        ReportData(super::ReportData),
        #[prost(message, tag = "51")]
        ReportDataResult(super::report_data::Result),
        #[prost(message, tag = "52")]
        NetworkProxyRequest(super::network_proxy::Request),
        #[prost(message, tag = "53")]
        WidgetV3(super::WidgetV3),
        #[prost(message, tag = "54")]
        WidgetV3SupportedList(super::widget_v3::SupportedList),
        #[prost(message, tag = "55")]
        OtaProgress(super::prepare_ota::Progress),
        #[prost(message, tag = "56")]
        WifiApResult(super::wi_fi_ap::Result),
        #[prost(message, tag = "57")]
        WifiAp(super::WiFiAp),
        #[prost(message, tag = "58")]
        AlertStatus(super::AlertStatus),
        #[prost(message, tag = "59")]
        NetworkStatus(super::NetworkStatus),
        #[prost(enumeration = "super::basic_status::Wearing", tag = "60")]
        WearStatus(i32),
        #[prost(message, tag = "61")]
        UsageGuide(super::UsageGuide),
        #[prost(message, tag = "62")]
        GuideFeedback(super::usage_guide::Feedback),
        #[prost(message, tag = "63")]
        BatteryStatus(super::device_status::Battery),
        #[prost(message, tag = "64")]
        WifiConfigResult(super::wi_fi_config::Result),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceStatus {
    #[prost(message, required, tag = "1")]
    pub battery: device_status::Battery,
}
/// Nested message and enum types in `DeviceStatus`.
pub mod device_status {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Battery {
        #[prost(uint32, required, tag = "1")]
        pub capacity: u32,
        #[prost(enumeration = "battery::ChargeStatus", optional, tag = "2")]
        pub charge_status: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "3")]
        pub charge_info: ::core::option::Option<battery::ChargeInfo>,
    }
    /// Nested message and enum types in `Battery`.
    pub mod battery {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ChargeInfo {
            #[prost(uint32, required, tag = "1")]
            pub state: u32,
            #[prost(uint32, optional, tag = "2")]
            pub timestamp: ::core::option::Option<u32>,
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ChargeStatus {
            Unknown = 0,
            Charging = 1,
            NotCharging = 2,
            Full = 3,
        }
        impl ChargeStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "UNKNOWN",
                    Self::Charging => "CHARGING",
                    Self::NotCharging => "NOT_CHARGING",
                    Self::Full => "FULL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNKNOWN" => Some(Self::Unknown),
                    "CHARGING" => Some(Self::Charging),
                    "NOT_CHARGING" => Some(Self::NotCharging),
                    "FULL" => Some(Self::Full),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    #[prost(string, required, tag = "1")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub firmware_version: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub imei: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub product_device: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemTime {
    #[prost(message, required, tag = "1")]
    pub date: Date,
    #[prost(message, required, tag = "2")]
    pub time: Time,
    #[prost(message, optional, tag = "3")]
    pub time_zone: ::core::option::Option<Timezone>,
    #[prost(bool, optional, tag = "4")]
    pub is_12_hours: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Language {
    #[prost(string, required, tag = "1")]
    pub locale: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HidStatus {
    #[prost(bool, required, tag = "1")]
    pub enable: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockScreen {
    #[prost(enumeration = "lock_screen::Status", required, tag = "1")]
    pub status: i32,
    #[prost(string, required, tag = "2")]
    pub pwd: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "3")]
    pub locked: ::core::option::Option<bool>,
}
/// Nested message and enum types in `LockScreen`.
pub mod lock_screen {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Disabled = 1,
        Enabled = 2,
        EnabledAndRequired = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Disabled => "DISABLED",
                Self::Enabled => "ENABLED",
                Self::EnabledAndRequired => "ENABLED_AND_REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISABLED" => Some(Self::Disabled),
                "ENABLED" => Some(Self::Enabled),
                "ENABLED_AND_REQUIRED" => Some(Self::EnabledAndRequired),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NightMode {
    #[prost(enumeration = "night_mode::Mode", required, tag = "1")]
    pub mode: i32,
    #[prost(message, optional, tag = "2")]
    pub start_time: ::core::option::Option<Time>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<Time>,
}
/// Nested message and enum types in `NightMode`.
pub mod night_mode {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Off = 1,
        SunsetOn = 2,
        TimingOn = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Off => "OFF",
                Self::SunsetOn => "SUNSET_ON",
                Self::TimingOn => "TIMING_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OFF" => Some(Self::Off),
                "SUNSET_ON" => Some(Self::SunsetOn),
                "TIMING_ON" => Some(Self::TimingOn),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthorizeUnlock {
    #[prost(enumeration = "authorize_unlock::Device", required, tag = "1")]
    pub device: i32,
    #[prost(bool, required, tag = "2")]
    pub enable: bool,
}
/// Nested message and enum types in `AuthorizeUnlock`.
pub mod authorize_unlock {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AuthorizeUnlock>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Device {
        Unknown = 0,
        Laptop = 1,
        Phone = 2,
    }
    impl Device {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Laptop => "LAPTOP",
                Self::Phone => "PHONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "LAPTOP" => Some(Self::Laptop),
                "PHONE" => Some(Self::Phone),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimingSetting {
    #[prost(enumeration = "TimingMode", required, tag = "1")]
    pub timing_mode: i32,
    #[prost(message, optional, tag = "2")]
    pub start_time: ::core::option::Option<Time>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<Time>,
    #[prost(uint32, optional, tag = "4")]
    pub repeat_days: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub timestamp: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WristScreen {
    #[prost(enumeration = "TimingMode", required, tag = "1")]
    pub timing_mode: i32,
    #[prost(message, optional, tag = "2")]
    pub start_time: ::core::option::Option<Time>,
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<Time>,
    #[prost(enumeration = "wrist_screen::Sensitivity", optional, tag = "4")]
    pub sensitivity: ::core::option::Option<i32>,
}
/// Nested message and enum types in `WristScreen`.
pub mod wrist_screen {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Sensitivity {
        None = 0,
        Standard = 1,
        High = 2,
    }
    impl Sensitivity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Standard => "STANDARD",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "STANDARD" => Some(Self::Standard),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Widget {
    #[prost(uint32, required, tag = "1")]
    pub function: u32,
    #[prost(bool, required, tag = "2")]
    pub enable: bool,
    #[prost(uint32, optional, tag = "3")]
    pub order: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Widget`.
pub mod widget {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::Widget>,
        #[prost(uint32, optional, tag = "2")]
        pub support_max_number: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub support_min_number: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetV2 {
    #[prost(enumeration = "WidgetStyle", required, tag = "1")]
    pub style: i32,
    #[prost(uint32, required, tag = "2")]
    pub function: u32,
    #[prost(uint32, required, tag = "3")]
    pub sub_type: u32,
    #[prost(string, required, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "SportType", optional, tag = "5")]
    pub sport_type: ::core::option::Option<i32>,
    #[prost(string, required, tag = "6")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "7")]
    pub app_name: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "8")]
    pub phone_type: ::core::option::Option<u32>,
}
/// Nested message and enum types in `WidgetV2`.
pub mod widget_v2 {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub support_widgets: ::prost::alloc::vec::Vec<super::WidgetV2>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetV3 {
    #[prost(message, repeated, tag = "1")]
    pub builtin_widgets: ::prost::alloc::vec::Vec<widget_v3::NativeBuiltin>,
    #[prost(uint32, optional, tag = "2")]
    pub min_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub max_count: ::core::option::Option<u32>,
}
/// Nested message and enum types in `WidgetV3`.
pub mod widget_v3 {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NativeBuiltin {
        #[prost(uint32, required, tag = "1")]
        pub id: u32,
        #[prost(string, required, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NativeBuiltinGroup {
        #[prost(uint32, required, tag = "1")]
        pub id: u32,
        #[prost(string, required, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub builtin_widgets: ::prost::alloc::vec::Vec<NativeBuiltin>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SupportedList {
        #[prost(message, repeated, tag = "1")]
        pub builtin_groups: ::prost::alloc::vec::Vec<NativeBuiltinGroup>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WidgetGroup {
    #[prost(uint32, required, tag = "1")]
    pub sequency: u32,
    #[prost(enumeration = "widget_group::Style", required, tag = "2")]
    pub style: i32,
    #[prost(message, repeated, tag = "3")]
    pub widgets: ::prost::alloc::vec::Vec<WidgetV2>,
}
/// Nested message and enum types in `WidgetGroup`.
pub mod widget_group {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Config {
        #[prost(uint32, required, tag = "1")]
        pub min_group_number: u32,
        #[prost(uint32, required, tag = "2")]
        pub max_group_number: u32,
        #[prost(uint32, required, tag = "3")]
        pub support_group_styles: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub groups: ::prost::alloc::vec::Vec<super::WidgetGroup>,
        #[prost(bool, optional, tag = "2")]
        pub full: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "3")]
        pub config: ::core::option::Option<Config>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Style {
        Style1 = 1,
        Style2 = 2,
        Style3 = 4,
        Style4 = 8,
        Style5 = 16,
        Style6 = 32,
        Style7 = 64,
        Style8 = 128,
        Style9 = 256,
        Style10 = 512,
        Style11 = 1024,
        Style12 = 2048,
        Style13 = 4096,
        Style14 = 8192,
        Style15 = 16384,
    }
    impl Style {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Style1 => "STYLE_1",
                Self::Style2 => "STYLE_2",
                Self::Style3 => "STYLE_3",
                Self::Style4 => "STYLE_4",
                Self::Style5 => "STYLE_5",
                Self::Style6 => "STYLE_6",
                Self::Style7 => "STYLE_7",
                Self::Style8 => "STYLE_8",
                Self::Style9 => "STYLE_9",
                Self::Style10 => "STYLE_10",
                Self::Style11 => "STYLE_11",
                Self::Style12 => "STYLE_12",
                Self::Style13 => "STYLE_13",
                Self::Style14 => "STYLE_14",
                Self::Style15 => "STYLE_15",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STYLE_1" => Some(Self::Style1),
                "STYLE_2" => Some(Self::Style2),
                "STYLE_3" => Some(Self::Style3),
                "STYLE_4" => Some(Self::Style4),
                "STYLE_5" => Some(Self::Style5),
                "STYLE_6" => Some(Self::Style6),
                "STYLE_7" => Some(Self::Style7),
                "STYLE_8" => Some(Self::Style8),
                "STYLE_9" => Some(Self::Style9),
                "STYLE_10" => Some(Self::Style10),
                "STYLE_11" => Some(Self::Style11),
                "STYLE_12" => Some(Self::Style12),
                "STYLE_13" => Some(Self::Style13),
                "STYLE_14" => Some(Self::Style14),
                "STYLE_15" => Some(Self::Style15),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct App {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "3")]
    pub hidden: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub persist: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub can_more: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub in_more: ::core::option::Option<bool>,
}
/// Nested message and enum types in `App`.
pub mod app {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::App>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppLayout {
    #[prost(enumeration = "app_layout::Layout", required, tag = "1")]
    pub layout: i32,
    #[prost(uint32, optional, tag = "2")]
    pub support_layouts: ::core::option::Option<u32>,
}
/// Nested message and enum types in `AppLayout`.
pub mod app_layout {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Layout {
        List = 1,
        Grid = 2,
        GridText = 4,
    }
    impl Layout {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::List => "LIST",
                Self::Grid => "GRID",
                Self::GridText => "GRID_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIST" => Some(Self::List),
                "GRID" => Some(Self::Grid),
                "GRID_TEXT" => Some(Self::GridText),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Shortcut {
    #[prost(enumeration = "shortcut::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(uint32, optional, tag = "2")]
    pub sub_type: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Shortcut`.
pub mod shortcut {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::Shortcut>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        None = 0,
        Voice = 1,
        Function = 2,
        Sport = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Voice => "VOICE",
                Self::Function => "FUNCTION",
                Self::Sport => "SPORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "VOICE" => Some(Self::Voice),
                "FUNCTION" => Some(Self::Function),
                "SPORT" => Some(Self::Sport),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SportOption {
    #[prost(enumeration = "SportType", required, tag = "1")]
    pub sport_type: i32,
    #[prost(bool, required, tag = "2")]
    pub show: bool,
}
/// Nested message and enum types in `SportOption`.
pub mod sport_option {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::SportOption>,
        #[prost(enumeration = "super::SportType", optional, tag = "2")]
        pub shortcut_sport_type: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceUpgrade {
    #[prost(bool, required, tag = "1")]
    pub force: bool,
    #[prost(string, required, tag = "2")]
    pub firmware_version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrepareOta {}
/// Nested message and enum types in `PrepareOta`.
pub mod prepare_ota {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Progress {
        #[prost(uint32, required, tag = "1")]
        pub code: u32,
        #[prost(float, optional, tag = "2")]
        pub percent: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag = "3")]
        pub min_battery: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(bool, required, tag = "1")]
        pub force: bool,
        #[prost(enumeration = "Type", required, tag = "2")]
        pub r#type: i32,
        #[prost(string, required, tag = "3")]
        pub firmware_version: ::prost::alloc::string::String,
        #[prost(string, required, tag = "4")]
        pub file_md5: ::prost::alloc::string::String,
        #[prost(string, required, tag = "5")]
        pub change_log: ::prost::alloc::string::String,
        #[prost(string, required, tag = "6")]
        pub file_url: ::prost::alloc::string::String,
        #[prost(uint32, optional, tag = "7")]
        pub file_size: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(enumeration = "super::PrepareStatus", required, tag = "1")]
        pub prepare_status: i32,
        #[prost(uint32, optional, tag = "2")]
        pub expected_slice_length: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub min_battery: ::core::option::Option<u32>,
        #[prost(message, optional, tag = "4")]
        pub progress: ::core::option::Option<Progress>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        All = 0,
        Rom = 1,
        Res = 2,
        Silent = 15,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::All => "ALL",
                Self::Rom => "ROM",
                Self::Res => "RES",
                Self::Silent => "SILENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALL" => Some(Self::All),
                "ROM" => Some(Self::Rom),
                "RES" => Some(Self::Res),
                "SILENT" => Some(Self::Silent),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmallHabit {
    #[prost(enumeration = "small_habit::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "2")]
    pub time: ::prost::alloc::vec::Vec<Time>,
    #[prost(enumeration = "ClockMode", required, tag = "3")]
    pub clock_mode: i32,
    #[prost(uint32, optional, tag = "4")]
    pub week_days: ::core::option::Option<u32>,
    #[prost(bool, required, tag = "5")]
    pub enable: bool,
    #[prost(string, required, tag = "6")]
    pub label: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SmallHabit`.
pub mod small_habit {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::SmallHabit>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TypeList {
        #[prost(enumeration = "Type", repeated, packed = "false", tag = "1")]
        pub r#type: ::prost::alloc::vec::Vec<i32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        GoToBedEarly = 0,
        DoMoreExercise = 1,
        DrinkWater = 2,
        Reading = 3,
        EatBreakfast = 4,
        CallParents = 5,
        EatFruit = 6,
        ActiveNeck = 7,
        LearnToCharge = 8,
        PracticeASkill = 9,
        ContactFriend = 10,
        SittingUpright = 11,
        EatVegetable = 12,
        CivilizedLanguage = 13,
        Meditation = 14,
        BookKeeping = 15,
        ReciteWords = 16,
        WalkAfterMeal = 17,
        GoOutWithKey = 18,
        DailySummary = 19,
        GargleAfterMeal = 20,
        SmileMore = 21,
        TakeMedicine = 22,
        NotHumpback = 23,
        Calligraphy = 24,
        LunchBreak = 25,
        DoEyeExercises = 26,
        DoYoga = 27,
        ApplyFacialMask = 28,
        QuitSugar = 29,
        ShovelCatLitter = 30,
        OnlineLesson = 31,
        WateringFlowers = 32,
        TakeAPictureOneDay = 33,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GoToBedEarly => "GO_TO_BED_EARLY",
                Self::DoMoreExercise => "DO_MORE_EXERCISE",
                Self::DrinkWater => "DRINK_WATER",
                Self::Reading => "READING",
                Self::EatBreakfast => "EAT_BREAKFAST",
                Self::CallParents => "CALL_PARENTS",
                Self::EatFruit => "EAT_FRUIT",
                Self::ActiveNeck => "ACTIVE_NECK",
                Self::LearnToCharge => "LEARN_TO_CHARGE",
                Self::PracticeASkill => "PRACTICE_A_SKILL",
                Self::ContactFriend => "CONTACT_FRIEND",
                Self::SittingUpright => "SITTING_UPRIGHT",
                Self::EatVegetable => "EAT_VEGETABLE",
                Self::CivilizedLanguage => "CIVILIZED_LANGUAGE",
                Self::Meditation => "MEDITATION",
                Self::BookKeeping => "BOOK_KEEPING",
                Self::ReciteWords => "RECITE_WORDS",
                Self::WalkAfterMeal => "WALK_AFTER_MEAL",
                Self::GoOutWithKey => "GO_OUT_WITH_KEY",
                Self::DailySummary => "DAILY_SUMMARY",
                Self::GargleAfterMeal => "GARGLE_AFTER_MEAL",
                Self::SmileMore => "SMILE_MORE",
                Self::TakeMedicine => "TAKE_MEDICINE",
                Self::NotHumpback => "NOT_HUMPBACK",
                Self::Calligraphy => "CALLIGRAPHY",
                Self::LunchBreak => "LUNCH_BREAK",
                Self::DoEyeExercises => "DO_EYE_EXERCISES",
                Self::DoYoga => "DO_YOGA",
                Self::ApplyFacialMask => "APPLY_FACIAL_MASK",
                Self::QuitSugar => "QUIT_SUGAR",
                Self::ShovelCatLitter => "SHOVEL_CAT_LITTER",
                Self::OnlineLesson => "ONLINE_LESSON",
                Self::WateringFlowers => "WATERING_FLOWERS",
                Self::TakeAPictureOneDay => "TAKE_A_PICTURE_ONE_DAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GO_TO_BED_EARLY" => Some(Self::GoToBedEarly),
                "DO_MORE_EXERCISE" => Some(Self::DoMoreExercise),
                "DRINK_WATER" => Some(Self::DrinkWater),
                "READING" => Some(Self::Reading),
                "EAT_BREAKFAST" => Some(Self::EatBreakfast),
                "CALL_PARENTS" => Some(Self::CallParents),
                "EAT_FRUIT" => Some(Self::EatFruit),
                "ACTIVE_NECK" => Some(Self::ActiveNeck),
                "LEARN_TO_CHARGE" => Some(Self::LearnToCharge),
                "PRACTICE_A_SKILL" => Some(Self::PracticeASkill),
                "CONTACT_FRIEND" => Some(Self::ContactFriend),
                "SITTING_UPRIGHT" => Some(Self::SittingUpright),
                "EAT_VEGETABLE" => Some(Self::EatVegetable),
                "CIVILIZED_LANGUAGE" => Some(Self::CivilizedLanguage),
                "MEDITATION" => Some(Self::Meditation),
                "BOOK_KEEPING" => Some(Self::BookKeeping),
                "RECITE_WORDS" => Some(Self::ReciteWords),
                "WALK_AFTER_MEAL" => Some(Self::WalkAfterMeal),
                "GO_OUT_WITH_KEY" => Some(Self::GoOutWithKey),
                "DAILY_SUMMARY" => Some(Self::DailySummary),
                "GARGLE_AFTER_MEAL" => Some(Self::GargleAfterMeal),
                "SMILE_MORE" => Some(Self::SmileMore),
                "TAKE_MEDICINE" => Some(Self::TakeMedicine),
                "NOT_HUMPBACK" => Some(Self::NotHumpback),
                "CALLIGRAPHY" => Some(Self::Calligraphy),
                "LUNCH_BREAK" => Some(Self::LunchBreak),
                "DO_EYE_EXERCISES" => Some(Self::DoEyeExercises),
                "DO_YOGA" => Some(Self::DoYoga),
                "APPLY_FACIAL_MASK" => Some(Self::ApplyFacialMask),
                "QUIT_SUGAR" => Some(Self::QuitSugar),
                "SHOVEL_CAT_LITTER" => Some(Self::ShovelCatLitter),
                "ONLINE_LESSON" => Some(Self::OnlineLesson),
                "WATERING_FLOWERS" => Some(Self::WateringFlowers),
                "TAKE_A_PICTURE_ONE_DAY" => Some(Self::TakeAPictureOneDay),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WiFiConfig {
    #[prost(message, required, tag = "1")]
    pub basic_info: wi_fi_config::BasicInfo,
    #[prost(oneof = "wi_fi_config::AuthInfo", tags = "2, 3")]
    pub auth_info: ::core::option::Option<wi_fi_config::AuthInfo>,
}
/// Nested message and enum types in `WiFiConfig`.
pub mod wi_fi_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Capability {
        #[prost(uint32, optional, tag = "1")]
        pub support_auth_mode: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub support_frequency: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BasicInfo {
        #[prost(string, required, tag = "1")]
        pub ssid: ::prost::alloc::string::String,
        #[prost(enumeration = "AuthMode", required, tag = "2")]
        pub auth_mode: i32,
        #[prost(enumeration = "Frequency", required, tag = "3")]
        pub frequency: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PskInfo {
        #[prost(string, required, tag = "1")]
        pub password: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EapInfo {
        #[prost(string, required, tag = "1")]
        pub identity: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub password: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(string, required, tag = "1")]
        pub ssid: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub code: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::WiFiConfig>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthMode {
        WpaNone = 1,
        WpaPsk = 2,
        WpaEap = 4,
    }
    impl AuthMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::WpaNone => "WPA_NONE",
                Self::WpaPsk => "WPA_PSK",
                Self::WpaEap => "WPA_EAP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WPA_NONE" => Some(Self::WpaNone),
                "WPA_PSK" => Some(Self::WpaPsk),
                "WPA_EAP" => Some(Self::WpaEap),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Frequency {
        F24g = 1,
        F5g = 2,
    }
    impl Frequency {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::F24g => "F_24G",
                Self::F5g => "F_5G",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "F_24G" => Some(Self::F24g),
                "F_5G" => Some(Self::F5g),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AuthInfo {
        #[prost(message, tag = "2")]
        PskInfo(PskInfo),
        #[prost(message, tag = "3")]
        EapInfo(EapInfo),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BasicStatus {}
/// Nested message and enum types in `BasicStatus`.
pub mod basic_status {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Sport {
        #[prost(enumeration = "super::SportType", required, tag = "1")]
        pub sport_type: i32,
        #[prost(enumeration = "super::SportState", optional, tag = "2")]
        pub sport_state: ::core::option::Option<i32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Present {
        #[prost(bool, required, tag = "1")]
        pub is_charging: bool,
        #[prost(uint32, optional, tag = "2")]
        pub battery: ::core::option::Option<u32>,
        #[prost(bool, required, tag = "3")]
        pub is_wearing: bool,
        #[prost(bool, required, tag = "4")]
        pub is_sleeping: bool,
        #[prost(message, required, tag = "5")]
        pub sport: Sport,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Report {
        #[prost(enumeration = "Charging", optional, tag = "1")]
        pub charging: ::core::option::Option<i32>,
        #[prost(enumeration = "Wearing", optional, tag = "2")]
        pub wearing: ::core::option::Option<i32>,
        #[prost(enumeration = "Sleeping", optional, tag = "3")]
        pub sleeping: ::core::option::Option<i32>,
        #[prost(enumeration = "Warning", optional, tag = "4")]
        pub waring: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub sport: ::core::option::Option<Sport>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Charging {
        Start = 1,
        Quit = 2,
        Finish = 3,
    }
    impl Charging {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Quit => "QUIT",
                Self::Finish => "FINISH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "QUIT" => Some(Self::Quit),
                "FINISH" => Some(Self::Finish),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Wearing {
        On = 1,
        Off = 2,
    }
    impl Wearing {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::On => "ON",
                Self::Off => "OFF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ON" => Some(Self::On),
                "OFF" => Some(Self::Off),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Sleeping {
        In = 1,
        Out = 2,
    }
    impl Sleeping {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::In => "IN",
                Self::Out => "OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IN" => Some(Self::In),
                "OUT" => Some(Self::Out),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Warning {
        HeartRateHigh = 1,
        HeartRateLow = 2,
        ActiveHeartRateHigh = 3,
        ActiveHeartRateLow = 4,
    }
    impl Warning {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::HeartRateHigh => "HEART_RATE_HIGH",
                Self::HeartRateLow => "HEART_RATE_LOW",
                Self::ActiveHeartRateHigh => "ACTIVE_HEART_RATE_HIGH",
                Self::ActiveHeartRateLow => "ACTIVE_HEART_RATE_LOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HEART_RATE_HIGH" => Some(Self::HeartRateHigh),
                "HEART_RATE_LOW" => Some(Self::HeartRateLow),
                "ACTIVE_HEART_RATE_HIGH" => Some(Self::ActiveHeartRateHigh),
                "ACTIVE_HEART_RATE_LOW" => Some(Self::ActiveHeartRateLow),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportData {
    #[prost(enumeration = "report_data::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(string, optional, tag = "2")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ReportData`.
pub mod report_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(enumeration = "Type", required, tag = "1")]
        pub r#type: i32,
        #[prost(enumeration = "Status", required, tag = "2")]
        pub status: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        DeviceLog = 1,
        Statistics = 2,
        DumpLog = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DeviceLog => "DEVICE_LOG",
                Self::Statistics => "STATISTICS",
                Self::DumpLog => "DUMP_LOG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEVICE_LOG" => Some(Self::DeviceLog),
                "STATISTICS" => Some(Self::Statistics),
                "DUMP_LOG" => Some(Self::DumpLog),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Success = 0,
        NoData = 1,
        UrlDirect = 2,
        Busy = 3,
        Fail = 10,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::NoData => "NO_DATA",
                Self::UrlDirect => "URL_DIRECT",
                Self::Busy => "BUSY",
                Self::Fail => "FAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "NO_DATA" => Some(Self::NoData),
                "URL_DIRECT" => Some(Self::UrlDirect),
                "BUSY" => Some(Self::Busy),
                "FAIL" => Some(Self::Fail),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkProxy {}
/// Nested message and enum types in `NetworkProxy`.
pub mod network_proxy {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(enumeration = "Type", required, tag = "1")]
        pub r#type: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Pan = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Pan => "PAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PAN" => Some(Self::Pan),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WiFiAp {
    #[prost(string, required, tag = "1")]
    pub ssid: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub gateway: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WiFiAP`.
pub mod wi_fi_ap {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(uint32, required, tag = "1")]
        pub code: u32,
        #[prost(message, optional, tag = "2")]
        pub wifi_ap: ::core::option::Option<super::WiFiAp>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlertStatus {
    #[prost(message, optional, tag = "1")]
    pub battery: ::core::option::Option<alert_status::Battery>,
    #[prost(message, optional, tag = "2")]
    pub temperature: ::core::option::Option<alert_status::Temperature>,
    #[prost(message, optional, tag = "3")]
    pub storage: ::core::option::Option<alert_status::Storage>,
    #[prost(message, optional, tag = "4")]
    pub ota: ::core::option::Option<alert_status::Ota>,
    #[prost(message, optional, tag = "5")]
    pub electrochromic: ::core::option::Option<alert_status::Electrochromic>,
    #[prost(message, optional, tag = "6")]
    pub camera: ::core::option::Option<alert_status::Camera>,
    #[prost(message, optional, tag = "7")]
    pub wear: ::core::option::Option<alert_status::Wear>,
}
/// Nested message and enum types in `AlertStatus`.
pub mod alert_status {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Battery {
        #[prost(uint32, required, tag = "1")]
        pub r#type: u32,
        #[prost(uint32, required, tag = "2")]
        pub capacity: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Temperature {
        #[prost(bool, required, tag = "1")]
        pub high: bool,
        #[prost(uint32, required, tag = "2")]
        pub temp: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Storage {
        #[prost(uint32, required, tag = "1")]
        pub free_space: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Ota {
        #[prost(uint32, optional, tag = "1")]
        pub status: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub error_code: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Electrochromic {
        #[prost(uint32, required, tag = "1")]
        pub color: u32,
        #[prost(uint32, required, tag = "2")]
        pub level: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Camera {
        #[prost(uint32, required, tag = "1")]
        pub status: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Wear {
        #[prost(uint32, required, tag = "1")]
        pub mode: u32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkStatus {
    #[prost(uint32, required, tag = "1")]
    pub capability: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UsageGuide {
    #[prost(uint32, required, tag = "1")]
    pub id: u32,
    #[prost(bool, required, tag = "2")]
    pub need_feedback: bool,
}
/// Nested message and enum types in `UsageGuide`.
pub mod usage_guide {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Feedback {
        #[prost(uint32, required, tag = "1")]
        pub guide_id: u32,
        #[prost(bool, required, tag = "2")]
        pub success: bool,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemSetting {
    #[prost(message, optional, tag = "1")]
    pub notificaton_setting: ::core::option::Option<system_setting::NotificationSetting>,
    #[prost(message, optional, tag = "2")]
    pub dnd_mode: ::core::option::Option<system_setting::DndMode>,
    #[prost(message, optional, tag = "3")]
    pub wear_setting: ::core::option::Option<system_setting::WearSetting>,
    #[prost(message, optional, tag = "4")]
    pub disconnect_reminder: ::core::option::Option<system_setting::DisconnectReminder>,
    #[prost(message, optional, tag = "5")]
    pub indicator_light: ::core::option::Option<system_setting::IndicatorLight>,
    #[prost(message, optional, tag = "6")]
    pub ai_assistant: ::core::option::Option<system_setting::AiAssistant>,
    #[prost(message, optional, tag = "7")]
    pub media_setting: ::core::option::Option<system_setting::MediaSetting>,
    #[prost(message, optional, tag = "8")]
    pub headset: ::core::option::Option<system_setting::Headset>,
    #[prost(message, optional, tag = "9")]
    pub ota_setting: ::core::option::Option<system_setting::OtaSetting>,
}
/// Nested message and enum types in `SystemSetting`.
pub mod system_setting {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NotificationSetting {
        #[prost(enumeration = "super::OptionalSwitcher", required, tag = "1")]
        pub auto_screen: i32,
        #[prost(enumeration = "super::OptionalSwitcher", required, tag = "2")]
        pub only_lockscreen: i32,
        #[prost(enumeration = "super::OptionalSwitcher", optional, tag = "3")]
        pub only_wear: ::core::option::Option<i32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DndMode {
        #[prost(bool, required, tag = "1")]
        pub sync_with_phone: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct WearSetting {
        #[prost(enumeration = "super::WearMode", required, tag = "1")]
        pub wear_mode: i32,
        #[prost(message, optional, tag = "2")]
        pub hybrid_mode: ::core::option::Option<wear_setting::HybridMode>,
    }
    /// Nested message and enum types in `WearSetting`.
    pub mod wear_setting {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct HybridMode {
            #[prost(enumeration = "super::super::PowerMode", required, tag = "1")]
            pub power_mode: i32,
            #[prost(uint64, optional, tag = "2")]
            pub lack_feature: ::core::option::Option<u64>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DisconnectReminder {
        #[prost(bool, required, tag = "1")]
        pub alert: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IndicatorLight {
        #[prost(uint32, required, tag = "1")]
        pub brightness: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AiAssistant {
        #[prost(bool, required, tag = "1")]
        pub voice_wakeup: bool,
        #[prost(bool, optional, tag = "2")]
        pub camera_access: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MediaSetting {
        #[prost(uint32, required, tag = "1")]
        pub shooting_mode: u32,
        #[prost(uint32, required, tag = "2")]
        pub video_duration: u32,
        #[prost(bool, required, tag = "3")]
        pub auto_sync: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Headset {
        #[prost(bool, required, tag = "1")]
        pub wear_detection: bool,
        #[prost(bool, optional, tag = "2")]
        pub volume_adaptive: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OtaSetting {
        #[prost(bool, required, tag = "1")]
        pub silent: bool,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(uint32, required, tag = "1")]
        pub items: u32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneSetting {
    #[prost(message, optional, tag = "1")]
    pub mute_mode: ::core::option::Option<phone_setting::MuteMode>,
}
/// Nested message and enum types in `PhoneSetting`.
pub mod phone_setting {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(uint32, required, tag = "1")]
        pub items: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MuteMode {
        #[prost(bool, required, tag = "1")]
        pub mute: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VibratorSetting {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<VibratorItem>,
    #[prost(uint32, required, tag = "2")]
    pub max_number: u32,
    #[prost(message, repeated, tag = "3")]
    pub vibrators: ::prost::alloc::vec::Vec<Vibrator>,
    #[prost(uint32, optional, tag = "4")]
    pub version: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vibrator {
    #[prost(uint32, required, tag = "1")]
    pub id: u32,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub segments: ::prost::alloc::vec::Vec<vibrator_effect::Segment>,
    #[prost(enumeration = "vibrator::Type", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Vibrator`.
pub mod vibrator {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Removal {
        #[prost(uint32, repeated, packed = "false", tag = "1")]
        pub ids: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        None = 0,
        Call = 1,
        Event = 2,
        Clock = 3,
        Notification = 4,
        Sedentary = 5,
        Message = 6,
        Goal = 7,
        Calendar = 8,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Call => "CALL",
                Self::Event => "EVENT",
                Self::Clock => "CLOCK",
                Self::Notification => "NOTIFICATION",
                Self::Sedentary => "SEDENTARY",
                Self::Message => "MESSAGE",
                Self::Goal => "GOAL",
                Self::Calendar => "CALENDAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "CALL" => Some(Self::Call),
                "EVENT" => Some(Self::Event),
                "CLOCK" => Some(Self::Clock),
                "NOTIFICATION" => Some(Self::Notification),
                "SEDENTARY" => Some(Self::Sedentary),
                "MESSAGE" => Some(Self::Message),
                "GOAL" => Some(Self::Goal),
                "CALENDAR" => Some(Self::Calendar),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VibratorItem {
    #[prost(enumeration = "vibrator::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub id: u32,
    #[prost(uint32, optional, tag = "3")]
    pub supported_builtin_ids: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VibratorEffect {
    #[prost(message, repeated, tag = "1")]
    pub segments: ::prost::alloc::vec::Vec<vibrator_effect::Segment>,
    #[prost(message, optional, tag = "2")]
    pub item: ::core::option::Option<VibratorItem>,
}
/// Nested message and enum types in `VibratorEffect`.
pub mod vibrator_effect {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Segment {
        #[prost(bool, required, tag = "1")]
        pub on: bool,
        #[prost(uint32, required, tag = "2")]
        pub duration: u32,
        #[prost(uint32, optional, tag = "3")]
        pub strength: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VibratorError {
    #[prost(enumeration = "vibrator_error::Code", required, tag = "1")]
    pub code: i32,
}
/// Nested message and enum types in `VibratorError`.
pub mod vibrator_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Ok = 0,
        NumberLimit = 1,
        IdNotExist = 2,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::NumberLimit => "NUMBER_LIMIT",
                Self::IdNotExist => "ID_NOT_EXIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "NUMBER_LIMIT" => Some(Self::NumberLimit),
                "ID_NOT_EXIST" => Some(Self::IdNotExist),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StorageInfo {
    #[prost(uint64, required, tag = "1")]
    pub used: u64,
    #[prost(uint64, required, tag = "2")]
    pub total: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhonePermission {
    #[prost(uint32, required, tag = "1")]
    pub permissions: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LowLatency {
    #[prost(uint32, required, tag = "1")]
    pub duration: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PowerMode {
    Performance = 0,
    PowerSave = 1,
    SuperPowerSave = 2,
}
impl PowerMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Performance => "PERFORMANCE",
            Self::PowerSave => "POWER_SAVE",
            Self::SuperPowerSave => "SUPER_POWER_SAVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERFORMANCE" => Some(Self::Performance),
            "POWER_SAVE" => Some(Self::PowerSave),
            "SUPER_POWER_SAVE" => Some(Self::SuperPowerSave),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResetMode {
    NoErase = 0,
    EraseAll = 1,
}
impl ResetMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoErase => "NO_ERASE",
            Self::EraseAll => "ERASE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_ERASE" => Some(Self::NoErase),
            "ERASE_ALL" => Some(Self::EraseAll),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FindMode {
    FindStart = 0,
    FindStop = 1,
}
impl FindMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FindStart => "FIND_START",
            Self::FindStop => "FIND_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIND_START" => Some(Self::FindStart),
            "FIND_STOP" => Some(Self::FindStop),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimingMode {
    AllDayOn = 0,
    TimedOn = 1,
    AllDayOff = 2,
    SmartOn = 3,
}
impl TimingMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AllDayOn => "ALL_DAY_ON",
            Self::TimedOn => "TIMED_ON",
            Self::AllDayOff => "ALL_DAY_OFF",
            Self::SmartOn => "SMART_ON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALL_DAY_ON" => Some(Self::AllDayOn),
            "TIMED_ON" => Some(Self::TimedOn),
            "ALL_DAY_OFF" => Some(Self::AllDayOff),
            "SMART_ON" => Some(Self::SmartOn),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Order {
    HeadResident = 0,
    Highest = 10,
    Lowest = 99,
    Resident = 100,
}
impl Order {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HeadResident => "HEAD_RESIDENT",
            Self::Highest => "HIGHEST",
            Self::Lowest => "LOWEST",
            Self::Resident => "RESIDENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEAD_RESIDENT" => Some(Self::HeadResident),
            "HIGHEST" => Some(Self::Highest),
            "LOWEST" => Some(Self::Lowest),
            "RESIDENT" => Some(Self::Resident),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchFace {
    #[prost(
        oneof = "watch_face::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15"
    )]
    pub payload: ::core::option::Option<watch_face::Payload>,
}
/// Nested message and enum types in `WatchFace`.
pub mod watch_face {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WatchFaceId {
        GetInstalledList = 0,
        SetWatchFace = 1,
        RemoveWatchFace = 2,
        RemoveWatchFacePhoto = 3,
        PrepareInstallWatchFace = 4,
        ReportInstallResult = 5,
        RemoveMultiWatchFace = 6,
        GetSupportData = 10,
        EditWatchFace = 11,
        BgImageResult = 12,
        FontResult = 13,
    }
    impl WatchFaceId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GetInstalledList => "GET_INSTALLED_LIST",
                Self::SetWatchFace => "SET_WATCH_FACE",
                Self::RemoveWatchFace => "REMOVE_WATCH_FACE",
                Self::RemoveWatchFacePhoto => "REMOVE_WATCH_FACE_PHOTO",
                Self::PrepareInstallWatchFace => "PREPARE_INSTALL_WATCH_FACE",
                Self::ReportInstallResult => "REPORT_INSTALL_RESULT",
                Self::RemoveMultiWatchFace => "REMOVE_MULTI_WATCH_FACE",
                Self::GetSupportData => "GET_SUPPORT_DATA",
                Self::EditWatchFace => "EDIT_WATCH_FACE",
                Self::BgImageResult => "BG_IMAGE_RESULT",
                Self::FontResult => "FONT_RESULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GET_INSTALLED_LIST" => Some(Self::GetInstalledList),
                "SET_WATCH_FACE" => Some(Self::SetWatchFace),
                "REMOVE_WATCH_FACE" => Some(Self::RemoveWatchFace),
                "REMOVE_WATCH_FACE_PHOTO" => Some(Self::RemoveWatchFacePhoto),
                "PREPARE_INSTALL_WATCH_FACE" => Some(Self::PrepareInstallWatchFace),
                "REPORT_INSTALL_RESULT" => Some(Self::ReportInstallResult),
                "REMOVE_MULTI_WATCH_FACE" => Some(Self::RemoveMultiWatchFace),
                "GET_SUPPORT_DATA" => Some(Self::GetSupportData),
                "EDIT_WATCH_FACE" => Some(Self::EditWatchFace),
                "BG_IMAGE_RESULT" => Some(Self::BgImageResult),
                "FONT_RESULT" => Some(Self::FontResult),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        WatchFaceList(super::watch_face_item::List),
        #[prost(string, tag = "2")]
        Id(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        Path(::prost::alloc::string::String),
        #[prost(bool, tag = "4")]
        Success(bool),
        #[prost(enumeration = "super::PrepareStatus", tag = "5")]
        PrepareStatus(i32),
        #[prost(message, tag = "6")]
        PrepareInfo(super::PrepareInfo),
        #[prost(message, tag = "7")]
        InstallResult(super::InstallResult),
        #[prost(message, tag = "8")]
        InfoList(super::watch_face_info::List),
        #[prost(message, tag = "9")]
        PrepareReply(super::PrepareReply),
        #[prost(message, tag = "11")]
        SupportDataList(super::watch_face_slot::List),
        #[prost(message, tag = "12")]
        EditRequest(super::EditRequest),
        #[prost(message, tag = "13")]
        EditResponse(super::EditResponse),
        #[prost(message, tag = "14")]
        BgImageResult(super::BgImageResult),
        #[prost(message, tag = "15")]
        FontResult(super::FontResult),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WatchFaceSlot {}
/// Nested message and enum types in `WatchFaceSlot`.
pub mod watch_face_slot {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(enumeration = "Data", repeated, packed = "false", tag = "1")]
        pub list: ::prost::alloc::vec::Vec<i32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(string, required, tag = "1")]
        pub slot_id: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub widget_id: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Data {
        Empty = 0,
        HeartRate = 1,
        Pressure = 2,
        Sleep = 3,
        Energy = 4,
        Step = 5,
        Calorie = 6,
        ValidStand = 7,
        Battery = 8,
        Date = 9,
        Weather = 10,
        AirPressure = 11,
        Altitude = 12,
        Timer = 13,
        Clock = 14,
        Aqi = 15,
        Humidity = 16,
        SportMode = 17,
        Uvi = 18,
        SunriseSunset = 19,
        WindDirection = 20,
    }
    impl Data {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Empty => "EMPTY",
                Self::HeartRate => "HEART_RATE",
                Self::Pressure => "PRESSURE",
                Self::Sleep => "SLEEP",
                Self::Energy => "ENERGY",
                Self::Step => "STEP",
                Self::Calorie => "CALORIE",
                Self::ValidStand => "VALID_STAND",
                Self::Battery => "BATTERY",
                Self::Date => "DATE",
                Self::Weather => "WEATHER",
                Self::AirPressure => "AIR_PRESSURE",
                Self::Altitude => "ALTITUDE",
                Self::Timer => "TIMER",
                Self::Clock => "CLOCK",
                Self::Aqi => "AQI",
                Self::Humidity => "HUMIDITY",
                Self::SportMode => "SPORT_MODE",
                Self::Uvi => "UVI",
                Self::SunriseSunset => "SUNRISE_SUNSET",
                Self::WindDirection => "WIND_DIRECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EMPTY" => Some(Self::Empty),
                "HEART_RATE" => Some(Self::HeartRate),
                "PRESSURE" => Some(Self::Pressure),
                "SLEEP" => Some(Self::Sleep),
                "ENERGY" => Some(Self::Energy),
                "STEP" => Some(Self::Step),
                "CALORIE" => Some(Self::Calorie),
                "VALID_STAND" => Some(Self::ValidStand),
                "BATTERY" => Some(Self::Battery),
                "DATE" => Some(Self::Date),
                "WEATHER" => Some(Self::Weather),
                "AIR_PRESSURE" => Some(Self::AirPressure),
                "ALTITUDE" => Some(Self::Altitude),
                "TIMER" => Some(Self::Timer),
                "CLOCK" => Some(Self::Clock),
                "AQI" => Some(Self::Aqi),
                "HUMIDITY" => Some(Self::Humidity),
                "SPORT_MODE" => Some(Self::SportMode),
                "UVI" => Some(Self::Uvi),
                "SUNRISE_SUNSET" => Some(Self::SunriseSunset),
                "WIND_DIRECTION" => Some(Self::WindDirection),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchFaceItem {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "3")]
    pub is_current: bool,
    #[prost(bool, optional, tag = "4")]
    pub can_remove: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "5")]
    pub version_code: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "6")]
    pub can_edit: ::core::option::Option<bool>,
    #[prost(string, required, tag = "7")]
    pub background_color: ::prost::alloc::string::String,
    #[prost(string, required, tag = "8")]
    pub background_image: ::prost::alloc::string::String,
    #[prost(string, required, tag = "9")]
    pub style: ::prost::alloc::string::String,
    #[prost(
        enumeration = "watch_face_slot::Data",
        repeated,
        packed = "false",
        tag = "10"
    )]
    pub data_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "ImageFormat", optional, tag = "11")]
    pub support_image_format: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "12")]
    pub background_image_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "13")]
    pub slot_item_list: ::prost::alloc::vec::Vec<watch_face_slot::Item>,
}
/// Nested message and enum types in `WatchFaceItem`.
pub mod watch_face_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::WatchFaceItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchFaceInfo {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WatchFaceInfo`.
pub mod watch_face_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::WatchFaceInfo>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareInfo {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub size: u32,
    #[prost(uint64, optional, tag = "3")]
    pub version_code: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub support_compress_mode: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub verification: ::core::option::Option<prepare_info::Verification>,
}
/// Nested message and enum types in `PrepareInfo`.
pub mod prepare_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Verification {
        #[prost(string, required, tag = "1")]
        pub info: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub sign: ::prost::alloc::string::String,
        #[prost(uint32, optional, tag = "3")]
        pub trial_duration: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareReply {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "PrepareStatus", required, tag = "2")]
    pub prepare_status: i32,
    #[prost(uint32, optional, tag = "3")]
    pub select_compress_mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub expected_slice_length: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallResult {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "install_result::Code", required, tag = "2")]
    pub code: i32,
    #[prost(bool, optional, tag = "3")]
    pub support_edit: ::core::option::Option<bool>,
    #[prost(enumeration = "ImageFormat", optional, tag = "4")]
    pub support_image_format: ::core::option::Option<i32>,
}
/// Nested message and enum types in `InstallResult`.
pub mod install_result {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        VerifyFailed = 0,
        InstallFailed = 1,
        InstallSuccess = 2,
        InstallUsed = 3,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::VerifyFailed => "VERIFY_FAILED",
                Self::InstallFailed => "INSTALL_FAILED",
                Self::InstallSuccess => "INSTALL_SUCCESS",
                Self::InstallUsed => "INSTALL_USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERIFY_FAILED" => Some(Self::VerifyFailed),
                "INSTALL_FAILED" => Some(Self::InstallFailed),
                "INSTALL_SUCCESS" => Some(Self::InstallSuccess),
                "INSTALL_USED" => Some(Self::InstallUsed),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchFaceImage {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "2")]
    pub size: ::core::option::Option<u32>,
}
/// Nested message and enum types in `WatchFaceImage`.
pub mod watch_face_image {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Group {
        #[prost(string, required, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub content_pos_index: u32,
        #[prost(message, required, tag = "3")]
        pub bg_image: super::WatchFaceImage,
        #[prost(message, optional, tag = "4")]
        pub fg_image: ::core::option::Option<super::WatchFaceImage>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupList {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<Group>,
        #[prost(uint32, required, tag = "2")]
        pub support_max_count: u32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchFaceLiteral {
    #[prost(message, required, tag = "1")]
    pub items: watch_face_literal::item::List,
    #[prost(string, required, tag = "2")]
    pub font: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "3")]
    pub font_size: ::core::option::Option<u32>,
}
/// Nested message and enum types in `WatchFaceLiteral`.
pub mod watch_face_literal {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(string, required, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub text_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "3")]
        pub source: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub literal_items: ::prost::alloc::vec::Vec<super::Item>,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditRequest {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "2")]
    pub set_current: bool,
    #[prost(string, required, tag = "3")]
    pub background_color: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub background_image: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "5")]
    pub background_image_size: ::core::option::Option<u32>,
    #[prost(string, required, tag = "6")]
    pub style: ::prost::alloc::string::String,
    #[prost(
        enumeration = "watch_face_slot::Data",
        repeated,
        packed = "false",
        tag = "7"
    )]
    pub data_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "8")]
    pub background_image_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, repeated, packed = "false", tag = "9")]
    pub background_image_size_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, repeated, tag = "10")]
    pub order_image_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "11")]
    pub delete_all_images: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "12")]
    pub slot_item_list: ::prost::alloc::vec::Vec<watch_face_slot::Item>,
    #[prost(bytes = "vec", optional, tag = "13")]
    pub foreground_color: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "14")]
    pub style_color_index: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "15")]
    pub image_group_list: ::core::option::Option<watch_face_image::GroupList>,
    #[prost(message, optional, tag = "16")]
    pub literal: ::core::option::Option<WatchFaceLiteral>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditResponse {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "edit_response::Code", required, tag = "2")]
    pub code: i32,
    #[prost(uint32, optional, tag = "3")]
    pub can_accept_image_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub expected_slice_length: ::core::option::Option<u32>,
}
/// Nested message and enum types in `EditResponse`.
pub mod edit_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Success = 0,
        SuccessButLowStorage = 1,
        FailForLowStorage = 2,
        FailForInvalidParam = 3,
        Fail = 4,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::SuccessButLowStorage => "SUCCESS_BUT_LOW_STORAGE",
                Self::FailForLowStorage => "FAIL_FOR_LOW_STORAGE",
                Self::FailForInvalidParam => "FAIL_FOR_INVALID_PARAM",
                Self::Fail => "FAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "SUCCESS_BUT_LOW_STORAGE" => Some(Self::SuccessButLowStorage),
                "FAIL_FOR_LOW_STORAGE" => Some(Self::FailForLowStorage),
                "FAIL_FOR_INVALID_PARAM" => Some(Self::FailForInvalidParam),
                "FAIL" => Some(Self::Fail),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BgImageResult {
    #[prost(enumeration = "bg_image_result::Code", required, tag = "1")]
    pub code: i32,
    #[prost(string, required, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub background_image: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BgImageResult`.
pub mod bg_image_result {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Success = 0,
        ImageSaveFailed = 1,
        ImageResolveFailed = 2,
        NoWatchFaceMatched = 3,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::ImageSaveFailed => "IMAGE_SAVE_FAILED",
                Self::ImageResolveFailed => "IMAGE_RESOLVE_FAILED",
                Self::NoWatchFaceMatched => "NO_WATCH_FACE_MATCHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "IMAGE_SAVE_FAILED" => Some(Self::ImageSaveFailed),
                "IMAGE_RESOLVE_FAILED" => Some(Self::ImageResolveFailed),
                "NO_WATCH_FACE_MATCHED" => Some(Self::NoWatchFaceMatched),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FontResult {
    #[prost(uint32, required, tag = "1")]
    pub code: u32,
    #[prost(string, required, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nfc {
    #[prost(
        oneof = "nfc::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19"
    )]
    pub payload: ::core::option::Option<nfc::Payload>,
}
/// Nested message and enum types in `Nfc`.
pub mod nfc {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NfcId {
        Command = 0,
        IssueCard = 1,
        AddCard = 2,
        DelCard = 3,
        SyncCardList = 4,
        SetDefaultCard = 5,
        GetDefaultCard = 6,
        SetBalance = 7,
        GetBalance = 8,
        SetConfig = 9,
        CapabilitySet = 10,
        CommandBatch = 16,
        GetCardSwitcherTime = 11,
        UpdateCardSwitcherTime = 12,
        AddCardSwitcherTime = 13,
        RemoveCardSwitcherTime = 14,
        GetCardSwitcherSmart = 21,
        SetCardSwitcherSmart = 22,
        NotifyCardStick = 15,
        OpenTai = 17,
        ProbeSector = 18,
        CloseTai = 19,
        CrackSectors = 20,
    }
    impl NfcId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Command => "COMMAND",
                Self::IssueCard => "ISSUE_CARD",
                Self::AddCard => "ADD_CARD",
                Self::DelCard => "DEL_CARD",
                Self::SyncCardList => "SYNC_CARD_LIST",
                Self::SetDefaultCard => "SET_DEFAULT_CARD",
                Self::GetDefaultCard => "GET_DEFAULT_CARD",
                Self::SetBalance => "SET_BALANCE",
                Self::GetBalance => "GET_BALANCE",
                Self::SetConfig => "SET_CONFIG",
                Self::CapabilitySet => "CAPABILITY_SET",
                Self::CommandBatch => "COMMAND_BATCH",
                Self::GetCardSwitcherTime => "GET_CARD_SWITCHER_TIME",
                Self::UpdateCardSwitcherTime => "UPDATE_CARD_SWITCHER_TIME",
                Self::AddCardSwitcherTime => "ADD_CARD_SWITCHER_TIME",
                Self::RemoveCardSwitcherTime => "REMOVE_CARD_SWITCHER_TIME",
                Self::GetCardSwitcherSmart => "GET_CARD_SWITCHER_SMART",
                Self::SetCardSwitcherSmart => "SET_CARD_SWITCHER_SMART",
                Self::NotifyCardStick => "NOTIFY_CARD_STICK",
                Self::OpenTai => "OPEN_TAI",
                Self::ProbeSector => "PROBE_SECTOR",
                Self::CloseTai => "CLOSE_TAI",
                Self::CrackSectors => "CRACK_SECTORS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMAND" => Some(Self::Command),
                "ISSUE_CARD" => Some(Self::IssueCard),
                "ADD_CARD" => Some(Self::AddCard),
                "DEL_CARD" => Some(Self::DelCard),
                "SYNC_CARD_LIST" => Some(Self::SyncCardList),
                "SET_DEFAULT_CARD" => Some(Self::SetDefaultCard),
                "GET_DEFAULT_CARD" => Some(Self::GetDefaultCard),
                "SET_BALANCE" => Some(Self::SetBalance),
                "GET_BALANCE" => Some(Self::GetBalance),
                "SET_CONFIG" => Some(Self::SetConfig),
                "CAPABILITY_SET" => Some(Self::CapabilitySet),
                "COMMAND_BATCH" => Some(Self::CommandBatch),
                "GET_CARD_SWITCHER_TIME" => Some(Self::GetCardSwitcherTime),
                "UPDATE_CARD_SWITCHER_TIME" => Some(Self::UpdateCardSwitcherTime),
                "ADD_CARD_SWITCHER_TIME" => Some(Self::AddCardSwitcherTime),
                "REMOVE_CARD_SWITCHER_TIME" => Some(Self::RemoveCardSwitcherTime),
                "GET_CARD_SWITCHER_SMART" => Some(Self::GetCardSwitcherSmart),
                "SET_CARD_SWITCHER_SMART" => Some(Self::SetCardSwitcherSmart),
                "NOTIFY_CARD_STICK" => Some(Self::NotifyCardStick),
                "OPEN_TAI" => Some(Self::OpenTai),
                "PROBE_SECTOR" => Some(Self::ProbeSector),
                "CLOSE_TAI" => Some(Self::CloseTai),
                "CRACK_SECTORS" => Some(Self::CrackSectors),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(bytes, tag = "1")]
        Command(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "2")]
        IssueCard(super::IssueCard),
        #[prost(message, tag = "3")]
        CardData(super::CardData),
        #[prost(message, tag = "4")]
        CardInfo(super::CardInfo),
        #[prost(message, tag = "5")]
        CardInfoList(super::card_info::List),
        #[prost(string, tag = "6")]
        Aid(::prost::alloc::string::String),
        #[prost(message, tag = "7")]
        BalanceInfo(super::BalanceInfo),
        #[prost(string, tag = "8")]
        Config(::prost::alloc::string::String),
        #[prost(message, tag = "9")]
        CommandInfoList(super::command_info::List),
        #[prost(uint32, tag = "10")]
        Capability(u32),
        #[prost(message, tag = "11")]
        CardSwitcherList(super::card_switcher::List),
        #[prost(message, tag = "12")]
        CardSwitcher(super::CardSwitcher),
        #[prost(message, tag = "13")]
        CardSwitcherResult(super::card_switcher::Result),
        #[prost(message, tag = "14")]
        SuperCardData(super::SuperCardData),
        #[prost(message, tag = "15")]
        ProbeRequest(super::probe_sector::Request),
        #[prost(message, tag = "16")]
        ProbeResponse(super::probe_sector::Response),
        #[prost(message, tag = "17")]
        KeyList(super::sector_key::List),
        #[prost(message, tag = "18")]
        CrackCardData(super::CrackCardData),
        #[prost(message, tag = "19")]
        CardSwitcherSmart(super::card_switcher::Smart),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueCard {
    #[prost(enumeration = "IssueCardStatus", required, tag = "1")]
    pub status: i32,
    #[prost(enumeration = "IssueCardType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub need_read_card: ::core::option::Option<bool>,
    #[prost(string, required, tag = "4")]
    pub icon_url: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub sid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardData {
    #[prost(bytes = "vec", required, tag = "1")]
    pub uid: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "2")]
    pub sak: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub atqa: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "4")]
    pub size: u32,
    #[prost(string, required, tag = "5")]
    pub content: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardInfo {
    #[prost(enumeration = "IssueCardType", required, tag = "1")]
    pub r#type: i32,
    #[prost(string, required, tag = "2")]
    pub aid: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub icon_url: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub sid: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "6")]
    pub balance: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "7")]
    pub support_hci: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "8")]
    pub trade_length: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub trade_offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub balance_offset: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "11")]
    pub tlv_hci_rule: ::prost::alloc::vec::Vec<card_info::TlvHciRule>,
    #[prost(string, repeated, tag = "12")]
    pub balance_command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", required, tag = "13")]
    pub car_key_id: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `CardInfo`.
pub mod card_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TlvHciRule {
        #[prost(string, required, tag = "1")]
        pub aid: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub data_offset: u32,
        #[prost(string, required, tag = "3")]
        pub hci_prefix: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "4")]
        pub trade_amount_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "5")]
        pub trade_amount_offset: ::core::option::Option<u32>,
        #[prost(string, repeated, tag = "6")]
        pub balance_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag = "7")]
        pub balance_offset: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::CardInfo>,
        #[prost(bool, optional, tag = "2")]
        pub full: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BalanceInfo {
    #[prost(string, required, tag = "1")]
    pub aid: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub balance: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandInfo {
    #[prost(bytes = "vec", required, tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, required, tag = "2")]
    pub expect_status: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CommandInfo`.
pub mod command_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::CommandInfo>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CardSwitcher {
    #[prost(string, required, tag = "1")]
    pub aid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub time: ::prost::alloc::vec::Vec<Time>,
}
/// Nested message and enum types in `CardSwitcher`.
pub mod card_switcher {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::CardSwitcher>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(uint32, required, tag = "1")]
        pub code: u32,
        #[prost(string, required, tag = "2")]
        pub conflict_aid: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Result`.
    pub mod result {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Code {
            Success = 0,
            AidNotFound = 1,
            TimeConflict = 2,
            Fail = 10,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Success => "SUCCESS",
                    Self::AidNotFound => "AID_NOT_FOUND",
                    Self::TimeConflict => "TIME_CONFLICT",
                    Self::Fail => "FAIL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUCCESS" => Some(Self::Success),
                    "AID_NOT_FOUND" => Some(Self::AidNotFound),
                    "TIME_CONFLICT" => Some(Self::TimeConflict),
                    "FAIL" => Some(Self::Fail),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Smart {
        #[prost(bool, required, tag = "1")]
        pub enabled: bool,
        #[prost(string, repeated, tag = "2")]
        pub aid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicCardData {
    #[prost(bytes = "vec", required, tag = "1")]
    pub uid: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "2")]
    pub sak: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub atqa: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "4")]
    pub size: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sector {
    #[prost(uint32, required, tag = "1")]
    pub index: u32,
    #[prost(bool, required, tag = "2")]
    pub enctypted: bool,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub key_a: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub key_b: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub content: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuperCardData {
    #[prost(message, required, tag = "1")]
    pub basic_card_data: BasicCardData,
    #[prost(message, repeated, tag = "2")]
    pub sectors: ::prost::alloc::vec::Vec<Sector>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProbeSector {}
/// Nested message and enum types in `ProbeSector`.
pub mod probe_sector {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyInfo {
        #[prost(bool, required, tag = "1")]
        pub found_key_a: bool,
        #[prost(bool, required, tag = "2")]
        pub found_key_b: bool,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub key_a_list: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(bytes = "vec", optional, tag = "4")]
        pub key_b_list: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tag {
        #[prost(uint32, required, tag = "1")]
        pub auth_uid: u32,
        #[prost(uint32, required, tag = "2")]
        pub index: u32,
        #[prost(message, required, tag = "3")]
        pub key_info: KeyInfo,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Nonce {
        #[prost(uint32, required, tag = "1")]
        pub median: u32,
        #[prost(uint32, required, tag = "2")]
        pub deviation: u32,
        #[prost(uint32, repeated, packed = "false", tag = "3")]
        pub distances: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, required, tag = "1")]
        pub median: u32,
        #[prost(uint32, required, tag = "2")]
        pub deviation: u32,
        #[prost(uint32, required, tag = "3")]
        pub nt: u32,
        #[prost(uint32, required, tag = "4")]
        pub nte: u32,
        #[prost(bytes = "vec", required, tag = "5")]
        pub parity: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(uint32, required, tag = "1")]
        pub index: u32,
        #[prost(uint32, required, tag = "2")]
        pub mode: u32,
        #[prost(message, required, tag = "3")]
        pub tag: Tag,
        #[prost(message, required, tag = "4")]
        pub nonce: Nonce,
        #[prost(bool, required, tag = "5")]
        pub dump_key_a: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(int32, required, tag = "1")]
        pub code: i32,
        #[prost(message, optional, tag = "2")]
        pub nonce: ::core::option::Option<Nonce>,
        #[prost(message, optional, tag = "3")]
        pub data: ::core::option::Option<Data>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SectorKey {
    #[prost(uint32, required, tag = "1")]
    pub index: u32,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `SectorKey`.
pub mod sector_key {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::SectorKey>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrackSector {
    #[prost(message, required, tag = "1")]
    pub sector: Sector,
    #[prost(uint32, required, tag = "2")]
    pub key_index: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrackCardData {
    #[prost(message, required, tag = "1")]
    pub basic_card_data: BasicCardData,
    #[prost(message, repeated, tag = "2")]
    pub crack_sectors: ::prost::alloc::vec::Vec<CrackSector>,
    #[prost(uint32, required, tag = "3")]
    pub cost_time: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IssueCardStatus {
    Start = 0,
    Continue = 3,
    Success = 1,
    Failure = 2,
}
impl IssueCardStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Start => "START",
            Self::Continue => "CONTINUE",
            Self::Success => "SUCCESS",
            Self::Failure => "FAILURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "START" => Some(Self::Start),
            "CONTINUE" => Some(Self::Continue),
            "SUCCESS" => Some(Self::Success),
            "FAILURE" => Some(Self::Failure),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IssueCardType {
    DoorCard = 0,
    BusCard = 1,
    UnionPayCard = 2,
    CloudCard = 3,
    MasterCard = 4,
    CarKey = 5,
    CarKeyIccoa = 7,
    CarKeyByd = 8,
    EasyCard = 6,
}
impl IssueCardType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DoorCard => "DOOR_CARD",
            Self::BusCard => "BUS_CARD",
            Self::UnionPayCard => "UNION_PAY_CARD",
            Self::CloudCard => "CLOUD_CARD",
            Self::MasterCard => "MASTER_CARD",
            Self::CarKey => "CAR_KEY",
            Self::CarKeyIccoa => "CAR_KEY_ICCOA",
            Self::CarKeyByd => "CAR_KEY_BYD",
            Self::EasyCard => "EASY_CARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOOR_CARD" => Some(Self::DoorCard),
            "BUS_CARD" => Some(Self::BusCard),
            "UNION_PAY_CARD" => Some(Self::UnionPayCard),
            "CLOUD_CARD" => Some(Self::CloudCard),
            "MASTER_CARD" => Some(Self::MasterCard),
            "CAR_KEY" => Some(Self::CarKey),
            "CAR_KEY_ICCOA" => Some(Self::CarKeyIccoa),
            "CAR_KEY_BYD" => Some(Self::CarKeyByd),
            "EASY_CARD" => Some(Self::EasyCard),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    #[prost(
        oneof = "notification::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16"
    )]
    pub payload: ::core::option::Option<notification::Payload>,
}
/// Nested message and enum types in `Notification`.
pub mod notification {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NotificationId {
        AddNotify = 0,
        RemoveNotify = 1,
        OpenNotify = 8,
        HangUp = 2,
        IncomingCallMute = 5,
        GetAppList = 3,
        SetApp = 4,
        GetAutoScreen = 6,
        SetAutoScreen = 7,
        GetReplyMsg = 9,
        AddReplyMsg = 10,
        RemoveReplyMsg = 11,
        UpdateReplyMsg = 12,
        ReplyMsgRequest = 13,
        ReplyMsgResult = 14,
        PrepareAppIcon = 15,
        AppIconApply = 16,
    }
    impl NotificationId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AddNotify => "ADD_NOTIFY",
                Self::RemoveNotify => "REMOVE_NOTIFY",
                Self::OpenNotify => "OPEN_NOTIFY",
                Self::HangUp => "HANG_UP",
                Self::IncomingCallMute => "INCOMING_CALL_MUTE",
                Self::GetAppList => "GET_APP_LIST",
                Self::SetApp => "SET_APP",
                Self::GetAutoScreen => "GET_AUTO_SCREEN",
                Self::SetAutoScreen => "SET_AUTO_SCREEN",
                Self::GetReplyMsg => "GET_REPLY_MSG",
                Self::AddReplyMsg => "ADD_REPLY_MSG",
                Self::RemoveReplyMsg => "REMOVE_REPLY_MSG",
                Self::UpdateReplyMsg => "UPDATE_REPLY_MSG",
                Self::ReplyMsgRequest => "REPLY_MSG_REQUEST",
                Self::ReplyMsgResult => "REPLY_MSG_RESULT",
                Self::PrepareAppIcon => "PREPARE_APP_ICON",
                Self::AppIconApply => "APP_ICON_APPLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADD_NOTIFY" => Some(Self::AddNotify),
                "REMOVE_NOTIFY" => Some(Self::RemoveNotify),
                "OPEN_NOTIFY" => Some(Self::OpenNotify),
                "HANG_UP" => Some(Self::HangUp),
                "INCOMING_CALL_MUTE" => Some(Self::IncomingCallMute),
                "GET_APP_LIST" => Some(Self::GetAppList),
                "SET_APP" => Some(Self::SetApp),
                "GET_AUTO_SCREEN" => Some(Self::GetAutoScreen),
                "SET_AUTO_SCREEN" => Some(Self::SetAutoScreen),
                "GET_REPLY_MSG" => Some(Self::GetReplyMsg),
                "ADD_REPLY_MSG" => Some(Self::AddReplyMsg),
                "REMOVE_REPLY_MSG" => Some(Self::RemoveReplyMsg),
                "UPDATE_REPLY_MSG" => Some(Self::UpdateReplyMsg),
                "REPLY_MSG_REQUEST" => Some(Self::ReplyMsgRequest),
                "REPLY_MSG_RESULT" => Some(Self::ReplyMsgResult),
                "PREPARE_APP_ICON" => Some(Self::PrepareAppIcon),
                "APP_ICON_APPLY" => Some(Self::AppIconApply),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Data(super::NotifyData),
        #[prost(message, tag = "2")]
        Id(super::NotifyId),
        #[prost(message, tag = "3")]
        DataList(super::notify_data::List),
        #[prost(message, tag = "4")]
        IdList(super::notify_id::List),
        #[prost(message, tag = "5")]
        AppInfo(super::AppInfo),
        #[prost(message, tag = "6")]
        AppInfoList(super::app_info::List),
        #[prost(bool, tag = "7")]
        EnableAutoScreen(bool),
        #[prost(enumeration = "super::reply_msg::Target", tag = "8")]
        ReplyMsgTarget(i32),
        #[prost(message, tag = "9")]
        ReplyMsg(super::ReplyMsg),
        #[prost(message, tag = "10")]
        ReplyMsgRemoval(super::reply_msg::Removal),
        #[prost(enumeration = "super::reply_msg::Result", tag = "11")]
        ReplyMsgResult(i32),
        #[prost(message, tag = "12")]
        ReplyRequest(super::ReplyRequest),
        #[prost(enumeration = "super::ReplyResult", tag = "13")]
        ReplyResult(i32),
        #[prost(message, tag = "14")]
        AppIconRequest(super::prepare_app_icon::Request),
        #[prost(message, tag = "15")]
        AppIconResponse(super::prepare_app_icon::Response),
        #[prost(message, tag = "16")]
        AppIconApply(super::AppIconApply),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyData {
    #[prost(string, required, tag = "1")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub app_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub sub_title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub date: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "7")]
    pub uid: u32,
    #[prost(string, required, tag = "9")]
    pub app_group: ::prost::alloc::string::String,
    #[prost(string, required, tag = "12")]
    pub key: ::prost::alloc::string::String,
    #[prost(enumeration = "CallType", optional, tag = "8")]
    pub call_type: ::core::option::Option<i32>,
    #[prost(string, required, tag = "10")]
    pub call_number: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "11")]
    pub support_reply: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "13")]
    pub support_open: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "14")]
    pub focus: ::core::option::Option<notify_data::Focus>,
    #[prost(message, optional, tag = "15")]
    pub focus_v2: ::core::option::Option<notify_data::FocusV2>,
}
/// Nested message and enum types in `NotifyData`.
pub mod notify_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::NotifyData>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Progress {
        #[prost(uint32, required, tag = "1")]
        pub section_count: u32,
        #[prost(uint32, required, tag = "2")]
        pub progress: u32,
        #[prost(bytes = "vec", optional, tag = "3")]
        pub color: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Text {
        #[prost(string, required, tag = "1")]
        pub chars: ::prost::alloc::string::String,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub color: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Info {
        #[prost(message, required, tag = "1")]
        pub title: Text,
        #[prost(message, optional, tag = "2")]
        pub sub_title: ::core::option::Option<Text>,
        #[prost(message, optional, tag = "3")]
        pub content: ::core::option::Option<Text>,
        #[prost(message, optional, tag = "4")]
        pub sub_content: ::core::option::Option<Text>,
        #[prost(message, optional, tag = "5")]
        pub special_title: ::core::option::Option<Text>,
        #[prost(bytes = "vec", optional, tag = "6")]
        pub special_title_bg: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Focus {
        #[prost(uint32, required, tag = "1")]
        pub style: u32,
        #[prost(message, required, tag = "2")]
        pub title: Text,
        #[prost(message, required, tag = "3")]
        pub content: Text,
        #[prost(message, required, tag = "4")]
        pub desc: Text,
        #[prost(message, optional, tag = "5")]
        pub progress: ::core::option::Option<Progress>,
        #[prost(bool, optional, tag = "6")]
        pub updatable: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "7")]
        pub sequence: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FocusV2 {
        #[prost(uint32, required, tag = "1")]
        pub scene: u32,
        #[prost(string, required, tag = "2")]
        pub ticker: ::prost::alloc::string::String,
        #[prost(message, required, tag = "3")]
        pub basic_info: Info,
        #[prost(message, optional, tag = "4")]
        pub hint_info: ::core::option::Option<Info>,
        #[prost(message, optional, tag = "5")]
        pub progress: ::core::option::Option<Progress>,
        #[prost(bool, optional, tag = "6")]
        pub updatable: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "7")]
        pub sequence: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyId {
    #[prost(uint32, required, tag = "1")]
    pub uid: u32,
    #[prost(string, required, tag = "2")]
    pub app_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub app_group: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NotifyId`.
pub mod notify_id {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::NotifyId>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyMsg {
    #[prost(enumeration = "reply_msg::Target", required, tag = "1")]
    pub target: i32,
    #[prost(string, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub support_max_numbers: ::core::option::Option<u32>,
}
/// Nested message and enum types in `ReplyMsg`.
pub mod reply_msg {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Removal {
        #[prost(enumeration = "Target", required, tag = "1")]
        pub target: i32,
        #[prost(uint32, repeated, packed = "false", tag = "2")]
        pub id: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Target {
        Sms = 1,
        Wechat = 2,
    }
    impl Target {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Sms => "SMS",
                Self::Wechat => "WECHAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SMS" => Some(Self::Sms),
                "WECHAT" => Some(Self::Wechat),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        Success = 0,
        ExceedLimit = 1,
        InvalidId = 2,
        Fail = 10,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::ExceedLimit => "EXCEED_LIMIT",
                Self::InvalidId => "INVALID_ID",
                Self::Fail => "FAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "EXCEED_LIMIT" => Some(Self::ExceedLimit),
                "INVALID_ID" => Some(Self::InvalidId),
                "FAIL" => Some(Self::Fail),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplyRequest {
    #[prost(enumeration = "reply_msg::Target", required, tag = "1")]
    pub target: i32,
    #[prost(string, required, tag = "2")]
    pub contents: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "3")]
    pub need_result: bool,
    #[prost(oneof = "reply_request::Data", tags = "4, 5")]
    pub data: ::core::option::Option<reply_request::Data>,
}
/// Nested message and enum types in `ReplyRequest`.
pub mod reply_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(string, tag = "4")]
        PhoneNumber(::prost::alloc::string::String),
        #[prost(message, tag = "5")]
        NotifyId(super::NotifyId),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrepareAppIcon {}
/// Nested message and enum types in `PrepareAppIcon`.
pub mod prepare_app_icon {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, required, tag = "1")]
        pub package_name: ::prost::alloc::string::String,
        #[prost(uint32, optional, tag = "2")]
        pub support_compress_mode: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(enumeration = "super::PrepareStatus", required, tag = "1")]
        pub prepare_status: i32,
        #[prost(enumeration = "super::ImageFormat", optional, tag = "2")]
        pub support_image_format: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag = "3")]
        pub expected_max_size: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "4")]
        pub select_compress_mode: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub expected_slice_length: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppIconApply {
    #[prost(string, required, tag = "1")]
    pub package_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppInfo {
    #[prost(uint32, required, tag = "1")]
    pub app_type: u32,
    #[prost(bool, required, tag = "2")]
    pub enable: bool,
}
/// Nested message and enum types in `AppInfo`.
pub mod app_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AppInfo>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Notification = 0,
        Call = 1,
        Wechat = 2,
        Qq = 3,
        Alipay = 4,
        Other = 5,
        Sms = 6,
        Mail = 7,
        Weibo = 8,
        Taobao = 9,
        Tiktok = 10,
        Dingding = 11,
        Mihome = 12,
        Xiaohongshu = 13,
        Pinduoduo = 14,
        Kuaishou = 15,
        Qqmusic = 16,
        Didi = 17,
        Baidumap = 18,
        Gaodemap = 19,
        Cloudmusic = 20,
        Kugou = 21,
        Baidu = 22,
        Qqmail = 23,
        Qqzone = 24,
        Tencentnews = 25,
        Toutiao = 26,
        Wework = 27,
        Meituan = 28,
        Keep = 29,
        Youku = 30,
        Qqlive = 31,
        Iqiyi = 32,
        Bilibili = 33,
        Tiktoklite = 34,
        Kusishoulite = 35,
        Ximalaya = 36,
        Weishi = 37,
        Dianping = 38,
        Meituanwm = 39,
        Eleme = 40,
        Zhihu = 41,
        Xianyu = 42,
        Taobaolite = 43,
        Jd = 44,
        Dewu = 45,
        Tmall = 46,
        Suning = 47,
        Ticket12306 = 48,
        Ccb = 49,
        Unionpay = 50,
        Cmb = 51,
        Jdjr = 52,
        Cb = 53,
        Icbc = 54,
        Zssh = 55,
        Abc = 56,
        Jtbank = 57,
        Weread = 58,
        Shuqi = 59,
        Qqbrowser = 60,
        Ucbrowser = 61,
        Soul = 62,
        Momo = 63,
        Tantan = 64,
        Douban = 65,
        Tieba = 66,
        Wuba = 67,
        Whatsapp = 68,
        Viber = 69,
        Snapchat = 70,
        Skype = 71,
        Telegram = 72,
        Fbmessenger = 73,
        Discord = 74,
        Kakao = 75,
        Vkontakte = 76,
        Line = 77,
        Twitter = 78,
        Gmail = 79,
        Outlook = 80,
        Fb = 81,
        Naver = 82,
        Hangout = 83,
        Bip = 84,
        Ok = 85,
        Sharechat = 86,
        Mamba = 87,
        Instagram = 88,
        Youtube = 89,
        Wps = 90,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Notification => "NOTIFICATION",
                Self::Call => "CALL",
                Self::Wechat => "WECHAT",
                Self::Qq => "QQ",
                Self::Alipay => "ALIPAY",
                Self::Other => "OTHER",
                Self::Sms => "SMS",
                Self::Mail => "MAIL",
                Self::Weibo => "WEIBO",
                Self::Taobao => "TAOBAO",
                Self::Tiktok => "TIKTOK",
                Self::Dingding => "DINGDING",
                Self::Mihome => "MIHOME",
                Self::Xiaohongshu => "XIAOHONGSHU",
                Self::Pinduoduo => "PINDUODUO",
                Self::Kuaishou => "KUAISHOU",
                Self::Qqmusic => "QQMUSIC",
                Self::Didi => "DIDI",
                Self::Baidumap => "BAIDUMAP",
                Self::Gaodemap => "GAODEMAP",
                Self::Cloudmusic => "CLOUDMUSIC",
                Self::Kugou => "KUGOU",
                Self::Baidu => "BAIDU",
                Self::Qqmail => "QQMAIL",
                Self::Qqzone => "QQZONE",
                Self::Tencentnews => "TENCENTNEWS",
                Self::Toutiao => "TOUTIAO",
                Self::Wework => "WEWORK",
                Self::Meituan => "MEITUAN",
                Self::Keep => "KEEP",
                Self::Youku => "YOUKU",
                Self::Qqlive => "QQLIVE",
                Self::Iqiyi => "IQIYI",
                Self::Bilibili => "BILIBILI",
                Self::Tiktoklite => "TIKTOKLITE",
                Self::Kusishoulite => "KUSISHOULITE",
                Self::Ximalaya => "XIMALAYA",
                Self::Weishi => "WEISHI",
                Self::Dianping => "DIANPING",
                Self::Meituanwm => "MEITUANWM",
                Self::Eleme => "ELEME",
                Self::Zhihu => "ZHIHU",
                Self::Xianyu => "XIANYU",
                Self::Taobaolite => "TAOBAOLITE",
                Self::Jd => "JD",
                Self::Dewu => "DEWU",
                Self::Tmall => "TMALL",
                Self::Suning => "SUNING",
                Self::Ticket12306 => "TICKET12306",
                Self::Ccb => "CCB",
                Self::Unionpay => "UNIONPAY",
                Self::Cmb => "CMB",
                Self::Jdjr => "JDJR",
                Self::Cb => "CB",
                Self::Icbc => "ICBC",
                Self::Zssh => "ZSSH",
                Self::Abc => "ABC",
                Self::Jtbank => "JTBANK",
                Self::Weread => "WEREAD",
                Self::Shuqi => "SHUQI",
                Self::Qqbrowser => "QQBROWSER",
                Self::Ucbrowser => "UCBROWSER",
                Self::Soul => "SOUL",
                Self::Momo => "MOMO",
                Self::Tantan => "TANTAN",
                Self::Douban => "DOUBAN",
                Self::Tieba => "TIEBA",
                Self::Wuba => "WUBA",
                Self::Whatsapp => "WHATSAPP",
                Self::Viber => "VIBER",
                Self::Snapchat => "SNAPCHAT",
                Self::Skype => "SKYPE",
                Self::Telegram => "TELEGRAM",
                Self::Fbmessenger => "FBMESSENGER",
                Self::Discord => "DISCORD",
                Self::Kakao => "KAKAO",
                Self::Vkontakte => "VKONTAKTE",
                Self::Line => "LINE",
                Self::Twitter => "TWITTER",
                Self::Gmail => "GMAIL",
                Self::Outlook => "OUTLOOK",
                Self::Fb => "FB",
                Self::Naver => "NAVER",
                Self::Hangout => "HANGOUT",
                Self::Bip => "BIP",
                Self::Ok => "OK",
                Self::Sharechat => "SHARECHAT",
                Self::Mamba => "MAMBA",
                Self::Instagram => "INSTAGRAM",
                Self::Youtube => "YOUTUBE",
                Self::Wps => "WPS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOTIFICATION" => Some(Self::Notification),
                "CALL" => Some(Self::Call),
                "WECHAT" => Some(Self::Wechat),
                "QQ" => Some(Self::Qq),
                "ALIPAY" => Some(Self::Alipay),
                "OTHER" => Some(Self::Other),
                "SMS" => Some(Self::Sms),
                "MAIL" => Some(Self::Mail),
                "WEIBO" => Some(Self::Weibo),
                "TAOBAO" => Some(Self::Taobao),
                "TIKTOK" => Some(Self::Tiktok),
                "DINGDING" => Some(Self::Dingding),
                "MIHOME" => Some(Self::Mihome),
                "XIAOHONGSHU" => Some(Self::Xiaohongshu),
                "PINDUODUO" => Some(Self::Pinduoduo),
                "KUAISHOU" => Some(Self::Kuaishou),
                "QQMUSIC" => Some(Self::Qqmusic),
                "DIDI" => Some(Self::Didi),
                "BAIDUMAP" => Some(Self::Baidumap),
                "GAODEMAP" => Some(Self::Gaodemap),
                "CLOUDMUSIC" => Some(Self::Cloudmusic),
                "KUGOU" => Some(Self::Kugou),
                "BAIDU" => Some(Self::Baidu),
                "QQMAIL" => Some(Self::Qqmail),
                "QQZONE" => Some(Self::Qqzone),
                "TENCENTNEWS" => Some(Self::Tencentnews),
                "TOUTIAO" => Some(Self::Toutiao),
                "WEWORK" => Some(Self::Wework),
                "MEITUAN" => Some(Self::Meituan),
                "KEEP" => Some(Self::Keep),
                "YOUKU" => Some(Self::Youku),
                "QQLIVE" => Some(Self::Qqlive),
                "IQIYI" => Some(Self::Iqiyi),
                "BILIBILI" => Some(Self::Bilibili),
                "TIKTOKLITE" => Some(Self::Tiktoklite),
                "KUSISHOULITE" => Some(Self::Kusishoulite),
                "XIMALAYA" => Some(Self::Ximalaya),
                "WEISHI" => Some(Self::Weishi),
                "DIANPING" => Some(Self::Dianping),
                "MEITUANWM" => Some(Self::Meituanwm),
                "ELEME" => Some(Self::Eleme),
                "ZHIHU" => Some(Self::Zhihu),
                "XIANYU" => Some(Self::Xianyu),
                "TAOBAOLITE" => Some(Self::Taobaolite),
                "JD" => Some(Self::Jd),
                "DEWU" => Some(Self::Dewu),
                "TMALL" => Some(Self::Tmall),
                "SUNING" => Some(Self::Suning),
                "TICKET12306" => Some(Self::Ticket12306),
                "CCB" => Some(Self::Ccb),
                "UNIONPAY" => Some(Self::Unionpay),
                "CMB" => Some(Self::Cmb),
                "JDJR" => Some(Self::Jdjr),
                "CB" => Some(Self::Cb),
                "ICBC" => Some(Self::Icbc),
                "ZSSH" => Some(Self::Zssh),
                "ABC" => Some(Self::Abc),
                "JTBANK" => Some(Self::Jtbank),
                "WEREAD" => Some(Self::Weread),
                "SHUQI" => Some(Self::Shuqi),
                "QQBROWSER" => Some(Self::Qqbrowser),
                "UCBROWSER" => Some(Self::Ucbrowser),
                "SOUL" => Some(Self::Soul),
                "MOMO" => Some(Self::Momo),
                "TANTAN" => Some(Self::Tantan),
                "DOUBAN" => Some(Self::Douban),
                "TIEBA" => Some(Self::Tieba),
                "WUBA" => Some(Self::Wuba),
                "WHATSAPP" => Some(Self::Whatsapp),
                "VIBER" => Some(Self::Viber),
                "SNAPCHAT" => Some(Self::Snapchat),
                "SKYPE" => Some(Self::Skype),
                "TELEGRAM" => Some(Self::Telegram),
                "FBMESSENGER" => Some(Self::Fbmessenger),
                "DISCORD" => Some(Self::Discord),
                "KAKAO" => Some(Self::Kakao),
                "VKONTAKTE" => Some(Self::Vkontakte),
                "LINE" => Some(Self::Line),
                "TWITTER" => Some(Self::Twitter),
                "GMAIL" => Some(Self::Gmail),
                "OUTLOOK" => Some(Self::Outlook),
                "FB" => Some(Self::Fb),
                "NAVER" => Some(Self::Naver),
                "HANGOUT" => Some(Self::Hangout),
                "BIP" => Some(Self::Bip),
                "OK" => Some(Self::Ok),
                "SHARECHAT" => Some(Self::Sharechat),
                "MAMBA" => Some(Self::Mamba),
                "INSTAGRAM" => Some(Self::Instagram),
                "YOUTUBE" => Some(Self::Youtube),
                "WPS" => Some(Self::Wps),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CallType {
    Nothing = 0,
    IncomingCall = 1,
    MissedCall = 2,
    OutgoingCall = 3,
}
impl CallType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Nothing => "NOTHING",
            Self::IncomingCall => "INCOMING_CALL",
            Self::MissedCall => "MISSED_CALL",
            Self::OutgoingCall => "OUTGOING_CALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOTHING" => Some(Self::Nothing),
            "INCOMING_CALL" => Some(Self::IncomingCall),
            "MISSED_CALL" => Some(Self::MissedCall),
            "OUTGOING_CALL" => Some(Self::OutgoingCall),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplyResult {
    ReplySuccess = 0,
    TargetNotSupport = 1,
    NotifyNotFound = 2,
    NoReplyPermission = 3,
    ReplyFail = 4,
}
impl ReplyResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReplySuccess => "REPLY_SUCCESS",
            Self::TargetNotSupport => "TARGET_NOT_SUPPORT",
            Self::NotifyNotFound => "NOTIFY_NOT_FOUND",
            Self::NoReplyPermission => "NO_REPLY_PERMISSION",
            Self::ReplyFail => "REPLY_FAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLY_SUCCESS" => Some(Self::ReplySuccess),
            "TARGET_NOT_SUPPORT" => Some(Self::TargetNotSupport),
            "NOTIFY_NOT_FOUND" => Some(Self::NotifyNotFound),
            "NO_REPLY_PERMISSION" => Some(Self::NoReplyPermission),
            "REPLY_FAIL" => Some(Self::ReplyFail),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fitness {
    #[prost(
        oneof = "fitness::Payload",
        tags = "1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70"
    )]
    pub payload: ::core::option::Option<fitness::Payload>,
}
/// Nested message and enum types in `Fitness`.
pub mod fitness {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FitnessId {
        SetUserProfile = 0,
        RequestUserProfile = 7,
        GetTodayFitnessIds = 1,
        GetHistoryFitnessIds = 2,
        RequestFitnessIds = 3,
        RequestFitnessId = 4,
        ConfirmFitnessId = 5,
        GetRemainingSportData = 6,
        GetBloodOxygenMonitor = 8,
        SetBloodOxygenMonitor = 9,
        GetHeartRateMonitor = 10,
        SetHeartRateMonitor = 11,
        GetSedentaryReminder = 12,
        SetSedentaryReminder = 13,
        GetPressureMonitor = 14,
        SetPressureMonitor = 15,
        GetBloodPressureReminder = 16,
        SetBloodPressureReminder = 17,
        GetEcgReminder = 18,
        SetEcgReminder = 19,
        CheckEcgActivation = 54,
        ActivateEcg = 55,
        DeactivateEcg = 85,
        StartPressureCalibrate = 23,
        StopPressureCalibrate = 24,
        CompletePressureCalibrate = 25,
        SportRequest = 26,
        PhoneSportData = 27,
        WearSportData = 28,
        GetSportStatus = 29,
        SportPreRequest = 30,
        EcgRequest = 32,
        ReportEcgData = 33,
        ReportEcgStatus = 34,
        GetWomenHealth = 20,
        RequestWomenHealth = 37,
        SyncWomenHealth = 38,
        SetWomenHealthForcast = 39,
        SetWomenHealthReminder = 40,
        SyncSleepResult = 41,
        GetGoalStatus = 42,
        SetGoalStatus = 43,
        GetBasicData = 44,
        RegisterBasicDataReport = 45,
        UnregisterBasicDataReport = 46,
        ReportBasicData = 47,
        SyncVitalityData = 51,
        SyncBestSportData = 52,
        GetVitalityReminder = 21,
        SetVitalityReminder = 22,
        GetActivityReminder = 35,
        SetActivityReminder = 36,
        PhoneSportDataV2d = 48,
        PhoneSportDataV2a = 49,
        WearSportDataV2a = 50,
        WearSensorData = 53,
        MotionInteract = 56,
        PhoneControlData = 83,
        WearControlData = 84,
        GymRequest = 64,
        GymAssist = 65,
        GymData = 66,
        GetGymSettings = 67,
        SetGymSettings = 68,
        GetNaviRoutes = 57,
        AddNaviRoute = 58,
        ReportAddRouteResult = 59,
        RemoveNaveRoutes = 60,
        GetSleepRegularity = 61,
        SetSleepRegularity = 62,
        GetSleepDisorder = 63,
        SetSleepDisorder = 69,
        SetResearchUserProfile = 70,
        GetTodayResearchIds = 71,
        GetHistoryResearchIds = 72,
        RequestResearchIds = 73,
        RequestResearchId = 74,
        ConfirmResearchId = 75,
        UpdateAppResearch = 76,
        SyncAppResearchList = 77,
        GetDeviceResearchList = 78,
        RequestResearchCalibration = 79,
        ReportResearchCalibrationStep1 = 80,
        ReportResearchCalibrationStep2 = 81,
        ReportResearchCalibration = 89,
        SetBpResearch = 82,
        RequestBpgCalibration = 90,
        GetBpgCalibStatus = 91,
        GetTrainingStatus = 86,
        SyncTrainingPlan = 87,
        StopTrainingPlan = 88,
    }
    impl FitnessId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SetUserProfile => "SET_USER_PROFILE",
                Self::RequestUserProfile => "REQUEST_USER_PROFILE",
                Self::GetTodayFitnessIds => "GET_TODAY_FITNESS_IDS",
                Self::GetHistoryFitnessIds => "GET_HISTORY_FITNESS_IDS",
                Self::RequestFitnessIds => "REQUEST_FITNESS_IDS",
                Self::RequestFitnessId => "REQUEST_FITNESS_ID",
                Self::ConfirmFitnessId => "CONFIRM_FITNESS_ID",
                Self::GetRemainingSportData => "GET_REMAINING_SPORT_DATA",
                Self::GetBloodOxygenMonitor => "GET_BLOOD_OXYGEN_MONITOR",
                Self::SetBloodOxygenMonitor => "SET_BLOOD_OXYGEN_MONITOR",
                Self::GetHeartRateMonitor => "GET_HEART_RATE_MONITOR",
                Self::SetHeartRateMonitor => "SET_HEART_RATE_MONITOR",
                Self::GetSedentaryReminder => "GET_SEDENTARY_REMINDER",
                Self::SetSedentaryReminder => "SET_SEDENTARY_REMINDER",
                Self::GetPressureMonitor => "GET_PRESSURE_MONITOR",
                Self::SetPressureMonitor => "SET_PRESSURE_MONITOR",
                Self::GetBloodPressureReminder => "GET_BLOOD_PRESSURE_REMINDER",
                Self::SetBloodPressureReminder => "SET_BLOOD_PRESSURE_REMINDER",
                Self::GetEcgReminder => "GET_ECG_REMINDER",
                Self::SetEcgReminder => "SET_ECG_REMINDER",
                Self::CheckEcgActivation => "CHECK_ECG_ACTIVATION",
                Self::ActivateEcg => "ACTIVATE_ECG",
                Self::DeactivateEcg => "DEACTIVATE_ECG",
                Self::StartPressureCalibrate => "START_PRESSURE_CALIBRATE",
                Self::StopPressureCalibrate => "STOP_PRESSURE_CALIBRATE",
                Self::CompletePressureCalibrate => "COMPLETE_PRESSURE_CALIBRATE",
                Self::SportRequest => "SPORT_REQUEST",
                Self::PhoneSportData => "PHONE_SPORT_DATA",
                Self::WearSportData => "WEAR_SPORT_DATA",
                Self::GetSportStatus => "GET_SPORT_STATUS",
                Self::SportPreRequest => "SPORT_PRE_REQUEST",
                Self::EcgRequest => "ECG_REQUEST",
                Self::ReportEcgData => "REPORT_ECG_DATA",
                Self::ReportEcgStatus => "REPORT_ECG_STATUS",
                Self::GetWomenHealth => "GET_WOMEN_HEALTH",
                Self::RequestWomenHealth => "REQUEST_WOMEN_HEALTH",
                Self::SyncWomenHealth => "SYNC_WOMEN_HEALTH",
                Self::SetWomenHealthForcast => "SET_WOMEN_HEALTH_FORCAST",
                Self::SetWomenHealthReminder => "SET_WOMEN_HEALTH_REMINDER",
                Self::SyncSleepResult => "SYNC_SLEEP_RESULT",
                Self::GetGoalStatus => "GET_GOAL_STATUS",
                Self::SetGoalStatus => "SET_GOAL_STATUS",
                Self::GetBasicData => "GET_BASIC_DATA",
                Self::RegisterBasicDataReport => "REGISTER_BASIC_DATA_REPORT",
                Self::UnregisterBasicDataReport => "UNREGISTER_BASIC_DATA_REPORT",
                Self::ReportBasicData => "REPORT_BASIC_DATA",
                Self::SyncVitalityData => "SYNC_VITALITY_DATA",
                Self::SyncBestSportData => "SYNC_BEST_SPORT_DATA",
                Self::GetVitalityReminder => "GET_VITALITY_REMINDER",
                Self::SetVitalityReminder => "SET_VITALITY_REMINDER",
                Self::GetActivityReminder => "GET_ACTIVITY_REMINDER",
                Self::SetActivityReminder => "SET_ACTIVITY_REMINDER",
                Self::PhoneSportDataV2d => "PHONE_SPORT_DATA_V2D",
                Self::PhoneSportDataV2a => "PHONE_SPORT_DATA_V2A",
                Self::WearSportDataV2a => "WEAR_SPORT_DATA_V2A",
                Self::WearSensorData => "WEAR_SENSOR_DATA",
                Self::MotionInteract => "MOTION_INTERACT",
                Self::PhoneControlData => "PHONE_CONTROL_DATA",
                Self::WearControlData => "WEAR_CONTROL_DATA",
                Self::GymRequest => "GYM_REQUEST",
                Self::GymAssist => "GYM_ASSIST",
                Self::GymData => "GYM_DATA",
                Self::GetGymSettings => "GET_GYM_SETTINGS",
                Self::SetGymSettings => "SET_GYM_SETTINGS",
                Self::GetNaviRoutes => "GET_NAVI_ROUTES",
                Self::AddNaviRoute => "ADD_NAVI_ROUTE",
                Self::ReportAddRouteResult => "REPORT_ADD_ROUTE_RESULT",
                Self::RemoveNaveRoutes => "REMOVE_NAVE_ROUTES",
                Self::GetSleepRegularity => "GET_SLEEP_REGULARITY",
                Self::SetSleepRegularity => "SET_SLEEP_REGULARITY",
                Self::GetSleepDisorder => "GET_SLEEP_DISORDER",
                Self::SetSleepDisorder => "SET_SLEEP_DISORDER",
                Self::SetResearchUserProfile => "SET_RESEARCH_USER_PROFILE",
                Self::GetTodayResearchIds => "GET_TODAY_RESEARCH_IDS",
                Self::GetHistoryResearchIds => "GET_HISTORY_RESEARCH_IDS",
                Self::RequestResearchIds => "REQUEST_RESEARCH_IDS",
                Self::RequestResearchId => "REQUEST_RESEARCH_ID",
                Self::ConfirmResearchId => "CONFIRM_RESEARCH_ID",
                Self::UpdateAppResearch => "UPDATE_APP_RESEARCH",
                Self::SyncAppResearchList => "SYNC_APP_RESEARCH_LIST",
                Self::GetDeviceResearchList => "GET_DEVICE_RESEARCH_LIST",
                Self::RequestResearchCalibration => "REQUEST_RESEARCH_CALIBRATION",
                Self::ReportResearchCalibrationStep1 => {
                    "REPORT_RESEARCH_CALIBRATION_STEP1"
                }
                Self::ReportResearchCalibrationStep2 => {
                    "REPORT_RESEARCH_CALIBRATION_STEP2"
                }
                Self::ReportResearchCalibration => "REPORT_RESEARCH_CALIBRATION",
                Self::SetBpResearch => "SET_BP_RESEARCH",
                Self::RequestBpgCalibration => "REQUEST_BPG_CALIBRATION",
                Self::GetBpgCalibStatus => "GET_BPG_CALIB_STATUS",
                Self::GetTrainingStatus => "GET_TRAINING_STATUS",
                Self::SyncTrainingPlan => "SYNC_TRAINING_PLAN",
                Self::StopTrainingPlan => "STOP_TRAINING_PLAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SET_USER_PROFILE" => Some(Self::SetUserProfile),
                "REQUEST_USER_PROFILE" => Some(Self::RequestUserProfile),
                "GET_TODAY_FITNESS_IDS" => Some(Self::GetTodayFitnessIds),
                "GET_HISTORY_FITNESS_IDS" => Some(Self::GetHistoryFitnessIds),
                "REQUEST_FITNESS_IDS" => Some(Self::RequestFitnessIds),
                "REQUEST_FITNESS_ID" => Some(Self::RequestFitnessId),
                "CONFIRM_FITNESS_ID" => Some(Self::ConfirmFitnessId),
                "GET_REMAINING_SPORT_DATA" => Some(Self::GetRemainingSportData),
                "GET_BLOOD_OXYGEN_MONITOR" => Some(Self::GetBloodOxygenMonitor),
                "SET_BLOOD_OXYGEN_MONITOR" => Some(Self::SetBloodOxygenMonitor),
                "GET_HEART_RATE_MONITOR" => Some(Self::GetHeartRateMonitor),
                "SET_HEART_RATE_MONITOR" => Some(Self::SetHeartRateMonitor),
                "GET_SEDENTARY_REMINDER" => Some(Self::GetSedentaryReminder),
                "SET_SEDENTARY_REMINDER" => Some(Self::SetSedentaryReminder),
                "GET_PRESSURE_MONITOR" => Some(Self::GetPressureMonitor),
                "SET_PRESSURE_MONITOR" => Some(Self::SetPressureMonitor),
                "GET_BLOOD_PRESSURE_REMINDER" => Some(Self::GetBloodPressureReminder),
                "SET_BLOOD_PRESSURE_REMINDER" => Some(Self::SetBloodPressureReminder),
                "GET_ECG_REMINDER" => Some(Self::GetEcgReminder),
                "SET_ECG_REMINDER" => Some(Self::SetEcgReminder),
                "CHECK_ECG_ACTIVATION" => Some(Self::CheckEcgActivation),
                "ACTIVATE_ECG" => Some(Self::ActivateEcg),
                "DEACTIVATE_ECG" => Some(Self::DeactivateEcg),
                "START_PRESSURE_CALIBRATE" => Some(Self::StartPressureCalibrate),
                "STOP_PRESSURE_CALIBRATE" => Some(Self::StopPressureCalibrate),
                "COMPLETE_PRESSURE_CALIBRATE" => Some(Self::CompletePressureCalibrate),
                "SPORT_REQUEST" => Some(Self::SportRequest),
                "PHONE_SPORT_DATA" => Some(Self::PhoneSportData),
                "WEAR_SPORT_DATA" => Some(Self::WearSportData),
                "GET_SPORT_STATUS" => Some(Self::GetSportStatus),
                "SPORT_PRE_REQUEST" => Some(Self::SportPreRequest),
                "ECG_REQUEST" => Some(Self::EcgRequest),
                "REPORT_ECG_DATA" => Some(Self::ReportEcgData),
                "REPORT_ECG_STATUS" => Some(Self::ReportEcgStatus),
                "GET_WOMEN_HEALTH" => Some(Self::GetWomenHealth),
                "REQUEST_WOMEN_HEALTH" => Some(Self::RequestWomenHealth),
                "SYNC_WOMEN_HEALTH" => Some(Self::SyncWomenHealth),
                "SET_WOMEN_HEALTH_FORCAST" => Some(Self::SetWomenHealthForcast),
                "SET_WOMEN_HEALTH_REMINDER" => Some(Self::SetWomenHealthReminder),
                "SYNC_SLEEP_RESULT" => Some(Self::SyncSleepResult),
                "GET_GOAL_STATUS" => Some(Self::GetGoalStatus),
                "SET_GOAL_STATUS" => Some(Self::SetGoalStatus),
                "GET_BASIC_DATA" => Some(Self::GetBasicData),
                "REGISTER_BASIC_DATA_REPORT" => Some(Self::RegisterBasicDataReport),
                "UNREGISTER_BASIC_DATA_REPORT" => Some(Self::UnregisterBasicDataReport),
                "REPORT_BASIC_DATA" => Some(Self::ReportBasicData),
                "SYNC_VITALITY_DATA" => Some(Self::SyncVitalityData),
                "SYNC_BEST_SPORT_DATA" => Some(Self::SyncBestSportData),
                "GET_VITALITY_REMINDER" => Some(Self::GetVitalityReminder),
                "SET_VITALITY_REMINDER" => Some(Self::SetVitalityReminder),
                "GET_ACTIVITY_REMINDER" => Some(Self::GetActivityReminder),
                "SET_ACTIVITY_REMINDER" => Some(Self::SetActivityReminder),
                "PHONE_SPORT_DATA_V2D" => Some(Self::PhoneSportDataV2d),
                "PHONE_SPORT_DATA_V2A" => Some(Self::PhoneSportDataV2a),
                "WEAR_SPORT_DATA_V2A" => Some(Self::WearSportDataV2a),
                "WEAR_SENSOR_DATA" => Some(Self::WearSensorData),
                "MOTION_INTERACT" => Some(Self::MotionInteract),
                "PHONE_CONTROL_DATA" => Some(Self::PhoneControlData),
                "WEAR_CONTROL_DATA" => Some(Self::WearControlData),
                "GYM_REQUEST" => Some(Self::GymRequest),
                "GYM_ASSIST" => Some(Self::GymAssist),
                "GYM_DATA" => Some(Self::GymData),
                "GET_GYM_SETTINGS" => Some(Self::GetGymSettings),
                "SET_GYM_SETTINGS" => Some(Self::SetGymSettings),
                "GET_NAVI_ROUTES" => Some(Self::GetNaviRoutes),
                "ADD_NAVI_ROUTE" => Some(Self::AddNaviRoute),
                "REPORT_ADD_ROUTE_RESULT" => Some(Self::ReportAddRouteResult),
                "REMOVE_NAVE_ROUTES" => Some(Self::RemoveNaveRoutes),
                "GET_SLEEP_REGULARITY" => Some(Self::GetSleepRegularity),
                "SET_SLEEP_REGULARITY" => Some(Self::SetSleepRegularity),
                "GET_SLEEP_DISORDER" => Some(Self::GetSleepDisorder),
                "SET_SLEEP_DISORDER" => Some(Self::SetSleepDisorder),
                "SET_RESEARCH_USER_PROFILE" => Some(Self::SetResearchUserProfile),
                "GET_TODAY_RESEARCH_IDS" => Some(Self::GetTodayResearchIds),
                "GET_HISTORY_RESEARCH_IDS" => Some(Self::GetHistoryResearchIds),
                "REQUEST_RESEARCH_IDS" => Some(Self::RequestResearchIds),
                "REQUEST_RESEARCH_ID" => Some(Self::RequestResearchId),
                "CONFIRM_RESEARCH_ID" => Some(Self::ConfirmResearchId),
                "UPDATE_APP_RESEARCH" => Some(Self::UpdateAppResearch),
                "SYNC_APP_RESEARCH_LIST" => Some(Self::SyncAppResearchList),
                "GET_DEVICE_RESEARCH_LIST" => Some(Self::GetDeviceResearchList),
                "REQUEST_RESEARCH_CALIBRATION" => Some(Self::RequestResearchCalibration),
                "REPORT_RESEARCH_CALIBRATION_STEP1" => {
                    Some(Self::ReportResearchCalibrationStep1)
                }
                "REPORT_RESEARCH_CALIBRATION_STEP2" => {
                    Some(Self::ReportResearchCalibrationStep2)
                }
                "REPORT_RESEARCH_CALIBRATION" => Some(Self::ReportResearchCalibration),
                "SET_BP_RESEARCH" => Some(Self::SetBpResearch),
                "REQUEST_BPG_CALIBRATION" => Some(Self::RequestBpgCalibration),
                "GET_BPG_CALIB_STATUS" => Some(Self::GetBpgCalibStatus),
                "GET_TRAINING_STATUS" => Some(Self::GetTrainingStatus),
                "SYNC_TRAINING_PLAN" => Some(Self::SyncTrainingPlan),
                "STOP_TRAINING_PLAN" => Some(Self::StopTrainingPlan),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        UserProfile(super::UserProfile),
        #[prost(bytes, tag = "2")]
        Ids(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "3")]
        Id(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "4")]
        RemainingSportDataList(super::remaining_sport_data::List),
        #[prost(message, tag = "5")]
        SyncParam(super::SyncParam),
        #[prost(message, tag = "7")]
        BloodOxygenMonitor(super::BloodOxygenMonitor),
        #[prost(message, tag = "8")]
        HeartRateMonitor(super::HeartRateMonitor),
        #[prost(message, tag = "9")]
        SedentaryReminder(super::SedentaryReminder),
        #[prost(message, tag = "10")]
        PressureMonitor(super::PressureMonitor),
        #[prost(message, tag = "11")]
        MeasureReminder(super::MeasureReminder),
        #[prost(message, tag = "12")]
        SectionList(super::women_health::section::List),
        #[prost(message, tag = "13")]
        VitalityReminder(super::VitalityReminder),
        #[prost(message, tag = "14")]
        ActivityReminder(super::ActivityReminder),
        #[prost(message, tag = "15")]
        WearSensorData(super::WearSensorData),
        #[prost(message, tag = "17")]
        PressurCalibrateResponse(super::pressure_calibrate::Response),
        #[prost(message, tag = "18")]
        EvaluationResult(super::pressure_calibrate::EvaluationResult),
        #[prost(message, tag = "19")]
        CalibrationResult(super::pressure_calibrate::CalibrationResult),
        #[prost(message, tag = "20")]
        SportRequest(super::SportRequest),
        #[prost(message, tag = "21")]
        SportResponse(super::SportResponse),
        #[prost(message, tag = "22")]
        PhoneSportData(super::PhoneSportData),
        #[prost(message, tag = "23")]
        WearSportData(super::WearSportData),
        #[prost(message, tag = "24")]
        SportStatus(super::SportStatus),
        #[prost(message, tag = "25")]
        SportPreRequest(super::SportPreRequest),
        #[prost(message, tag = "26")]
        SportPreResponse(super::SportPreResponse),
        #[prost(message, tag = "27")]
        EcgRequest(super::EcgRequest),
        #[prost(message, tag = "28")]
        EcgResponse(super::EcgResponse),
        #[prost(message, tag = "29")]
        EcgData(super::EcgData),
        #[prost(message, tag = "30")]
        EcgStatus(super::EcgStatus),
        #[prost(message, tag = "34")]
        WomenHealth(super::WomenHealth),
        #[prost(bool, tag = "35")]
        ForcastOn(bool),
        #[prost(message, tag = "36")]
        ReminderList(super::women_health::reminder::List),
        #[prost(message, tag = "37")]
        SleepResult(super::SleepResult),
        #[prost(message, tag = "38")]
        GoalStatus(super::goal::Status),
        #[prost(message, tag = "39")]
        BasicData(super::BasicData),
        #[prost(message, tag = "40")]
        PhoneSportDataV2d(super::PhoneSportDataV2d),
        #[prost(message, tag = "41")]
        PhoneSportDataV2a(super::PhoneSportDataV2a),
        #[prost(message, tag = "42")]
        WearSportDataV2a(super::WearSportDataV2a),
        #[prost(message, tag = "43")]
        VitalityDataList(super::vitality_data::List),
        #[prost(message, tag = "44")]
        SportDataList(super::best_sport_data::List),
        #[prost(message, tag = "45")]
        EcgActivation(super::EcgActivation),
        #[prost(message, tag = "46")]
        MotionInteract(super::MotionInteract),
        #[prost(message, tag = "47")]
        NaviRouteList(super::navi_route::List),
        #[prost(message, tag = "48")]
        NaviRouteAddReqeust(super::navi_route::AddRequest),
        #[prost(message, tag = "49")]
        NaviRouteAddResponse(super::navi_route::AddResponse),
        #[prost(message, tag = "50")]
        GymRequest(super::GymRequest),
        #[prost(message, tag = "51")]
        GymResponse(super::GymResponse),
        #[prost(message, tag = "52")]
        GymAssist(super::GymAssist),
        #[prost(message, tag = "53")]
        GymData(super::GymData),
        #[prost(message, tag = "54")]
        GymSettingList(super::gym_setting::List),
        #[prost(message, tag = "55")]
        NaviRouteAddResult(super::navi_route::AddResult),
        #[prost(message, tag = "56")]
        NaviRouteRemoveReqeust(super::navi_route::RemoveRequest),
        #[prost(message, tag = "57")]
        NaviRouteRemoveResponse(super::navi_route::RemoveResponse),
        #[prost(message, tag = "58")]
        SleepRegularity(super::SleepRegularity),
        #[prost(message, tag = "59")]
        SleepDisorder(super::SleepDisorder),
        #[prost(message, tag = "60")]
        ResearchApp(super::research::App),
        #[prost(message, tag = "61")]
        ResearchAppList(super::research::app::List),
        #[prost(message, tag = "62")]
        ResearchDeviceList(super::research::device::List),
        #[prost(message, tag = "63")]
        ResearchCaliRequest(super::research::CalibrationRequest),
        #[prost(message, tag = "64")]
        ResearchCaliResponse(super::research::CalibrationResponse),
        #[prost(message, tag = "65")]
        ResearchBpSetting(super::research::BpSetting),
        #[prost(message, tag = "66")]
        PhoneControlData(super::PhoneControlData),
        #[prost(message, tag = "67")]
        WearControlData(super::WearControlData),
        #[prost(message, tag = "68")]
        Training(super::Training),
        #[prost(message, tag = "69")]
        BpgCaliRequest(super::research::BpgCalibrationRequest),
        #[prost(message, tag = "70")]
        BpgCaliStatus(super::research::BpgCalibrationStatus),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserProfile {
    #[prost(uint32, optional, tag = "1")]
    pub height: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub weight: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "3")]
    pub birth: ::core::option::Option<u32>,
    #[prost(enumeration = "Sex", optional, tag = "4")]
    pub sex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub max_hr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub goal_calorie: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub goal_step: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "8")]
    pub maximal_met: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "9")]
    pub goal_valid_stand: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub goal_sleep: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub goal_intensity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub default_height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub default_weight: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub default_birth: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub default_sex: ::core::option::Option<u32>,
    #[prost(string, required, tag = "16")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "17")]
    pub blood_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub rh_blood_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub organ_donation_volunteer: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "20")]
    pub contact: ::core::option::Option<user_profile::Contact>,
    #[prost(string, required, tag = "21")]
    pub allergy_medicine: ::prost::alloc::string::String,
    #[prost(string, required, tag = "22")]
    pub chronic_disease: ::prost::alloc::string::String,
    #[prost(string, required, tag = "23")]
    pub medical_program: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UserProfile`.
pub mod user_profile {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Contact {
        #[prost(string, required, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub number: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "3")]
        pub relation: u32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncParam {
    #[prost(uint32, required, tag = "1")]
    pub reason: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemainingSportData {
    #[prost(bytes = "vec", required, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, optional, tag = "2")]
    pub sport_course_type: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "3")]
    pub cloud_course_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "4")]
    pub duration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub distance: ::core::option::Option<u32>,
}
/// Nested message and enum types in `RemainingSportData`.
pub mod remaining_sport_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::RemainingSportData>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WarningOption {
    #[prost(bool, required, tag = "1")]
    pub warning: bool,
    #[prost(uint32, required, tag = "2")]
    pub warning_value: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BloodOxygenMonitor {
    #[prost(bool, required, tag = "1")]
    pub support_all_day: bool,
    #[prost(enumeration = "blood_oxygen_monitor::Mode", required, tag = "2")]
    pub mode: i32,
    #[prost(uint32, optional, tag = "3")]
    pub frequency: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub warning_non_sleep: ::core::option::Option<WarningOption>,
}
/// Nested message and enum types in `BloodOxygenMonitor`.
pub mod blood_oxygen_monitor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Off = 0,
        SleepOn = 1,
        AllDayOn = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Off => "OFF",
                Self::SleepOn => "SLEEP_ON",
                Self::AllDayOn => "ALL_DAY_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OFF" => Some(Self::Off),
                "SLEEP_ON" => Some(Self::SleepOn),
                "ALL_DAY_ON" => Some(Self::AllDayOn),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeartRateMonitor {
    #[prost(enumeration = "heart_rate_monitor::Mode", required, tag = "1")]
    pub mode: i32,
    #[prost(uint32, required, tag = "2")]
    pub frequency: u32,
    #[prost(bool, optional, tag = "7")]
    pub support_intelligent_monitor: ::core::option::Option<bool>,
    #[prost(bool, required, tag = "3")]
    pub warning: bool,
    #[prost(uint32, required, tag = "4")]
    pub warning_value: u32,
    #[prost(message, optional, tag = "8")]
    pub warning_low: ::core::option::Option<WarningOption>,
    #[prost(enumeration = "OptionalSwitcher", optional, tag = "10")]
    pub abnormal_cardiac: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "5")]
    pub assit_sleep: ::core::option::Option<heart_rate_monitor::AssistSleep>,
    #[prost(enumeration = "OptionalSwitcher", optional, tag = "9")]
    pub sleep_breathe_quality: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "6")]
    pub warning_sport: ::core::option::Option<WarningOption>,
    #[prost(enumeration = "OptionalSwitcher", optional, tag = "11")]
    pub sleep_breathe_rate: ::core::option::Option<i32>,
}
/// Nested message and enum types in `HeartRateMonitor`.
pub mod heart_rate_monitor {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AssistSleep {
        #[prost(bool, required, tag = "1")]
        pub on: bool,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Auto = 0,
        Off = 1,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Auto => "AUTO",
                Self::Off => "OFF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTO" => Some(Self::Auto),
                "OFF" => Some(Self::Off),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SedentaryReminder {
    #[prost(bool, required, tag = "1")]
    pub on: bool,
    #[prost(message, required, tag = "2")]
    pub start_time: Time,
    #[prost(message, required, tag = "3")]
    pub end_time: Time,
    #[prost(bool, required, tag = "4")]
    pub no_disturb_in_launch_break: bool,
    #[prost(message, optional, tag = "6")]
    pub launch_break_start_time: ::core::option::Option<Time>,
    #[prost(message, optional, tag = "7")]
    pub launch_break_end_time: ::core::option::Option<Time>,
    #[prost(enumeration = "OptionalSwitcher", optional, tag = "5")]
    pub stretch_guide: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PressureMonitor {
    #[prost(bool, required, tag = "1")]
    pub on: bool,
    #[prost(message, optional, tag = "2")]
    pub warning_non_sleep: ::core::option::Option<WarningOption>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PressureCalibrate {}
/// Nested message and enum types in `PressureCalibrate`.
pub mod pressure_calibrate {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(enumeration = "Code", required, tag = "1")]
        pub code: i32,
        #[prost(uint32, optional, tag = "2")]
        pub need_collect_time: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct EvaluationResult {
        #[prost(uint32, required, tag = "1")]
        pub value: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CalibrationResult {
        #[prost(enumeration = "Code", required, tag = "1")]
        pub code: i32,
        #[prost(uint32, optional, tag = "2")]
        pub current_pressure: ::core::option::Option<u32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Ok = 0,
        NotWearing = 1,
        InSport = 2,
        NotInCalibrating = 3,
        Unknown = 10,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::NotWearing => "NOT_WEARING",
                Self::InSport => "IN_SPORT",
                Self::NotInCalibrating => "NOT_IN_CALIBRATING",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "NOT_WEARING" => Some(Self::NotWearing),
                "IN_SPORT" => Some(Self::InSport),
                "NOT_IN_CALIBRATING" => Some(Self::NotInCalibrating),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SleepResult {
    #[prost(message, repeated, tag = "1")]
    pub section_list: ::prost::alloc::vec::Vec<sleep_result::Section>,
    #[prost(message, optional, tag = "2")]
    pub animal: ::core::option::Option<sleep_result::Animal>,
}
/// Nested message and enum types in `SleepResult`.
pub mod sleep_result {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Animal {
        #[prost(uint32, required, tag = "1")]
        pub r#type: u32,
        #[prost(uint32, optional, tag = "2")]
        pub current_progress: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub total_progress: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExtraData {
        #[prost(uint32, required, tag = "1")]
        pub bedtime: u32,
        #[prost(uint32, required, tag = "2")]
        pub sleep_time: u32,
        #[prost(uint32, required, tag = "3")]
        pub sleep_quality: u32,
        #[prost(uint32, required, tag = "4")]
        pub sleep_efficiency: u32,
        #[prost(uint32, required, tag = "5")]
        pub breathing: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Section {
        #[prost(message, required, tag = "1")]
        pub timezone: super::Timezone,
        #[prost(uint32, required, tag = "2")]
        pub valid_sleep_time: u32,
        #[prost(uint32, required, tag = "3")]
        pub sleep_timestamp: u32,
        #[prost(uint32, required, tag = "4")]
        pub wakeup_timestamp: u32,
        #[prost(uint32, required, tag = "5")]
        pub average_heart_rate: u32,
        #[prost(uint32, required, tag = "6")]
        pub average_blood_oxygen: u32,
        #[prost(message, optional, tag = "7")]
        pub extra_data: ::core::option::Option<ExtraData>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Goal {
    #[prost(enumeration = "goal::Type", required, tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `Goal`.
pub mod goal {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Status {
        #[prost(message, repeated, tag = "1")]
        pub current_goals: ::prost::alloc::vec::Vec<super::Goal>,
        #[prost(message, repeated, tag = "2")]
        pub supported_goals: ::prost::alloc::vec::Vec<super::Goal>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Step = 1,
        Calorie = 2,
        Intensity = 3,
        Stand = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Step => "STEP",
                Self::Calorie => "CALORIE",
                Self::Intensity => "INTENSITY",
                Self::Stand => "STAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STEP" => Some(Self::Step),
                "CALORIE" => Some(Self::Calorie),
                "INTENSITY" => Some(Self::Intensity),
                "STAND" => Some(Self::Stand),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BasicData {
    #[prost(uint32, required, tag = "1")]
    pub steps: u32,
    #[prost(uint32, required, tag = "2")]
    pub calories: u32,
    #[prost(uint32, optional, tag = "3")]
    pub distance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub heart_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub intensity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub valid_stand: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VitalityData {}
/// Nested message and enum types in `VitalityData`.
pub mod vitality_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(enumeration = "super::goal::Type", required, tag = "1")]
        pub r#type: i32,
        #[prost(uint32, required, tag = "2")]
        pub total: u32,
        #[prost(uint32, optional, tag = "3")]
        pub interval: ::core::option::Option<u32>,
        #[prost(uint32, repeated, packed = "false", tag = "4")]
        pub detail: ::prost::alloc::vec::Vec<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(uint32, optional, tag = "1")]
        pub timestamp: ::core::option::Option<u32>,
        #[prost(message, repeated, tag = "2")]
        pub list: ::prost::alloc::vec::Vec<Item>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BestSportData {
    #[prost(enumeration = "SportType", required, tag = "1")]
    pub sport_type: i32,
    #[prost(uint32, required, tag = "2")]
    pub duration: u32,
    #[prost(uint32, optional, tag = "3")]
    pub distance: ::core::option::Option<u32>,
}
/// Nested message and enum types in `BestSportData`.
pub mod best_sport_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub sport_data_list: ::prost::alloc::vec::Vec<super::BestSportData>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SportTarget {
    #[prost(enumeration = "SportTargetType", required, tag = "1")]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub value: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SportCourse {
    #[prost(uint32, required, tag = "1")]
    pub sport_course_type: u32,
    #[prost(uint64, optional, tag = "2")]
    pub cloud_course_id: ::core::option::Option<u64>,
    #[prost(string, required, tag = "3")]
    pub course_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SportStatus {
    #[prost(enumeration = "SportType", required, tag = "1")]
    pub sport_type: i32,
    #[prost(enumeration = "SportType", optional, tag = "11")]
    pub main_sport_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub timestamp: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub timezone: ::core::option::Option<Timezone>,
    #[prost(uint32, optional, tag = "4")]
    pub duration: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "5")]
    pub paused: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub standalone: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "7")]
    pub select_version: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "8")]
    pub app_launched: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "9")]
    pub sport_target_list: ::prost::alloc::vec::Vec<SportTarget>,
    #[prost(message, optional, tag = "10")]
    pub sport_course: ::core::option::Option<SportCourse>,
    #[prost(enumeration = "WearMode", optional, tag = "12")]
    pub wear_mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SportPreRequest {
    #[prost(enumeration = "SportType", required, tag = "1")]
    pub sport_type: i32,
    #[prost(enumeration = "SportType", optional, tag = "3")]
    pub main_sport_type: ::core::option::Option<i32>,
    #[prost(uint32, required, tag = "2")]
    pub support_versions: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SportPreResponse {
    #[prost(enumeration = "sport_response::Code", required, tag = "1")]
    pub code: i32,
    #[prost(uint32, required, tag = "2")]
    pub select_version: u32,
    #[prost(enumeration = "GpsAccuracy", optional, tag = "3")]
    pub gps_accuracy: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SportRequest {
    #[prost(uint32, required, tag = "1")]
    pub timestamp: u32,
    #[prost(message, required, tag = "2")]
    pub timezone: Timezone,
    #[prost(enumeration = "SportType", required, tag = "3")]
    pub sport_type: i32,
    #[prost(enumeration = "SportType", optional, tag = "9")]
    pub main_sport_type: ::core::option::Option<i32>,
    #[prost(enumeration = "SportState", required, tag = "4")]
    pub state: i32,
    #[prost(bytes = "vec", required, tag = "5")]
    pub ids: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, optional, tag = "6")]
    pub support_versions: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "7")]
    pub sport_target_list: ::prost::alloc::vec::Vec<SportTarget>,
    #[prost(message, optional, tag = "8")]
    pub sport_course: ::core::option::Option<SportCourse>,
    #[prost(enumeration = "WearMode", optional, tag = "10")]
    pub wear_mode: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "11")]
    pub extra_data: ::core::option::Option<SportExtraData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SportResponse {
    #[prost(enumeration = "sport_response::Code", required, tag = "1")]
    pub code: i32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub ids: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub sport_status: ::core::option::Option<SportStatus>,
    #[prost(enumeration = "GpsAccuracy", optional, tag = "4")]
    pub gps_accuracy: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "5")]
    pub select_version: ::core::option::Option<u32>,
    #[prost(enumeration = "WearMode", optional, tag = "6")]
    pub current_wear_mode: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "7")]
    pub extra_data: ::core::option::Option<SportExtraData>,
}
/// Nested message and enum types in `SportResponse`.
pub mod sport_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Ok = 0,
        Busy = 1,
        TypeNotMatch = 2,
        NoPermission = 3,
        SportNotSupport = 4,
        LackOfAccuracy = 5,
        Charging = 6,
        LowBattery = 7,
        VersionNotSupport = 8,
        ModeNotMatch = 9,
        Unknown = 10,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::Busy => "BUSY",
                Self::TypeNotMatch => "TYPE_NOT_MATCH",
                Self::NoPermission => "NO_PERMISSION",
                Self::SportNotSupport => "SPORT_NOT_SUPPORT",
                Self::LackOfAccuracy => "LACK_OF_ACCURACY",
                Self::Charging => "CHARGING",
                Self::LowBattery => "LOW_BATTERY",
                Self::VersionNotSupport => "VERSION_NOT_SUPPORT",
                Self::ModeNotMatch => "MODE_NOT_MATCH",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "BUSY" => Some(Self::Busy),
                "TYPE_NOT_MATCH" => Some(Self::TypeNotMatch),
                "NO_PERMISSION" => Some(Self::NoPermission),
                "SPORT_NOT_SUPPORT" => Some(Self::SportNotSupport),
                "LACK_OF_ACCURACY" => Some(Self::LackOfAccuracy),
                "CHARGING" => Some(Self::Charging),
                "LOW_BATTERY" => Some(Self::LowBattery),
                "VERSION_NOT_SUPPORT" => Some(Self::VersionNotSupport),
                "MODE_NOT_MATCH" => Some(Self::ModeNotMatch),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneSportData {
    #[prost(uint32, required, tag = "1")]
    pub distance: u32,
    #[prost(uint32, required, tag = "2")]
    pub pace: u32,
    #[prost(enumeration = "GpsAccuracy", required, tag = "3")]
    pub gps_accuracy: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WearSportData {
    #[prost(uint32, required, tag = "1")]
    pub steps: u32,
    #[prost(uint32, required, tag = "2")]
    pub calories: u32,
    #[prost(uint32, required, tag = "3")]
    pub heart_rate: u32,
    #[prost(uint32, optional, tag = "4")]
    pub max_heart_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub min_heart_rate: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneSportDataV2d {
    #[prost(enumeration = "GpsAccuracy", required, tag = "1")]
    pub gps_accuracy: i32,
    #[prost(uint32, required, tag = "2")]
    pub timestamp: u32,
    #[prost(double, required, tag = "3")]
    pub longitude: f64,
    #[prost(double, required, tag = "4")]
    pub latitude: f64,
    #[prost(double, optional, tag = "5")]
    pub altitude: ::core::option::Option<f64>,
    #[prost(float, optional, tag = "6")]
    pub speed: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub bearing: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "8")]
    pub horizontal_accuracy: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub vertical_accuracy: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneSportDataV2a {
    #[prost(uint32, required, tag = "1")]
    pub duration: u32,
    #[prost(uint32, required, tag = "2")]
    pub heart_rate: u32,
    #[prost(uint32, required, tag = "3")]
    pub calories: u32,
    #[prost(uint32, optional, tag = "4")]
    pub distance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub current_pace: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub average_pace: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub steps: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub stride: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub stride_frequency: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "10")]
    pub rise: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "11")]
    pub decline: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "12")]
    pub reminder_kilometre_duration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub reminder_kilometre_pace: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub reminder_pace: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub reminder_heart_rate: ::core::option::Option<u32>,
    #[prost(enumeration = "SportTargetType", optional, tag = "16")]
    pub target_type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "17")]
    pub target_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub current_value: ::core::option::Option<u32>,
    #[prost(enumeration = "HeartRateSection", optional, tag = "19")]
    pub heart_rate_section: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WearSportDataV2a {
    #[prost(uint32, required, tag = "1")]
    pub heart_rate: u32,
    #[prost(uint32, required, tag = "2")]
    pub calories: u32,
    #[prost(uint32, optional, tag = "3")]
    pub steps: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub distance: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub error_state: ::core::option::Option<wear_sport_data_v2a::ErrorState>,
    #[prost(uint32, optional, tag = "6")]
    pub stride: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub revolution_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub frequency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub run_style: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub impact: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub on_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub off_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub on_off_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub current_pace: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "15")]
    pub current_speed: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "16")]
    pub vertical_stride_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub vertical_amplitude: ::core::option::Option<u32>,
}
/// Nested message and enum types in `WearSportDataV2A`.
pub mod wear_sport_data_v2a {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ErrorState {
        #[prost(bool, optional, tag = "1")]
        pub mode_changed: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "2")]
        pub low_battery: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GymSetting {
    #[prost(enumeration = "gym_setting::Key", required, tag = "1")]
    pub key: i32,
    #[prost(sint32, required, tag = "2")]
    pub value: i32,
}
/// Nested message and enum types in `GYMSetting`.
pub mod gym_setting {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::GymSetting>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Key {
        ChildLock = 0,
        SafetyLock = 1,
        DeviceLock = 2,
        DeviceInDebugMode = 3,
        SpeedUpLimit = 4,
    }
    impl Key {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ChildLock => "CHILD_LOCK",
                Self::SafetyLock => "SAFETY_LOCK",
                Self::DeviceLock => "DEVICE_LOCK",
                Self::DeviceInDebugMode => "DEVICE_IN_DEBUG_MODE",
                Self::SpeedUpLimit => "SPEED_UP_LIMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHILD_LOCK" => Some(Self::ChildLock),
                "SAFETY_LOCK" => Some(Self::SafetyLock),
                "DEVICE_LOCK" => Some(Self::DeviceLock),
                "DEVICE_IN_DEBUG_MODE" => Some(Self::DeviceInDebugMode),
                "SPEED_UP_LIMIT" => Some(Self::SpeedUpLimit),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GymRequest {
    #[prost(uint32, required, tag = "1")]
    pub timestamp: u32,
    #[prost(message, required, tag = "2")]
    pub timezone: Timezone,
    #[prost(enumeration = "SportType", required, tag = "3")]
    pub sport_type: i32,
    #[prost(enumeration = "SportType", optional, tag = "9")]
    pub main_sport_type: ::core::option::Option<i32>,
    #[prost(enumeration = "SportState", required, tag = "4")]
    pub state: i32,
    #[prost(message, repeated, tag = "5")]
    pub sport_target_list: ::prost::alloc::vec::Vec<SportTarget>,
    #[prost(message, optional, tag = "6")]
    pub sport_course: ::core::option::Option<SportCourse>,
    #[prost(uint32, optional, tag = "7")]
    pub gym_capability: ::core::option::Option<u32>,
    #[prost(bytes = "vec", required, tag = "8")]
    pub ids: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GymResponse {
    #[prost(enumeration = "gym_response::Code", required, tag = "1")]
    pub code: i32,
    #[prost(uint32, optional, tag = "2")]
    pub gym_capability: ::core::option::Option<u32>,
    #[prost(bytes = "vec", required, tag = "3")]
    pub ids: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub sport_status: ::core::option::Option<SportStatus>,
}
/// Nested message and enum types in `GYMResponse`.
pub mod gym_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Ok = 0,
        Busy = 1,
        TypeNotMatch = 2,
        SportNotSupport = 3,
        LowBattery = 4,
        ChildLock = 5,
        SafetyLock = 6,
        DeviceLock = 7,
        DeviceInDebugMode = 8,
        DeviceInOta = 9,
        Unknown = 16,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::Busy => "BUSY",
                Self::TypeNotMatch => "TYPE_NOT_MATCH",
                Self::SportNotSupport => "SPORT_NOT_SUPPORT",
                Self::LowBattery => "LOW_BATTERY",
                Self::ChildLock => "CHILD_LOCK",
                Self::SafetyLock => "SAFETY_LOCK",
                Self::DeviceLock => "DEVICE_LOCK",
                Self::DeviceInDebugMode => "DEVICE_IN_DEBUG_MODE",
                Self::DeviceInOta => "DEVICE_IN_OTA",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "BUSY" => Some(Self::Busy),
                "TYPE_NOT_MATCH" => Some(Self::TypeNotMatch),
                "SPORT_NOT_SUPPORT" => Some(Self::SportNotSupport),
                "LOW_BATTERY" => Some(Self::LowBattery),
                "CHILD_LOCK" => Some(Self::ChildLock),
                "SAFETY_LOCK" => Some(Self::SafetyLock),
                "DEVICE_LOCK" => Some(Self::DeviceLock),
                "DEVICE_IN_DEBUG_MODE" => Some(Self::DeviceInDebugMode),
                "DEVICE_IN_OTA" => Some(Self::DeviceInOta),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GymAssist {
    #[prost(uint32, optional, tag = "1")]
    pub heart_rate: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "2")]
    pub adjust_speed: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "3")]
    pub adjust_pace: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub adjust_resistance_level: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GymData {
    #[prost(uint32, required, tag = "1")]
    pub duration: u32,
    #[prost(uint32, optional, tag = "2")]
    pub calories: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub heart_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub distance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub steps: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub step_frequency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub current_pace: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "8")]
    pub speed: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "9")]
    pub current_rpm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub revolution_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub current_power: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub current_resistance_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub jump_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub jump_height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub stumble_count: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EcgRequest {
    #[prost(enumeration = "ecg_request::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(enumeration = "ecg_request::State", required, tag = "2")]
    pub state: i32,
    #[prost(uint32, optional, tag = "3")]
    pub expected_duration: ::core::option::Option<u32>,
}
/// Nested message and enum types in `ECGRequest`.
pub mod ecg_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Handheld = 0,
        Fitting = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Handheld => "HANDHELD",
                Self::Fitting => "FITTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HANDHELD" => Some(Self::Handheld),
                "FITTING" => Some(Self::Fitting),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Start = 0,
        Stop = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Start => "START",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EcgResponse {
    #[prost(enumeration = "ecg_response::Code", required, tag = "1")]
    pub code: i32,
}
/// Nested message and enum types in `ECGResponse`.
pub mod ecg_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Ready = 0,
        Busy = 1,
        FallOff = 2,
        InSport = 3,
        Charging = 4,
        Fail = 10,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ready => "READY",
                Self::Busy => "BUSY",
                Self::FallOff => "FALL_OFF",
                Self::InSport => "IN_SPORT",
                Self::Charging => "CHARGING",
                Self::Fail => "FAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "READY" => Some(Self::Ready),
                "BUSY" => Some(Self::Busy),
                "FALL_OFF" => Some(Self::FallOff),
                "IN_SPORT" => Some(Self::InSport),
                "CHARGING" => Some(Self::Charging),
                "FAIL" => Some(Self::Fail),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EcgData {
    #[prost(bytes = "vec", required, tag = "1")]
    pub sampling_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, optional, tag = "2")]
    pub heart_rate: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EcgStatus {
    #[prost(enumeration = "ecg_status::Status", required, tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `ECGStatus`.
pub mod ecg_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        FallOff = 0,
        WearOn = 1,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FallOff => "FALL_OFF",
                Self::WearOn => "WEAR_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FALL_OFF" => Some(Self::FallOff),
                "WEAR_ON" => Some(Self::WearOn),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WomenHealth {
    #[prost(bool, required, tag = "1")]
    pub enabled: bool,
    #[prost(bool, optional, tag = "2")]
    pub forcast_on: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "3")]
    pub reminder_list: ::core::option::Option<women_health::reminder::List>,
    #[prost(message, optional, tag = "4")]
    pub data_list: ::core::option::Option<women_health::data::List>,
    #[prost(uint32, optional, tag = "5")]
    pub menstruation_days: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub menstruation_peroid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub init_timestamp: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "8")]
    pub sections: ::core::option::Option<women_health::section::List>,
}
/// Nested message and enum types in `WomenHealth`.
pub mod women_health {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Reminder {
        #[prost(enumeration = "Type", required, tag = "1")]
        pub r#type: i32,
        #[prost(uint32, required, tag = "2")]
        pub advanced_days: u32,
    }
    /// Nested message and enum types in `Reminder`.
    pub mod reminder {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Reminder>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(enumeration = "Type", required, tag = "1")]
        pub r#type: i32,
        #[prost(bool, required, tag = "2")]
        pub forcast: bool,
    }
    /// Nested message and enum types in `Data`.
    pub mod data {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(uint32, required, tag = "1")]
            pub timestamp: u32,
            #[prost(message, required, tag = "2")]
            pub timezone: super::super::Timezone,
            #[prost(message, repeated, tag = "3")]
            pub list: ::prost::alloc::vec::Vec<super::Data>,
            #[prost(uint32, optional, tag = "4")]
            pub last_timestamp: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "5")]
            pub last_days: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag = "6")]
            pub next_timestamp: ::core::option::Option<u32>,
            #[prost(enumeration = "super::Type", optional, tag = "7")]
            pub next_type: ::core::option::Option<i32>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Section {
        #[prost(uint32, required, tag = "1")]
        pub start_timestamp: u32,
        #[prost(uint32, required, tag = "2")]
        pub end_timestamp: u32,
        #[prost(uint32, required, tag = "3")]
        pub update_timestamp: u32,
        #[prost(bool, optional, tag = "4")]
        pub is_deleted: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `Section`.
    pub mod section {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Section>,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Normal = 0,
        Menstruation = 1,
        Ovulation = 2,
        EasyPregnancy = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "NORMAL",
                Self::Menstruation => "MENSTRUATION",
                Self::Ovulation => "OVULATION",
                Self::EasyPregnancy => "EASY_PREGNANCY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NORMAL" => Some(Self::Normal),
                "MENSTRUATION" => Some(Self::Menstruation),
                "OVULATION" => Some(Self::Ovulation),
                "EASY_PREGNANCY" => Some(Self::EasyPregnancy),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeasureReminder {
    #[prost(bool, required, tag = "1")]
    pub enable: bool,
    #[prost(enumeration = "measure_reminder::Category", optional, tag = "2")]
    pub category: ::core::option::Option<i32>,
    #[prost(enumeration = "ClockMode", optional, tag = "3")]
    pub clock_mode: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub week_days: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "5")]
    pub times: ::prost::alloc::vec::Vec<Time>,
}
/// Nested message and enum types in `MeasureReminder`.
pub mod measure_reminder {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Category {
        Normal = 0,
        Mild = 1,
        Serious = 2,
        Unknown = 3,
    }
    impl Category {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "NORMAL",
                Self::Mild => "MILD",
                Self::Serious => "SERIOUS",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NORMAL" => Some(Self::Normal),
                "MILD" => Some(Self::Mild),
                "SERIOUS" => Some(Self::Serious),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VitalityReminder {
    #[prost(bool, required, tag = "1")]
    pub reach_goal: bool,
    #[prost(bool, required, tag = "2")]
    pub reach_help: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActivityReminder {
    #[prost(bool, required, tag = "1")]
    pub seven_day_stage: bool,
    #[prost(bool, required, tag = "2")]
    pub day_upper_limit: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AxisSensor {
    #[prost(uint64, required, tag = "1")]
    pub timestamp: u64,
    #[prost(float, required, tag = "2")]
    pub x: f32,
    #[prost(float, required, tag = "3")]
    pub y: f32,
    #[prost(float, required, tag = "4")]
    pub z: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WearSensorData {
    #[prost(message, repeated, tag = "1")]
    pub accel: ::prost::alloc::vec::Vec<AxisSensor>,
    #[prost(message, repeated, tag = "2")]
    pub gyro: ::prost::alloc::vec::Vec<AxisSensor>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EcgActivation {
    #[prost(bool, required, tag = "1")]
    pub status: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MotionInteract {
    #[prost(uint32, required, tag = "1")]
    pub vibrate_level: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NaviRoute {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "3")]
    pub distance: u32,
}
/// Nested message and enum types in `NaviRoute`.
pub mod navi_route {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::NaviRoute>,
        #[prost(uint32, required, tag = "2")]
        pub supported_max_number: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddRequest {
        #[prost(message, required, tag = "1")]
        pub navi_route: super::NaviRoute,
        #[prost(uint32, required, tag = "2")]
        pub route_size: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddResponse {
        #[prost(string, required, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::PrepareStatus", required, tag = "2")]
        pub prepare_status: i32,
        #[prost(uint32, optional, tag = "3")]
        pub expected_slice_length: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddResult {
        #[prost(string, required, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub code: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveRequest {
        #[prost(string, repeated, tag = "1")]
        pub router_id_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RemoveResponse {
        #[prost(uint32, required, tag = "1")]
        pub code: u32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SleepRegularity {
    #[prost(bool, required, tag = "1")]
    pub on: bool,
    #[prost(uint32, required, tag = "2")]
    pub measure_period: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SleepDisorder {
    #[prost(bool, required, tag = "1")]
    pub reminder: bool,
    #[prost(message, repeated, tag = "2")]
    pub times: ::prost::alloc::vec::Vec<Time>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Research {}
/// Nested message and enum types in `Research`.
pub mod research {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct App {
        #[prost(uint32, required, tag = "1")]
        pub id: u32,
        #[prost(uint32, required, tag = "2")]
        pub r#type: u32,
        #[prost(bool, required, tag = "3")]
        pub enable: bool,
        #[prost(uint32, required, tag = "4")]
        pub timestamp: u32,
    }
    /// Nested message and enum types in `App`.
    pub mod app {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::App>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Device {
        #[prost(uint32, required, tag = "1")]
        pub r#type: u32,
        #[prost(bool, required, tag = "2")]
        pub enable: bool,
    }
    /// Nested message and enum types in `Device`.
    pub mod device {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Device>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CalibrationRequest {
        #[prost(uint32, required, tag = "1")]
        pub research_id: u32,
        #[prost(uint32, required, tag = "2")]
        pub r#type: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CalibrationResponse {
        #[prost(uint32, required, tag = "1")]
        pub research_id: u32,
        #[prost(uint32, required, tag = "2")]
        pub code: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BpSetting {
        #[prost(uint32, required, tag = "1")]
        pub research_id: u32,
        #[prost(message, required, tag = "2")]
        pub cali_morning: super::Time,
        #[prost(message, required, tag = "3")]
        pub cali_afternoon: super::Time,
        #[prost(uint32, required, tag = "4")]
        pub reminder_frequence: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BpgCalibrationRequest {
        #[prost(uint32, required, tag = "1")]
        pub research_id: u32,
        #[prost(uint32, required, tag = "2")]
        pub need_calib_times: u32,
        #[prost(uint32, required, tag = "3")]
        pub current_calib_times: u32,
        #[prost(uint32, required, tag = "4")]
        pub systolic_bp: u32,
        #[prost(uint32, required, tag = "5")]
        pub diastolic_bp: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BpgCalibrationStatus {
        #[prost(uint32, required, tag = "1")]
        pub calib_success_times: u32,
        #[prost(uint32, required, tag = "2")]
        pub calib_success_ts: u32,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneControlData {
    #[prost(uint32, optional, tag = "1")]
    pub user_role: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub remote_control: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub vibrate_level: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WearControlData {
    #[prost(uint32, optional, tag = "1")]
    pub key_event: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Course {
    #[prost(uint32, required, tag = "1")]
    pub r#type: u32,
    #[prost(uint64, required, tag = "2")]
    pub id: u64,
    #[prost(message, optional, tag = "3")]
    pub detail: ::core::option::Option<course::Detail>,
}
/// Nested message and enum types in `Course`.
pub mod course {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Target {
        #[prost(enumeration = "super::SportTargetType", required, tag = "1")]
        pub target_type: i32,
        #[prost(uint32, required, tag = "2")]
        pub value1: u32,
        #[prost(uint32, optional, tag = "3")]
        pub value2: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Part {
        #[prost(uint32, required, tag = "1")]
        pub r#type: u32,
        #[prost(uint32, required, tag = "2")]
        pub duration: u32,
        #[prost(message, optional, tag = "3")]
        pub target: ::core::option::Option<Target>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Detail {
        #[prost(string, required, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(uint32, optional, tag = "2")]
        pub duration: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub distance: ::core::option::Option<u32>,
        #[prost(string, required, tag = "4")]
        pub description: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "5")]
        pub parts: ::prost::alloc::vec::Vec<Part>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Training {
    #[prost(uint32, required, tag = "1")]
    pub r#type: u32,
    #[prost(uint64, required, tag = "2")]
    pub id: u64,
}
/// Nested message and enum types in `Training`.
pub mod training {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(message, required, tag = "1")]
        pub course: super::Course,
        #[prost(bool, required, tag = "2")]
        pub finished: bool,
        #[prost(uint32, optional, tag = "3")]
        pub timestamp: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Plan {
        #[prost(uint32, required, tag = "1")]
        pub timestamp: u32,
        #[prost(message, repeated, tag = "2")]
        pub items: ::prost::alloc::vec::Vec<Item>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SportExtraData {
    #[prost(uint32, optional, tag = "1")]
    pub avg_pace: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub max_pace: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "3")]
    pub avg_speed: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub max_speed: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "5")]
    pub avg_frequency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub max_frequency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub avg_stride: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8")]
    pub degree: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "9")]
    pub main_run_style: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub forefoot_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub heel_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "12")]
    pub avg_impact: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub max_impact: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "14")]
    pub avg_on_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "15")]
    pub min_on_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub avg_off_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "17")]
    pub max_off_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "18")]
    pub avg_on_off_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "19")]
    pub min_on_off_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "20")]
    pub max_on_ground: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "21")]
    pub avg_vertical_stride_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "22")]
    pub min_vertical_stride_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "23")]
    pub max_vertical_stride_ratio: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "24")]
    pub avg_vertical_amplitude: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "25")]
    pub min_vertical_amplitude: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "26")]
    pub max_vertical_amplitude: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GpsAccuracy {
    GpsLow = 0,
    GpsMedium = 1,
    GpsHigh = 2,
    GpsUnknown = 10,
}
impl GpsAccuracy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GpsLow => "GPS_LOW",
            Self::GpsMedium => "GPS_MEDIUM",
            Self::GpsHigh => "GPS_HIGH",
            Self::GpsUnknown => "GPS_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GPS_LOW" => Some(Self::GpsLow),
            "GPS_MEDIUM" => Some(Self::GpsMedium),
            "GPS_HIGH" => Some(Self::GpsHigh),
            "GPS_UNKNOWN" => Some(Self::GpsUnknown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GymCapability {
    GymSaveData = 1,
    GymReceiveAssist = 2,
}
impl GymCapability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GymSaveData => "GYM_SAVE_DATA",
            Self::GymReceiveAssist => "GYM_RECEIVE_ASSIST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GYM_SAVE_DATA" => Some(Self::GymSaveData),
            "GYM_RECEIVE_ASSIST" => Some(Self::GymReceiveAssist),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lpa {
    #[prost(oneof = "lpa::Payload", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub payload: ::core::option::Option<lpa::Payload>,
}
/// Nested message and enum types in `Lpa`.
pub mod lpa {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LpaId {
        Command = 0,
        GetEuiccInfo = 1,
        GetProfileList = 2,
        OperateProfile = 3,
        ReportOperateResult = 4,
        PrepareDownloadProfile = 5,
        DownloadProfile = 6,
        ReportDownloadProgress = 7,
        RequestHttp = 8,
        ResponseHttp = 9,
    }
    impl LpaId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Command => "COMMAND",
                Self::GetEuiccInfo => "GET_EUICC_INFO",
                Self::GetProfileList => "GET_PROFILE_LIST",
                Self::OperateProfile => "OPERATE_PROFILE",
                Self::ReportOperateResult => "REPORT_OPERATE_RESULT",
                Self::PrepareDownloadProfile => "PREPARE_DOWNLOAD_PROFILE",
                Self::DownloadProfile => "DOWNLOAD_PROFILE",
                Self::ReportDownloadProgress => "REPORT_DOWNLOAD_PROGRESS",
                Self::RequestHttp => "REQUEST_HTTP",
                Self::ResponseHttp => "RESPONSE_HTTP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMAND" => Some(Self::Command),
                "GET_EUICC_INFO" => Some(Self::GetEuiccInfo),
                "GET_PROFILE_LIST" => Some(Self::GetProfileList),
                "OPERATE_PROFILE" => Some(Self::OperateProfile),
                "REPORT_OPERATE_RESULT" => Some(Self::ReportOperateResult),
                "PREPARE_DOWNLOAD_PROFILE" => Some(Self::PrepareDownloadProfile),
                "DOWNLOAD_PROFILE" => Some(Self::DownloadProfile),
                "REPORT_DOWNLOAD_PROGRESS" => Some(Self::ReportDownloadProgress),
                "REQUEST_HTTP" => Some(Self::RequestHttp),
                "RESPONSE_HTTP" => Some(Self::ResponseHttp),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(string, tag = "1")]
        Data(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        EuiccInfo(super::EuiccInfo),
        #[prost(message, tag = "3")]
        ProfileList(super::profile::List),
        #[prost(message, tag = "4")]
        ProfileOperator(super::ProfileOperator),
        #[prost(message, tag = "5")]
        OperateResult(super::OperateResult),
        #[prost(message, tag = "6")]
        ProfilePrepare(super::ProfilePrepare),
        #[prost(message, tag = "7")]
        ProfileDownload(super::ProfileDownload),
        #[prost(message, tag = "8")]
        DownloadResult(super::DownloadProgress),
        #[prost(message, tag = "9")]
        HttpRequest(super::HttpRequest),
        #[prost(message, tag = "10")]
        HttpResponse(super::HttpResponse),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EuiccInfo {
    #[prost(bytes = "vec", required, tag = "1")]
    pub eid: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, required, tag = "2")]
    pub imei: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profile {
    #[prost(bytes = "vec", required, tag = "1")]
    pub iccid: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, required, tag = "2")]
    pub imei: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "4")]
    pub enable: bool,
}
/// Nested message and enum types in `Profile`.
pub mod profile {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::Profile>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileOperator {
    #[prost(enumeration = "profile_operator::Cmd", required, tag = "1")]
    pub cmd: i32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub iccid: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ProfileOperator`.
pub mod profile_operator {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cmd {
        Enable = 0,
        Disable = 1,
        Delete = 2,
    }
    impl Cmd {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Enable => "ENABLE",
                Self::Disable => "DISABLE",
                Self::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLE" => Some(Self::Enable),
                "DISABLE" => Some(Self::Disable),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperateResult {
    #[prost(bool, required, tag = "1")]
    pub success: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProfilePrepare {
    #[prost(enumeration = "TelecomOperator", required, tag = "1")]
    pub telecom_operator: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileDownload {
    #[prost(string, required, tag = "1")]
    pub activation_code: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub confirmation_code: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DownloadProgress {
    #[prost(int32, required, tag = "1")]
    pub progress: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRequest {
    #[prost(uint64, required, tag = "1")]
    pub xid: u64,
    #[prost(string, required, tag = "2")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub payload: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpResponse {
    #[prost(uint64, required, tag = "1")]
    pub xid: u64,
    #[prost(int32, required, tag = "2")]
    pub status_code: i32,
    #[prost(string, required, tag = "3")]
    pub result: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TelecomOperator {
    ChinaMobile = 1,
    ChinaUnicom = 2,
    ChinaTelecom = 3,
}
impl TelecomOperator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ChinaMobile => "CHINA_MOBILE",
            Self::ChinaUnicom => "CHINA_UNICOM",
            Self::ChinaTelecom => "CHINA_TELECOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHINA_MOBILE" => Some(Self::ChinaMobile),
            "CHINA_UNICOM" => Some(Self::ChinaUnicom),
            "CHINA_TELECOM" => Some(Self::ChinaTelecom),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Weather {
    #[prost(oneof = "weather::Payload", tags = "1, 2, 3, 4, 5, 6")]
    pub payload: ::core::option::Option<weather::Payload>,
}
/// Nested message and enum types in `Weather`.
pub mod weather {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WeatherId {
        LatestWeather = 0,
        DailyForecast = 1,
        HourlyForecast = 2,
        WearRequest = 3,
        SetPressure = 4,
        GetCityKeys = 5,
        UpdateCityKeys = 6,
        AddCityKey = 7,
        RemoveCityKeys = 8,
        GetConfig = 9,
        SetConfig = 10,
    }
    impl WeatherId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LatestWeather => "LATEST_WEATHER",
                Self::DailyForecast => "DAILY_FORECAST",
                Self::HourlyForecast => "HOURLY_FORECAST",
                Self::WearRequest => "WEAR_REQUEST",
                Self::SetPressure => "SET_PRESSURE",
                Self::GetCityKeys => "GET_CITY_KEYS",
                Self::UpdateCityKeys => "UPDATE_CITY_KEYS",
                Self::AddCityKey => "ADD_CITY_KEY",
                Self::RemoveCityKeys => "REMOVE_CITY_KEYS",
                Self::GetConfig => "GET_CONFIG",
                Self::SetConfig => "SET_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LATEST_WEATHER" => Some(Self::LatestWeather),
                "DAILY_FORECAST" => Some(Self::DailyForecast),
                "HOURLY_FORECAST" => Some(Self::HourlyForecast),
                "WEAR_REQUEST" => Some(Self::WearRequest),
                "SET_PRESSURE" => Some(Self::SetPressure),
                "GET_CITY_KEYS" => Some(Self::GetCityKeys),
                "UPDATE_CITY_KEYS" => Some(Self::UpdateCityKeys),
                "ADD_CITY_KEY" => Some(Self::AddCityKey),
                "REMOVE_CITY_KEYS" => Some(Self::RemoveCityKeys),
                "GET_CONFIG" => Some(Self::GetConfig),
                "SET_CONFIG" => Some(Self::SetConfig),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Latest(super::WeatherLatest),
        #[prost(message, tag = "2")]
        Forecast(super::WeatherForecast),
        #[prost(float, tag = "3")]
        Pressure(f32),
        #[prost(message, tag = "4")]
        CityKeyList(super::city_key::List),
        #[prost(message, tag = "5")]
        CityKey(super::CityKey),
        #[prost(message, tag = "6")]
        WeatherConfig(super::WeatherConfig),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CityKey {
    #[prost(string, required, tag = "1")]
    pub location_key: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub city_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CityKey`.
pub mod city_key {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::CityKey>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherId {
    #[prost(string, required, tag = "1")]
    pub pub_time: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub city_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub location_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub location_key: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "5")]
    pub is_current_location: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherLatest {
    #[prost(message, required, tag = "1")]
    pub id: WeatherId,
    #[prost(uint32, required, tag = "2")]
    pub weather: u32,
    #[prost(message, required, tag = "3")]
    pub temperature: KeyValue,
    #[prost(message, required, tag = "4")]
    pub humidity: KeyValue,
    #[prost(message, required, tag = "5")]
    pub wind_info: KeyValue,
    #[prost(message, required, tag = "6")]
    pub uvindex: KeyValue,
    #[prost(message, required, tag = "7")]
    pub aqi: KeyValue,
    #[prost(message, required, tag = "8")]
    pub alerts_list: alerts::List,
    #[prost(float, optional, tag = "9")]
    pub pressure: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherForecast {
    #[prost(message, required, tag = "1")]
    pub id: WeatherId,
    #[prost(message, required, tag = "2")]
    pub data_list: weather_forecast::data::List,
}
/// Nested message and enum types in `WeatherForecast`.
pub mod weather_forecast {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, required, tag = "1")]
        pub aqi: super::KeyValue,
        #[prost(message, optional, tag = "2")]
        pub weather: ::core::option::Option<super::RangeValue>,
        #[prost(message, optional, tag = "3")]
        pub temperature: ::core::option::Option<super::RangeValue>,
        #[prost(string, required, tag = "4")]
        pub temperature_unit: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub sun_rise_set: ::core::option::Option<super::SunRiseSet>,
        #[prost(message, optional, tag = "6")]
        pub wind_info: ::core::option::Option<super::KeyValue>,
    }
    /// Nested message and enum types in `Data`.
    pub mod data {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Data>,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alerts {
    #[prost(string, required, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub level: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub detail: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Alerts`.
pub mod alerts {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::Alerts>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SunRiseSet {
    #[prost(string, required, tag = "1")]
    pub sun_rise: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub sun_set: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeatherConfig {
    #[prost(enumeration = "TemperatureUnit", optional, tag = "1")]
    pub temperature_unit: ::core::option::Option<i32>,
    #[prost(enumeration = "OptionalSwitcher", optional, tag = "2")]
    pub alert: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stock {
    #[prost(oneof = "stock::Payload", tags = "1, 2, 3, 4")]
    pub payload: ::core::option::Option<stock::Payload>,
}
/// Nested message and enum types in `Stock`.
pub mod stock {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StockId {
        SyncStockInfo = 0,
        SyncStockInfoList = 1,
        DeleteStock = 2,
        SetStockList = 3,
        GetStockList = 4,
        WearRequest = 5,
    }
    impl StockId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SyncStockInfo => "SYNC_STOCK_INFO",
                Self::SyncStockInfoList => "SYNC_STOCK_INFO_LIST",
                Self::DeleteStock => "DELETE_STOCK",
                Self::SetStockList => "SET_STOCK_LIST",
                Self::GetStockList => "GET_STOCK_LIST",
                Self::WearRequest => "WEAR_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_STOCK_INFO" => Some(Self::SyncStockInfo),
                "SYNC_STOCK_INFO_LIST" => Some(Self::SyncStockInfoList),
                "DELETE_STOCK" => Some(Self::DeleteStock),
                "SET_STOCK_LIST" => Some(Self::SetStockList),
                "GET_STOCK_LIST" => Some(Self::GetStockList),
                "WEAR_REQUEST" => Some(Self::WearRequest),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        StockInfo(super::StockInfo),
        #[prost(message, tag = "2")]
        StockInfoList(super::stock_info::List),
        #[prost(string, tag = "3")]
        Symbol(::prost::alloc::string::String),
        #[prost(message, tag = "4")]
        StockSymbolList(super::stock_symbol::List),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StockInfo {
    #[prost(string, required, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub market: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(float, required, tag = "4")]
    pub latest_price: f32,
    #[prost(float, required, tag = "5")]
    pub pre_close: f32,
    #[prost(uint32, required, tag = "6")]
    pub halted: u32,
    #[prost(uint32, required, tag = "7")]
    pub timestamp: u32,
    #[prost(uint32, required, tag = "8")]
    pub delay_mintue: u32,
}
/// Nested message and enum types in `StockInfo`.
pub mod stock_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::StockInfo>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StockSymbol {
    #[prost(string, required, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "2")]
    pub is_widget: bool,
    #[prost(uint32, required, tag = "3")]
    pub order: u32,
}
/// Nested message and enum types in `StockSymbol`.
pub mod stock_symbol {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::StockSymbol>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Calendar {
    #[prost(oneof = "calendar::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<calendar::Payload>,
}
/// Nested message and enum types in `Calendar`.
pub mod calendar {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CalendarId {
        SyncCalendarInfo = 0,
        SyncCalendarInfoList = 1,
        WearRequest = 2,
    }
    impl CalendarId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SyncCalendarInfo => "SYNC_CALENDAR_INFO",
                Self::SyncCalendarInfoList => "SYNC_CALENDAR_INFO_LIST",
                Self::WearRequest => "WEAR_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_CALENDAR_INFO" => Some(Self::SyncCalendarInfo),
                "SYNC_CALENDAR_INFO_LIST" => Some(Self::SyncCalendarInfoList),
                "WEAR_REQUEST" => Some(Self::WearRequest),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        CalendarInfo(super::CalendarInfo),
        #[prost(message, tag = "2")]
        CalendarInfoList(super::calendar_info::List),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalendarInfo {
    #[prost(string, required, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub location: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "4")]
    pub start: u32,
    #[prost(uint32, required, tag = "5")]
    pub end: u32,
    #[prost(bool, required, tag = "6")]
    pub all_day: bool,
    #[prost(int32, required, tag = "7")]
    pub reminder_minutes: i32,
}
/// Nested message and enum types in `CalendarInfo`.
pub mod calendar_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::CalendarInfo>,
        #[prost(bool, optional, tag = "2")]
        pub disable: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Factory {
    #[prost(
        oneof = "factory::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 128"
    )]
    pub payload: ::core::option::Option<factory::Payload>,
}
/// Nested message and enum types in `Factory`.
pub mod factory {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FactoryId {
        SetMode = 0,
        GetMode = 6,
        ConfigNfc = 1,
        DumpFile = 2,
        PreviewImage = 3,
        DumpMedia = 4,
        SetBrightness = 5,
        SelfCheckingRequest = 7,
        ReportSelfCheckingResult = 8,
        SelfCheckingStepRequest = 16,
        ReportSelfCheckingStepResult = 17,
        SensorCaptureRequest = 10,
        SensorConfirmRequest = 11,
        SensorReplayRequest = 15,
        GetAppInfoList = 9,
        SubscribeAppBehavior = 12,
        UnsubscribeAppBehavior = 13,
        ReportAppBehavior = 14,
        SetAttp = 128,
    }
    impl FactoryId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SetMode => "SET_MODE",
                Self::GetMode => "GET_MODE",
                Self::ConfigNfc => "CONFIG_NFC",
                Self::DumpFile => "DUMP_FILE",
                Self::PreviewImage => "PREVIEW_IMAGE",
                Self::DumpMedia => "DUMP_MEDIA",
                Self::SetBrightness => "SET_BRIGHTNESS",
                Self::SelfCheckingRequest => "SELF_CHECKING_REQUEST",
                Self::ReportSelfCheckingResult => "REPORT_SELF_CHECKING_RESULT",
                Self::SelfCheckingStepRequest => "SELF_CHECKING_STEP_REQUEST",
                Self::ReportSelfCheckingStepResult => "REPORT_SELF_CHECKING_STEP_RESULT",
                Self::SensorCaptureRequest => "SENSOR_CAPTURE_REQUEST",
                Self::SensorConfirmRequest => "SENSOR_CONFIRM_REQUEST",
                Self::SensorReplayRequest => "SENSOR_REPLAY_REQUEST",
                Self::GetAppInfoList => "GET_APP_INFO_LIST",
                Self::SubscribeAppBehavior => "SUBSCRIBE_APP_BEHAVIOR",
                Self::UnsubscribeAppBehavior => "UNSUBSCRIBE_APP_BEHAVIOR",
                Self::ReportAppBehavior => "REPORT_APP_BEHAVIOR",
                Self::SetAttp => "SET_ATTP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SET_MODE" => Some(Self::SetMode),
                "GET_MODE" => Some(Self::GetMode),
                "CONFIG_NFC" => Some(Self::ConfigNfc),
                "DUMP_FILE" => Some(Self::DumpFile),
                "PREVIEW_IMAGE" => Some(Self::PreviewImage),
                "DUMP_MEDIA" => Some(Self::DumpMedia),
                "SET_BRIGHTNESS" => Some(Self::SetBrightness),
                "SELF_CHECKING_REQUEST" => Some(Self::SelfCheckingRequest),
                "REPORT_SELF_CHECKING_RESULT" => Some(Self::ReportSelfCheckingResult),
                "SELF_CHECKING_STEP_REQUEST" => Some(Self::SelfCheckingStepRequest),
                "REPORT_SELF_CHECKING_STEP_RESULT" => {
                    Some(Self::ReportSelfCheckingStepResult)
                }
                "SENSOR_CAPTURE_REQUEST" => Some(Self::SensorCaptureRequest),
                "SENSOR_CONFIRM_REQUEST" => Some(Self::SensorConfirmRequest),
                "SENSOR_REPLAY_REQUEST" => Some(Self::SensorReplayRequest),
                "GET_APP_INFO_LIST" => Some(Self::GetAppInfoList),
                "SUBSCRIBE_APP_BEHAVIOR" => Some(Self::SubscribeAppBehavior),
                "UNSUBSCRIBE_APP_BEHAVIOR" => Some(Self::UnsubscribeAppBehavior),
                "REPORT_APP_BEHAVIOR" => Some(Self::ReportAppBehavior),
                "SET_ATTP" => Some(Self::SetAttp),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(enumeration = "super::FactoryMode", tag = "1")]
        Mode(i32),
        #[prost(message, tag = "2")]
        NfcList(super::nfc_info::List),
        #[prost(message, tag = "3")]
        File(super::FileInfo),
        #[prost(message, tag = "4")]
        ImageRequest(super::PreviewImageRequest),
        #[prost(message, tag = "5")]
        ImageResponse(super::PreviewImageResponse),
        #[prost(uint32, tag = "6")]
        Brightness(u32),
        #[prost(message, tag = "7")]
        SelfCheckingRequest(super::self_checking::Request),
        #[prost(message, tag = "8")]
        SelfCheckingResponse(super::self_checking::Response),
        #[prost(message, tag = "9")]
        SelfCheckingResult(super::self_checking::Result),
        #[prost(message, tag = "10")]
        SensorCaptureRequest(super::SensorCaptureRequest),
        #[prost(message, tag = "11")]
        SensorCaptureResponse(super::SensorCaptureResponse),
        #[prost(message, tag = "12")]
        SensorConfirmRequest(super::SensorConfirmRequest),
        #[prost(message, tag = "13")]
        SensorConfirmResponse(super::SensorConfirmResponse),
        #[prost(message, tag = "14")]
        AppInfoList(super::cta::app_info::List),
        #[prost(message, tag = "15")]
        AppBehavior(super::cta::AppBehavior),
        #[prost(message, tag = "16")]
        SensorReplayRequest(super::SensorReplayRequest),
        #[prost(message, tag = "17")]
        SensorReplayResponse(super::SensorReplayResponse),
        #[prost(message, tag = "18")]
        SelfCheckingStepRequest(super::self_checking::StepRequest),
        #[prost(message, tag = "19")]
        SelfCheckingStepResult(super::self_checking::StepResult),
        #[prost(string, tag = "128")]
        Attp(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfcInfo {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `NfcInfo`.
pub mod nfc_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::NfcInfo>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "2")]
    pub is_append: bool,
    #[prost(bytes = "vec", required, tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewImageRequest {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PreviewImageResponse {
    #[prost(enumeration = "PrepareStatus", required, tag = "1")]
    pub status: i32,
    #[prost(enumeration = "ImageFormat", optional, tag = "2")]
    pub expected_image_format: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub expected_slice_length: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorCaptureRequest {
    #[prost(enumeration = "sensor_capture_request::State", required, tag = "1")]
    pub state: i32,
    #[prost(enumeration = "sensor_capture_request::Mode", required, tag = "2")]
    pub mode: i32,
    #[prost(uint32, optional, tag = "3")]
    pub timestamp: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub meta_info: ::core::option::Option<sensor_capture_request::MetaInfo>,
    #[prost(message, optional, tag = "5")]
    pub sensor_list: ::core::option::Option<sensor_capture_request::sensor::List>,
    #[prost(bytes = "vec", required, tag = "6")]
    pub setting_info: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `SensorCaptureRequest`.
pub mod sensor_capture_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetaInfo {
        #[prost(string, required, tag = "1")]
        pub user_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::Sex", required, tag = "2")]
        pub sex: i32,
        #[prost(uint32, required, tag = "3")]
        pub user_age: u32,
        #[prost(uint32, required, tag = "4")]
        pub height: u32,
        #[prost(float, required, tag = "5")]
        pub weight: f32,
        #[prost(string, required, tag = "6")]
        pub main_scene: ::prost::alloc::string::String,
        #[prost(string, required, tag = "7")]
        pub sub_scene: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Sensor {
        #[prost(uint32, required, tag = "1")]
        pub r#type: u32,
        #[prost(uint32, required, tag = "2")]
        pub frequence: u32,
    }
    /// Nested message and enum types in `Sensor`.
    pub mod sensor {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Sensor>,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        StartCapture = 1,
        StopCapture = 2,
        SyncCapture = 3,
        SetCapture = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StartCapture => "START_CAPTURE",
                Self::StopCapture => "STOP_CAPTURE",
                Self::SyncCapture => "SYNC_CAPTURE",
                Self::SetCapture => "SET_CAPTURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "START_CAPTURE" => Some(Self::StartCapture),
                "STOP_CAPTURE" => Some(Self::StopCapture),
                "SYNC_CAPTURE" => Some(Self::SyncCapture),
                "SET_CAPTURE" => Some(Self::SetCapture),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        OnlineCapture = 1,
        OfflineCapture = 2,
        RealtimeCapture = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OnlineCapture => "ONLINE_CAPTURE",
                Self::OfflineCapture => "OFFLINE_CAPTURE",
                Self::RealtimeCapture => "REALTIME_CAPTURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ONLINE_CAPTURE" => Some(Self::OnlineCapture),
                "OFFLINE_CAPTURE" => Some(Self::OfflineCapture),
                "REALTIME_CAPTURE" => Some(Self::RealtimeCapture),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorCaptureResponse {
    #[prost(uint32, required, tag = "1")]
    pub code: u32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub setting_info: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorConfirmRequest {
    #[prost(bytes = "vec", required, tag = "1")]
    pub data_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "2")]
    pub status: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SensorConfirmResponse {
    #[prost(uint32, required, tag = "1")]
    pub result: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SelfChecking {}
/// Nested message and enum types in `SelfChecking`.
pub mod self_checking {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(enumeration = "Cmd", required, tag = "1")]
        pub cmd: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(enumeration = "Cmd", required, tag = "1")]
        pub cmd: i32,
        #[prost(enumeration = "Status", required, tag = "2")]
        pub status: i32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(enumeration = "Func", required, tag = "1")]
        pub func: i32,
        #[prost(bool, required, tag = "2")]
        pub pass: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<Item>,
        #[prost(bool, optional, tag = "2")]
        pub partial: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StepRequest {
        #[prost(enumeration = "Func", required, tag = "1")]
        pub func: i32,
        #[prost(uint32, required, tag = "2")]
        pub step: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StepResult {
        #[prost(enumeration = "Func", required, tag = "1")]
        pub func: i32,
        #[prost(uint32, required, tag = "2")]
        pub step: u32,
        #[prost(uint32, required, tag = "3")]
        pub result: u32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cmd {
        Enter = 0,
        Start = 1,
        Exit = 2,
    }
    impl Cmd {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Enter => "ENTER",
                Self::Start => "START",
                Self::Exit => "EXIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTER" => Some(Self::Enter),
                "START" => Some(Self::Start),
                "EXIT" => Some(Self::Exit),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Ok = 0,
        WillReboot = 1,
        Fail = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::WillReboot => "WILL_REBOOT",
                Self::Fail => "FAIL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "WILL_REBOOT" => Some(Self::WillReboot),
                "FAIL" => Some(Self::Fail),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Func {
        Bluetooth = 1,
        Gnss = 2,
        Nfc = 3,
        Wifi = 4,
        Esim = 5,
        Acc = 6,
        Gyro = 7,
        Mag = 8,
        Baro = 9,
        Light = 10,
        Ppg = 11,
        Cap = 12,
        Temp = 13,
        Charge = 14,
        Battery = 15,
        Dp = 16,
        Tp = 17,
        Key = 18,
        Rotary = 19,
        Motor = 20,
        Storage = 21,
        Audio = 22,
        Dou = 23,
        Mic = 24,
        Pa = 25,
        Camera = 26,
        Imu = 27,
        IndicatorLight = 28,
        PrivacyLight = 29,
        Range = 30,
        HeartRate = 31,
        BloodOxygen = 32,
        Ecg = 33,
    }
    impl Func {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Bluetooth => "BLUETOOTH",
                Self::Gnss => "GNSS",
                Self::Nfc => "NFC",
                Self::Wifi => "WIFI",
                Self::Esim => "ESIM",
                Self::Acc => "ACC",
                Self::Gyro => "GYRO",
                Self::Mag => "MAG",
                Self::Baro => "BARO",
                Self::Light => "LIGHT",
                Self::Ppg => "PPG",
                Self::Cap => "CAP",
                Self::Temp => "TEMP",
                Self::Charge => "CHARGE",
                Self::Battery => "BATTERY",
                Self::Dp => "DP",
                Self::Tp => "TP",
                Self::Key => "KEY",
                Self::Rotary => "ROTARY",
                Self::Motor => "MOTOR",
                Self::Storage => "STORAGE",
                Self::Audio => "AUDIO",
                Self::Dou => "DOU",
                Self::Mic => "MIC",
                Self::Pa => "PA",
                Self::Camera => "CAMERA",
                Self::Imu => "IMU",
                Self::IndicatorLight => "INDICATOR_LIGHT",
                Self::PrivacyLight => "PRIVACY_LIGHT",
                Self::Range => "RANGE",
                Self::HeartRate => "HEART_RATE",
                Self::BloodOxygen => "BLOOD_OXYGEN",
                Self::Ecg => "ECG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BLUETOOTH" => Some(Self::Bluetooth),
                "GNSS" => Some(Self::Gnss),
                "NFC" => Some(Self::Nfc),
                "WIFI" => Some(Self::Wifi),
                "ESIM" => Some(Self::Esim),
                "ACC" => Some(Self::Acc),
                "GYRO" => Some(Self::Gyro),
                "MAG" => Some(Self::Mag),
                "BARO" => Some(Self::Baro),
                "LIGHT" => Some(Self::Light),
                "PPG" => Some(Self::Ppg),
                "CAP" => Some(Self::Cap),
                "TEMP" => Some(Self::Temp),
                "CHARGE" => Some(Self::Charge),
                "BATTERY" => Some(Self::Battery),
                "DP" => Some(Self::Dp),
                "TP" => Some(Self::Tp),
                "KEY" => Some(Self::Key),
                "ROTARY" => Some(Self::Rotary),
                "MOTOR" => Some(Self::Motor),
                "STORAGE" => Some(Self::Storage),
                "AUDIO" => Some(Self::Audio),
                "DOU" => Some(Self::Dou),
                "MIC" => Some(Self::Mic),
                "PA" => Some(Self::Pa),
                "CAMERA" => Some(Self::Camera),
                "IMU" => Some(Self::Imu),
                "INDICATOR_LIGHT" => Some(Self::IndicatorLight),
                "PRIVACY_LIGHT" => Some(Self::PrivacyLight),
                "RANGE" => Some(Self::Range),
                "HEART_RATE" => Some(Self::HeartRate),
                "BLOOD_OXYGEN" => Some(Self::BloodOxygen),
                "ECG" => Some(Self::Ecg),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Cta {}
/// Nested message and enum types in `CTA`.
pub mod cta {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppInfo {
        #[prost(string, required, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, required, tag = "3")]
        pub version: ::prost::alloc::string::String,
        #[prost(string, required, tag = "4")]
        pub update_time: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AppInfo`.
    pub mod app_info {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::AppInfo>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppBehavior {
        #[prost(string, required, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(message, required, tag = "2")]
        pub items: super::KeyValueStr,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorReplayRequest {
    #[prost(uint32, required, tag = "1")]
    pub r#type: u32,
    #[prost(uint32, required, tag = "2")]
    pub instance: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub md5: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SensorReplayResponse {
    #[prost(uint32, required, tag = "1")]
    pub status: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FactoryMode {
    User = 0,
    Userdebug = 1,
    Eng = 2,
    SeleChecking = 3,
    MedicalMeter = 4,
}
impl FactoryMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::User => "USER",
            Self::Userdebug => "USERDEBUG",
            Self::Eng => "ENG",
            Self::SeleChecking => "SELE_CHECKING",
            Self::MedicalMeter => "MEDICAL_METER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER" => Some(Self::User),
            "USERDEBUG" => Some(Self::Userdebug),
            "ENG" => Some(Self::Eng),
            "SELE_CHECKING" => Some(Self::SeleChecking),
            "MEDICAL_METER" => Some(Self::MedicalMeter),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aivs {
    #[prost(oneof = "aivs::Payload", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub payload: ::core::option::Option<aivs::Payload>,
}
/// Nested message and enum types in `Aivs`.
pub mod aivs {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AivsId {
        SyncInstructionList = 0,
        GetConfig = 1,
        SetConfig = 2,
        GetMediaConfig = 3,
        RequestMultiModal = 4,
        SyncAivsStatus = 5,
        SyncAivsError = 6,
        GetAflashSupportedLanguage = 7,
        ReplyAflashConfirmResult = 8,
        LlmIssueImage = 9,
    }
    impl AivsId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SyncInstructionList => "SYNC_INSTRUCTION_LIST",
                Self::GetConfig => "GET_CONFIG",
                Self::SetConfig => "SET_CONFIG",
                Self::GetMediaConfig => "GET_MEDIA_CONFIG",
                Self::RequestMultiModal => "REQUEST_MULTI_MODAL",
                Self::SyncAivsStatus => "SYNC_AIVS_STATUS",
                Self::SyncAivsError => "SYNC_AIVS_ERROR",
                Self::GetAflashSupportedLanguage => "GET_AFLASH_SUPPORTED_LANGUAGE",
                Self::ReplyAflashConfirmResult => "REPLY_AFLASH_CONFIRM_RESULT",
                Self::LlmIssueImage => "LLM_ISSUE_IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_INSTRUCTION_LIST" => Some(Self::SyncInstructionList),
                "GET_CONFIG" => Some(Self::GetConfig),
                "SET_CONFIG" => Some(Self::SetConfig),
                "GET_MEDIA_CONFIG" => Some(Self::GetMediaConfig),
                "REQUEST_MULTI_MODAL" => Some(Self::RequestMultiModal),
                "SYNC_AIVS_STATUS" => Some(Self::SyncAivsStatus),
                "SYNC_AIVS_ERROR" => Some(Self::SyncAivsError),
                "GET_AFLASH_SUPPORTED_LANGUAGE" => Some(Self::GetAflashSupportedLanguage),
                "REPLY_AFLASH_CONFIRM_RESULT" => Some(Self::ReplyAflashConfirmResult),
                "LLM_ISSUE_IMAGE" => Some(Self::LlmIssueImage),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        InstructionList(super::aivs_instruction::List),
        #[prost(message, tag = "2")]
        AivsConfig(super::AivsConfig),
        #[prost(message, tag = "3")]
        ImageConfig(super::MediaConfig),
        #[prost(message, tag = "4")]
        MultiModel(super::MultiModal),
        #[prost(message, tag = "5")]
        AivsStatus(super::AivsStatus),
        #[prost(message, tag = "6")]
        AivsError(super::AivsError),
        #[prost(message, tag = "7")]
        AflashSupportedLanguage(super::a_flash::SupportedLanguage),
        #[prost(message, tag = "8")]
        AflashConfirmResult(super::a_flash::ConfirmResult),
        #[prost(message, tag = "9")]
        LlmImageRequest(super::llm::issue_image::Request),
        #[prost(message, tag = "10")]
        LlmImageResponse(super::llm::issue_image::Response),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AivsConfig {
    #[prost(bool, required, tag = "1")]
    pub enable_tts: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AivsInstruction {
    #[prost(enumeration = "ResultType", required, tag = "1")]
    pub result_type: i32,
    #[prost(uint32, required, tag = "13")]
    pub session_id: u32,
    #[prost(message, optional, tag = "2")]
    pub recognize_result: ::core::option::Option<SpeechRecognizeResult>,
    #[prost(message, optional, tag = "3")]
    pub template_toast: ::core::option::Option<TemplateToast>,
    #[prost(message, optional, tag = "4")]
    pub template_general: ::core::option::Option<TemplateGeneral>,
    #[prost(message, optional, tag = "5")]
    pub template_general2: ::core::option::Option<TemplateGeneral2>,
    #[prost(message, optional, tag = "6")]
    pub template_weather: ::core::option::Option<TemplateWeather>,
    #[prost(message, optional, tag = "7")]
    pub template_playinfo: ::core::option::Option<TemplatePlayInfo>,
    #[prost(message, optional, tag = "8")]
    pub template_lists: ::core::option::Option<TemplateLists>,
    #[prost(message, optional, tag = "9")]
    pub template_switchpanel: ::core::option::Option<TemplateSwitchPanel>,
    #[prost(message, optional, tag = "10")]
    pub alerts_setalert: ::core::option::Option<AlertsSetAlert>,
    #[prost(message, optional, tag = "11")]
    pub speechsynthesizer_speak: ::core::option::Option<SpeechSynthesizerSpeak>,
    #[prost(message, optional, tag = "14")]
    pub laucher_lauchapp: ::core::option::Option<LauncherLaunchApp>,
    #[prost(message, optional, tag = "15")]
    pub template_switchpanellist: ::core::option::Option<TemplateSwitchPanelList>,
    #[prost(message, optional, tag = "16")]
    pub brightnesscontroller_ajustbrightness: ::core::option::Option<
        BrightnessControllerAjustBrightness,
    >,
    #[prost(message, optional, tag = "17")]
    pub system_setproperty: ::core::option::Option<SystemSetProperty>,
    #[prost(message, optional, tag = "18")]
    pub application_operate: ::core::option::Option<ApplicationOperate>,
    #[prost(message, optional, tag = "19")]
    pub alerts_deliveralertintention: ::core::option::Option<
        AlertsDeliverAlertIntention,
    >,
    #[prost(enumeration = "MediaErrorType", optional, tag = "20")]
    pub media_errortype: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "21")]
    pub speaker_setmute: ::core::option::Option<SpeakerSetMute>,
    #[prost(message, optional, tag = "22")]
    pub speaker_setvolume: ::core::option::Option<SpeakerSetVolume>,
    #[prost(message, optional, tag = "23")]
    pub speaker_ajustvolume: ::core::option::Option<SpeakerAjustVolume>,
    #[prost(message, optional, tag = "24")]
    pub template_devicelist: ::core::option::Option<TemplateDeviceList>,
    #[prost(message, optional, tag = "25")]
    pub execute_deviceskill: ::core::option::Option<ExecuteDeviceSkill>,
    #[prost(message, optional, tag = "26")]
    pub show_contacts: ::core::option::Option<ShowContacts>,
    #[prost(message, optional, tag = "27")]
    pub contact_data: ::core::option::Option<show_contacts::ContactData>,
    #[prost(message, optional, tag = "28")]
    pub wearable_controller_switch: ::core::option::Option<wearable_controller::Switch>,
    #[prost(message, optional, tag = "29")]
    pub wearable_controller_execute: ::core::option::Option<
        wearable_controller::Execute,
    >,
    #[prost(message, optional, tag = "30")]
    pub llm_loading_card: ::core::option::Option<llm::LoadingCard>,
    #[prost(message, optional, tag = "31")]
    pub llm_declaration_content: ::core::option::Option<llm::DeclarationContent>,
    #[prost(message, optional, tag = "32")]
    pub llm_illegal_content: ::core::option::Option<llm::IllegalContent>,
    #[prost(message, optional, tag = "33")]
    pub llm_toast_stream: ::core::option::Option<llm::ToastStream>,
    #[prost(message, optional, tag = "34")]
    pub wearable_controller_action: ::core::option::Option<wearable_controller::Action>,
}
/// Nested message and enum types in `AivsInstruction`.
pub mod aivs_instruction {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AivsInstruction>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechRecognizeResult {
    #[prost(bool, required, tag = "1")]
    pub is_final: bool,
    #[prost(message, required, tag = "2")]
    pub results: speech_recognize_result_item::List,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateToast {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateGeneral {
    #[prost(message, required, tag = "1")]
    pub title: Title,
    #[prost(string, required, tag = "2")]
    pub text: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub results: ::core::option::Option<abstract_item::List>,
    #[prost(string, required, tag = "4")]
    pub skill_description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateGeneral2 {
    #[prost(message, required, tag = "1")]
    pub main_title: RichText,
    #[prost(message, required, tag = "2")]
    pub sub_titles: rich_text::List,
    #[prost(message, required, tag = "3")]
    pub texts: rich_text::List,
    #[prost(string, required, tag = "4")]
    pub skill_description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateWeather {
    #[prost(message, required, tag = "1")]
    pub weather: weather_item::List,
    #[prost(string, required, tag = "2")]
    pub skill_description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplatePlayInfo {
    #[prost(message, required, tag = "1")]
    pub items: play_info_item::List,
    #[prost(enumeration = "PlayInfoType", required, tag = "2")]
    pub r#type: i32,
    #[prost(string, required, tag = "3")]
    pub skill_description: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateLists {
    #[prost(string, required, tag = "1")]
    pub skill_description: ::prost::alloc::string::String,
    #[prost(message, required, tag = "2")]
    pub items: lists_item::List,
    #[prost(message, optional, tag = "3")]
    pub title: ::core::option::Option<Title>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateSwitchPanel {
    #[prost(message, required, tag = "1")]
    pub title: Title,
    #[prost(string, required, tag = "2")]
    pub skill_description: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(enumeration = "SwitchPanelType", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateSwitchPanelList {
    #[prost(message, required, tag = "1")]
    pub titles: switch_item::List,
    #[prost(string, required, tag = "2")]
    pub skill_description: ::prost::alloc::string::String,
    #[prost(enumeration = "SwitchPanelType", optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "4")]
    pub items: ::core::option::Option<switch_item::List>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchItem {
    #[prost(message, required, tag = "1")]
    pub title: Title,
    #[prost(string, required, tag = "2")]
    pub status: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SwitchItem`.
pub mod switch_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::SwitchItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlertsSetAlert {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "AlertType", required, tag = "2")]
    pub r#type: i32,
    #[prost(string, required, tag = "3")]
    pub datetime: ::prost::alloc::string::String,
    #[prost(enumeration = "AlertCircleType", optional, tag = "4")]
    pub circle: ::core::option::Option<i32>,
    #[prost(string, required, tag = "5")]
    pub circle_extra: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub offset: ::prost::alloc::string::String,
    #[prost(string, required, tag = "7")]
    pub event: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlertsDeliverAlertIntention {
    #[prost(enumeration = "AlertType", required, tag = "1")]
    pub r#type: i32,
    #[prost(enumeration = "AlertOperation", required, tag = "2")]
    pub operation: i32,
    #[prost(bool, required, tag = "3")]
    pub operate_all: bool,
    #[prost(enumeration = "AlertCircleType", optional, tag = "4")]
    pub circle: ::core::option::Option<i32>,
    #[prost(string, required, tag = "5")]
    pub circle_extra: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub event: ::prost::alloc::string::String,
    #[prost(enumeration = "AlertFilterType", optional, tag = "7")]
    pub filter_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "8")]
    pub time: ::core::option::Option<AlertTimeInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechSynthesizerSpeak {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechRecognizeResultItem {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SpeechRecognizeResultItem`.
pub mod speech_recognize_result_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::SpeechRecognizeResultItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemSetProperty {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LauncherLaunchApp {
    #[prost(message, required, tag = "1")]
    pub intent: AndroidIntent,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteDeviceSkill {
    #[prost(message, required, tag = "1")]
    pub intent: AndroidIntent,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrightnessControllerAjustBrightness {
    #[prost(int32, required, tag = "1")]
    pub brightness_delta: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationOperate {
    #[prost(enumeration = "ApplictionOp", required, tag = "1")]
    pub operation: i32,
    #[prost(string, required, tag = "2")]
    pub keyword: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub app_pkg_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidIntent {
    #[prost(string, required, tag = "1")]
    pub pkg_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbstractItem {
    #[prost(string, required, tag = "1")]
    pub k: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub v: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AbstractItem`.
pub mod abstract_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AbstractItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Title {
    #[prost(string, required, tag = "1")]
    pub main_title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub sub_title: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RichText {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub color: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub bg_color: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RichText`.
pub mod rich_text {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::RichText>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherItem {
    #[prost(string, required, tag = "1")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub aqi: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub current_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub high_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub low_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "7")]
    pub icon_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub weather_code: ::core::option::Option<WeatherCode>,
    #[prost(message, optional, tag = "9")]
    pub wind: ::core::option::Option<WeatherWind>,
    #[prost(string, required, tag = "10")]
    pub weekday: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WeatherItem`.
pub mod weather_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::WeatherItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherCode {
    #[prost(string, required, tag = "1")]
    pub current: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub to: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherWind {
    #[prost(message, optional, tag = "1")]
    pub direction: ::core::option::Option<WeatherWindDirection>,
    #[prost(message, optional, tag = "2")]
    pub speed: ::core::option::Option<WeatherWindSpeed>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherWindDirection {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub current: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub to: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherWindSpeed {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub current: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub to: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayInfoItem {
    #[prost(message, required, tag = "1")]
    pub title: Title,
    #[prost(uint32, optional, tag = "2")]
    pub duration_in_ms: ::core::option::Option<u32>,
    #[prost(string, required, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PlayInfoItem`.
pub mod play_info_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::PlayInfoItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListsItem {
    #[prost(message, required, tag = "1")]
    pub title: Title,
    #[prost(string, required, tag = "2")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub skill_description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ListsItem`.
pub mod lists_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ListsItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlertTimeInfo {
    #[prost(enumeration = "AlertTimeType", required, tag = "1")]
    pub r#type: i32,
    #[prost(string, required, tag = "2")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub datetime: ::core::option::Option<AlertDateTime>,
    #[prost(message, optional, tag = "4")]
    pub start_datetime: ::core::option::Option<AlertDateTime>,
    #[prost(message, optional, tag = "5")]
    pub end_datetime: ::core::option::Option<AlertDateTime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlertDateTime {
    #[prost(string, required, tag = "1")]
    pub value: ::prost::alloc::string::String,
    #[prost(int64, required, tag = "2")]
    pub timestamp: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpeakerSetMute {
    #[prost(bool, required, tag = "1")]
    pub mute: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpeakerSetVolume {
    #[prost(int32, required, tag = "1")]
    pub volume: i32,
    #[prost(enumeration = "SpeakerVolumeType", required, tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "SpeakerUnitDef", required, tag = "3")]
    pub unit: i32,
    #[prost(bool, optional, tag = "4")]
    pub once: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpeakerAjustVolume {
    #[prost(int32, required, tag = "1")]
    pub volume_delta: i32,
    #[prost(enumeration = "SpeakerVolumeType", required, tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "SpeakerUnitDef", required, tag = "3")]
    pub unit: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateDeviceList {
    #[prost(message, required, tag = "1")]
    pub items: device_item::List,
    #[prost(bool, required, tag = "2")]
    pub exceed_max_items: bool,
    #[prost(bool, required, tag = "3")]
    pub show_index: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceItem {
    #[prost(message, required, tag = "1")]
    pub title: Title,
}
/// Nested message and enum types in `DeviceItem`.
pub mod device_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::DeviceItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowContacts {
    #[prost(enumeration = "show_contacts::Code", required, tag = "1")]
    pub code: i32,
    #[prost(message, repeated, tag = "2")]
    pub list: ::prost::alloc::vec::Vec<show_contacts::ContactData>,
}
/// Nested message and enum types in `ShowContacts`.
pub mod show_contacts {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContactData {
        #[prost(string, required, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub number: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        Ok = 0,
        NoPermission = 1,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::NoPermission => "NO_PERMISSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "NO_PERMISSION" => Some(Self::NoPermission),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WearableController {}
/// Nested message and enum types in `WearableController`.
pub mod wearable_controller {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Switch {
        #[prost(enumeration = "super::SportState", required, tag = "1")]
        pub sport_state: i32,
        #[prost(enumeration = "super::SportType", required, tag = "2")]
        pub sport_type: i32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Execute {
        #[prost(string, required, tag = "1")]
        pub directive: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Action {
        #[prost(string, required, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub payload: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Llm {}
/// Nested message and enum types in `LLM`.
pub mod llm {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LoadingCard {
        #[prost(uint32, required, tag = "1")]
        pub timeout: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeclarationContent {
        #[prost(string, required, tag = "1")]
        pub text: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IllegalContent {
        #[prost(string, required, tag = "1")]
        pub text: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ToastStream {
        #[prost(string, required, tag = "1")]
        pub markdown_text: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IssueImage {}
    /// Nested message and enum types in `IssueImage`.
    pub mod issue_image {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Request {
            #[prost(uint32, required, tag = "1")]
            pub session_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Response {
            #[prost(enumeration = "super::super::PrepareStatus", required, tag = "1")]
            pub prepare_status: i32,
            #[prost(enumeration = "super::super::ImageFormat", optional, tag = "2")]
            pub support_image_format: ::core::option::Option<i32>,
            #[prost(uint32, optional, tag = "3")]
            pub expected_slice_length: ::core::option::Option<u32>,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaConfig {
    #[prost(uint32, required, tag = "1")]
    pub img_width: u32,
    #[prost(uint32, required, tag = "2")]
    pub img_height: u32,
    #[prost(uint32, required, tag = "3")]
    pub img_format: u32,
    #[prost(uint32, required, tag = "4")]
    pub standby_freq: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AivsRequestInfo {
    #[prost(bytes = "vec", required, tag = "1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", required, tag = "2")]
    pub transaction_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiModal {
    #[prost(message, required, tag = "1")]
    pub request_info: AivsRequestInfo,
    #[prost(uint32, required, tag = "2")]
    pub cmd: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AivsStatus {
    #[prost(enumeration = "aivs_status::VoiceStatus", required, tag = "1")]
    pub voice_status: i32,
    #[prost(enumeration = "aivs_status::TtsStatus", required, tag = "2")]
    pub tts_status: i32,
    #[prost(enumeration = "aivs_status::MediaPlayStatus", required, tag = "3")]
    pub media_play_status: i32,
    #[prost(enumeration = "aivs_status::ImageStatus", required, tag = "4")]
    pub image_status: i32,
    #[prost(enumeration = "aivs_status::OperatingStatus", required, tag = "5")]
    pub operating_status: i32,
    #[prost(enumeration = "aivs_status::DeviceStatus", required, tag = "6")]
    pub device_status: i32,
}
/// Nested message and enum types in `AivsStatus`.
pub mod aivs_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VoiceStatus {
        VoiceIdle = 0,
        WakeUp = 1,
        Recording = 2,
        Standby = 3,
    }
    impl VoiceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::VoiceIdle => "VOICE_IDLE",
                Self::WakeUp => "WAKE_UP",
                Self::Recording => "RECORDING",
                Self::Standby => "STANDBY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOICE_IDLE" => Some(Self::VoiceIdle),
                "WAKE_UP" => Some(Self::WakeUp),
                "RECORDING" => Some(Self::Recording),
                "STANDBY" => Some(Self::Standby),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TtsStatus {
        TtsIdle = 0,
        TtsPlaying = 1,
    }
    impl TtsStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TtsIdle => "TTS_IDLE",
                Self::TtsPlaying => "TTS_PLAYING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TTS_IDLE" => Some(Self::TtsIdle),
                "TTS_PLAYING" => Some(Self::TtsPlaying),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaPlayStatus {
        MediaIdle = 0,
        MediaPlaying = 1,
        MediaPaused = 2,
        MediaStopped = 3,
    }
    impl MediaPlayStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MediaIdle => "MEDIA_IDLE",
                Self::MediaPlaying => "MEDIA_PLAYING",
                Self::MediaPaused => "MEDIA_PAUSED",
                Self::MediaStopped => "MEDIA_STOPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEDIA_IDLE" => Some(Self::MediaIdle),
                "MEDIA_PLAYING" => Some(Self::MediaPlaying),
                "MEDIA_PAUSED" => Some(Self::MediaPaused),
                "MEDIA_STOPPED" => Some(Self::MediaStopped),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageStatus {
        ImageIdle = 0,
        ImagePrepare = 1,
        ImageUploading = 2,
    }
    impl ImageStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ImageIdle => "IMAGE_IDLE",
                Self::ImagePrepare => "IMAGE_PREPARE",
                Self::ImageUploading => "IMAGE_UPLOADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMAGE_IDLE" => Some(Self::ImageIdle),
                "IMAGE_PREPARE" => Some(Self::ImagePrepare),
                "IMAGE_UPLOADING" => Some(Self::ImageUploading),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperatingStatus {
        OperatingIdle = 0,
        Executing = 1,
    }
    impl OperatingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OperatingIdle => "OPERATING_IDLE",
                Self::Executing => "EXECUTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATING_IDLE" => Some(Self::OperatingIdle),
                "EXECUTING" => Some(Self::Executing),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeviceStatus {
        ConnectedOnline = 0,
        ConnectedOffline = 1,
        DisconnectedOffline = 2,
    }
    impl DeviceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ConnectedOnline => "CONNECTED_ONLINE",
                Self::ConnectedOffline => "CONNECTED_OFFLINE",
                Self::DisconnectedOffline => "DISCONNECTED_OFFLINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTED_ONLINE" => Some(Self::ConnectedOnline),
                "CONNECTED_OFFLINE" => Some(Self::ConnectedOffline),
                "DISCONNECTED_OFFLINE" => Some(Self::DisconnectedOffline),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AivsError {
    #[prost(uint32, required, tag = "1")]
    pub error_code: u32,
    #[prost(string, required, tag = "2")]
    pub error_msg: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AFlash {}
/// Nested message and enum types in `AFlash`.
pub mod a_flash {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SupportedLanguage {
        #[prost(string, required, tag = "1")]
        pub languages: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfirmResult {
        #[prost(enumeration = "Scene", required, tag = "1")]
        pub scene: i32,
        #[prost(bool, required, tag = "2")]
        pub confirm: bool,
        #[prost(string, required, tag = "3")]
        pub content: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub album_wf: ::core::option::Option<confirm_result::AlbumWf>,
    }
    /// Nested message and enum types in `ConfirmResult`.
    pub mod confirm_result {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AlbumWf {
            #[prost(string, required, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(enumeration = "super::super::ImageFormat", required, tag = "2")]
            pub image_format: i32,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scene {
        QuestionAndAnswer = 0,
        TextToImage = 1,
    }
    impl Scene {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::QuestionAndAnswer => "QUESTION_AND_ANSWER",
                Self::TextToImage => "TEXT_TO_IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "QUESTION_AND_ANSWER" => Some(Self::QuestionAndAnswer),
                "TEXT_TO_IMAGE" => Some(Self::TextToImage),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResultType {
    StartListening = 0,
    EndListening = 1,
    RecognizeResult = 2,
    StopCapture = 3,
    DialogFinish = 4,
    SystemTruncationnotification = 5,
    ErrorNetwork = 80,
    ErrorAuth = 81,
    ErrorTooManyDevices = 82,
    ErrorContentTooLong = 83,
    AivsErrorAsrTimeout = 112,
    AivsErrorTtsTimeout = 113,
    ErrorConnectTimeout = 84,
    ErrorAudioEmpty = 85,
    ErrorSubscriptionExpired = 86,
    ErrorTodayFreeCountLimit = 87,
    ErrorAllFreeCountLimit = 88,
    ErrorSensativeContent = 89,
    ErrorUnsupportLanguage = 90,
    ErrorUnknown = 91,
    TemplateToast = 256,
    TemplateGeneral = 257,
    TemplateGeneral2 = 258,
    TemplateWeather = 259,
    TemplatePlayinfo = 260,
    TemplateLists = 261,
    TemplateSwitchpanel = 262,
    AlertsSetalert = 263,
    SpeechsynthesizerSpeak = 264,
    SpeechrecognizerExpectspeech = 265,
    LauncherLaunchapp = 266,
    TemplateSwitchpanellist = 267,
    BrightnesscontrollerAdjustbrightness = 268,
    SystemSetproperty = 269,
    ApplicationOperate = 270,
    AlertsDeliveralertintention = 271,
    AlertsStopalert = 272,
    Playbackcontroller = 273,
    PlaybackcontrollerStop = 274,
    PlaybackcontrollerPlay = 275,
    PlaybackcontrollerPause = 276,
    PlaybackcontrollerNext = 277,
    PlaybackcontrollerPrev = 278,
    PlaybackcontrollerContinueplaying = 279,
    SpeakerSetmute = 280,
    SpeakerSetvolume = 281,
    SpeakerAjustvolume = 282,
    TemplateDevicelist = 283,
    ExecuteDeviceskill = 284,
    ShowContacts = 285,
    MakeCall = 286,
    WearableControllerSwitch = 287,
    WearableControllerExecute = 288,
    WearableControllerAction = 294,
    LlmLoadingCard = 289,
    LlmDeclarationContent = 290,
    LlmIllegalContent = 291,
    LlmToastStream = 292,
    LlmFinishStream = 293,
}
impl ResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StartListening => "START_LISTENING",
            Self::EndListening => "END_LISTENING",
            Self::RecognizeResult => "RECOGNIZE_RESULT",
            Self::StopCapture => "STOP_CAPTURE",
            Self::DialogFinish => "DIALOG_FINISH",
            Self::SystemTruncationnotification => "SYSTEM_TRUNCATIONNOTIFICATION",
            Self::ErrorNetwork => "ERROR_NETWORK",
            Self::ErrorAuth => "ERROR_AUTH",
            Self::ErrorTooManyDevices => "ERROR_TOO_MANY_DEVICES",
            Self::ErrorContentTooLong => "ERROR_CONTENT_TOO_LONG",
            Self::AivsErrorAsrTimeout => "AIVS_ERROR_ASR_TIMEOUT",
            Self::AivsErrorTtsTimeout => "AIVS_ERROR_TTS_TIMEOUT",
            Self::ErrorConnectTimeout => "ERROR_CONNECT_TIMEOUT",
            Self::ErrorAudioEmpty => "ERROR_AUDIO_EMPTY",
            Self::ErrorSubscriptionExpired => "ERROR_SUBSCRIPTION_EXPIRED",
            Self::ErrorTodayFreeCountLimit => "ERROR_TODAY_FREE_COUNT_LIMIT",
            Self::ErrorAllFreeCountLimit => "ERROR_ALL_FREE_COUNT_LIMIT",
            Self::ErrorSensativeContent => "ERROR_SENSATIVE_CONTENT",
            Self::ErrorUnsupportLanguage => "ERROR_UNSUPPORT_LANGUAGE",
            Self::ErrorUnknown => "ERROR_UNKNOWN",
            Self::TemplateToast => "TEMPLATE_TOAST",
            Self::TemplateGeneral => "TEMPLATE_GENERAL",
            Self::TemplateGeneral2 => "TEMPLATE_GENERAL2",
            Self::TemplateWeather => "TEMPLATE_WEATHER",
            Self::TemplatePlayinfo => "TEMPLATE_PLAYINFO",
            Self::TemplateLists => "TEMPLATE_LISTS",
            Self::TemplateSwitchpanel => "TEMPLATE_SWITCHPANEL",
            Self::AlertsSetalert => "ALERTS_SETALERT",
            Self::SpeechsynthesizerSpeak => "SPEECHSYNTHESIZER_SPEAK",
            Self::SpeechrecognizerExpectspeech => "SPEECHRECOGNIZER_EXPECTSPEECH",
            Self::LauncherLaunchapp => "LAUNCHER_LAUNCHAPP",
            Self::TemplateSwitchpanellist => "TEMPLATE_SWITCHPANELLIST",
            Self::BrightnesscontrollerAdjustbrightness => {
                "BRIGHTNESSCONTROLLER_ADJUSTBRIGHTNESS"
            }
            Self::SystemSetproperty => "SYSTEM_SETPROPERTY",
            Self::ApplicationOperate => "APPLICATION_OPERATE",
            Self::AlertsDeliveralertintention => "ALERTS_DELIVERALERTINTENTION",
            Self::AlertsStopalert => "ALERTS_STOPALERT",
            Self::Playbackcontroller => "PLAYBACKCONTROLLER",
            Self::PlaybackcontrollerStop => "PLAYBACKCONTROLLER_STOP",
            Self::PlaybackcontrollerPlay => "PLAYBACKCONTROLLER_PLAY",
            Self::PlaybackcontrollerPause => "PLAYBACKCONTROLLER_PAUSE",
            Self::PlaybackcontrollerNext => "PLAYBACKCONTROLLER_NEXT",
            Self::PlaybackcontrollerPrev => "PLAYBACKCONTROLLER_PREV",
            Self::PlaybackcontrollerContinueplaying => {
                "PLAYBACKCONTROLLER_CONTINUEPLAYING"
            }
            Self::SpeakerSetmute => "SPEAKER_SETMUTE",
            Self::SpeakerSetvolume => "SPEAKER_SETVOLUME",
            Self::SpeakerAjustvolume => "SPEAKER_AJUSTVOLUME",
            Self::TemplateDevicelist => "TEMPLATE_DEVICELIST",
            Self::ExecuteDeviceskill => "EXECUTE_DEVICESKILL",
            Self::ShowContacts => "SHOW_CONTACTS",
            Self::MakeCall => "MAKE_CALL",
            Self::WearableControllerSwitch => "WEARABLE_CONTROLLER_SWITCH",
            Self::WearableControllerExecute => "WEARABLE_CONTROLLER_EXECUTE",
            Self::WearableControllerAction => "WEARABLE_CONTROLLER_ACTION",
            Self::LlmLoadingCard => "LLM_LOADING_CARD",
            Self::LlmDeclarationContent => "LLM_DECLARATION_CONTENT",
            Self::LlmIllegalContent => "LLM_ILLEGAL_CONTENT",
            Self::LlmToastStream => "LLM_TOAST_STREAM",
            Self::LlmFinishStream => "LLM_FINISH_STREAM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "START_LISTENING" => Some(Self::StartListening),
            "END_LISTENING" => Some(Self::EndListening),
            "RECOGNIZE_RESULT" => Some(Self::RecognizeResult),
            "STOP_CAPTURE" => Some(Self::StopCapture),
            "DIALOG_FINISH" => Some(Self::DialogFinish),
            "SYSTEM_TRUNCATIONNOTIFICATION" => Some(Self::SystemTruncationnotification),
            "ERROR_NETWORK" => Some(Self::ErrorNetwork),
            "ERROR_AUTH" => Some(Self::ErrorAuth),
            "ERROR_TOO_MANY_DEVICES" => Some(Self::ErrorTooManyDevices),
            "ERROR_CONTENT_TOO_LONG" => Some(Self::ErrorContentTooLong),
            "AIVS_ERROR_ASR_TIMEOUT" => Some(Self::AivsErrorAsrTimeout),
            "AIVS_ERROR_TTS_TIMEOUT" => Some(Self::AivsErrorTtsTimeout),
            "ERROR_CONNECT_TIMEOUT" => Some(Self::ErrorConnectTimeout),
            "ERROR_AUDIO_EMPTY" => Some(Self::ErrorAudioEmpty),
            "ERROR_SUBSCRIPTION_EXPIRED" => Some(Self::ErrorSubscriptionExpired),
            "ERROR_TODAY_FREE_COUNT_LIMIT" => Some(Self::ErrorTodayFreeCountLimit),
            "ERROR_ALL_FREE_COUNT_LIMIT" => Some(Self::ErrorAllFreeCountLimit),
            "ERROR_SENSATIVE_CONTENT" => Some(Self::ErrorSensativeContent),
            "ERROR_UNSUPPORT_LANGUAGE" => Some(Self::ErrorUnsupportLanguage),
            "ERROR_UNKNOWN" => Some(Self::ErrorUnknown),
            "TEMPLATE_TOAST" => Some(Self::TemplateToast),
            "TEMPLATE_GENERAL" => Some(Self::TemplateGeneral),
            "TEMPLATE_GENERAL2" => Some(Self::TemplateGeneral2),
            "TEMPLATE_WEATHER" => Some(Self::TemplateWeather),
            "TEMPLATE_PLAYINFO" => Some(Self::TemplatePlayinfo),
            "TEMPLATE_LISTS" => Some(Self::TemplateLists),
            "TEMPLATE_SWITCHPANEL" => Some(Self::TemplateSwitchpanel),
            "ALERTS_SETALERT" => Some(Self::AlertsSetalert),
            "SPEECHSYNTHESIZER_SPEAK" => Some(Self::SpeechsynthesizerSpeak),
            "SPEECHRECOGNIZER_EXPECTSPEECH" => Some(Self::SpeechrecognizerExpectspeech),
            "LAUNCHER_LAUNCHAPP" => Some(Self::LauncherLaunchapp),
            "TEMPLATE_SWITCHPANELLIST" => Some(Self::TemplateSwitchpanellist),
            "BRIGHTNESSCONTROLLER_ADJUSTBRIGHTNESS" => {
                Some(Self::BrightnesscontrollerAdjustbrightness)
            }
            "SYSTEM_SETPROPERTY" => Some(Self::SystemSetproperty),
            "APPLICATION_OPERATE" => Some(Self::ApplicationOperate),
            "ALERTS_DELIVERALERTINTENTION" => Some(Self::AlertsDeliveralertintention),
            "ALERTS_STOPALERT" => Some(Self::AlertsStopalert),
            "PLAYBACKCONTROLLER" => Some(Self::Playbackcontroller),
            "PLAYBACKCONTROLLER_STOP" => Some(Self::PlaybackcontrollerStop),
            "PLAYBACKCONTROLLER_PLAY" => Some(Self::PlaybackcontrollerPlay),
            "PLAYBACKCONTROLLER_PAUSE" => Some(Self::PlaybackcontrollerPause),
            "PLAYBACKCONTROLLER_NEXT" => Some(Self::PlaybackcontrollerNext),
            "PLAYBACKCONTROLLER_PREV" => Some(Self::PlaybackcontrollerPrev),
            "PLAYBACKCONTROLLER_CONTINUEPLAYING" => {
                Some(Self::PlaybackcontrollerContinueplaying)
            }
            "SPEAKER_SETMUTE" => Some(Self::SpeakerSetmute),
            "SPEAKER_SETVOLUME" => Some(Self::SpeakerSetvolume),
            "SPEAKER_AJUSTVOLUME" => Some(Self::SpeakerAjustvolume),
            "TEMPLATE_DEVICELIST" => Some(Self::TemplateDevicelist),
            "EXECUTE_DEVICESKILL" => Some(Self::ExecuteDeviceskill),
            "SHOW_CONTACTS" => Some(Self::ShowContacts),
            "MAKE_CALL" => Some(Self::MakeCall),
            "WEARABLE_CONTROLLER_SWITCH" => Some(Self::WearableControllerSwitch),
            "WEARABLE_CONTROLLER_EXECUTE" => Some(Self::WearableControllerExecute),
            "WEARABLE_CONTROLLER_ACTION" => Some(Self::WearableControllerAction),
            "LLM_LOADING_CARD" => Some(Self::LlmLoadingCard),
            "LLM_DECLARATION_CONTENT" => Some(Self::LlmDeclarationContent),
            "LLM_ILLEGAL_CONTENT" => Some(Self::LlmIllegalContent),
            "LLM_TOAST_STREAM" => Some(Self::LlmToastStream),
            "LLM_FINISH_STREAM" => Some(Self::LlmFinishStream),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplictionOp {
    Unknown = -1,
    Open = 0,
    Install = 1,
    Uninstall = 2,
    Close = 3,
    Search = 4,
}
impl ApplictionOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ApplictionOp_UNKNOWN",
            Self::Open => "ApplictionOp_OPEN",
            Self::Install => "ApplictionOp_INSTALL",
            Self::Uninstall => "ApplictionOp_UNINSTALL",
            Self::Close => "ApplictionOp_CLOSE",
            Self::Search => "ApplictionOp_SEARCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ApplictionOp_UNKNOWN" => Some(Self::Unknown),
            "ApplictionOp_OPEN" => Some(Self::Open),
            "ApplictionOp_INSTALL" => Some(Self::Install),
            "ApplictionOp_UNINSTALL" => Some(Self::Uninstall),
            "ApplictionOp_CLOSE" => Some(Self::Close),
            "ApplictionOp_SEARCH" => Some(Self::Search),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlayInfoType {
    PitUnknown = -1,
    Joke = 0,
    Poem = 1,
    Music = 2,
    Station = 3,
    VoiceNews = 4,
    Sound = 5,
    Translation = 6,
}
impl PlayInfoType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PitUnknown => "PIT_UNKNOWN",
            Self::Joke => "JOKE",
            Self::Poem => "POEM",
            Self::Music => "MUSIC",
            Self::Station => "STATION",
            Self::VoiceNews => "VOICE_NEWS",
            Self::Sound => "SOUND",
            Self::Translation => "TRANSLATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PIT_UNKNOWN" => Some(Self::PitUnknown),
            "JOKE" => Some(Self::Joke),
            "POEM" => Some(Self::Poem),
            "MUSIC" => Some(Self::Music),
            "STATION" => Some(Self::Station),
            "VOICE_NEWS" => Some(Self::VoiceNews),
            "SOUND" => Some(Self::Sound),
            "TRANSLATION" => Some(Self::Translation),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SwitchPanelType {
    Unknown = -1,
    Default = 0,
    Countdown = 1,
}
impl SwitchPanelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SwitchPanelType_UNKNOWN",
            Self::Default => "DEFAULT",
            Self::Countdown => "COUNTDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SwitchPanelType_UNKNOWN" => Some(Self::Unknown),
            "DEFAULT" => Some(Self::Default),
            "COUNTDOWN" => Some(Self::Countdown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertType {
    Unknown = -1,
    Alarm = 0,
    Reminder = 1,
    Timer = 2,
}
impl AlertType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "AlertType_UNKNOWN",
            Self::Alarm => "ALARM",
            Self::Reminder => "REMINDER",
            Self::Timer => "TIMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AlertType_UNKNOWN" => Some(Self::Unknown),
            "ALARM" => Some(Self::Alarm),
            "REMINDER" => Some(Self::Reminder),
            "TIMER" => Some(Self::Timer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertCircleType {
    Unknown = -1,
    Once = 0,
    Everyday = 1,
    Workday = 2,
    MondayToFriday = 3,
    Holiday = 4,
    Weekend = 5,
    Weekly = 6,
    Monthly = 7,
    Yearly = 8,
}
impl AlertCircleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "AlertCircleType_UNKNOWN",
            Self::Once => "ONCE",
            Self::Everyday => "EVERYDAY",
            Self::Workday => "WORKDAY",
            Self::MondayToFriday => "MONDAY_TO_FRIDAY",
            Self::Holiday => "HOLIDAY",
            Self::Weekend => "WEEKEND",
            Self::Weekly => "WEEKLY",
            Self::Monthly => "MONTHLY",
            Self::Yearly => "YEARLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AlertCircleType_UNKNOWN" => Some(Self::Unknown),
            "ONCE" => Some(Self::Once),
            "EVERYDAY" => Some(Self::Everyday),
            "WORKDAY" => Some(Self::Workday),
            "MONDAY_TO_FRIDAY" => Some(Self::MondayToFriday),
            "HOLIDAY" => Some(Self::Holiday),
            "WEEKEND" => Some(Self::Weekend),
            "WEEKLY" => Some(Self::Weekly),
            "MONTHLY" => Some(Self::Monthly),
            "YEARLY" => Some(Self::Yearly),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertOperation {
    Unknown = -1,
    Open = 0,
    Close = 1,
    Pause = 2,
    Proceed = 3,
    Query = 4,
    Delete = 5,
}
impl AlertOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "AlertOperation_UNKNOWN",
            Self::Open => "OPEN",
            Self::Close => "CLOSE",
            Self::Pause => "PAUSE",
            Self::Proceed => "PROCEED",
            Self::Query => "QUERY",
            Self::Delete => "DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AlertOperation_UNKNOWN" => Some(Self::Unknown),
            "OPEN" => Some(Self::Open),
            "CLOSE" => Some(Self::Close),
            "PAUSE" => Some(Self::Pause),
            "PROCEED" => Some(Self::Proceed),
            "QUERY" => Some(Self::Query),
            "DELETE" => Some(Self::Delete),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertFilterType {
    AlertfilterUnknown = -1,
    AlertfilterRecentlySet = 0,
    AlertfilterRecentlyCall = 1,
    AlertfilterOnStatus = 2,
    AlertfilterOffStatus = 3,
}
impl AlertFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AlertfilterUnknown => "ALERTFILTER_UNKNOWN",
            Self::AlertfilterRecentlySet => "ALERTFILTER_RECENTLY_SET",
            Self::AlertfilterRecentlyCall => "ALERTFILTER_RECENTLY_CALL",
            Self::AlertfilterOnStatus => "ALERTFILTER_ON_STATUS",
            Self::AlertfilterOffStatus => "ALERTFILTER_OFF_STATUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALERTFILTER_UNKNOWN" => Some(Self::AlertfilterUnknown),
            "ALERTFILTER_RECENTLY_SET" => Some(Self::AlertfilterRecentlySet),
            "ALERTFILTER_RECENTLY_CALL" => Some(Self::AlertfilterRecentlyCall),
            "ALERTFILTER_ON_STATUS" => Some(Self::AlertfilterOnStatus),
            "ALERTFILTER_OFF_STATUS" => Some(Self::AlertfilterOffStatus),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertTimeType {
    AlerttimeUnknown = -1,
    AlerttimeDatetime = 0,
    AlerttimeDuration = 1,
    AlerttimeOffset = 2,
    AlerttimeIndeterDatetime = 3,
}
impl AlertTimeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AlerttimeUnknown => "ALERTTIME_UNKNOWN",
            Self::AlerttimeDatetime => "ALERTTIME_DATETIME",
            Self::AlerttimeDuration => "ALERTTIME_DURATION",
            Self::AlerttimeOffset => "ALERTTIME_OFFSET",
            Self::AlerttimeIndeterDatetime => "ALERTTIME_INDETER_DATETIME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALERTTIME_UNKNOWN" => Some(Self::AlerttimeUnknown),
            "ALERTTIME_DATETIME" => Some(Self::AlerttimeDatetime),
            "ALERTTIME_DURATION" => Some(Self::AlerttimeDuration),
            "ALERTTIME_OFFSET" => Some(Self::AlerttimeOffset),
            "ALERTTIME_INDETER_DATETIME" => Some(Self::AlerttimeIndeterDatetime),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MediaErrorType {
    MediaErrorOk = 0,
    MediaErrorUnsupportSystem = 1,
    MediaErrorNoPermission = 2,
    MediaErrorNoMusic = 3,
    MediaErrorAlreadyPlayingOnPlay = 4,
    MediaErrorAlreadyPausedOnPause = 5,
    MediaErrorAlreadyMaxOnRaiseVolume = 6,
    MediaErrorAlreadyMinOnLowerVolume = 7,
    MediaErrorAlreadyPausedOnAdjustVolume = 8,
    MediaErrorAlreadyPausedOnSetVolume = 9,
    MediaErrorAlreadyPausedOnSetMute = 10,
}
impl MediaErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MediaErrorOk => "Media_ERROR_OK",
            Self::MediaErrorUnsupportSystem => "Media_ERROR_UNSUPPORT_SYSTEM",
            Self::MediaErrorNoPermission => "Media_ERROR_NO_PERMISSION",
            Self::MediaErrorNoMusic => "Media_ERROR_NO_MUSIC",
            Self::MediaErrorAlreadyPlayingOnPlay => "Media_ERROR_ALREADY_PLAYING_ON_PLAY",
            Self::MediaErrorAlreadyPausedOnPause => "Media_ERROR_ALREADY_PAUSED_ON_PAUSE",
            Self::MediaErrorAlreadyMaxOnRaiseVolume => {
                "Media_ERROR_ALREADY_MAX_ON_RAISE_VOLUME"
            }
            Self::MediaErrorAlreadyMinOnLowerVolume => {
                "Media_ERROR_ALREADY_MIN_ON_LOWER_VOLUME"
            }
            Self::MediaErrorAlreadyPausedOnAdjustVolume => {
                "Media_ERROR_ALREADY_PAUSED_ON_ADJUST_VOLUME"
            }
            Self::MediaErrorAlreadyPausedOnSetVolume => {
                "Media_ERROR_ALREADY_PAUSED_ON_SET_VOLUME"
            }
            Self::MediaErrorAlreadyPausedOnSetMute => {
                "Media_ERROR_ALREADY_PAUSED_ON_SET_MUTE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Media_ERROR_OK" => Some(Self::MediaErrorOk),
            "Media_ERROR_UNSUPPORT_SYSTEM" => Some(Self::MediaErrorUnsupportSystem),
            "Media_ERROR_NO_PERMISSION" => Some(Self::MediaErrorNoPermission),
            "Media_ERROR_NO_MUSIC" => Some(Self::MediaErrorNoMusic),
            "Media_ERROR_ALREADY_PLAYING_ON_PLAY" => {
                Some(Self::MediaErrorAlreadyPlayingOnPlay)
            }
            "Media_ERROR_ALREADY_PAUSED_ON_PAUSE" => {
                Some(Self::MediaErrorAlreadyPausedOnPause)
            }
            "Media_ERROR_ALREADY_MAX_ON_RAISE_VOLUME" => {
                Some(Self::MediaErrorAlreadyMaxOnRaiseVolume)
            }
            "Media_ERROR_ALREADY_MIN_ON_LOWER_VOLUME" => {
                Some(Self::MediaErrorAlreadyMinOnLowerVolume)
            }
            "Media_ERROR_ALREADY_PAUSED_ON_ADJUST_VOLUME" => {
                Some(Self::MediaErrorAlreadyPausedOnAdjustVolume)
            }
            "Media_ERROR_ALREADY_PAUSED_ON_SET_VOLUME" => {
                Some(Self::MediaErrorAlreadyPausedOnSetVolume)
            }
            "Media_ERROR_ALREADY_PAUSED_ON_SET_MUTE" => {
                Some(Self::MediaErrorAlreadyPausedOnSetMute)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpeakerVolumeType {
    SpeakerVolumeUnknown = -1,
    SpeakerVolumeMedia = 0,
    SpeakerVolumeRing = 1,
    SpeakerVolumeNotification = 2,
    SpeakerVolumeVoiceAssistant = 3,
    SpeakerVolumeAlarm = 4,
}
impl SpeakerVolumeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SpeakerVolumeUnknown => "Speaker_VOLUME_UNKNOWN",
            Self::SpeakerVolumeMedia => "Speaker_VOLUME_MEDIA",
            Self::SpeakerVolumeRing => "Speaker_VOLUME_RING",
            Self::SpeakerVolumeNotification => "Speaker_VOLUME_NOTIFICATION",
            Self::SpeakerVolumeVoiceAssistant => "Speaker_VOLUME_VOICE_ASSISTANT",
            Self::SpeakerVolumeAlarm => "Speaker_VOLUME_ALARM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Speaker_VOLUME_UNKNOWN" => Some(Self::SpeakerVolumeUnknown),
            "Speaker_VOLUME_MEDIA" => Some(Self::SpeakerVolumeMedia),
            "Speaker_VOLUME_RING" => Some(Self::SpeakerVolumeRing),
            "Speaker_VOLUME_NOTIFICATION" => Some(Self::SpeakerVolumeNotification),
            "Speaker_VOLUME_VOICE_ASSISTANT" => Some(Self::SpeakerVolumeVoiceAssistant),
            "Speaker_VOLUME_ALARM" => Some(Self::SpeakerVolumeAlarm),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpeakerUnitDef {
    SpeakerUnitUnknown = -1,
    SpeakerUnitPercent = 0,
    SpeakerUnitAbsolute = 1,
}
impl SpeakerUnitDef {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SpeakerUnitUnknown => "Speaker_UNIT_UNKNOWN",
            Self::SpeakerUnitPercent => "Speaker_UNIT_PERCENT",
            Self::SpeakerUnitAbsolute => "Speaker_UNIT_ABSOLUTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Speaker_UNIT_UNKNOWN" => Some(Self::SpeakerUnitUnknown),
            "Speaker_UNIT_PERCENT" => Some(Self::SpeakerUnitPercent),
            "Speaker_UNIT_ABSOLUTE" => Some(Self::SpeakerUnitAbsolute),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Market {
    #[prost(oneof = "market::Payload", tags = "1, 2, 3, 4")]
    pub payload: ::core::option::Option<market::Payload>,
}
/// Nested message and enum types in `Market`.
pub mod market {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MarketId {
        TryInstallApk = 0,
        TryInstallApks = 1,
        ReportInstallProgress = 2,
        TryInstallApkNew = 3,
        TryInstallApksNew = 4,
        SendPhoneMessage = 5,
        SendWearMessage = 6,
    }
    impl MarketId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TryInstallApk => "TRY_INSTALL_APK",
                Self::TryInstallApks => "TRY_INSTALL_APKS",
                Self::ReportInstallProgress => "REPORT_INSTALL_PROGRESS",
                Self::TryInstallApkNew => "TRY_INSTALL_APK_NEW",
                Self::TryInstallApksNew => "TRY_INSTALL_APKS_NEW",
                Self::SendPhoneMessage => "SEND_PHONE_MESSAGE",
                Self::SendWearMessage => "SEND_WEAR_MESSAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRY_INSTALL_APK" => Some(Self::TryInstallApk),
                "TRY_INSTALL_APKS" => Some(Self::TryInstallApks),
                "REPORT_INSTALL_PROGRESS" => Some(Self::ReportInstallProgress),
                "TRY_INSTALL_APK_NEW" => Some(Self::TryInstallApkNew),
                "TRY_INSTALL_APKS_NEW" => Some(Self::TryInstallApksNew),
                "SEND_PHONE_MESSAGE" => Some(Self::SendPhoneMessage),
                "SEND_WEAR_MESSAGE" => Some(Self::SendWearMessage),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Apk(super::Apk),
        #[prost(message, tag = "2")]
        ApkList(super::apk::List),
        #[prost(message, tag = "3")]
        InstallProgress(super::InstallProgress),
        #[prost(message, tag = "4")]
        MarketMessage(super::MarketMessage),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Apk {
    #[prost(enumeration = "ApkType", required, tag = "1")]
    pub r#type: i32,
    #[prost(oneof = "apk::Payload", tags = "2, 3, 4")]
    pub payload: ::core::option::Option<apk::Payload>,
}
/// Nested message and enum types in `Apk`.
pub mod apk {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::Apk>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(string, tag = "2")]
        PackageName(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        Url(::prost::alloc::string::String),
        #[prost(message, tag = "4")]
        ApkInfo(super::ApkInfo),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApkInfo {
    #[prost(string, required, tag = "1")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub package_hash: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "3")]
    pub version_code: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallProgress {
    #[prost(enumeration = "InstallCode", required, tag = "1")]
    pub code: i32,
    #[prost(string, required, tag = "2")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "3")]
    pub download_progress: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketMessage {
    #[prost(bytes = "vec", required, tag = "1")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApkType {
    App = 0,
    WatchFace = 1,
}
impl ApkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::App => "APP",
            Self::WatchFace => "WATCH_FACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APP" => Some(Self::App),
            "WATCH_FACE" => Some(Self::WatchFace),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstallCode {
    VersionDowngrade = 0,
    LatestVersion = 1,
    ApkNotFound = 2,
    WaitingDownload = 3,
    Downloading = 4,
    DownloadFailed = 5,
    Installing = 6,
    InstallSuccess = 7,
    InstallFailed = 8,
    Cancelled = 9,
}
impl InstallCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VersionDowngrade => "VERSION_DOWNGRADE",
            Self::LatestVersion => "LATEST_VERSION",
            Self::ApkNotFound => "APK_NOT_FOUND",
            Self::WaitingDownload => "WAITING_DOWNLOAD",
            Self::Downloading => "DOWNLOADING",
            Self::DownloadFailed => "DOWNLOAD_FAILED",
            Self::Installing => "INSTALLING",
            Self::InstallSuccess => "INSTALL_SUCCESS",
            Self::InstallFailed => "INSTALL_FAILED",
            Self::Cancelled => "CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSION_DOWNGRADE" => Some(Self::VersionDowngrade),
            "LATEST_VERSION" => Some(Self::LatestVersion),
            "APK_NOT_FOUND" => Some(Self::ApkNotFound),
            "WAITING_DOWNLOAD" => Some(Self::WaitingDownload),
            "DOWNLOADING" => Some(Self::Downloading),
            "DOWNLOAD_FAILED" => Some(Self::DownloadFailed),
            "INSTALLING" => Some(Self::Installing),
            "INSTALL_SUCCESS" => Some(Self::InstallSuccess),
            "INSTALL_FAILED" => Some(Self::InstallFailed),
            "CANCELLED" => Some(Self::Cancelled),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gnss {
    #[prost(oneof = "gnss::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<gnss::Payload>,
}
/// Nested message and enum types in `Gnss`.
pub mod gnss {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GnssId {
        RequestOnline = 0,
        RequestOffline = 1,
        RequestGpsInfo = 3,
        SendGpsInfo = 2,
    }
    impl GnssId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RequestOnline => "REQUEST_ONLINE",
                Self::RequestOffline => "REQUEST_OFFLINE",
                Self::RequestGpsInfo => "REQUEST_GPS_INFO",
                Self::SendGpsInfo => "SEND_GPS_INFO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REQUEST_ONLINE" => Some(Self::RequestOnline),
                "REQUEST_OFFLINE" => Some(Self::RequestOffline),
                "REQUEST_GPS_INFO" => Some(Self::RequestGpsInfo),
                "SEND_GPS_INFO" => Some(Self::SendGpsInfo),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(uint32, tag = "1")]
        Days(u32),
        #[prost(message, tag = "2")]
        Data(super::Data),
        #[prost(message, tag = "3")]
        GpsInfo(super::GpsInfo),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(enumeration = "data::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(string, required, tag = "2")]
    pub source: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "3")]
    pub days: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub need_gps_info: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "5")]
    pub expected_slice_length: ::core::option::Option<u32>,
}
/// Nested message and enum types in `Data`.
pub mod data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Agps = 1,
        Beidou = 2,
        Galileo = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Agps => "AGPS",
                Self::Beidou => "BEIDOU",
                Self::Galileo => "GALILEO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AGPS" => Some(Self::Agps),
                "BEIDOU" => Some(Self::Beidou),
                "GALILEO" => Some(Self::Galileo),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpsInfo {
    #[prost(uint32, required, tag = "1")]
    pub timestamp: u32,
    #[prost(double, required, tag = "2")]
    pub longitude: f64,
    #[prost(double, required, tag = "3")]
    pub latitude: f64,
    #[prost(double, optional, tag = "4")]
    pub altitude: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Clock {
    #[prost(
        oneof = "clock::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18"
    )]
    pub payload: ::core::option::Option<clock::Payload>,
}
/// Nested message and enum types in `Clock`.
pub mod clock {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClockId {
        GetClockList = 0,
        AddClock = 1,
        UpdateClock = 2,
        RemoveClock = 3,
        RemoveClocks = 4,
        EnableOrDisableClock = 5,
        GetReminderList = 14,
        AddReminder = 15,
        UpdateReminder = 17,
        RemoveReminders = 18,
        SyncReminderList = 19,
        MarkReminder = 20,
        RequestReminders = 21,
        SyncHoliday = 6,
        WearRequestHoliday = 7,
        GetWorkAndRest = 8,
        SetWorkAndRest = 9,
        GetWorldClockList = 10,
        AddWorldClock = 11,
        RemoveWorldClock = 12,
        RemoveWorldClocks = 13,
        PhoneAlarmOperation = 16,
    }
    impl ClockId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GetClockList => "GET_CLOCK_LIST",
                Self::AddClock => "ADD_CLOCK",
                Self::UpdateClock => "UPDATE_CLOCK",
                Self::RemoveClock => "REMOVE_CLOCK",
                Self::RemoveClocks => "REMOVE_CLOCKS",
                Self::EnableOrDisableClock => "ENABLE_OR_DISABLE_CLOCK",
                Self::GetReminderList => "GET_REMINDER_LIST",
                Self::AddReminder => "ADD_REMINDER",
                Self::UpdateReminder => "UPDATE_REMINDER",
                Self::RemoveReminders => "REMOVE_REMINDERS",
                Self::SyncReminderList => "SYNC_REMINDER_LIST",
                Self::MarkReminder => "MARK_REMINDER",
                Self::RequestReminders => "REQUEST_REMINDERS",
                Self::SyncHoliday => "SYNC_HOLIDAY",
                Self::WearRequestHoliday => "WEAR_REQUEST_HOLIDAY",
                Self::GetWorkAndRest => "GET_WORK_AND_REST",
                Self::SetWorkAndRest => "SET_WORK_AND_REST",
                Self::GetWorldClockList => "GET_WORLD_CLOCK_LIST",
                Self::AddWorldClock => "ADD_WORLD_CLOCK",
                Self::RemoveWorldClock => "REMOVE_WORLD_CLOCK",
                Self::RemoveWorldClocks => "REMOVE_WORLD_CLOCKS",
                Self::PhoneAlarmOperation => "PHONE_ALARM_OPERATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GET_CLOCK_LIST" => Some(Self::GetClockList),
                "ADD_CLOCK" => Some(Self::AddClock),
                "UPDATE_CLOCK" => Some(Self::UpdateClock),
                "REMOVE_CLOCK" => Some(Self::RemoveClock),
                "REMOVE_CLOCKS" => Some(Self::RemoveClocks),
                "ENABLE_OR_DISABLE_CLOCK" => Some(Self::EnableOrDisableClock),
                "GET_REMINDER_LIST" => Some(Self::GetReminderList),
                "ADD_REMINDER" => Some(Self::AddReminder),
                "UPDATE_REMINDER" => Some(Self::UpdateReminder),
                "REMOVE_REMINDERS" => Some(Self::RemoveReminders),
                "SYNC_REMINDER_LIST" => Some(Self::SyncReminderList),
                "MARK_REMINDER" => Some(Self::MarkReminder),
                "REQUEST_REMINDERS" => Some(Self::RequestReminders),
                "SYNC_HOLIDAY" => Some(Self::SyncHoliday),
                "WEAR_REQUEST_HOLIDAY" => Some(Self::WearRequestHoliday),
                "GET_WORK_AND_REST" => Some(Self::GetWorkAndRest),
                "SET_WORK_AND_REST" => Some(Self::SetWorkAndRest),
                "GET_WORLD_CLOCK_LIST" => Some(Self::GetWorldClockList),
                "ADD_WORLD_CLOCK" => Some(Self::AddWorldClock),
                "REMOVE_WORLD_CLOCK" => Some(Self::RemoveWorldClock),
                "REMOVE_WORLD_CLOCKS" => Some(Self::RemoveWorldClocks),
                "PHONE_ALARM_OPERATION" => Some(Self::PhoneAlarmOperation),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        ClockInfoList(super::clock_info::List),
        #[prost(message, tag = "2")]
        ClockData(super::clock_info::Data),
        #[prost(message, tag = "3")]
        ClockInfo(super::ClockInfo),
        #[prost(uint32, tag = "4")]
        Id(u32),
        #[prost(message, tag = "5")]
        ClockIdList(super::ClockIdList),
        #[prost(bool, tag = "6")]
        Enable(bool),
        #[prost(message, tag = "7")]
        ClockHoliday(super::ClockHoliday),
        #[prost(enumeration = "super::ClockError", tag = "8")]
        ClockError(i32),
        #[prost(message, tag = "9")]
        WorkAndRest(super::WorkAndRest),
        #[prost(message, tag = "10")]
        ReminderInfoList(super::reminder_info::List),
        #[prost(message, tag = "11")]
        WorldClockIdList(super::WorldClockIdList),
        #[prost(string, tag = "12")]
        WorldClockId(::prost::alloc::string::String),
        #[prost(enumeration = "super::WorldClockResult", tag = "13")]
        WorldClockResult(i32),
        #[prost(message, tag = "14")]
        ReminderData(super::reminder_info::Data),
        #[prost(message, tag = "15")]
        ReminderInfo(super::ReminderInfo),
        #[prost(message, tag = "16")]
        PhoneAlarmOperation(super::phone_alarm::Operation),
        #[prost(message, tag = "17")]
        ReminderIdList(super::ReminderIdList),
        #[prost(message, tag = "18")]
        ReminderMark(super::reminder_info::Mark),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockInfo {
    #[prost(uint32, required, tag = "1")]
    pub id: u32,
    #[prost(message, required, tag = "2")]
    pub data: clock_info::Data,
}
/// Nested message and enum types in `ClockInfo`.
pub mod clock_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, required, tag = "2")]
        pub time: super::Time,
        #[prost(enumeration = "super::ClockMode", required, tag = "3")]
        pub clock_mode: i32,
        #[prost(uint32, optional, tag = "4")]
        pub week_days: ::core::option::Option<u32>,
        #[prost(bool, required, tag = "5")]
        pub enable: bool,
        #[prost(string, required, tag = "6")]
        pub label: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ClockInfo>,
        #[prost(uint32, optional, tag = "2")]
        pub support_max_clocks: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClockIdList {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkAndRest {
    #[prost(enumeration = "work_and_rest::Source", required, tag = "1")]
    pub source: i32,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<work_and_rest::Data>,
}
/// Nested message and enum types in `WorkAndRest`.
pub mod work_and_rest {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, required, tag = "1")]
        pub bedtime: super::Time,
        #[prost(message, required, tag = "2")]
        pub getup_time: super::Time,
        #[prost(sint32, required, tag = "3")]
        pub remind_bed: i32,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        None = 0,
        Miui = 1,
        Manual = 2,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Miui => "MIUI",
                Self::Manual => "MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "MIUI" => Some(Self::Miui),
                "MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldClockIdList {
    #[prost(string, repeated, tag = "1")]
    pub id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhoneAlarm {
    #[prost(uint32, required, tag = "1")]
    pub id: u32,
    #[prost(uint32, optional, tag = "2")]
    pub alert_time: ::core::option::Option<u32>,
    #[prost(string, required, tag = "3")]
    pub label: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PhoneAlarm`.
pub mod phone_alarm {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Operation {
        #[prost(enumeration = "OpCode", required, tag = "1")]
        pub op_code: i32,
        #[prost(message, required, tag = "2")]
        pub phone_alarm: super::PhoneAlarm,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OpCode {
        Alert = 0,
        Dismiss = 1,
        Snooze = 2,
    }
    impl OpCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Alert => "ALERT",
                Self::Dismiss => "DISMISS",
                Self::Snooze => "SNOOZE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALERT" => Some(Self::Alert),
                "DISMISS" => Some(Self::Dismiss),
                "SNOOZE" => Some(Self::Snooze),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReminderInfo {
    #[prost(uint32, required, tag = "1")]
    pub id: u32,
    #[prost(message, required, tag = "2")]
    pub data: reminder_info::Data,
}
/// Nested message and enum types in `ReminderInfo`.
pub mod reminder_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ReminderInfo>,
        #[prost(uint32, optional, tag = "2")]
        pub support_max_reminders: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubTodo {
        #[prost(uint32, required, tag = "1")]
        pub id: u32,
        #[prost(uint32, required, tag = "2")]
        pub status: u32,
        #[prost(string, required, tag = "3")]
        pub content: ::prost::alloc::string::String,
        #[prost(bool, optional, tag = "4")]
        pub truncated: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, required, tag = "1")]
        pub date: super::Date,
        #[prost(message, required, tag = "2")]
        pub time: super::Time,
        #[prost(enumeration = "super::ClockMode", required, tag = "3")]
        pub clock_mode: i32,
        #[prost(uint32, optional, tag = "4")]
        pub week_days: ::core::option::Option<u32>,
        #[prost(string, required, tag = "5")]
        pub label: ::prost::alloc::string::String,
        #[prost(bool, optional, tag = "6")]
        pub truncated: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag = "7")]
        pub source: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "8")]
        pub status: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag = "9")]
        pub update_time: ::core::option::Option<u64>,
        #[prost(message, repeated, tag = "10")]
        pub sub_list: ::prost::alloc::vec::Vec<SubTodo>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Mark {
        #[prost(uint32, required, tag = "1")]
        pub id: u32,
        #[prost(uint32, optional, tag = "2")]
        pub source: ::core::option::Option<u32>,
        #[prost(uint32, required, tag = "3")]
        pub status: u32,
        #[prost(uint64, required, tag = "4")]
        pub update_time: u64,
        #[prost(message, repeated, tag = "5")]
        pub sub_list: ::prost::alloc::vec::Vec<SubTodo>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReminderIdList {
    #[prost(uint32, repeated, packed = "false", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClockError {
    ExceedLimit = 1,
    InvalidId = 2,
    InvalidData = 3,
    NotSupportHoliday = 4,
}
impl ClockError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ExceedLimit => "EXCEED_LIMIT",
            Self::InvalidId => "INVALID_ID",
            Self::InvalidData => "INVALID_DATA",
            Self::NotSupportHoliday => "NOT_SUPPORT_HOLIDAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXCEED_LIMIT" => Some(Self::ExceedLimit),
            "INVALID_ID" => Some(Self::InvalidId),
            "INVALID_DATA" => Some(Self::InvalidData),
            "NOT_SUPPORT_HOLIDAY" => Some(Self::NotSupportHoliday),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorldClockResult {
    OperateSuccess = 0,
    IdNotSupport = 1,
    OverLimit = 2,
}
impl WorldClockResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::OperateSuccess => "OPERATE_SUCCESS",
            Self::IdNotSupport => "ID_NOT_SUPPORT",
            Self::OverLimit => "OVER_LIMIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATE_SUCCESS" => Some(Self::OperateSuccess),
            "ID_NOT_SUPPORT" => Some(Self::IdNotSupport),
            "OVER_LIMIT" => Some(Self::OverLimit),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Media {
    #[prost(
        oneof = "media::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19"
    )]
    pub payload: ::core::option::Option<media::Payload>,
}
/// Nested message and enum types in `Media`.
pub mod media {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaId {
        WearRequest = 0,
        SyncPlayerInfo = 1,
        ControlPlayer = 2,
        GetSongSummary = 3,
        AddSonglist = 4,
        RemoveSonglist = 5,
        RenameSonglist = 6,
        QuerySongForSonglist = 7,
        AddSongToSonglist = 8,
        RemoveSongFromSonglist = 9,
        GetSong = 10,
        AddSong = 11,
        ReportSongResult = 12,
        RemoveSong = 13,
        GetMediaFileSummary = 14,
        SyncMediaFileList = 15,
        ReportMediaFileList = 16,
        RequestMediaFile = 17,
        RequestMediaFileList = 18,
        ConfirmMediaFile = 19,
        RequestRecord = 20,
        GetRecordStatus = 21,
        ReportRecordStatus = 22,
    }
    impl MediaId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::WearRequest => "WEAR_REQUEST",
                Self::SyncPlayerInfo => "SYNC_PLAYER_INFO",
                Self::ControlPlayer => "CONTROL_PLAYER",
                Self::GetSongSummary => "GET_SONG_SUMMARY",
                Self::AddSonglist => "ADD_SONGLIST",
                Self::RemoveSonglist => "REMOVE_SONGLIST",
                Self::RenameSonglist => "RENAME_SONGLIST",
                Self::QuerySongForSonglist => "QUERY_SONG_FOR_SONGLIST",
                Self::AddSongToSonglist => "ADD_SONG_TO_SONGLIST",
                Self::RemoveSongFromSonglist => "REMOVE_SONG_FROM_SONGLIST",
                Self::GetSong => "GET_SONG",
                Self::AddSong => "ADD_SONG",
                Self::ReportSongResult => "REPORT_SONG_RESULT",
                Self::RemoveSong => "REMOVE_SONG",
                Self::GetMediaFileSummary => "GET_MEDIA_FILE_SUMMARY",
                Self::SyncMediaFileList => "SYNC_MEDIA_FILE_LIST",
                Self::ReportMediaFileList => "REPORT_MEDIA_FILE_LIST",
                Self::RequestMediaFile => "REQUEST_MEDIA_FILE",
                Self::RequestMediaFileList => "REQUEST_MEDIA_FILE_LIST",
                Self::ConfirmMediaFile => "CONFIRM_MEDIA_FILE",
                Self::RequestRecord => "REQUEST_RECORD",
                Self::GetRecordStatus => "GET_RECORD_STATUS",
                Self::ReportRecordStatus => "REPORT_RECORD_STATUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WEAR_REQUEST" => Some(Self::WearRequest),
                "SYNC_PLAYER_INFO" => Some(Self::SyncPlayerInfo),
                "CONTROL_PLAYER" => Some(Self::ControlPlayer),
                "GET_SONG_SUMMARY" => Some(Self::GetSongSummary),
                "ADD_SONGLIST" => Some(Self::AddSonglist),
                "REMOVE_SONGLIST" => Some(Self::RemoveSonglist),
                "RENAME_SONGLIST" => Some(Self::RenameSonglist),
                "QUERY_SONG_FOR_SONGLIST" => Some(Self::QuerySongForSonglist),
                "ADD_SONG_TO_SONGLIST" => Some(Self::AddSongToSonglist),
                "REMOVE_SONG_FROM_SONGLIST" => Some(Self::RemoveSongFromSonglist),
                "GET_SONG" => Some(Self::GetSong),
                "ADD_SONG" => Some(Self::AddSong),
                "REPORT_SONG_RESULT" => Some(Self::ReportSongResult),
                "REMOVE_SONG" => Some(Self::RemoveSong),
                "GET_MEDIA_FILE_SUMMARY" => Some(Self::GetMediaFileSummary),
                "SYNC_MEDIA_FILE_LIST" => Some(Self::SyncMediaFileList),
                "REPORT_MEDIA_FILE_LIST" => Some(Self::ReportMediaFileList),
                "REQUEST_MEDIA_FILE" => Some(Self::RequestMediaFile),
                "REQUEST_MEDIA_FILE_LIST" => Some(Self::RequestMediaFileList),
                "CONFIRM_MEDIA_FILE" => Some(Self::ConfirmMediaFile),
                "REQUEST_RECORD" => Some(Self::RequestRecord),
                "GET_RECORD_STATUS" => Some(Self::GetRecordStatus),
                "REPORT_RECORD_STATUS" => Some(Self::ReportRecordStatus),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        PlayerInfo(super::PlayerInfo),
        #[prost(message, tag = "2")]
        PlayerControl(super::PlayerControl),
        #[prost(message, tag = "3")]
        SongSummary(super::SongSummary),
        #[prost(message, tag = "4")]
        SonglistRequest(super::songlist::Request),
        #[prost(message, tag = "5")]
        SonglistResponse(super::songlist::Response),
        #[prost(message, tag = "6")]
        SongGetRequest(super::song::GetRequest),
        #[prost(message, tag = "7")]
        SongGetResponse(super::song::GetResponse),
        #[prost(message, tag = "8")]
        SongAddRequest(super::song::AddRequest),
        #[prost(message, tag = "9")]
        SongAddResponse(super::song::AddResponse),
        #[prost(message, tag = "10")]
        SongReportResult(super::song::ReportResult),
        #[prost(message, tag = "11")]
        SongRemoveRequest(super::song::RemoveRequest),
        #[prost(message, tag = "12")]
        SongRemoveResponse(super::song::RemoveResponse),
        #[prost(message, tag = "13")]
        MediaFileSummary(super::media_file::Summary),
        #[prost(message, tag = "14")]
        MediaFileList(super::media_file::List),
        #[prost(message, tag = "15")]
        MediaFileIdentifier(super::media_file::Identifier),
        #[prost(message, tag = "16")]
        MediaFileIdentifiers(super::media_file::identifier::List),
        #[prost(message, tag = "17")]
        RecordRequest(super::RecordRequest),
        #[prost(message, tag = "18")]
        RecordResponse(super::RecordResponse),
        #[prost(message, tag = "19")]
        RecordStatus(super::RecordStatus),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerInfo {
    #[prost(enumeration = "player_info::State", required, tag = "1")]
    pub state: i32,
    #[prost(uint32, optional, tag = "2")]
    pub volume: ::core::option::Option<u32>,
    #[prost(string, required, tag = "3")]
    pub player_name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub song_title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub song_artist: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "6")]
    pub current_position: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub duration: ::core::option::Option<u32>,
}
/// Nested message and enum types in `PlayerInfo`.
pub mod player_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        None = 0,
        Playing = 1,
        Pause = 2,
        Stop = 3,
        NoPermission = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Playing => "PLAYING",
                Self::Pause => "PAUSE",
                Self::Stop => "STOP",
                Self::NoPermission => "NO_PERMISSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "PLAYING" => Some(Self::Playing),
                "PAUSE" => Some(Self::Pause),
                "STOP" => Some(Self::Stop),
                "NO_PERMISSION" => Some(Self::NoPermission),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerControl {
    #[prost(enumeration = "player_control::Command", required, tag = "1")]
    pub command: i32,
    #[prost(uint32, optional, tag = "2")]
    pub volume: ::core::option::Option<u32>,
}
/// Nested message and enum types in `PlayerControl`.
pub mod player_control {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Command {
        Play = 0,
        Pause = 1,
        Stop = 2,
        Prev = 3,
        Next = 4,
        AdjustVolume = 5,
    }
    impl Command {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Play => "PLAY",
                Self::Pause => "PAUSE",
                Self::Stop => "STOP",
                Self::Prev => "PREV",
                Self::Next => "NEXT",
                Self::AdjustVolume => "ADJUST_VOLUME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLAY" => Some(Self::Play),
                "PAUSE" => Some(Self::Pause),
                "STOP" => Some(Self::Stop),
                "PREV" => Some(Self::Prev),
                "NEXT" => Some(Self::Next),
                "ADJUST_VOLUME" => Some(Self::AdjustVolume),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SongSummary {
    #[prost(uint32, required, tag = "1")]
    pub support_media_format: u32,
    #[prost(uint32, required, tag = "2")]
    pub song_count: u32,
    #[prost(uint32, required, tag = "3")]
    pub songlist_limit: u32,
    #[prost(message, repeated, tag = "4")]
    pub list: ::prost::alloc::vec::Vec<Songlist>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Songlist {
    #[prost(uint32, required, tag = "1")]
    pub id: u32,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "3")]
    pub song_count: u32,
}
/// Nested message and enum types in `Songlist`.
pub mod songlist {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(enumeration = "request::Cmd", required, tag = "1")]
        pub cmd: i32,
        #[prost(uint32, required, tag = "2")]
        pub id: u32,
        #[prost(string, required, tag = "3")]
        pub name: ::prost::alloc::string::String,
        #[prost(bytes = "vec", required, tag = "4")]
        pub song_ids: ::prost::alloc::vec::Vec<u8>,
    }
    /// Nested message and enum types in `Request`.
    pub mod request {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Cmd {
            Add = 1,
            Remove = 2,
            Rename = 3,
            QuerySong = 4,
            AddSong = 5,
            RemoveSong = 6,
        }
        impl Cmd {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Add => "ADD",
                    Self::Remove => "REMOVE",
                    Self::Rename => "RENAME",
                    Self::QuerySong => "QUERY_SONG",
                    Self::AddSong => "ADD_SONG",
                    Self::RemoveSong => "REMOVE_SONG",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ADD" => Some(Self::Add),
                    "REMOVE" => Some(Self::Remove),
                    "RENAME" => Some(Self::Rename),
                    "QUERY_SONG" => Some(Self::QuerySong),
                    "ADD_SONG" => Some(Self::AddSong),
                    "REMOVE_SONG" => Some(Self::RemoveSong),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(enumeration = "response::Code", required, tag = "1")]
        pub code: i32,
        #[prost(bytes = "vec", required, tag = "2")]
        pub song_ids: ::prost::alloc::vec::Vec<u8>,
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Code {
            NoError = 0,
            CmdNotSupport = 1,
            ExceedLimit = 2,
            IdExist = 3,
            IdNotFound = 4,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::NoError => "NO_ERROR",
                    Self::CmdNotSupport => "CMD_NOT_SUPPORT",
                    Self::ExceedLimit => "EXCEED_LIMIT",
                    Self::IdExist => "ID_EXIST",
                    Self::IdNotFound => "ID_NOT_FOUND",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NO_ERROR" => Some(Self::NoError),
                    "CMD_NOT_SUPPORT" => Some(Self::CmdNotSupport),
                    "EXCEED_LIMIT" => Some(Self::ExceedLimit),
                    "ID_EXIST" => Some(Self::IdExist),
                    "ID_NOT_FOUND" => Some(Self::IdNotFound),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Song {
    #[prost(bytes = "vec", required, tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "3")]
    pub size: u32,
    #[prost(uint32, optional, tag = "5")]
    pub duration: ::core::option::Option<u32>,
    #[prost(string, required, tag = "6")]
    pub album: ::prost::alloc::string::String,
    #[prost(string, required, tag = "7")]
    pub artist: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Song`.
pub mod song {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GetRequest {
        #[prost(uint32, required, tag = "1")]
        pub index: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GetResponse {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::Song>,
        #[prost(uint32, required, tag = "2")]
        pub next_index: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddRequest {
        #[prost(message, required, tag = "1")]
        pub song: super::Song,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AddResponse {
        #[prost(enumeration = "super::PrepareStatus", required, tag = "1")]
        pub prepare_status: i32,
        #[prost(uint32, optional, tag = "2")]
        pub expected_slice_length: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReportResult {
        #[prost(enumeration = "report_result::Code", required, tag = "1")]
        pub code: i32,
        #[prost(bytes = "vec", optional, tag = "2")]
        pub id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    /// Nested message and enum types in `ReportResult`.
    pub mod report_result {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Code {
            Success = 0,
            IdNotMatch = 1,
            Fail = 2,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Success => "SUCCESS",
                    Self::IdNotMatch => "ID_NOT_MATCH",
                    Self::Fail => "FAIL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUCCESS" => Some(Self::Success),
                    "ID_NOT_MATCH" => Some(Self::IdNotMatch),
                    "FAIL" => Some(Self::Fail),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RemoveRequest {
        #[prost(bytes = "vec", required, tag = "1")]
        pub id: ::prost::alloc::vec::Vec<u8>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RemoveResponse {
        #[prost(bool, required, tag = "1")]
        pub success: bool,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaFile {}
/// Nested message and enum types in `MediaFile`.
pub mod media_file {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Summary {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<summary::Item>,
    }
    /// Nested message and enum types in `Summary`.
    pub mod summary {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Item {
            #[prost(enumeration = "super::Type", required, tag = "1")]
            pub r#type: i32,
            #[prost(uint32, required, tag = "2")]
            pub count: u32,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::MediaFile>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Identifier {
        #[prost(string, required, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(bool, required, tag = "2")]
        pub thumbnail: bool,
    }
    /// Nested message and enum types in `Identifier`.
    pub mod identifier {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Identifier>,
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Jpeg = 0,
        Png = 1,
        Mp4 = 2,
        Quicktime = 3,
        Pcm = 4,
        Opus = 5,
        Sbc = 6,
        Msbc = 7,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Jpeg => "JPEG",
                Self::Png => "PNG",
                Self::Mp4 => "MP4",
                Self::Quicktime => "QUICKTIME",
                Self::Pcm => "PCM",
                Self::Opus => "OPUS",
                Self::Sbc => "SBC",
                Self::Msbc => "MSBC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JPEG" => Some(Self::Jpeg),
                "PNG" => Some(Self::Png),
                "MP4" => Some(Self::Mp4),
                "QUICKTIME" => Some(Self::Quicktime),
                "PCM" => Some(Self::Pcm),
                "OPUS" => Some(Self::Opus),
                "SBC" => Some(Self::Sbc),
                "MSBC" => Some(Self::Msbc),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordRequest {
    #[prost(enumeration = "RecordType", required, tag = "1")]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub action: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordResponse {
    #[prost(uint32, required, tag = "1")]
    pub code: u32,
    #[prost(message, optional, tag = "2")]
    pub media_file_id: ::core::option::Option<media_file::Identifier>,
    #[prost(uint32, optional, tag = "3")]
    pub duration: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordStatus {
    #[prost(message, required, tag = "1")]
    pub duration: LimitValue,
    #[prost(message, optional, tag = "2")]
    pub size: ::core::option::Option<LimitValue>,
    #[prost(message, optional, tag = "3")]
    pub extra_data: ::core::option::Option<record_status::ExtraData>,
}
/// Nested message and enum types in `RecordStatus`.
pub mod record_status {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExtraData {
        #[prost(message, required, tag = "1")]
        pub media_file: super::MediaFile,
        #[prost(uint32, required, tag = "2")]
        pub status: u32,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RecordType {
    RecordNormal = 0,
    RecordRealtime = 1,
    RecordMusic = 2,
    RecordTranslation = 3,
    RecordTranslationFace = 4,
}
impl RecordType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RecordNormal => "RECORD_NORMAL",
            Self::RecordRealtime => "RECORD_REALTIME",
            Self::RecordMusic => "RECORD_MUSIC",
            Self::RecordTranslation => "RECORD_TRANSLATION",
            Self::RecordTranslationFace => "RECORD_TRANSLATION_FACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RECORD_NORMAL" => Some(Self::RecordNormal),
            "RECORD_REALTIME" => Some(Self::RecordRealtime),
            "RECORD_MUSIC" => Some(Self::RecordMusic),
            "RECORD_TRANSLATION" => Some(Self::RecordTranslation),
            "RECORD_TRANSLATION_FACE" => Some(Self::RecordTranslationFace),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Alexa {
    #[prost(oneof = "alexa::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<alexa::Payload>,
}
/// Nested message and enum types in `Alexa`.
pub mod alexa {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AlexaId {
        SyncInstructionList = 0,
        SetConfig = 1,
        GetConfig = 2,
        ReportQuietMode = 3,
    }
    impl AlexaId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SyncInstructionList => "SYNC_INSTRUCTION_LIST",
                Self::SetConfig => "SET_CONFIG",
                Self::GetConfig => "GET_CONFIG",
                Self::ReportQuietMode => "REPORT_QUIET_MODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_INSTRUCTION_LIST" => Some(Self::SyncInstructionList),
                "SET_CONFIG" => Some(Self::SetConfig),
                "GET_CONFIG" => Some(Self::GetConfig),
                "REPORT_QUIET_MODE" => Some(Self::ReportQuietMode),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        InstructionList(super::alexa_instruction::List),
        #[prost(message, tag = "2")]
        Config(super::AlexaConfig),
        #[prost(message, tag = "3")]
        QuietMode(super::AlexaQuietMode),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaConfig {
    #[prost(string, required, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub refresh_token: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub language: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlexaQuietMode {
    #[prost(bool, required, tag = "1")]
    pub on: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaInstruction {
    #[prost(enumeration = "AlexaResultType", required, tag = "1")]
    pub result_type: i32,
    #[prost(message, optional, tag = "2")]
    pub template_general: ::core::option::Option<AlexaTemplateGeneral>,
    #[prost(message, optional, tag = "3")]
    pub template_weather: ::core::option::Option<AlexaTemplateWeather>,
    #[prost(message, optional, tag = "4")]
    pub template_lists: ::core::option::Option<AlexaTemplateLists>,
    #[prost(message, optional, tag = "5")]
    pub alerts_setalert: ::core::option::Option<AlexaAlertsSetAlert>,
    #[prost(message, optional, tag = "6")]
    pub speechsynthesizer_speak: ::core::option::Option<AlexaSpeechSynthesizerSpeak>,
    #[prost(enumeration = "AlexaAuthStatus", optional, tag = "7")]
    pub auth_status: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "12")]
    pub alerts_deletealerts: ::core::option::Option<alexa_alerts_delete_alert::List>,
    #[prost(message, optional, tag = "13")]
    pub notifications_setindicator: ::core::option::Option<
        AlexaNotificationsSetIndicator,
    >,
}
/// Nested message and enum types in `AlexaInstruction`.
pub mod alexa_instruction {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AlexaInstruction>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaTemplateGeneral {
    #[prost(message, required, tag = "1")]
    pub title: AlexaTitle,
    #[prost(string, required, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaTemplateWeather {
    #[prost(message, required, tag = "1")]
    pub title: AlexaTitle,
    #[prost(string, required, tag = "2")]
    pub current_weather: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub high_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub low_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub image: ::prost::alloc::string::String,
    #[prost(message, required, tag = "7")]
    pub weather_forecast: alexa_weather_item::List,
    #[prost(int32, required, tag = "8")]
    pub weather_code: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaWeatherItem {
    #[prost(string, required, tag = "1")]
    pub date: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub weekday: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub high_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub low_temperature: ::prost::alloc::string::String,
    #[prost(string, required, tag = "5")]
    pub image: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "6")]
    pub weather_code: i32,
}
/// Nested message and enum types in `AlexaWeatherItem`.
pub mod alexa_weather_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AlexaWeatherItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaTemplateLists {
    #[prost(message, required, tag = "1")]
    pub title: AlexaTitle,
    #[prost(message, required, tag = "2")]
    pub items: alexa_lists_item::List,
    #[prost(bool, required, tag = "3")]
    pub exceed_max_items: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaListsItem {
    #[prost(string, required, tag = "1")]
    pub left: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub right: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AlexaListsItem`.
pub mod alexa_lists_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AlexaListsItem>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaAlertsSetAlert {
    #[prost(string, required, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(enumeration = "AlexaAlertType", required, tag = "2")]
    pub r#type: i32,
    #[prost(string, required, tag = "3")]
    pub scheduled_time: ::prost::alloc::string::String,
    #[prost(string, required, tag = "4")]
    pub label: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaAlertsDeleteAlert {
    #[prost(string, required, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AlexaAlertsDeleteAlert`.
pub mod alexa_alerts_delete_alert {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AlexaAlertsDeleteAlert>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaSpeechSynthesizerSpeak {
    #[prost(string, required, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlexaTitle {
    #[prost(string, required, tag = "1")]
    pub main_title: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub sub_title: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlexaNotificationsSetIndicator {
    #[prost(bool, required, tag = "1")]
    pub play_audio_indicator: bool,
    #[prost(bool, required, tag = "2")]
    pub persist_visual_indicator: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlexaResultType {
    AlexaStartListening = 0,
    AlexaEndListening = 1,
    AlexaAuthStatus = 3,
    AlexaErrorNetwork = 80,
    AlexaErrorAuth = 81,
    AlexaErrorContentTooLong = 82,
    AlexaErrorUnrecognizableSpeech = 83,
    AlexaErrorUnsupportedArea = 84,
    AlexaErrorIosDeviceNotSupport = 85,
    AlexaErrorAndroidDeviceNotSupport = 86,
    AlexaErrorPlayNotSupport = 87,
    AlexaTemplateGeneral = 257,
    AlexaTemplateWeather = 258,
    AlexaTemplateLists = 259,
    AlexaAlertsSetalert = 260,
    AlexaAlertsDeletealerts = 261,
    AlexaSpeechsynthesizerSpeak = 262,
    AlexaSpeechrecognizerExpectspeech = 263,
    AlexaNotificationsSetindicator = 264,
    AlexaNotificationsClearindicator = 265,
}
impl AlexaResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AlexaStartListening => "ALEXA_START_LISTENING",
            Self::AlexaEndListening => "ALEXA_END_LISTENING",
            Self::AlexaAuthStatus => "ALEXA_AUTH_STATUS",
            Self::AlexaErrorNetwork => "ALEXA_ERROR_NETWORK",
            Self::AlexaErrorAuth => "ALEXA_ERROR_AUTH",
            Self::AlexaErrorContentTooLong => "ALEXA_ERROR_CONTENT_TOO_LONG",
            Self::AlexaErrorUnrecognizableSpeech => "ALEXA_ERROR_UNRECOGNIZABLE_SPEECH",
            Self::AlexaErrorUnsupportedArea => "ALEXA_ERROR_UNSUPPORTED_AREA",
            Self::AlexaErrorIosDeviceNotSupport => "ALEXA_ERROR_IOS_DEVICE_NOT_SUPPORT",
            Self::AlexaErrorAndroidDeviceNotSupport => {
                "ALEXA_ERROR_ANDROID_DEVICE_NOT_SUPPORT"
            }
            Self::AlexaErrorPlayNotSupport => "ALEXA_ERROR_PLAY_NOT_SUPPORT",
            Self::AlexaTemplateGeneral => "ALEXA_TEMPLATE_GENERAL",
            Self::AlexaTemplateWeather => "ALEXA_TEMPLATE_WEATHER",
            Self::AlexaTemplateLists => "ALEXA_TEMPLATE_LISTS",
            Self::AlexaAlertsSetalert => "ALEXA_ALERTS_SETALERT",
            Self::AlexaAlertsDeletealerts => "ALEXA_ALERTS_DELETEALERTS",
            Self::AlexaSpeechsynthesizerSpeak => "ALEXA_SPEECHSYNTHESIZER_SPEAK",
            Self::AlexaSpeechrecognizerExpectspeech => {
                "ALEXA_SPEECHRECOGNIZER_EXPECTSPEECH"
            }
            Self::AlexaNotificationsSetindicator => "ALEXA_NOTIFICATIONS_SETINDICATOR",
            Self::AlexaNotificationsClearindicator => {
                "ALEXA_NOTIFICATIONS_CLEARINDICATOR"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALEXA_START_LISTENING" => Some(Self::AlexaStartListening),
            "ALEXA_END_LISTENING" => Some(Self::AlexaEndListening),
            "ALEXA_AUTH_STATUS" => Some(Self::AlexaAuthStatus),
            "ALEXA_ERROR_NETWORK" => Some(Self::AlexaErrorNetwork),
            "ALEXA_ERROR_AUTH" => Some(Self::AlexaErrorAuth),
            "ALEXA_ERROR_CONTENT_TOO_LONG" => Some(Self::AlexaErrorContentTooLong),
            "ALEXA_ERROR_UNRECOGNIZABLE_SPEECH" => {
                Some(Self::AlexaErrorUnrecognizableSpeech)
            }
            "ALEXA_ERROR_UNSUPPORTED_AREA" => Some(Self::AlexaErrorUnsupportedArea),
            "ALEXA_ERROR_IOS_DEVICE_NOT_SUPPORT" => {
                Some(Self::AlexaErrorIosDeviceNotSupport)
            }
            "ALEXA_ERROR_ANDROID_DEVICE_NOT_SUPPORT" => {
                Some(Self::AlexaErrorAndroidDeviceNotSupport)
            }
            "ALEXA_ERROR_PLAY_NOT_SUPPORT" => Some(Self::AlexaErrorPlayNotSupport),
            "ALEXA_TEMPLATE_GENERAL" => Some(Self::AlexaTemplateGeneral),
            "ALEXA_TEMPLATE_WEATHER" => Some(Self::AlexaTemplateWeather),
            "ALEXA_TEMPLATE_LISTS" => Some(Self::AlexaTemplateLists),
            "ALEXA_ALERTS_SETALERT" => Some(Self::AlexaAlertsSetalert),
            "ALEXA_ALERTS_DELETEALERTS" => Some(Self::AlexaAlertsDeletealerts),
            "ALEXA_SPEECHSYNTHESIZER_SPEAK" => Some(Self::AlexaSpeechsynthesizerSpeak),
            "ALEXA_SPEECHRECOGNIZER_EXPECTSPEECH" => {
                Some(Self::AlexaSpeechrecognizerExpectspeech)
            }
            "ALEXA_NOTIFICATIONS_SETINDICATOR" => {
                Some(Self::AlexaNotificationsSetindicator)
            }
            "ALEXA_NOTIFICATIONS_CLEARINDICATOR" => {
                Some(Self::AlexaNotificationsClearindicator)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlexaAlertType {
    Unknown = -1,
    AlexaAlarm = 0,
    AlexaReminder = 1,
    AlexaTimer = 2,
}
impl AlexaAlertType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ALEXA_AlertType_UNKNOWN",
            Self::AlexaAlarm => "ALEXA_ALARM",
            Self::AlexaReminder => "ALEXA_REMINDER",
            Self::AlexaTimer => "ALEXA_TIMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALEXA_AlertType_UNKNOWN" => Some(Self::Unknown),
            "ALEXA_ALARM" => Some(Self::AlexaAlarm),
            "ALEXA_REMINDER" => Some(Self::AlexaReminder),
            "ALEXA_TIMER" => Some(Self::AlexaTimer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlexaAuthStatus {
    AlexaAuth = 0,
    AlexaNoAuth = 1,
}
impl AlexaAuthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AlexaAuth => "ALEXA_AUTH",
            Self::AlexaNoAuth => "ALEXA_NO_AUTH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALEXA_AUTH" => Some(Self::AlexaAuth),
            "ALEXA_NO_AUTH" => Some(Self::AlexaNoAuth),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThirdpartyApp {
    #[prost(
        oneof = "thirdparty_app::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20"
    )]
    pub payload: ::core::option::Option<thirdparty_app::Payload>,
}
/// Nested message and enum types in `ThirdpartyApp`.
pub mod thirdparty_app {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThirdpartyAppId {
        GetInstalledList = 0,
        PrepareInstallApp = 1,
        ReportInstallResult = 2,
        RemoveApp = 3,
        LaunchApp = 4,
        SyncPermissionInfo = 5,
        RequestPhoneAppStatus = 6,
        SyncPhoneAppStatus = 7,
        SendPhoneMessage = 8,
        SendWearMessage = 9,
        RequestWechatLicense = 10,
        ResponseWechatLicense = 11,
        RequestMihome = 12,
        ResponseMihome = 13,
        RequestScene = 14,
        ResponseScene = 15,
        ExecuteScene = 16,
        ResultScene = 17,
        RequestCourseTable = 18,
        SyncCourseTable = 19,
        SyncCurrentBloodGlucose = 20,
    }
    impl ThirdpartyAppId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GetInstalledList => "GET_INSTALLED_LIST",
                Self::PrepareInstallApp => "PREPARE_INSTALL_APP",
                Self::ReportInstallResult => "REPORT_INSTALL_RESULT",
                Self::RemoveApp => "REMOVE_APP",
                Self::LaunchApp => "LAUNCH_APP",
                Self::SyncPermissionInfo => "SYNC_PERMISSION_INFO",
                Self::RequestPhoneAppStatus => "REQUEST_PHONE_APP_STATUS",
                Self::SyncPhoneAppStatus => "SYNC_PHONE_APP_STATUS",
                Self::SendPhoneMessage => "SEND_PHONE_MESSAGE",
                Self::SendWearMessage => "SEND_WEAR_MESSAGE",
                Self::RequestWechatLicense => "REQUEST_WECHAT_LICENSE",
                Self::ResponseWechatLicense => "RESPONSE_WECHAT_LICENSE",
                Self::RequestMihome => "REQUEST_MIHOME",
                Self::ResponseMihome => "RESPONSE_MIHOME",
                Self::RequestScene => "REQUEST_SCENE",
                Self::ResponseScene => "RESPONSE_SCENE",
                Self::ExecuteScene => "EXECUTE_SCENE",
                Self::ResultScene => "RESULT_SCENE",
                Self::RequestCourseTable => "REQUEST_COURSE_TABLE",
                Self::SyncCourseTable => "SYNC_COURSE_TABLE",
                Self::SyncCurrentBloodGlucose => "SYNC_CURRENT_BLOOD_GLUCOSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GET_INSTALLED_LIST" => Some(Self::GetInstalledList),
                "PREPARE_INSTALL_APP" => Some(Self::PrepareInstallApp),
                "REPORT_INSTALL_RESULT" => Some(Self::ReportInstallResult),
                "REMOVE_APP" => Some(Self::RemoveApp),
                "LAUNCH_APP" => Some(Self::LaunchApp),
                "SYNC_PERMISSION_INFO" => Some(Self::SyncPermissionInfo),
                "REQUEST_PHONE_APP_STATUS" => Some(Self::RequestPhoneAppStatus),
                "SYNC_PHONE_APP_STATUS" => Some(Self::SyncPhoneAppStatus),
                "SEND_PHONE_MESSAGE" => Some(Self::SendPhoneMessage),
                "SEND_WEAR_MESSAGE" => Some(Self::SendWearMessage),
                "REQUEST_WECHAT_LICENSE" => Some(Self::RequestWechatLicense),
                "RESPONSE_WECHAT_LICENSE" => Some(Self::ResponseWechatLicense),
                "REQUEST_MIHOME" => Some(Self::RequestMihome),
                "RESPONSE_MIHOME" => Some(Self::ResponseMihome),
                "REQUEST_SCENE" => Some(Self::RequestScene),
                "RESPONSE_SCENE" => Some(Self::ResponseScene),
                "EXECUTE_SCENE" => Some(Self::ExecuteScene),
                "RESULT_SCENE" => Some(Self::ResultScene),
                "REQUEST_COURSE_TABLE" => Some(Self::RequestCourseTable),
                "SYNC_COURSE_TABLE" => Some(Self::SyncCourseTable),
                "SYNC_CURRENT_BLOOD_GLUCOSE" => Some(Self::SyncCurrentBloodGlucose),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        AppItemList(super::app_item::List),
        #[prost(message, tag = "2")]
        InstallRequest(super::app_installer::Request),
        #[prost(message, tag = "3")]
        InstallResponse(super::app_installer::Response),
        #[prost(message, tag = "4")]
        InstallResult(super::app_installer::Result),
        #[prost(message, tag = "5")]
        BasicInfo(super::BasicInfo),
        #[prost(message, tag = "6")]
        LaunchInfo(super::LaunchInfo),
        #[prost(message, tag = "7")]
        PermissionInfoList(super::permission_info::List),
        #[prost(message, tag = "8")]
        AppStatus(super::PhoneAppStatus),
        #[prost(message, tag = "9")]
        MessageContent(super::MessageContent),
        #[prost(message, tag = "10")]
        WechatLicenseRequest(super::wechat_license::Request),
        #[prost(message, tag = "12")]
        WechatLicenseResponse(super::wechat_license::Response),
        #[prost(message, tag = "13")]
        MihomeRequest(super::mi_home::Request),
        #[prost(message, tag = "14")]
        MihomeList(super::mi_home::List),
        #[prost(message, tag = "15")]
        SceneRequest(super::mi_home::scene::Request),
        #[prost(message, tag = "16")]
        SceneList(super::mi_home::scene::List),
        #[prost(message, tag = "17")]
        SceneExcutor(super::mi_home::scene::Executor),
        #[prost(message, tag = "18")]
        SceneResult(super::mi_home::scene::Result),
        #[prost(message, tag = "19")]
        CourseTable(super::CourseTable),
        #[prost(message, tag = "20")]
        BloodGlucose(super::BloodGlucose),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppItem {
    #[prost(string, required, tag = "1")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub fingerprint: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "3")]
    pub version_code: u32,
    #[prost(bool, required, tag = "4")]
    pub can_remove: bool,
    #[prost(string, required, tag = "5")]
    pub app_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AppItem`.
pub mod app_item {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::AppItem>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppInstaller {}
/// Nested message and enum types in `AppInstaller`.
pub mod app_installer {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, required, tag = "1")]
        pub package_name: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub version_code: u32,
        #[prost(uint32, required, tag = "3")]
        pub package_size: u32,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(enumeration = "super::PrepareStatus", required, tag = "1")]
        pub prepare_status: i32,
        #[prost(uint32, optional, tag = "2")]
        pub expected_slice_length: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(enumeration = "result::Code", required, tag = "1")]
        pub code: i32,
        #[prost(oneof = "result::Payload", tags = "2, 3")]
        pub payload: ::core::option::Option<result::Payload>,
    }
    /// Nested message and enum types in `Result`.
    pub mod result {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Code {
            InstallSuccess = 0,
            InstallFailed = 1,
            VerifyFailed = 2,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::InstallSuccess => "INSTALL_SUCCESS",
                    Self::InstallFailed => "INSTALL_FAILED",
                    Self::VerifyFailed => "VERIFY_FAILED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INSTALL_SUCCESS" => Some(Self::InstallSuccess),
                    "INSTALL_FAILED" => Some(Self::InstallFailed),
                    "VERIFY_FAILED" => Some(Self::VerifyFailed),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Payload {
            #[prost(string, tag = "2")]
            PackageName(::prost::alloc::string::String),
            #[prost(message, tag = "3")]
            AppItem(super::super::AppItem),
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BasicInfo {
    #[prost(string, required, tag = "1")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", required, tag = "2")]
    pub fingerprint: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LaunchInfo {
    #[prost(message, required, tag = "1")]
    pub basic_info: BasicInfo,
    #[prost(string, required, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionInfo {
    #[prost(message, required, tag = "1")]
    pub basic_info: BasicInfo,
    #[prost(
        enumeration = "permission_info::Permission",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub grant_permissions: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `PermissionInfo`.
pub mod permission_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::PermissionInfo>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Permission {
        DeviceStatus = 1,
        UserStatus = 2,
        BodySensor = 3,
        MotionSensor = 4,
        Notify = 5,
    }
    impl Permission {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DeviceStatus => "DEVICE_STATUS",
                Self::UserStatus => "USER_STATUS",
                Self::BodySensor => "BODY_SENSOR",
                Self::MotionSensor => "MOTION_SENSOR",
                Self::Notify => "NOTIFY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEVICE_STATUS" => Some(Self::DeviceStatus),
                "USER_STATUS" => Some(Self::UserStatus),
                "BODY_SENSOR" => Some(Self::BodySensor),
                "MOTION_SENSOR" => Some(Self::MotionSensor),
                "NOTIFY" => Some(Self::Notify),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhoneAppStatus {
    #[prost(message, required, tag = "1")]
    pub basic_info: BasicInfo,
    #[prost(enumeration = "phone_app_status::Status", required, tag = "2")]
    pub status: i32,
}
/// Nested message and enum types in `PhoneAppStatus`.
pub mod phone_app_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Connected = 1,
        Disconnected = 2,
        Uninstalled = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Connected => "CONNECTED",
                Self::Disconnected => "DISCONNECTED",
                Self::Uninstalled => "UNINSTALLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTED" => Some(Self::Connected),
                "DISCONNECTED" => Some(Self::Disconnected),
                "UNINSTALLED" => Some(Self::Uninstalled),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageContent {
    #[prost(message, required, tag = "1")]
    pub basic_info: BasicInfo,
    #[prost(bytes = "vec", required, tag = "2")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WechatLicense {}
/// Nested message and enum types in `WechatLicense`.
pub mod wechat_license {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {}
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(int32, required, tag = "1")]
        pub code: i32,
        #[prost(uint32, optional, tag = "2")]
        pub key_version: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub product_id: ::core::option::Option<u32>,
        #[prost(string, required, tag = "4")]
        pub signature: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiHome {
    #[prost(uint64, required, tag = "1")]
    pub id: u64,
    #[prost(uint64, required, tag = "2")]
    pub uid: u64,
    #[prost(string, required, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MiHome`.
pub mod mi_home {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {}
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::MiHome>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Scene {}
    /// Nested message and enum types in `Scene`.
    pub mod scene {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Request {
            #[prost(uint64, required, tag = "1")]
            pub home_id: u64,
            #[prost(uint64, required, tag = "2")]
            pub uid: u64,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(uint64, required, tag = "1")]
            pub home_id: u64,
            #[prost(message, repeated, tag = "2")]
            pub list: ::prost::alloc::vec::Vec<super::Scene>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Executor {
            #[prost(uint64, required, tag = "1")]
            pub id: u64,
            #[prost(uint32, required, tag = "2")]
            pub r#type: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Result {
            #[prost(bool, required, tag = "1")]
            pub result: bool,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CourseTable {
    #[prost(uint64, required, tag = "1")]
    pub timestamp: u64,
    #[prost(uint32, required, tag = "2")]
    pub week_number: u32,
    #[prost(message, repeated, tag = "3")]
    pub section_list: ::prost::alloc::vec::Vec<course_table::Section>,
    #[prost(message, repeated, tag = "4")]
    pub course_list: ::prost::alloc::vec::Vec<course_table::Course>,
}
/// Nested message and enum types in `CourseTable`.
pub mod course_table {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Section {
        #[prost(message, required, tag = "1")]
        pub start_time: super::Time,
        #[prost(message, required, tag = "2")]
        pub end_time: super::Time,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Course {
        #[prost(string, required, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub weeks: u32,
        #[prost(uint32, required, tag = "3")]
        pub days: u32,
        #[prost(uint32, required, tag = "4")]
        pub sections: u32,
        #[prost(string, required, tag = "5")]
        pub teacher: ::prost::alloc::string::String,
        #[prost(string, required, tag = "6")]
        pub location: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BloodGlucose {
    #[prost(uint64, required, tag = "1")]
    pub timestamp: u64,
    #[prost(float, required, tag = "2")]
    pub value: f32,
    #[prost(uint32, required, tag = "3")]
    pub status: u32,
    #[prost(bool, optional, tag = "4")]
    pub alert: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    #[prost(oneof = "contact::Payload", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub payload: ::core::option::Option<contact::Payload>,
}
/// Nested message and enum types in `Contact`.
pub mod contact {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContactId {
        GetEmergencyContact = 0,
        SetEmergencyContact = 1,
        RequestMiuiSos = 8,
        ResponseMiuiSos = 9,
        ApplyFallHelp = 10,
        EndFallHelp = 11,
        QueryContactInfo = 2,
        SendContactInfo = 3,
        GetContactList = 4,
        AddContactList = 5,
        RemoveContactList = 6,
        SyncContactList = 7,
    }
    impl ContactId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GetEmergencyContact => "GET_EMERGENCY_CONTACT",
                Self::SetEmergencyContact => "SET_EMERGENCY_CONTACT",
                Self::RequestMiuiSos => "REQUEST_MIUI_SOS",
                Self::ResponseMiuiSos => "RESPONSE_MIUI_SOS",
                Self::ApplyFallHelp => "APPLY_FALL_HELP",
                Self::EndFallHelp => "END_FALL_HELP",
                Self::QueryContactInfo => "QUERY_CONTACT_INFO",
                Self::SendContactInfo => "SEND_CONTACT_INFO",
                Self::GetContactList => "GET_CONTACT_LIST",
                Self::AddContactList => "ADD_CONTACT_LIST",
                Self::RemoveContactList => "REMOVE_CONTACT_LIST",
                Self::SyncContactList => "SYNC_CONTACT_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GET_EMERGENCY_CONTACT" => Some(Self::GetEmergencyContact),
                "SET_EMERGENCY_CONTACT" => Some(Self::SetEmergencyContact),
                "REQUEST_MIUI_SOS" => Some(Self::RequestMiuiSos),
                "RESPONSE_MIUI_SOS" => Some(Self::ResponseMiuiSos),
                "APPLY_FALL_HELP" => Some(Self::ApplyFallHelp),
                "END_FALL_HELP" => Some(Self::EndFallHelp),
                "QUERY_CONTACT_INFO" => Some(Self::QueryContactInfo),
                "SEND_CONTACT_INFO" => Some(Self::SendContactInfo),
                "GET_CONTACT_LIST" => Some(Self::GetContactList),
                "ADD_CONTACT_LIST" => Some(Self::AddContactList),
                "REMOVE_CONTACT_LIST" => Some(Self::RemoveContactList),
                "SYNC_CONTACT_LIST" => Some(Self::SyncContactList),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        EmergencyContact(super::EmergencyContact),
        #[prost(string, tag = "2")]
        Number(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        ContactInfo(super::ContactInfo),
        #[prost(message, tag = "4")]
        ContactInfoList(super::contact_info::List),
        #[prost(message, tag = "5")]
        MiuiSosRequest(super::miui_sos::Request),
        #[prost(message, tag = "6")]
        MiuiSosResponse(super::miui_sos::Response),
        #[prost(message, tag = "7")]
        HelpRequest(super::HelpRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactInfo {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub number: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ContactInfo`.
pub mod contact_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ContactInfo>,
        #[prost(uint32, optional, tag = "2")]
        pub current_segment: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "3")]
        pub total_segment: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmergencyContact {
    #[prost(bool, required, tag = "1")]
    pub enabled: bool,
    #[prost(message, optional, tag = "2")]
    pub contact_info: ::core::option::Option<ContactInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiuiSos {}
/// Nested message and enum types in `MiuiSOS`.
pub mod miui_sos {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Request {}
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(uint32, required, tag = "1")]
        pub code: u32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelpRequest {
    #[prost(string, repeated, tag = "1")]
    pub sms_number: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub reason: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mass {
    #[prost(oneof = "mass::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<mass::Payload>,
}
/// Nested message and enum types in `Mass`.
pub mod mass {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MassId {
        Prepare = 0,
        Control = 1,
    }
    impl MassId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Prepare => "PREPARE",
                Self::Control => "CONTROL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREPARE" => Some(Self::Prepare),
                "CONTROL" => Some(Self::Control),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        PrepareRequest(super::PrepareRequest),
        #[prost(message, tag = "2")]
        PrepareResponse(super::PrepareResponse),
        #[prost(message, tag = "3")]
        MassControl(super::MassControl),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareRequest {
    #[prost(uint32, required, tag = "1")]
    pub data_type: u32,
    #[prost(bytes = "vec", required, tag = "2")]
    pub data_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, required, tag = "3")]
    pub data_length: u32,
    #[prost(uint32, optional, tag = "4")]
    pub support_compress_mode: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrepareResponse {
    #[prost(bytes = "vec", required, tag = "1")]
    pub data_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "PrepareStatus", required, tag = "2")]
    pub prepare_status: i32,
    #[prost(uint32, optional, tag = "3")]
    pub select_compress_mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub remained_data_length: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub expected_slice_length: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MassControl {
    #[prost(enumeration = "mass_control::Op", required, tag = "1")]
    pub op: i32,
    #[prost(uint32, required, tag = "2")]
    pub data_type: u32,
    #[prost(bytes = "vec", required, tag = "3")]
    pub data_id: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `MassControl`.
pub mod mass_control {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Op {
        Pause = 1,
        Cancel = 2,
        Error = 3,
    }
    impl Op {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Pause => "PAUSE",
                Self::Cancel => "CANCEL",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PAUSE" => Some(Self::Pause),
                "CANCEL" => Some(Self::Cancel),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interconnection {
    #[prost(
        oneof = "interconnection::Payload",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27"
    )]
    pub payload: ::core::option::Option<interconnection::Payload>,
}
/// Nested message and enum types in `Interconnection`.
pub mod interconnection {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InterconnectionId {
        RequestPhoneStatus = 0,
        SyncPhoneStatus = 1,
        RegisterPhoneUsage = 17,
        UnregisterPhoneUsage = 18,
        SendPhoneUsage = 19,
        StartPhoneTrace = 20,
        FinishPhoneTrace = 21,
        SendPhoneTrace = 22,
        ReqeustShareDevices = 2,
        SyncShareDevices = 3,
        UpdateShareDevice = 4,
        ControlAudio = 5,
        ControlTv = 6,
        ControlHeadset = 7,
        SendControlResult = 8,
        RequestProjectionDevices = 9,
        SyncProjectionDevices = 10,
        RequestProjection = 11,
        SendProjectionResponse = 12,
        ReportProjectionData = 13,
        ReportProjectionReport = 14,
        NotifyProjectionMembers = 15,
        EnterCourseZone = 16,
        StartSlideShow = 23,
        StopSlideShow = 24,
        StartDemoShow = 25,
        StopDemoShow = 26,
        SubscribeMisDevice = 27,
        UnsubscribeMisDevice = 28,
        SyncMisDevice = 29,
        PublishMisSpec = 30,
        ReportMisSpec = 31,
        GetWearSpecBasic = 32,
        SendMisPacket = 33,
        RequestServerCert = 34,
        ResponseServerCert = 35,
        RequestDeviceCert = 36,
        ResponseDeviceCert = 37,
        RequestProps = 38,
        ResponseProps = 39,
    }
    impl InterconnectionId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RequestPhoneStatus => "REQUEST_PHONE_STATUS",
                Self::SyncPhoneStatus => "SYNC_PHONE_STATUS",
                Self::RegisterPhoneUsage => "REGISTER_PHONE_USAGE",
                Self::UnregisterPhoneUsage => "UNREGISTER_PHONE_USAGE",
                Self::SendPhoneUsage => "SEND_PHONE_USAGE",
                Self::StartPhoneTrace => "START_PHONE_TRACE",
                Self::FinishPhoneTrace => "FINISH_PHONE_TRACE",
                Self::SendPhoneTrace => "SEND_PHONE_TRACE",
                Self::ReqeustShareDevices => "REQEUST_SHARE_DEVICES",
                Self::SyncShareDevices => "SYNC_SHARE_DEVICES",
                Self::UpdateShareDevice => "UPDATE_SHARE_DEVICE",
                Self::ControlAudio => "CONTROL_AUDIO",
                Self::ControlTv => "CONTROL_TV",
                Self::ControlHeadset => "CONTROL_HEADSET",
                Self::SendControlResult => "SEND_CONTROL_RESULT",
                Self::RequestProjectionDevices => "REQUEST_PROJECTION_DEVICES",
                Self::SyncProjectionDevices => "SYNC_PROJECTION_DEVICES",
                Self::RequestProjection => "REQUEST_PROJECTION",
                Self::SendProjectionResponse => "SEND_PROJECTION_RESPONSE",
                Self::ReportProjectionData => "REPORT_PROJECTION_DATA",
                Self::ReportProjectionReport => "REPORT_PROJECTION_REPORT",
                Self::NotifyProjectionMembers => "NOTIFY_PROJECTION_MEMBERS",
                Self::EnterCourseZone => "ENTER_COURSE_ZONE",
                Self::StartSlideShow => "START_SLIDE_SHOW",
                Self::StopSlideShow => "STOP_SLIDE_SHOW",
                Self::StartDemoShow => "START_DEMO_SHOW",
                Self::StopDemoShow => "STOP_DEMO_SHOW",
                Self::SubscribeMisDevice => "SUBSCRIBE_MIS_DEVICE",
                Self::UnsubscribeMisDevice => "UNSUBSCRIBE_MIS_DEVICE",
                Self::SyncMisDevice => "SYNC_MIS_DEVICE",
                Self::PublishMisSpec => "PUBLISH_MIS_SPEC",
                Self::ReportMisSpec => "REPORT_MIS_SPEC",
                Self::GetWearSpecBasic => "GET_WEAR_SPEC_BASIC",
                Self::SendMisPacket => "SEND_MIS_PACKET",
                Self::RequestServerCert => "REQUEST_SERVER_CERT",
                Self::ResponseServerCert => "RESPONSE_SERVER_CERT",
                Self::RequestDeviceCert => "REQUEST_DEVICE_CERT",
                Self::ResponseDeviceCert => "RESPONSE_DEVICE_CERT",
                Self::RequestProps => "REQUEST_PROPS",
                Self::ResponseProps => "RESPONSE_PROPS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REQUEST_PHONE_STATUS" => Some(Self::RequestPhoneStatus),
                "SYNC_PHONE_STATUS" => Some(Self::SyncPhoneStatus),
                "REGISTER_PHONE_USAGE" => Some(Self::RegisterPhoneUsage),
                "UNREGISTER_PHONE_USAGE" => Some(Self::UnregisterPhoneUsage),
                "SEND_PHONE_USAGE" => Some(Self::SendPhoneUsage),
                "START_PHONE_TRACE" => Some(Self::StartPhoneTrace),
                "FINISH_PHONE_TRACE" => Some(Self::FinishPhoneTrace),
                "SEND_PHONE_TRACE" => Some(Self::SendPhoneTrace),
                "REQEUST_SHARE_DEVICES" => Some(Self::ReqeustShareDevices),
                "SYNC_SHARE_DEVICES" => Some(Self::SyncShareDevices),
                "UPDATE_SHARE_DEVICE" => Some(Self::UpdateShareDevice),
                "CONTROL_AUDIO" => Some(Self::ControlAudio),
                "CONTROL_TV" => Some(Self::ControlTv),
                "CONTROL_HEADSET" => Some(Self::ControlHeadset),
                "SEND_CONTROL_RESULT" => Some(Self::SendControlResult),
                "REQUEST_PROJECTION_DEVICES" => Some(Self::RequestProjectionDevices),
                "SYNC_PROJECTION_DEVICES" => Some(Self::SyncProjectionDevices),
                "REQUEST_PROJECTION" => Some(Self::RequestProjection),
                "SEND_PROJECTION_RESPONSE" => Some(Self::SendProjectionResponse),
                "REPORT_PROJECTION_DATA" => Some(Self::ReportProjectionData),
                "REPORT_PROJECTION_REPORT" => Some(Self::ReportProjectionReport),
                "NOTIFY_PROJECTION_MEMBERS" => Some(Self::NotifyProjectionMembers),
                "ENTER_COURSE_ZONE" => Some(Self::EnterCourseZone),
                "START_SLIDE_SHOW" => Some(Self::StartSlideShow),
                "STOP_SLIDE_SHOW" => Some(Self::StopSlideShow),
                "START_DEMO_SHOW" => Some(Self::StartDemoShow),
                "STOP_DEMO_SHOW" => Some(Self::StopDemoShow),
                "SUBSCRIBE_MIS_DEVICE" => Some(Self::SubscribeMisDevice),
                "UNSUBSCRIBE_MIS_DEVICE" => Some(Self::UnsubscribeMisDevice),
                "SYNC_MIS_DEVICE" => Some(Self::SyncMisDevice),
                "PUBLISH_MIS_SPEC" => Some(Self::PublishMisSpec),
                "REPORT_MIS_SPEC" => Some(Self::ReportMisSpec),
                "GET_WEAR_SPEC_BASIC" => Some(Self::GetWearSpecBasic),
                "SEND_MIS_PACKET" => Some(Self::SendMisPacket),
                "REQUEST_SERVER_CERT" => Some(Self::RequestServerCert),
                "RESPONSE_SERVER_CERT" => Some(Self::ResponseServerCert),
                "REQUEST_DEVICE_CERT" => Some(Self::RequestDeviceCert),
                "RESPONSE_DEVICE_CERT" => Some(Self::ResponseDeviceCert),
                "REQUEST_PROPS" => Some(Self::RequestProps),
                "RESPONSE_PROPS" => Some(Self::ResponseProps),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        PhoneStatus(super::PhoneStatus),
        #[prost(message, tag = "2")]
        ShareDevices(super::share_device::List),
        #[prost(message, tag = "3")]
        ShareDevice(super::ShareDevice),
        #[prost(message, tag = "4")]
        AudioControl(super::AudioControl),
        #[prost(message, tag = "5")]
        TvControl(super::TvControl),
        #[prost(message, tag = "6")]
        HeadsetControl(super::HeadsetControl),
        #[prost(message, tag = "7")]
        ControlResult(super::ControlResult),
        #[prost(message, tag = "8")]
        ProjectionDevices(super::projection_device::List),
        #[prost(message, tag = "9")]
        ProjectionRequest(super::ProjectionRequest),
        #[prost(message, tag = "10")]
        ProjectionResponse(super::ProjectionResponse),
        #[prost(message, tag = "11")]
        ProjectionData(super::ProjectionData),
        #[prost(message, tag = "12")]
        RequestInfo(super::RequestInfo),
        #[prost(message, tag = "13")]
        ProjectionReport(super::ProjectionReport),
        #[prost(message, tag = "14")]
        ProjectionMembers(super::projection_member::List),
        #[prost(message, tag = "15")]
        CourseZone(super::CourseZone),
        #[prost(message, tag = "16")]
        PhoneUsage(super::PhoneUsage),
        #[prost(message, tag = "17")]
        PhoneTrace(super::PhoneTrace),
        #[prost(message, tag = "18")]
        MishowSlideRequest(super::mi_show::SlideRequest),
        #[prost(message, tag = "19")]
        MishowDemo(super::mi_show::Demo),
        #[prost(message, tag = "20")]
        MisDevices(super::mis::device::List),
        #[prost(message, tag = "21")]
        WearSpecBasic(super::mis::WearSpecBasic),
        #[prost(message, tag = "22")]
        MisPayload(super::mis::Payload),
        #[prost(message, tag = "23")]
        CertServerRequest(super::cert::ServerRequest),
        #[prost(message, tag = "24")]
        CertDeviceRequest(super::cert::DeviceRequest),
        #[prost(message, tag = "25")]
        CertResponse(super::cert::Response),
        #[prost(message, tag = "26")]
        PropRequest(super::prop::Request),
        #[prost(message, tag = "27")]
        PropResponse(super::prop::Response),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneStatus {
    #[prost(uint32, required, tag = "1")]
    pub screen: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareDevice {
    #[prost(enumeration = "DeviceType", required, tag = "1")]
    pub r#type: i32,
    #[prost(string, required, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "share_device::Info", tags = "4, 5, 6")]
    pub info: ::core::option::Option<share_device::Info>,
}
/// Nested message and enum types in `ShareDevice`.
pub mod share_device {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ShareDevice>,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Info {
        #[prost(message, tag = "4")]
        AudioInfo(super::AudioInfo),
        #[prost(message, tag = "5")]
        TvInfo(super::TvInfo),
        #[prost(message, tag = "6")]
        HeadsetInfo(super::HeadsetInfo),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioData {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub current_positon: u32,
    #[prost(uint32, required, tag = "3")]
    pub duration: u32,
    #[prost(uint32, required, tag = "4")]
    pub volume: u32,
    #[prost(string, required, tag = "5")]
    pub artist: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub album: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInfo {
    #[prost(uint32, required, tag = "1")]
    pub state: u32,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<AudioData>,
    #[prost(string, required, tag = "3")]
    pub output_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TvData {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TvInfo {
    #[prost(uint32, required, tag = "1")]
    pub state: u32,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<TvData>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeadsetInfo {
    #[prost(uint32, required, tag = "1")]
    pub voice_mode: u32,
    #[prost(uint32, required, tag = "2")]
    pub multi_connection: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioControl {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub cmd: u32,
    #[prost(uint32, optional, tag = "3")]
    pub int_value: ::core::option::Option<u32>,
    #[prost(string, required, tag = "4")]
    pub str_value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TvControl {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub cmd: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeadsetControl {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "2")]
    pub voice_mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub multi_connection: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlResult {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "2")]
    pub code: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionDevice {
    #[prost(string, required, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "3")]
    pub state: u32,
}
/// Nested message and enum types in `ProjectionDevice`.
pub mod projection_device {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ProjectionDevice>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionRequest {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub cmd: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionResponse {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(uint32, required, tag = "2")]
    pub code: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionData {
    #[prost(enumeration = "SportType", required, tag = "1")]
    pub sport_type: i32,
    #[prost(uint32, required, tag = "2")]
    pub start_time: u32,
    #[prost(uint32, required, tag = "3")]
    pub duration: u32,
    #[prost(uint32, required, tag = "4")]
    pub heart_rate: u32,
    #[prost(uint32, required, tag = "5")]
    pub calories: u32,
    #[prost(uint32, optional, tag = "6")]
    pub steps: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub distance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "8")]
    pub current_pace: ::core::option::Option<u32>,
    #[prost(float, optional, tag = "9")]
    pub speed: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag = "10")]
    pub jump_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub stumble_count: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "12")]
    pub group_info: ::core::option::Option<projection_data::GroupInfo>,
    #[prost(bool, optional, tag = "13")]
    pub abnormal_heart_rate: ::core::option::Option<bool>,
    #[prost(enumeration = "HeartRateSection", optional, tag = "14")]
    pub heart_rate_zone: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "15")]
    pub device_list: ::core::option::Option<projection_data::device::List>,
}
/// Nested message and enum types in `ProjectionData`.
pub mod projection_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GroupInfo {
        #[prost(uint32, required, tag = "1")]
        pub segment_type: u32,
        #[prost(uint32, required, tag = "2")]
        pub segment_timestamp: u32,
        #[prost(uint32, required, tag = "3")]
        pub segment_duration: u32,
        #[prost(uint32, optional, tag = "4")]
        pub group_index: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "5")]
        pub calories: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "6")]
        pub recommend_heart_rate: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "7")]
        pub count: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Device {
        #[prost(uint32, required, tag = "1")]
        pub r#type: u32,
        #[prost(uint32, required, tag = "2")]
        pub pid: u32,
        #[prost(uint32, required, tag = "3")]
        pub connect_status: u32,
    }
    /// Nested message and enum types in `Device`.
    pub mod device {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Device>,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestInfo {
    #[prost(bool, required, tag = "1")]
    pub only_audio: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionReport {
    #[prost(uint32, required, tag = "1")]
    pub timestamp: u32,
    #[prost(message, required, tag = "2")]
    pub timezone: Timezone,
    #[prost(uint32, required, tag = "3")]
    pub duration: u32,
    #[prost(uint32, required, tag = "4")]
    pub toal_calories: u32,
    #[prost(uint32, required, tag = "5")]
    pub calories: u32,
    #[prost(uint32, required, tag = "6")]
    pub avg_heart_rate: u32,
    #[prost(uint32, required, tag = "7")]
    pub max_heart_rate: u32,
    #[prost(uint32, required, tag = "8")]
    pub min_heart_rate: u32,
    #[prost(uint32, required, tag = "9")]
    pub hrm_warm_up_duration: u32,
    #[prost(uint32, required, tag = "10")]
    pub hrm_fat_burning_duration: u32,
    #[prost(uint32, required, tag = "11")]
    pub hrm_aerobic_duration: u32,
    #[prost(uint32, required, tag = "12")]
    pub hrm_anaerobic_duration: u32,
    #[prost(uint32, required, tag = "13")]
    pub hrm_extreme_duration: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionMember {
    #[prost(string, required, tag = "1")]
    pub device_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub user_name: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "4")]
    pub status: ::core::option::Option<u32>,
}
/// Nested message and enum types in `ProjectionMember`.
pub mod projection_member {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub list: ::prost::alloc::vec::Vec<super::ProjectionMember>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CourseZone {
    #[prost(uint32, required, tag = "1")]
    pub status: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneUsage {
    #[prost(bool, required, tag = "1")]
    pub hold: bool,
    #[prost(uint32, required, tag = "2")]
    pub screen: u32,
    #[prost(uint32, required, tag = "3")]
    pub foreground_app_type: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhoneTrace {
    #[prost(uint32, required, tag = "1")]
    pub dir_angle: u32,
    #[prost(uint32, required, tag = "2")]
    pub dir_change_count: u32,
    #[prost(uint32, required, tag = "3")]
    pub dir_change_std: u32,
    #[prost(uint32, required, tag = "4")]
    pub dir_change_avg: u32,
    #[prost(uint32, required, tag = "5")]
    pub ambient_light_avg: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MiShow {}
/// Nested message and enum types in `MiShow`.
pub mod mi_show {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SlideRequest {
        #[prost(uint64, required, tag = "1")]
        pub timestamp: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Demo {
        #[prost(string, required, tag = "1")]
        pub show: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Mis {}
/// Nested message and enum types in `Mis`.
pub mod mis {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Device {
        #[prost(string, required, tag = "1")]
        pub did: ::prost::alloc::string::String,
        #[prost(uint32, required, tag = "2")]
        pub pdid: u32,
        #[prost(uint32, required, tag = "3")]
        pub status: u32,
        #[prost(string, required, tag = "4")]
        pub name: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Device`.
    pub mod device {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            #[prost(message, repeated, tag = "1")]
            pub list: ::prost::alloc::vec::Vec<super::Device>,
            #[prost(bool, optional, tag = "2")]
            pub car_owner: ::core::option::Option<bool>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WearSpecBasic {
        #[prost(string, required, tag = "1")]
        pub device_info: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Payload {
        #[prost(string, required, tag = "1")]
        pub spec: ::prost::alloc::string::String,
        #[prost(bytes = "vec", required, tag = "2")]
        pub packet: ::prost::alloc::vec::Vec<u8>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Cert {}
/// Nested message and enum types in `Cert`.
pub mod cert {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ServerRequest {}
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeviceRequest {
        #[prost(string, required, tag = "1")]
        pub payload: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(int32, required, tag = "1")]
        pub error_code: i32,
        #[prost(string, required, tag = "2")]
        pub result: ::prost::alloc::string::String,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Prop {}
/// Nested message and enum types in `Prop`.
pub mod prop {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, required, tag = "1")]
        pub did: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub props: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(string, required, tag = "1")]
        pub did: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub props_value: ::prost::alloc::vec::Vec<super::KeyValueStr>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceType {
    AndroidPhone = 1,
    AndroidPad = 2,
    AndroidTv = 3,
    WindowsPc = 4,
    Soundbox = 5,
    SoundboxScreen = 6,
    Headset = 7,
}
impl DeviceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AndroidPhone => "ANDROID_PHONE",
            Self::AndroidPad => "ANDROID_PAD",
            Self::AndroidTv => "ANDROID_TV",
            Self::WindowsPc => "WINDOWS_PC",
            Self::Soundbox => "SOUNDBOX",
            Self::SoundboxScreen => "SOUNDBOX_SCREEN",
            Self::Headset => "HEADSET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANDROID_PHONE" => Some(Self::AndroidPhone),
            "ANDROID_PAD" => Some(Self::AndroidPad),
            "ANDROID_TV" => Some(Self::AndroidTv),
            "WINDOWS_PC" => Some(Self::WindowsPc),
            "SOUNDBOX" => Some(Self::Soundbox),
            "SOUNDBOX_SCREEN" => Some(Self::SoundboxScreen),
            "HEADSET" => Some(Self::Headset),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WearPacket {
    #[prost(enumeration = "wear_packet::Type", required, tag = "1")]
    pub r#type: i32,
    #[prost(uint32, required, tag = "2")]
    pub id: u32,
    #[prost(
        oneof = "wear_packet::Payload",
        tags = "3, 4, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 100"
    )]
    pub payload: ::core::option::Option<wear_packet::Payload>,
}
/// Nested message and enum types in `WearPacket`.
pub mod wear_packet {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Other = 0,
        Account = 1,
        System = 2,
        WatchFace = 4,
        Nfc = 5,
        Notification = 7,
        Fitness = 8,
        Lpa = 9,
        Weather = 10,
        Stock = 11,
        Calendar = 12,
        Factory = 13,
        Aivs = 14,
        Market = 15,
        Gnss = 16,
        Clock = 17,
        Media = 18,
        Alexa = 19,
        ThirdpartyApp = 20,
        Contact = 21,
        Mass = 22,
        Interconnection = 23,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Other => "OTHER",
                Self::Account => "ACCOUNT",
                Self::System => "SYSTEM",
                Self::WatchFace => "WATCH_FACE",
                Self::Nfc => "NFC",
                Self::Notification => "NOTIFICATION",
                Self::Fitness => "FITNESS",
                Self::Lpa => "LPA",
                Self::Weather => "WEATHER",
                Self::Stock => "STOCK",
                Self::Calendar => "CALENDAR",
                Self::Factory => "FACTORY",
                Self::Aivs => "AIVS",
                Self::Market => "MARKET",
                Self::Gnss => "GNSS",
                Self::Clock => "CLOCK",
                Self::Media => "MEDIA",
                Self::Alexa => "ALEXA",
                Self::ThirdpartyApp => "THIRDPARTY_APP",
                Self::Contact => "CONTACT",
                Self::Mass => "MASS",
                Self::Interconnection => "INTERCONNECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OTHER" => Some(Self::Other),
                "ACCOUNT" => Some(Self::Account),
                "SYSTEM" => Some(Self::System),
                "WATCH_FACE" => Some(Self::WatchFace),
                "NFC" => Some(Self::Nfc),
                "NOTIFICATION" => Some(Self::Notification),
                "FITNESS" => Some(Self::Fitness),
                "LPA" => Some(Self::Lpa),
                "WEATHER" => Some(Self::Weather),
                "STOCK" => Some(Self::Stock),
                "CALENDAR" => Some(Self::Calendar),
                "FACTORY" => Some(Self::Factory),
                "AIVS" => Some(Self::Aivs),
                "MARKET" => Some(Self::Market),
                "GNSS" => Some(Self::Gnss),
                "CLOCK" => Some(Self::Clock),
                "MEDIA" => Some(Self::Media),
                "ALEXA" => Some(Self::Alexa),
                "THIRDPARTY_APP" => Some(Self::ThirdpartyApp),
                "CONTACT" => Some(Self::Contact),
                "MASS" => Some(Self::Mass),
                "INTERCONNECTION" => Some(Self::Interconnection),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "3")]
        Account(super::Account),
        #[prost(message, tag = "4")]
        System(super::System),
        #[prost(message, tag = "6")]
        WatchFace(super::WatchFace),
        #[prost(message, tag = "7")]
        Nfc(super::Nfc),
        #[prost(message, tag = "9")]
        Notification(super::Notification),
        #[prost(message, tag = "10")]
        Fitness(super::Fitness),
        #[prost(message, tag = "11")]
        Lpa(super::Lpa),
        #[prost(message, tag = "12")]
        Weather(super::Weather),
        #[prost(message, tag = "13")]
        Stock(super::Stock),
        #[prost(message, tag = "14")]
        Calendar(super::Calendar),
        #[prost(message, tag = "15")]
        Factory(super::Factory),
        #[prost(message, tag = "16")]
        Aivs(super::Aivs),
        #[prost(message, tag = "17")]
        Market(super::Market),
        #[prost(message, tag = "18")]
        Gnss(super::Gnss),
        #[prost(message, tag = "19")]
        Clock(super::Clock),
        #[prost(message, tag = "20")]
        Media(super::Media),
        #[prost(message, tag = "21")]
        Alexa(super::Alexa),
        #[prost(message, tag = "22")]
        ThirdpartyApp(super::ThirdpartyApp),
        #[prost(message, tag = "23")]
        Contact(super::Contact),
        #[prost(message, tag = "24")]
        Mass(super::Mass),
        #[prost(message, tag = "25")]
        Interconnection(super::Interconnection),
        #[prost(enumeration = "super::ErrorCode", tag = "100")]
        ErrorCode(i32),
    }
}
